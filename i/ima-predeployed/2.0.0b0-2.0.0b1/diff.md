# Comparing `tmp/ima-predeployed-2.0.0b0.tar.gz` & `tmp/ima-predeployed-2.0.0b1.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "ima-predeployed-2.0.0b0.tar", last modified: Mon Jun 12 12:03:55 2023, max compression
+gzip compressed data, was "ima-predeployed-2.0.0b1.tar", last modified: Mon Jun 26 15:36:58 2023, max compression
```

## Comparing `ima-predeployed-2.0.0b0.tar` & `ima-predeployed-2.0.0b1.tar`

### file list

```diff
@@ -1,72 +1,72 @@
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-12 12:03:55.170870 ima-predeployed-2.0.0b0/
--rw-r--r--   0 runner    (1001) docker     (123)    34522 2023-06-12 11:53:28.000000 ima-predeployed-2.0.0b0/LICENSE
--rw-r--r--   0 runner    (1001) docker     (123)       56 2023-06-12 11:53:28.000000 ima-predeployed-2.0.0b0/MANIFEST.in
--rw-r--r--   0 runner    (1001) docker     (123)      563 2023-06-12 12:03:55.174870 ima-predeployed-2.0.0b0/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (123)       83 2023-06-12 11:53:28.000000 ima-predeployed-2.0.0b0/README.md
--rw-r--r--   0 runner    (1001) docker     (123)      103 2023-06-12 11:53:28.000000 ima-predeployed-2.0.0b0/pyproject.toml
--rw-r--r--   0 runner    (1001) docker     (123)      704 2023-06-12 12:03:55.174870 ima-predeployed-2.0.0b0/setup.cfg
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-12 12:03:55.142870 ima-predeployed-2.0.0b0/src/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-12 12:03:55.146870 ima-predeployed-2.0.0b0/src/ima_predeployed/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-12 11:53:28.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1719 2023-06-12 11:53:28.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/addresses.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-12 12:03:55.166870 ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-12 11:53:28.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/.gitkeep
--rw-r--r--   0 runner    (1001) docker     (123)    46035 2023-06-12 12:03:39.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/CommunityLocker.json
--rw-r--r--   0 runner    (1001) docker     (123)   666877 2023-06-12 12:03:39.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/CommunityLocker.meta.json
--rw-r--r--   0 runner    (1001) docker     (123)    58650 2023-06-12 12:03:46.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/ERC1155OnChain.json
--rw-r--r--   0 runner    (1001) docker     (123)   666876 2023-06-12 12:03:46.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/ERC1155OnChain.meta.json
--rw-r--r--   0 runner    (1001) docker     (123)    40369 2023-06-12 12:03:44.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/ERC20OnChain.json
--rw-r--r--   0 runner    (1001) docker     (123)   666874 2023-06-12 12:03:44.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/ERC20OnChain.meta.json
--rw-r--r--   0 runner    (1001) docker     (123)    53201 2023-06-12 12:03:45.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/ERC721OnChain.json
--rw-r--r--   0 runner    (1001) docker     (123)   666875 2023-06-12 12:03:45.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/ERC721OnChain.meta.json
--rw-r--r--   0 runner    (1001) docker     (123)    39987 2023-06-12 12:03:43.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/EthErc20.json
--rw-r--r--   0 runner    (1001) docker     (123)   666870 2023-06-12 12:03:43.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/EthErc20.meta.json
--rw-r--r--   0 runner    (1001) docker     (123)    22061 2023-06-12 12:03:36.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/KeyStorage.json
--rw-r--r--   0 runner    (1001) docker     (123)   666872 2023-06-12 12:03:36.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/KeyStorage.meta.json
--rw-r--r--   0 runner    (1001) docker     (123)    94370 2023-06-12 12:03:36.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/MessageProxyForSchain.json
--rw-r--r--   0 runner    (1001) docker     (123)   666883 2023-06-12 12:03:36.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/MessageProxyForSchain.meta.json
--rw-r--r--   0 runner    (1001) docker     (123)    12032 2023-06-12 12:03:37.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/TokenManager.json
--rw-r--r--   0 runner    (1001) docker     (123)   666874 2023-06-12 12:03:37.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/TokenManager.meta.json
--rw-r--r--   0 runner    (1001) docker     (123)   157111 2023-06-12 12:03:42.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/TokenManagerERC1155.json
--rw-r--r--   0 runner    (1001) docker     (123)   666881 2023-06-12 12:03:42.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/TokenManagerERC1155.meta.json
--rw-r--r--   0 runner    (1001) docker     (123)   117065 2023-06-12 12:03:40.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/TokenManagerERC20.json
--rw-r--r--   0 runner    (1001) docker     (123)   666879 2023-06-12 12:03:40.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/TokenManagerERC20.meta.json
--rw-r--r--   0 runner    (1001) docker     (123)   121494 2023-06-12 12:03:40.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/TokenManagerERC721.json
--rw-r--r--   0 runner    (1001) docker     (123)   666880 2023-06-12 12:03:40.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/TokenManagerERC721.meta.json
--rw-r--r--   0 runner    (1001) docker     (123)   124162 2023-06-12 12:03:41.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/TokenManagerERC721WithMetadata.json
--rw-r--r--   0 runner    (1001) docker     (123)   666892 2023-06-12 12:03:41.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/TokenManagerERC721WithMetadata.meta.json
--rw-r--r--   0 runner    (1001) docker     (123)    48294 2023-06-12 12:03:43.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/TokenManagerEth.json
--rw-r--r--   0 runner    (1001) docker     (123)   666877 2023-06-12 12:03:43.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/TokenManagerEth.meta.json
--rw-r--r--   0 runner    (1001) docker     (123)    33186 2023-06-12 12:03:38.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/TokenManagerLinker.json
--rw-r--r--   0 runner    (1001) docker     (123)   666880 2023-06-12 12:03:38.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/TokenManagerLinker.meta.json
--rw-r--r--   0 runner    (1001) docker     (123)     4317 2023-06-12 11:53:28.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/contract_generator.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-12 12:03:55.170870 ima-predeployed-2.0.0b0/src/ima_predeployed/contracts/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-12 11:53:28.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/contracts/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)      747 2023-06-12 11:53:28.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/contracts/admin_upgradeability_proxy.py
--rw-r--r--   0 runner    (1001) docker     (123)     3814 2023-06-12 11:53:28.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/contracts/community_locker.py
--rw-r--r--   0 runner    (1001) docker     (123)      600 2023-06-12 11:53:28.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/contracts/erc1155_on_chain.py
--rw-r--r--   0 runner    (1001) docker     (123)      592 2023-06-12 11:53:28.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/contracts/erc20_on_chain.py
--rw-r--r--   0 runner    (1001) docker     (123)      596 2023-06-12 11:53:28.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/contracts/erc721_on_chain.py
--rw-r--r--   0 runner    (1001) docker     (123)     3248 2023-06-12 11:53:28.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/contracts/eth_erc20.py
--rw-r--r--   0 runner    (1001) docker     (123)     2125 2023-06-12 11:53:28.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/contracts/key_storage.py
--rw-r--r--   0 runner    (1001) docker     (123)     5507 2023-06-12 11:53:28.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/contracts/message_proxy_for_schain.py
--rw-r--r--   0 runner    (1001) docker     (123)      382 2023-06-12 11:53:28.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/contracts/proxy_admin.py
--rw-r--r--   0 runner    (1001) docker     (123)     3806 2023-06-12 11:53:28.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/contracts/token_manager.py
--rw-r--r--   0 runner    (1001) docker     (123)     1423 2023-06-12 11:53:28.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/contracts/token_manager_erc1155.py
--rw-r--r--   0 runner    (1001) docker     (123)     1440 2023-06-12 11:53:28.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/contracts/token_manager_erc20.py
--rw-r--r--   0 runner    (1001) docker     (123)     1415 2023-06-12 11:53:28.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/contracts/token_manager_erc721.py
--rw-r--r--   0 runner    (1001) docker     (123)     1536 2023-06-12 11:53:28.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/contracts/token_manager_erc721_with_metadata.py
--rw-r--r--   0 runner    (1001) docker     (123)     1786 2023-06-12 11:53:28.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/contracts/token_manager_eth.py
--rw-r--r--   0 runner    (1001) docker     (123)     3416 2023-06-12 11:53:28.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/contracts/token_manager_linker.py
--rw-r--r--   0 runner    (1001) docker     (123)    11195 2023-06-12 11:53:28.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/generator.py
--rw-r--r--   0 runner    (1001) docker     (123)      733 2023-06-12 11:53:28.000000 ima-predeployed-2.0.0b0/src/ima_predeployed/upgradeable_contract_generator.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-12 12:03:55.146870 ima-predeployed-2.0.0b0/src/ima_predeployed.egg-info/
--rw-r--r--   0 runner    (1001) docker     (123)      563 2023-06-12 12:03:55.000000 ima-predeployed-2.0.0b0/src/ima_predeployed.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (123)     2943 2023-06-12 12:03:55.000000 ima-predeployed-2.0.0b0/src/ima_predeployed.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (123)        1 2023-06-12 12:03:55.000000 ima-predeployed-2.0.0b0/src/ima_predeployed.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (123)       41 2023-06-12 12:03:55.000000 ima-predeployed-2.0.0b0/src/ima_predeployed.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (123)       16 2023-06-12 12:03:55.000000 ima-predeployed-2.0.0b0/src/ima_predeployed.egg-info/top_level.txt
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-12 12:03:55.170870 ima-predeployed-2.0.0b0/test/
--rw-r--r--   0 runner    (1001) docker     (123)     2074 2023-06-12 11:53:28.000000 ima-predeployed-2.0.0b0/test/test.py
--rw-r--r--   0 runner    (1001) docker     (123)      696 2023-06-12 11:53:28.000000 ima-predeployed-2.0.0b0/test/test_generator.py
--rw-r--r--   0 runner    (1001) docker     (123)        8 2023-06-12 12:03:35.000000 ima-predeployed-2.0.0b0/version.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 15:36:58.349431 ima-predeployed-2.0.0b1/
+-rw-r--r--   0 runner    (1001) docker     (123)    34522 2023-06-26 15:29:26.000000 ima-predeployed-2.0.0b1/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)       56 2023-06-26 15:29:26.000000 ima-predeployed-2.0.0b1/MANIFEST.in
+-rw-r--r--   0 runner    (1001) docker     (123)      563 2023-06-26 15:36:58.349431 ima-predeployed-2.0.0b1/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)       83 2023-06-26 15:29:26.000000 ima-predeployed-2.0.0b1/README.md
+-rw-r--r--   0 runner    (1001) docker     (123)      103 2023-06-26 15:29:26.000000 ima-predeployed-2.0.0b1/pyproject.toml
+-rw-r--r--   0 runner    (1001) docker     (123)      689 2023-06-26 15:36:58.349431 ima-predeployed-2.0.0b1/setup.cfg
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 15:36:58.329431 ima-predeployed-2.0.0b1/src/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 15:36:58.333431 ima-predeployed-2.0.0b1/src/ima_predeployed/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 15:29:26.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1719 2023-06-26 15:29:26.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/addresses.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 15:36:58.345431 ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 15:29:26.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/.gitkeep
+-rw-r--r--   0 runner    (1001) docker     (123)    46035 2023-06-26 15:36:47.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/CommunityLocker.json
+-rw-r--r--   0 runner    (1001) docker     (123)   673177 2023-06-26 15:36:47.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/CommunityLocker.meta.json
+-rw-r--r--   0 runner    (1001) docker     (123)    58650 2023-06-26 15:36:52.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/ERC1155OnChain.json
+-rw-r--r--   0 runner    (1001) docker     (123)   673176 2023-06-26 15:36:52.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/ERC1155OnChain.meta.json
+-rw-r--r--   0 runner    (1001) docker     (123)    40369 2023-06-26 15:36:50.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/ERC20OnChain.json
+-rw-r--r--   0 runner    (1001) docker     (123)   673174 2023-06-26 15:36:50.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/ERC20OnChain.meta.json
+-rw-r--r--   0 runner    (1001) docker     (123)    53201 2023-06-26 15:36:51.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/ERC721OnChain.json
+-rw-r--r--   0 runner    (1001) docker     (123)   673175 2023-06-26 15:36:51.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/ERC721OnChain.meta.json
+-rw-r--r--   0 runner    (1001) docker     (123)    39987 2023-06-26 15:36:50.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/EthErc20.json
+-rw-r--r--   0 runner    (1001) docker     (123)   673170 2023-06-26 15:36:50.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/EthErc20.meta.json
+-rw-r--r--   0 runner    (1001) docker     (123)    22061 2023-06-26 15:36:45.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/KeyStorage.json
+-rw-r--r--   0 runner    (1001) docker     (123)   673172 2023-06-26 15:36:45.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/KeyStorage.meta.json
+-rw-r--r--   0 runner    (1001) docker     (123)    94370 2023-06-26 15:36:45.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/MessageProxyForSchain.json
+-rw-r--r--   0 runner    (1001) docker     (123)   673183 2023-06-26 15:36:45.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/MessageProxyForSchain.meta.json
+-rw-r--r--   0 runner    (1001) docker     (123)    12032 2023-06-26 15:36:46.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/TokenManager.json
+-rw-r--r--   0 runner    (1001) docker     (123)   673174 2023-06-26 15:36:46.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/TokenManager.meta.json
+-rw-r--r--   0 runner    (1001) docker     (123)   157111 2023-06-26 15:36:49.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/TokenManagerERC1155.json
+-rw-r--r--   0 runner    (1001) docker     (123)   673181 2023-06-26 15:36:49.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/TokenManagerERC1155.meta.json
+-rw-r--r--   0 runner    (1001) docker     (123)   117065 2023-06-26 15:36:47.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/TokenManagerERC20.json
+-rw-r--r--   0 runner    (1001) docker     (123)   673179 2023-06-26 15:36:47.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/TokenManagerERC20.meta.json
+-rw-r--r--   0 runner    (1001) docker     (123)   121494 2023-06-26 15:36:48.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/TokenManagerERC721.json
+-rw-r--r--   0 runner    (1001) docker     (123)   673180 2023-06-26 15:36:48.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/TokenManagerERC721.meta.json
+-rw-r--r--   0 runner    (1001) docker     (123)   124162 2023-06-26 15:36:48.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/TokenManagerERC721WithMetadata.json
+-rw-r--r--   0 runner    (1001) docker     (123)   673192 2023-06-26 15:36:48.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/TokenManagerERC721WithMetadata.meta.json
+-rw-r--r--   0 runner    (1001) docker     (123)    48294 2023-06-26 15:36:49.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/TokenManagerEth.json
+-rw-r--r--   0 runner    (1001) docker     (123)   673177 2023-06-26 15:36:49.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/TokenManagerEth.meta.json
+-rw-r--r--   0 runner    (1001) docker     (123)    33186 2023-06-26 15:36:46.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/TokenManagerLinker.json
+-rw-r--r--   0 runner    (1001) docker     (123)   673180 2023-06-26 15:36:46.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/TokenManagerLinker.meta.json
+-rw-r--r--   0 runner    (1001) docker     (123)     4317 2023-06-26 15:29:26.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/contract_generator.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 15:36:58.349431 ima-predeployed-2.0.0b1/src/ima_predeployed/contracts/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 15:29:26.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/contracts/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      747 2023-06-26 15:29:26.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/contracts/admin_upgradeability_proxy.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3814 2023-06-26 15:29:26.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/contracts/community_locker.py
+-rw-r--r--   0 runner    (1001) docker     (123)      600 2023-06-26 15:29:26.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/contracts/erc1155_on_chain.py
+-rw-r--r--   0 runner    (1001) docker     (123)      592 2023-06-26 15:29:26.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/contracts/erc20_on_chain.py
+-rw-r--r--   0 runner    (1001) docker     (123)      596 2023-06-26 15:29:26.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/contracts/erc721_on_chain.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3248 2023-06-26 15:29:26.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/contracts/eth_erc20.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2125 2023-06-26 15:29:26.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/contracts/key_storage.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5507 2023-06-26 15:29:26.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/contracts/message_proxy_for_schain.py
+-rw-r--r--   0 runner    (1001) docker     (123)      382 2023-06-26 15:29:26.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/contracts/proxy_admin.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3806 2023-06-26 15:29:26.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/contracts/token_manager.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1423 2023-06-26 15:29:26.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/contracts/token_manager_erc1155.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1440 2023-06-26 15:29:26.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/contracts/token_manager_erc20.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1415 2023-06-26 15:29:26.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/contracts/token_manager_erc721.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1536 2023-06-26 15:29:26.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/contracts/token_manager_erc721_with_metadata.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1786 2023-06-26 15:29:26.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/contracts/token_manager_eth.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3416 2023-06-26 15:29:26.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/contracts/token_manager_linker.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11195 2023-06-26 15:29:26.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/generator.py
+-rw-r--r--   0 runner    (1001) docker     (123)      733 2023-06-26 15:29:26.000000 ima-predeployed-2.0.0b1/src/ima_predeployed/upgradeable_contract_generator.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 15:36:58.333431 ima-predeployed-2.0.0b1/src/ima_predeployed.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (123)      563 2023-06-26 15:36:58.000000 ima-predeployed-2.0.0b1/src/ima_predeployed.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     2943 2023-06-26 15:36:58.000000 ima-predeployed-2.0.0b1/src/ima_predeployed.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-06-26 15:36:58.000000 ima-predeployed-2.0.0b1/src/ima_predeployed.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       29 2023-06-26 15:36:58.000000 ima-predeployed-2.0.0b1/src/ima_predeployed.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       16 2023-06-26 15:36:58.000000 ima-predeployed-2.0.0b1/src/ima_predeployed.egg-info/top_level.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 15:36:58.349431 ima-predeployed-2.0.0b1/test/
+-rw-r--r--   0 runner    (1001) docker     (123)     2074 2023-06-26 15:29:26.000000 ima-predeployed-2.0.0b1/test/test.py
+-rw-r--r--   0 runner    (1001) docker     (123)      696 2023-06-26 15:29:26.000000 ima-predeployed-2.0.0b1/test/test_generator.py
+-rw-r--r--   0 runner    (1001) docker     (123)        8 2023-06-26 15:36:44.000000 ima-predeployed-2.0.0b1/version.txt
```

### Comparing `ima-predeployed-2.0.0b0/LICENSE` & `ima-predeployed-2.0.0b1/LICENSE`

 * *Files identical despite different names*

### Comparing `ima-predeployed-2.0.0b0/PKG-INFO` & `ima-predeployed-2.0.0b1/PKG-INFO`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: ima-predeployed
-Version: 2.0.0b0
+Version: 2.0.0b1
 Summary: A tool to generate config for predeployed IMA
 Home-page: https://github.com/skalenetwork/IMA
 Author: Dmytro Stebaiev
 Author-email: dmytro@skalelabs.com
 Classifier: Programming Language :: Python :: 3
 Classifier: License :: OSI Approved :: GNU Affero General Public License v3
 Classifier: Operating System :: OS Independent
```

### Comparing `ima-predeployed-2.0.0b0/setup.cfg` & `ima-predeployed-2.0.0b1/setup.cfg`

 * *Files 2% similar despite different names*

```diff
@@ -15,16 +15,15 @@
 [options]
 package_dir = 
 	= src
 packages = find:
 include_package_data = True
 python_requires = >=3.6
 install_requires = 
-	predeployed-generator >= 1.1.0
-	web3 >= 6.0.0
+	predeployed-generator >= 1.2.0
 
 [options.packages.find]
 where = src
 
 [egg_info]
 tag_build = 
 tag_date = 0
```

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/addresses.py` & `ima-predeployed-2.0.0b1/src/ima_predeployed/addresses.py`

 * *Files identical despite different names*

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/CommunityLocker.json` & `ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/CommunityLocker.json`

 * *Files identical despite different names*

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/CommunityLocker.meta.json` & `ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/TokenManagerERC20.meta.json`

 * *Files 1% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.8745592948717948%*

 * *Differences: {"'input'": "{'sources': {'@skalenetwork/skale-manager-interfaces/IWallets.sol': {'content': '// "*

 * *            'SPDX-License-Identifier: AGPL-3.0-only\\n\\n/*\\n    IWallets - SKALE Manager '*

 * *            'Interfaces\\n    Copyright (C) 2021-Present SKALE Labs\\n    @author Dmytro '*

 * *            'Stebaeiv\\n\\n    SKALE Manager Interfaces is free software: you can redistribute it '*

 * *            'and/or modify\\n    it under the terms of the GNU Affero General Public License as '*

 * *            'published\\n    by […]*

```diff
@@ -218,22 +218,28 @@
             },
             "@skalenetwork/ima-interfaces/schain/tokens/IEthErc20.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   IEthErc20 - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\n\ninterface IEthErc20 {\n    function mint(address account, uint256 amount) external;\n    function forceBurn(address account, uint256 amount) external;\n    function initialize(address tokenManagerEthAddress) external;\n}"
             },
             "@skalenetwork/skale-manager-interfaces/IContractManager.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IContractManager.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IContractManager {\n    /**\n     * @dev Emitted when contract is upgraded.\n     */\n    event ContractUpgraded(string contractsName, address contractsAddress);\n\n    function initialize() external;\n    function setContractsAddress(string calldata contractsName, address newContractsAddress) external;\n    function contracts(bytes32 nameHash) external view returns (address);\n    function getDelegationPeriodManager() external view returns (address);\n    function getBounty() external view returns (address);\n    function getValidatorService() external view returns (address);\n    function getTimeHelpers() external view returns (address);\n    function getConstantsHolder() external view returns (address);\n    function getSkaleToken() external view returns (address);\n    function getTokenState() external view returns (address);\n    function getPunisher() external view returns (address);\n    function getContract(string calldata name) external view returns (address);\n}"
             },
+            "@skalenetwork/skale-manager-interfaces/INodes.sol": {
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    INodes.sol - SKALE Manager\n    Copyright (C) 2018-Present SKALE Labs\n    @author Artem Payvin\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"./utils/IRandom.sol\";\n\ninterface INodes {\n    // All Nodes states\n    enum NodeStatus {Active, Leaving, Left, In_Maintenance}\n\n    struct Node {\n        string name;\n        bytes4 ip;\n        bytes4 publicIP;\n        uint16 port;\n        bytes32[2] publicKey;\n        uint startBlock;\n        uint lastRewardDate;\n        uint finishTime;\n        NodeStatus status;\n        uint validatorId;\n    }\n\n    // struct to note which Nodes and which number of Nodes owned by user\n    struct CreatedNodes {\n        mapping (uint => bool) isNodeExist;\n        uint numberOfNodes;\n    }\n\n    struct SpaceManaging {\n        uint8 freeSpace;\n        uint indexInSpaceMap;\n    }\n\n    struct NodeCreationParams {\n        string name;\n        bytes4 ip;\n        bytes4 publicIp;\n        uint16 port;\n        bytes32[2] publicKey;\n        uint16 nonce;\n        string domainName;\n    }\n    \n    /**\n     * @dev Emitted when a node is created.\n     */\n    event NodeCreated(\n        uint nodeIndex,\n        address owner,\n        string name,\n        bytes4 ip,\n        bytes4 publicIP,\n        uint16 port,\n        uint16 nonce,\n        string domainName\n    );\n\n    /**\n     * @dev Emitted when a node completes a network exit.\n     */\n    event ExitCompleted(\n        uint nodeIndex\n    );\n\n    /**\n     * @dev Emitted when a node begins to exit from the network.\n     */\n    event ExitInitialized(\n        uint nodeIndex,\n        uint startLeavingPeriod\n    );\n\n    /**\n     * @dev Emitted when a node set to in compliant or compliant.\n     */\n    event IncompliantNode(\n        uint indexed nodeIndex,\n        bool status\n    );\n\n    /**\n     * @dev Emitted when a node set to in maintenance or from in maintenance.\n     */\n    event MaintenanceNode(\n        uint indexed nodeIndex,\n        bool status\n    );\n\n    /**\n     * @dev Emitted when a node status changed.\n     */\n    event IPChanged(\n        uint indexed nodeIndex,\n        bytes4 previousIP,\n        bytes4 newIP\n    );\n    \n    function removeSpaceFromNode(uint nodeIndex, uint8 space) external returns (bool);\n    function addSpaceToNode(uint nodeIndex, uint8 space) external;\n    function changeNodeLastRewardDate(uint nodeIndex) external;\n    function changeNodeFinishTime(uint nodeIndex, uint time) external;\n    function createNode(address from, NodeCreationParams calldata params) external;\n    function initExit(uint nodeIndex) external;\n    function completeExit(uint nodeIndex) external returns (bool);\n    function deleteNodeForValidator(uint validatorId, uint nodeIndex) external;\n    function checkPossibilityCreatingNode(address nodeAddress) external;\n    function checkPossibilityToMaintainNode(uint validatorId, uint nodeIndex) external returns (bool);\n    function setNodeInMaintenance(uint nodeIndex) external;\n    function removeNodeFromInMaintenance(uint nodeIndex) external;\n    function setNodeIncompliant(uint nodeIndex) external;\n    function setNodeCompliant(uint nodeIndex) external;\n    function setDomainName(uint nodeIndex, string memory domainName) external;\n    function makeNodeVisible(uint nodeIndex) external;\n    function makeNodeInvisible(uint nodeIndex) external;\n    function changeIP(uint nodeIndex, bytes4 newIP, bytes4 newPublicIP) external;\n    function numberOfActiveNodes() external view returns (uint);\n    function incompliant(uint nodeIndex) external view returns (bool);\n    function getRandomNodeWithFreeSpace(\n        uint8 freeSpace,\n        IRandom.RandomGenerator memory randomGenerator\n    )\n        external\n        view\n        returns (uint);\n    function isTimeForReward(uint nodeIndex) external view returns (bool);\n    function getNodeIP(uint nodeIndex) external view returns (bytes4);\n    function getNodeDomainName(uint nodeIndex) external view returns (string memory);\n    function getNodePort(uint nodeIndex) external view returns (uint16);\n    function getNodePublicKey(uint nodeIndex) external view returns (bytes32[2] memory);\n    function getNodeAddress(uint nodeIndex) external view returns (address);\n    function getNodeFinishTime(uint nodeIndex) external view returns (uint);\n    function isNodeLeft(uint nodeIndex) external view returns (bool);\n    function isNodeInMaintenance(uint nodeIndex) external view returns (bool);\n    function getNodeLastRewardDate(uint nodeIndex) external view returns (uint);\n    function getNodeNextRewardDate(uint nodeIndex) external view returns (uint);\n    function getNumberOfNodes() external view returns (uint);\n    function getNumberOnlineNodes() external view returns (uint);\n    function getActiveNodeIds() external view returns (uint[] memory activeNodeIds);\n    function getNodeStatus(uint nodeIndex) external view returns (NodeStatus);\n    function getValidatorNodeIndexes(uint validatorId) external view returns (uint[] memory);\n    function countNodesWithFreeSpace(uint8 freeSpace) external view returns (uint count);\n    function getValidatorId(uint nodeIndex) external view returns (uint);\n    function isNodeExist(address from, uint nodeIndex) external view returns (bool);\n    function isNodeActive(uint nodeIndex) external view returns (bool);\n    function isNodeLeaving(uint nodeIndex) external view returns (bool);\n}\n"
+            },
             "@skalenetwork/skale-manager-interfaces/ISchains.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchains.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchains {\n\n    struct SchainOption {\n        string name;\n        bytes value;\n    }\n    \n    /**\n     * @dev Emitted when an schain is created.\n     */\n    event SchainCreated(\n        string name,\n        address owner,\n        uint partOfNode,\n        uint lifetime,\n        uint numberOfNodes,\n        uint deposit,\n        uint16 nonce,\n        bytes32 schainHash\n    );\n\n    /**\n     * @dev Emitted when an schain is deleted.\n     */\n    event SchainDeleted(\n        address owner,\n        string name,\n        bytes32 indexed schainHash\n    );\n\n    /**\n     * @dev Emitted when a node in an schain is rotated.\n     */\n    event NodeRotated(\n        bytes32 schainHash,\n        uint oldNode,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a node is added to an schain.\n     */\n    event NodeAdded(\n        bytes32 schainHash,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a group of nodes is created for an schain.\n     */\n    event SchainNodes(\n        string name,\n        bytes32 schainHash,\n        uint[] nodesInGroup\n    );\n\n    function addSchain(address from, uint deposit, bytes calldata data) external;\n    function addSchainByFoundation(\n        uint lifetime,\n        uint8 typeOfSchain,\n        uint16 nonce,\n        string calldata name,\n        address schainOwner,\n        address schainOriginator,\n        SchainOption[] calldata options\n    )\n        external\n        payable;\n    function deleteSchain(address from, string calldata name) external;\n    function deleteSchainByRoot(string calldata name) external;\n    function restartSchainCreation(string calldata name) external;\n    function verifySchainSignature(\n        uint256 signA,\n        uint256 signB,\n        bytes32 hash,\n        uint256 counter,\n        uint256 hashA,\n        uint256 hashB,\n        string calldata schainName\n    )\n        external\n        view\n        returns (bool);\n    function getSchainPrice(uint typeOfSchain, uint lifetime) external view returns (uint);\n    function getOption(bytes32 schainHash, string calldata optionName) external view returns (bytes memory);\n    function getOptions(bytes32 schainHash) external view returns (SchainOption[] memory);\n}"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchains.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchains {\n\n    struct SchainOption {\n        string name;\n        bytes value;\n    }\n    \n    /**\n     * @dev Emitted when an schain is created.\n     */\n    event SchainCreated(\n        string name,\n        address owner,\n        uint partOfNode,\n        uint lifetime,\n        uint numberOfNodes,\n        uint deposit,\n        uint16 nonce,\n        bytes32 schainHash\n    );\n\n    /**\n     * @dev Emitted when an schain is deleted.\n     */\n    event SchainDeleted(\n        address owner,\n        string name,\n        bytes32 indexed schainHash\n    );\n\n    /**\n     * @dev Emitted when a node in an schain is rotated.\n     */\n    event NodeRotated(\n        bytes32 schainHash,\n        uint oldNode,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a node is added to an schain.\n     */\n    event NodeAdded(\n        bytes32 schainHash,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a group of nodes is created for an schain.\n     */\n    event SchainNodes(\n        string name,\n        bytes32 schainHash,\n        uint[] nodesInGroup\n    );\n\n    function addSchain(address from, uint deposit, bytes calldata data) external;\n    function addSchainByFoundation(\n        uint lifetime,\n        uint8 typeOfSchain,\n        uint16 nonce,\n        string calldata name,\n        address schainOwner,\n        address schainOriginator,\n        SchainOption[] calldata options\n    )\n        external\n        payable;\n    function deleteSchain(address from, string calldata name) external;\n    function deleteSchainByRoot(string calldata name) external;\n    function restartSchainCreation(string calldata name) external;\n    function verifySchainSignature(\n        uint256 signA,\n        uint256 signB,\n        bytes32 hash,\n        uint256 counter,\n        uint256 hashA,\n        uint256 hashB,\n        string calldata schainName\n    )\n        external\n        view\n        returns (bool);\n    function getSchainPrice(uint typeOfSchain, uint lifetime) external view returns (uint);\n    function getOption(bytes32 schainHash, string calldata optionName) external view returns (bytes memory);\n    function getOptions(bytes32 schainHash) external view returns (SchainOption[] memory);\n}\n"
             },
             "@skalenetwork/skale-manager-interfaces/ISchainsInternal.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchainsInternal - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchainsInternal {\n    struct Schain {\n        string name;\n        address owner;\n        uint indexInOwnerList;\n        uint8 partOfNode;\n        uint lifetime;\n        uint startDate;\n        uint startBlock;\n        uint deposit;\n        uint64 index;\n        uint generation;\n        address originator;\n    }\n\n    struct SchainType {\n        uint8 partOfNode;\n        uint numberOfNodes;\n    }\n\n    /**\n     * @dev Emitted when schain type added.\n     */\n    event SchainTypeAdded(uint indexed schainType, uint partOfNode, uint numberOfNodes);\n\n    /**\n     * @dev Emitted when schain type removed.\n     */\n    event SchainTypeRemoved(uint indexed schainType);\n\n    function initializeSchain(\n        string calldata name,\n        address from,\n        address originator,\n        uint lifetime,\n        uint deposit) external;\n    function createGroupForSchain(\n        bytes32 schainHash,\n        uint numberOfNodes,\n        uint8 partOfNode\n    )\n        external\n        returns (uint[] memory);\n    function changeLifetime(bytes32 schainHash, uint lifetime, uint deposit) external;\n    function removeSchain(bytes32 schainHash, address from) external;\n    function removeNodeFromSchain(uint nodeIndex, bytes32 schainHash) external;\n    function deleteGroup(bytes32 schainHash) external;\n    function setException(bytes32 schainHash, uint nodeIndex) external;\n    function setNodeInGroup(bytes32 schainHash, uint nodeIndex) external;\n    function removeHolesForSchain(bytes32 schainHash) external;\n    function addSchainType(uint8 partOfNode, uint numberOfNodes) external;\n    function removeSchainType(uint typeOfSchain) external;\n    function setNumberOfSchainTypes(uint newNumberOfSchainTypes) external;\n    function removeNodeFromAllExceptionSchains(uint nodeIndex) external;\n    function removeAllNodesFromSchainExceptions(bytes32 schainHash) external;\n    function makeSchainNodesInvisible(bytes32 schainHash) external;\n    function makeSchainNodesVisible(bytes32 schainHash) external;\n    function newGeneration() external;\n    function addSchainForNode(uint nodeIndex, bytes32 schainHash) external;\n    function removeSchainForNode(uint nodeIndex, uint schainIndex) external;\n    function removeNodeFromExceptions(bytes32 schainHash, uint nodeIndex) external;\n    function isSchainActive(bytes32 schainHash) external view returns (bool);\n    function schainsAtSystem(uint index) external view returns (bytes32);\n    function numberOfSchains() external view returns (uint64);\n    function getSchains() external view returns (bytes32[] memory);\n    function getSchainsPartOfNode(bytes32 schainHash) external view returns (uint8);\n    function getSchainListSize(address from) external view returns (uint);\n    function getSchainHashesByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainIdsByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainHashesForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainIdsForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainOwner(bytes32 schainHash) external view returns (address);\n    function getSchainOriginator(bytes32 schainHash) external view returns (address);\n    function isSchainNameAvailable(string calldata name) external view returns (bool);\n    function isTimeExpired(bytes32 schainHash) external view returns (bool);\n    function isOwnerAddress(address from, bytes32 schainId) external view returns (bool);\n    function getSchainName(bytes32 schainHash) external view returns (string memory);\n    function getActiveSchain(uint nodeIndex) external view returns (bytes32);\n    function getActiveSchains(uint nodeIndex) external view returns (bytes32[] memory activeSchains);\n    function getNumberOfNodesInGroup(bytes32 schainHash) external view returns (uint);\n    function getNodesInGroup(bytes32 schainHash) external view returns (uint[] memory);\n    function isNodeAddressesInGroup(bytes32 schainId, address sender) external view returns (bool);\n    function getNodeIndexInGroup(bytes32 schainHash, uint nodeId) external view returns (uint);\n    function isAnyFreeNode(bytes32 schainHash) external view returns (bool);\n    function checkException(bytes32 schainHash, uint nodeIndex) external view returns (bool);\n    function checkHoleForSchain(bytes32 schainHash, uint indexOfNode) external view returns (bool);\n    function checkSchainOnNode(uint nodeIndex, bytes32 schainHash) external view returns (bool);\n    function getSchainType(uint typeOfSchain) external view returns(uint8, uint);\n    function getGeneration(bytes32 schainHash) external view returns (uint);\n    function isSchainExist(bytes32 schainHash) external view returns (bool);\n}"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchainsInternal - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"./INodes.sol\";\n\ninterface ISchainsInternal {\n    struct Schain {\n        string name;\n        address owner;\n        uint indexInOwnerList;\n        uint8 partOfNode;\n        uint lifetime;\n        uint startDate;\n        uint startBlock;\n        uint deposit;\n        uint64 index;\n        uint generation;\n        address originator;\n    }\n\n    struct SchainType {\n        uint8 partOfNode;\n        uint numberOfNodes;\n    }\n\n    /**\n     * @dev Emitted when schain type added.\n     */\n    event SchainTypeAdded(uint indexed schainType, uint partOfNode, uint numberOfNodes);\n\n    /**\n     * @dev Emitted when schain type removed.\n     */\n    event SchainTypeRemoved(uint indexed schainType);\n\n    function initializeSchain(\n        string calldata name,\n        address from,\n        address originator,\n        uint lifetime,\n        uint deposit) external;\n    function createGroupForSchain(\n        bytes32 schainHash,\n        uint numberOfNodes,\n        uint8 partOfNode\n    )\n        external\n        returns (uint[] memory);\n    function changeLifetime(bytes32 schainHash, uint lifetime, uint deposit) external;\n    function removeSchain(bytes32 schainHash, address from) external;\n    function removeNodeFromSchain(uint nodeIndex, bytes32 schainHash) external;\n    function deleteGroup(bytes32 schainHash) external;\n    function setException(bytes32 schainHash, uint nodeIndex) external;\n    function setNodeInGroup(bytes32 schainHash, uint nodeIndex) external;\n    function removeHolesForSchain(bytes32 schainHash) external;\n    function addSchainType(uint8 partOfNode, uint numberOfNodes) external;\n    function removeSchainType(uint typeOfSchain) external;\n    function setNumberOfSchainTypes(uint newNumberOfSchainTypes) external;\n    function removeNodeFromAllExceptionSchains(uint nodeIndex) external;\n    function removeAllNodesFromSchainExceptions(bytes32 schainHash) external;\n    function makeSchainNodesInvisible(bytes32 schainHash) external;\n    function makeSchainNodesVisible(bytes32 schainHash) external;\n    function newGeneration() external;\n    function addSchainForNode(INodes nodes,uint nodeIndex, bytes32 schainHash) external;\n    function removeSchainForNode(uint nodeIndex, uint schainIndex) external;\n    function removeNodeFromExceptions(bytes32 schainHash, uint nodeIndex) external;\n    function isSchainActive(bytes32 schainHash) external view returns (bool);\n    function schainsAtSystem(uint index) external view returns (bytes32);\n    function numberOfSchains() external view returns (uint64);\n    function getSchains() external view returns (bytes32[] memory);\n    function getSchainsPartOfNode(bytes32 schainHash) external view returns (uint8);\n    function getSchainListSize(address from) external view returns (uint);\n    function getSchainHashesByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainHashesForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainOwner(bytes32 schainHash) external view returns (address);\n    function getSchainOriginator(bytes32 schainHash) external view returns (address);\n    function isSchainNameAvailable(string calldata name) external view returns (bool);\n    function isTimeExpired(bytes32 schainHash) external view returns (bool);\n    function isOwnerAddress(address from, bytes32 schainHash) external view returns (bool);\n    function getSchainName(bytes32 schainHash) external view returns (string memory);\n    function getActiveSchain(uint nodeIndex) external view returns (bytes32);\n    function getActiveSchains(uint nodeIndex) external view returns (bytes32[] memory activeSchains);\n    function getNumberOfNodesInGroup(bytes32 schainHash) external view returns (uint);\n    function getNodesInGroup(bytes32 schainHash) external view returns (uint[] memory);\n    function isNodeAddressesInGroup(bytes32 schainHash, address sender) external view returns (bool);\n    function getNodeIndexInGroup(bytes32 schainHash, uint nodeHash) external view returns (uint);\n    function isAnyFreeNode(bytes32 schainHash) external view returns (bool);\n    function checkException(bytes32 schainHash, uint nodeIndex) external view returns (bool);\n    function checkHoleForSchain(bytes32 schainHash, uint indexOfNode) external view returns (bool);\n    function checkSchainOnNode(uint nodeIndex, bytes32 schainHash) external view returns (bool);\n    function getSchainType(uint typeOfSchain) external view returns(uint8, uint);\n    function getGeneration(bytes32 schainHash) external view returns (uint);\n    function isSchainExist(bytes32 schainHash) external view returns (bool);\n}"
             },
             "@skalenetwork/skale-manager-interfaces/IWallets.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IWallets - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IWallets {\n    /**\n     * @dev Emitted when the validator wallet was funded\n     */\n    event ValidatorWalletRecharged(address sponsor, uint amount, uint validatorId);\n\n    /**\n     * @dev Emitted when the schain wallet was funded\n     */\n    event SchainWalletRecharged(address sponsor, uint amount, bytes32 schainHash);\n\n    /**\n     * @dev Emitted when the node received a refund from validator to its wallet\n     */\n    event NodeRefundedByValidator(address node, uint validatorId, uint amount);\n\n    /**\n     * @dev Emitted when the node received a refund from schain to its wallet\n     */\n    event NodeRefundedBySchain(address node, bytes32 schainHash, uint amount);\n\n    /**\n     * @dev Emitted when the validator withdrawn funds from validator wallet\n     */\n    event WithdrawFromValidatorWallet(uint indexed validatorId, uint amount);\n\n    /**\n     * @dev Emitted when the schain owner withdrawn funds from schain wallet\n     */\n    event WithdrawFromSchainWallet(bytes32 indexed schainHash, uint amount);\n\n    receive() external payable;\n    function refundGasByValidator(uint validatorId, address payable spender, uint spentGas) external;\n    function refundGasByValidatorToSchain(uint validatorId, bytes32 schainHash) external;\n    function refundGasBySchain(bytes32 schainId, address payable spender, uint spentGas, bool isDebt) external;\n    function withdrawFundsFromSchainWallet(address payable schainOwner, bytes32 schainHash) external;\n    function withdrawFundsFromValidatorWallet(uint amount) external;\n    function rechargeValidatorWallet(uint validatorId) external payable;\n    function rechargeSchainWallet(bytes32 schainId) external payable;\n    function getSchainBalance(bytes32 schainHash) external view returns (uint);\n    function getValidatorBalance(uint validatorId) external view returns (uint);\n}\n"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IWallets - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IWallets {\n    receive() external payable;\n    function refundGasByValidator(uint validatorId, address payable spender, uint gasLimit) external;\n    function refundGasByValidatorToSchain(uint validatorId, bytes32 schainHash) external;\n    function refundGasBySchain(bytes32 schainId, address payable spender, uint spentGas, bool isDebt) external;\n    function withdrawFundsFromSchainWallet(address payable schainOwner, bytes32 schainHash) external;\n    function withdrawFundsFromValidatorWallet(uint amount) external;\n    function rechargeValidatorWallet(uint validatorId) external payable;\n    function rechargeSchainWallet(bytes32 schainId) external payable;\n    function getSchainBalance(bytes32 schainHash) external view returns (uint);\n    function getValidatorBalance(uint validatorId) external view returns (uint);\n}\n"
+            },
+            "@skalenetwork/skale-manager-interfaces/utils/IRandom.sol": {
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IRandom.sol - SKALE Manager Interfaces\n    Copyright (C) 2022-Present SKALE Labs\n    @author Dmytro Stebaiev\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\n\ninterface IRandom {\n    struct RandomGenerator {\n        uint seed;\n    }\n}"
             },
             "contracts/MessageProxy.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   MessageProxy.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/IGasReimbursable.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageProxy.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageReceiver.sol\";\n\n\n/**\n * @title MessageProxy\n * @dev Abstract contract for MessageProxyForMainnet and MessageProxyForSchain.\n */\nabstract contract MessageProxy is AccessControlEnumerableUpgradeable, IMessageProxy {\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    /**\n     * @dev Structure that stores counters for outgoing and incoming messages.\n     */\n    struct ConnectedChainInfo {\n        // message counters start with 0\n        uint256 incomingMessageCounter;\n        uint256 outgoingMessageCounter;\n        bool inited;\n        uint256 lastOutgoingMessageBlockId;\n    }\n\n    bytes32 public constant MAINNET_HASH = keccak256(abi.encodePacked(\"Mainnet\"));\n    bytes32 public constant CHAIN_CONNECTOR_ROLE = keccak256(\"CHAIN_CONNECTOR_ROLE\");\n    bytes32 public constant EXTRA_CONTRACT_REGISTRAR_ROLE = keccak256(\"EXTRA_CONTRACT_REGISTRAR_ROLE\");\n    bytes32 public constant CONSTANT_SETTER_ROLE = keccak256(\"CONSTANT_SETTER_ROLE\");\n    uint256 public constant MESSAGES_LENGTH = 10;\n    uint256 public constant REVERT_REASON_LENGTH = 64;\n\n    //   schainHash => ConnectedChainInfo\n    mapping(bytes32 => ConnectedChainInfo) public connectedChains;\n    //   schainHash => contract address => allowed\n    mapping(bytes32 => mapping(address => bool)) private _deprecatedRegistryContracts;\n\n    uint256 public gasLimit;\n\n    /**\n     * @dev Emitted for every outgoing message to schain.\n     */\n    event OutgoingMessage(\n        bytes32 indexed dstChainHash,\n        uint256 indexed msgCounter,\n        address indexed srcContract,\n        address dstContract,\n        bytes data\n    );\n\n    /**\n     * @dev Emitted when function `postMessage` returns revert.\n     *  Used to prevent stuck loop inside function `postIncomingMessages`.\n     */\n    event PostMessageError(\n        uint256 indexed msgCounter,\n        bytes message\n    );\n\n    /**\n     * @dev Emitted when gas limit per one call of `postMessage` was changed.\n     */\n    event GasLimitWasChanged(\n        uint256 oldValue,\n        uint256 newValue\n    );\n\n    /**\n     * @dev Emitted when the version was updated\n     */\n    event VersionUpdated(string oldVersion, string newVersion);\n\n    /**\n     * @dev Emitted when extra contract was added.\n     */\n    event ExtraContractRegistered(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Emitted when extra contract was removed.\n     */\n    event ExtraContractRemoved(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Emitted when referenced to previous outgoing message.\n     */\n    event PreviousMessageReference (\n        uint256 currentMessage,\n        uint256 previousOutgoingMessageBlockId\n    );\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CHAIN_CONNECTOR_ROLE}.\n     */\n    modifier onlyChainConnector() {\n        require(hasRole(CHAIN_CONNECTOR_ROLE, msg.sender), \"CHAIN_CONNECTOR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {EXTRA_CONTRACT_REGISTRAR_ROLE}.\n     */\n    modifier onlyExtraContractRegistrar() {\n        require(hasRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender), \"EXTRA_CONTRACT_REGISTRAR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CONSTANT_SETTER_ROLE}.\n     */\n    modifier onlyConstantSetter() {\n        require(hasRole(CONSTANT_SETTER_ROLE, msg.sender), \"Not enough permissions to set constant\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {DEFAULT_ADMIN_ROLE}.\n     */\n    modifier onlyOwner() {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"DEFAULT_ADMIN_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Sets gasLimit to a new value.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CONSTANT_SETTER_ROLE.\n     */\n    function setNewGasLimit(uint256 newGasLimit) external override onlyConstantSetter {\n        emit GasLimitWasChanged(gasLimit, newGasLimit);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Virtual function for `postIncomingMessages`.\n     */\n    function postIncomingMessages(\n        string calldata fromSchainName,\n        uint256 startingCounter,\n        Message[] calldata messages,\n        Signature calldata sign\n    )\n        external\n        virtual\n        override;\n\n    /**\n     * @dev Allows `msg.sender` to register extra contract for all schains\n     * for being able to transfer messages from custom contracts.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     * - Passed address should be contract.\n     * - Extra contract must not be registered.\n     */\n    function registerExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is already registered\");\n        _getRegistryContracts()[bytes32(0)].add(extraContract);\n        emit ExtraContractRegistered(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Allows `msg.sender` to remove extra contract for all schains.\n     * Extra contract will no longer be able to send messages through MessageProxy.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     */\n    function removeExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[bytes32(0)].remove(extraContract);\n        emit ExtraContractRemoved(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Should return length of contract registered by schainHash.\n     */\n    function getContractRegisteredLength(bytes32 schainHash) external view override returns (uint256) {\n        return _getRegistryContracts()[schainHash].length();\n    }\n\n    /**\n     * @dev Should return a range of contracts registered by schainHash.\n     *\n     * Requirements:\n     * range should be less or equal 10 contracts\n     */\n    function getContractRegisteredRange(\n        bytes32 schainHash,\n        uint256 from,\n        uint256 to\n    )\n        external\n        view\n        override\n        returns (address[] memory contractsInRange)\n    {\n        require(\n            from < to && to - from <= 10 && to <= _getRegistryContracts()[schainHash].length(),\n            \"Range is incorrect\"\n        );\n        contractsInRange = new address[](to - from);\n        for (uint256 i = from; i < to; i++) {\n            contractsInRange[i - from] = _getRegistryContracts()[schainHash].at(i);\n        }\n    }\n\n    /**\n     * @dev Returns number of outgoing messages.\n     *\n     * Requirements:\n     *\n     * - Target schain  must be initialized.\n     */\n    function getOutgoingMessagesCounter(string calldata targetSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 dstChainHash = keccak256(abi.encodePacked(targetSchainName));\n        require(connectedChains[dstChainHash].inited, \"Destination chain is not initialized\");\n        return connectedChains[dstChainHash].outgoingMessageCounter;\n    }\n\n\n    /**\n     * @dev Should return block number of the last message transferred to schain\n     */\n    function getLastOutgoingMessageBlockId(string memory targetSchainName) external view override returns (uint) {\n        bytes32 dstChainHash = keccak256(abi.encodePacked(targetSchainName));\n        require(connectedChains[dstChainHash].inited, \"Destination chain is not initialized\");\n        return connectedChains[dstChainHash].lastOutgoingMessageBlockId;\n    }\n\n    /**\n     * @dev Returns number of incoming messages.\n     *\n     * Requirements:\n     *\n     * - Source schain must be initialized.\n     */\n    function getIncomingMessagesCounter(string calldata fromSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 srcChainHash = keccak256(abi.encodePacked(fromSchainName));\n        require(connectedChains[srcChainHash].inited, \"Source chain is not initialized\");\n        return connectedChains[srcChainHash].incomingMessageCounter;\n    }\n\n    function initializeMessageProxy(uint newGasLimit) public initializer {\n        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(CHAIN_CONNECTOR_ROLE, msg.sender);\n        _setupRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender);\n        _setupRole(CONSTANT_SETTER_ROLE, msg.sender);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Posts message from this contract to `targetChainHash` MessageProxy contract.\n     * This is called by a smart contract to make a cross-chain call.\n     *\n     * Emits an {OutgoingMessage} event.\n     *\n     * Requirements:\n     *\n     * - Target chain must be initialized.\n     * - Target chain must be registered as external contract.\n     */\n    function postOutgoingMessage(\n        bytes32 targetChainHash,\n        address targetContract,\n        bytes memory data\n    )\n        public\n        override\n        virtual\n    {\n        require(connectedChains[targetChainHash].inited, \"Destination chain is not initialized\");\n        _authorizeOutgoingMessageSender(targetChainHash);\n\n        uint outgoingMessageCounter = connectedChains[targetChainHash].outgoingMessageCounter;\n        emit OutgoingMessage(\n            targetChainHash,\n            outgoingMessageCounter,\n            msg.sender,\n            targetContract,\n            data\n        );\n        emit PreviousMessageReference(\n            outgoingMessageCounter,\n            connectedChains[targetChainHash].lastOutgoingMessageBlockId\n        );\n        connectedChains[targetChainHash].outgoingMessageCounter++;\n        connectedChains[targetChainHash].lastOutgoingMessageBlockId = block.number;\n    }\n\n    /**\n     * @dev Allows CHAIN_CONNECTOR_ROLE to remove connected chain from this contract.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CHAIN_CONNECTOR_ROLE.\n     * - `schainName` must be initialized.\n     */\n    function removeConnectedChain(string memory schainName) public virtual override onlyChainConnector {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(connectedChains[schainHash].inited, \"Chain is not initialized\");\n        delete connectedChains[schainHash];\n    }\n\n    /**\n     * @dev Checks whether chain is currently connected.\n     */\n    function isConnectedChain(\n        string memory schainName\n    )\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return connectedChains[keccak256(abi.encodePacked(schainName))].inited;\n    }\n\n    /**\n     * @dev Checks whether contract is currently registered as extra contract.\n     */\n    function isContractRegistered(\n        bytes32 schainHash,\n        address contractAddress\n    )\n        public\n        view\n        override\n        returns (bool)\n    {\n        return _getRegistryContracts()[schainHash].contains(contractAddress);\n    }\n\n    /**\n     * @dev Allows MessageProxy to register extra contract for being able to transfer messages from custom contracts.\n     *\n     * Requirements:\n     *\n     * - Extra contract address must be contract.\n     * - Extra contract must not be registered.\n     * - Extra contract must not be registered for all chains.\n     */\n    function _registerExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {\n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is already registered\");\n        require(\n            !_getRegistryContracts()[bytes32(0)].contains(extraContract),\n            \"Extra contract is already registered for all chains\"\n        );\n\n        _getRegistryContracts()[chainHash].add(extraContract);\n        emit ExtraContractRegistered(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to remove extra contract,\n     * thus `extraContract` will no longer be available to transfer messages from mainnet to schain.\n     *\n     * Requirements:\n     *\n     * - Extra contract must be registered.\n     */\n    function _removeExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {\n        require(_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[chainHash].remove(extraContract);\n        emit ExtraContractRemoved(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to connect schain with MessageProxyOnMainnet for transferring messages.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CHAIN_CONNECTOR_ROLE.\n     * - SKALE chain must not be connected.\n     */\n    function _addConnectedChain(bytes32 schainHash) internal onlyChainConnector {\n        require(!connectedChains[schainHash].inited,\"Chain is already connected\");\n        connectedChains[schainHash] = ConnectedChainInfo({\n            incomingMessageCounter: 0,\n            outgoingMessageCounter: 0,\n            inited: true,\n            lastOutgoingMessageBlockId: 0\n        });\n    }\n\n    /**\n     * @dev Allows MessageProxy to send messages from schain to mainnet.\n     * Destination contract must implement `postMessage` method.\n     */\n    function _callReceiverContract(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n    {\n        if (!message.destinationContract.isContract()) {\n            emit PostMessageError(\n                counter,\n                \"Destination contract is not a contract\"\n            );\n            return;\n        }\n        try IMessageReceiver(message.destinationContract).postMessage{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) {\n            return;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                _getSlice(bytes(reason), REVERT_REASON_LENGTH)\n            );\n        } catch Panic(uint errorCode) {\n               emit PostMessageError(\n                counter,\n                abi.encodePacked(errorCode)\n            );\n        } catch (bytes memory revertData) {\n            emit PostMessageError(\n                counter,\n                _getSlice(revertData, REVERT_REASON_LENGTH)\n            );\n        }\n    }\n\n    /**\n     * @dev Returns receiver of message.\n     */\n    function _getGasPayer(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n        returns (address)\n    {\n        try IGasReimbursable(message.destinationContract).gasPayer{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) returns (address receiver) {\n            return receiver;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                _getSlice(bytes(reason), REVERT_REASON_LENGTH)\n            );\n            return address(0);\n        } catch Panic(uint errorCode) {\n               emit PostMessageError(\n                counter,\n                abi.encodePacked(errorCode)\n            );\n            return address(0);\n        } catch (bytes memory revertData) {\n            emit PostMessageError(\n                counter,\n                _getSlice(revertData, REVERT_REASON_LENGTH)\n            );\n            return address(0);\n        }\n    }\n\n    /**\n     * @dev Checks whether msg.sender is registered as custom extra contract.\n     */\n    function _authorizeOutgoingMessageSender(bytes32 targetChainHash) internal view virtual {\n        require(\n            isContractRegistered(bytes32(0), msg.sender) || isContractRegistered(targetChainHash, msg.sender),\n            \"Sender contract is not registered\"\n        );\n    }\n\n    /**\n     * @dev Returns list of registered custom extra contracts.\n     */\n    function _getRegistryContracts()\n        internal\n        view\n        virtual\n        returns (mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) storage);\n\n    /**\n     * @dev Returns hash of message array.\n     */\n    function _hashedArray(\n        Message[] calldata messages,\n        uint256 startingCounter,\n        string calldata fromChainName\n    )\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32 sourceHash = keccak256(abi.encodePacked(fromChainName));\n        bytes32 hash = keccak256(abi.encodePacked(sourceHash, bytes32(startingCounter)));\n        for (uint256 i = 0; i < messages.length; i++) {\n            hash = keccak256(\n                abi.encodePacked(\n                    abi.encode(\n                        hash,\n                        messages[i].sender,\n                        messages[i].destinationContract\n                    ),\n                    messages[i].data\n                )\n            );\n        }\n        return hash;\n    }\n\n    function _getSlice(bytes memory text, uint end) private pure returns (bytes memory) {\n        uint slicedEnd = end < text.length ? end : text.length;\n        bytes memory sliced = new bytes(slicedEnd);\n        for(uint i = 0; i < slicedEnd; i++){\n            sliced[i] = text[i];\n        }\n        return sliced;\n    }\n}\n"
             },
             "contracts/Messages.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   Messages.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\n\n/**\n * @title Messages\n * @dev Library for encoding and decoding messages\n * for transferring from Mainnet to Schain and vice versa.\n */\nlibrary Messages {\n\n    /**\n     * @dev Enumerator that describes all supported message types.\n     */\n    enum MessageType {\n        EMPTY,\n        TRANSFER_ETH,\n        TRANSFER_ERC20,\n        TRANSFER_ERC20_AND_TOTAL_SUPPLY,\n        TRANSFER_ERC20_AND_TOKEN_INFO,\n        TRANSFER_ERC721,\n        TRANSFER_ERC721_AND_TOKEN_INFO,\n        USER_STATUS,\n        INTERCHAIN_CONNECTION,\n        TRANSFER_ERC1155,\n        TRANSFER_ERC1155_AND_TOKEN_INFO,\n        TRANSFER_ERC1155_BATCH,\n        TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO,\n        TRANSFER_ERC721_WITH_METADATA,\n        TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO\n    }\n\n    /**\n     * @dev Structure for base message.\n     */\n    struct BaseMessage {\n        MessageType messageType;\n    }\n\n    /**\n     * @dev Structure for describing ETH.\n     */\n    struct TransferEthMessage {\n        BaseMessage message;\n        address receiver;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for user status.\n     */\n    struct UserStatusMessage {\n        BaseMessage message;\n        address receiver;\n        bool isActive;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 token.\n     */\n    struct TransferErc20Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC20 token.\n     */\n    struct Erc20TokenInfo {\n        string name;\n        uint8 decimals;\n        string symbol;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token supply.\n     */\n    struct TransferErc20AndTotalSupplyMessage {\n        TransferErc20Message baseErc20transfer;\n        uint256 totalSupply;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token info.\n     */\n    struct TransferErc20AndTokenInfoMessage {\n        TransferErc20Message baseErc20transfer;\n        uint256 totalSupply;\n        Erc20TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing base ERC721.\n     */\n    struct TransferErc721Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 tokenId;\n    }\n\n    /**\n     * @dev Structure for describing base ERC721 with metadata.\n     */\n    struct TransferErc721MessageWithMetadata {\n        TransferErc721Message erc721message;\n        string tokenURI;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token info.\n     */\n    struct Erc721TokenInfo {\n        string name;\n        string symbol;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC721 token.\n     */\n    struct TransferErc721AndTokenInfoMessage {\n        TransferErc721Message baseErc721transfer;\n        Erc721TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC721 token with metadata.\n     */\n    struct TransferErc721WithMetadataAndTokenInfoMessage {\n        TransferErc721MessageWithMetadata baseErc721transferWithMetadata;\n        Erc721TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing whether interchain connection is allowed.\n     */\n    struct InterchainConnectionMessage {\n        BaseMessage message;\n        bool isAllowed;\n    }\n\n    /**\n     * @dev Structure for describing whether interchain connection is allowed.\n     */\n    struct TransferErc1155Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 id;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for describing ERC1155 token in batches.\n     */\n    struct TransferErc1155BatchMessage {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256[] ids;\n        uint256[] amounts;\n    }\n\n    /**\n     * @dev Structure for describing ERC1155 token info.\n     */\n    struct Erc1155TokenInfo {\n        string uri;\n    }\n\n    /**\n     * @dev Structure for describing message for transferring ERC1155 token with info.\n     */\n    struct TransferErc1155AndTokenInfoMessage {\n        TransferErc1155Message baseErc1155transfer;\n        Erc1155TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing message for transferring ERC1155 token in batches with info.\n     */\n    struct TransferErc1155BatchAndTokenInfoMessage {\n        TransferErc1155BatchMessage baseErc1155Batchtransfer;\n        Erc1155TokenInfo tokenInfo;\n    }\n\n\n    /**\n     * @dev Returns type of message for encoded data.\n     */\n    function getMessageType(bytes calldata data) internal pure returns (MessageType) {\n        uint256 firstWord = abi.decode(data, (uint256));\n        if (firstWord % 32 == 0) {\n            return getMessageType(data[firstWord:]);\n        } else {\n            return abi.decode(data, (Messages.MessageType));\n        }\n    }\n\n    /**\n     * @dev Encodes message for transferring ETH. Returns encoded message.\n     */\n    function encodeTransferEthMessage(address receiver, uint256 amount) internal pure returns (bytes memory) {\n        TransferEthMessage memory message = TransferEthMessage(\n            BaseMessage(MessageType.TRANSFER_ETH),\n            receiver,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ETH. Returns structure `TransferEthMessage`.\n     */\n    function decodeTransferEthMessage(\n        bytes calldata data\n    ) internal pure returns (TransferEthMessage memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ETH, \"Message type is not ETH transfer\");\n        return abi.decode(data, (TransferEthMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ETH. Returns encoded message.\n     */\n    function encodeTransferErc20Message(\n        address token,\n        address receiver,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        TransferErc20Message memory message = TransferErc20Message(\n            BaseMessage(MessageType.TRANSFER_ERC20),\n            token,\n            receiver,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC20 with total supply. Returns encoded message.\n     */\n    function encodeTransferErc20AndTotalSupplyMessage(\n        address token,\n        address receiver,\n        uint256 amount,\n        uint256 totalSupply\n    ) internal pure returns (bytes memory) {\n        TransferErc20AndTotalSupplyMessage memory message = TransferErc20AndTotalSupplyMessage(\n            TransferErc20Message(\n                BaseMessage(MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY),\n                token,\n                receiver,\n                amount\n            ),\n            totalSupply\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20. Returns structure `TransferErc20Message`.\n     */\n    function decodeTransferErc20Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc20Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC20, \"Message type is not ERC20 transfer\");\n        return abi.decode(data, (TransferErc20Message));\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20 with total supply. \n     * Returns structure `TransferErc20AndTotalSupplyMessage`.\n     */\n    function decodeTransferErc20AndTotalSupplyMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc20AndTotalSupplyMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY,\n            \"Message type is not ERC20 transfer and total supply\"\n        );\n        return abi.decode(data, (TransferErc20AndTotalSupplyMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC20 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc20AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 amount,\n        uint256 totalSupply,\n        Erc20TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc20AndTokenInfoMessage memory message = TransferErc20AndTokenInfoMessage(\n            TransferErc20Message(\n                BaseMessage(MessageType.TRANSFER_ERC20_AND_TOKEN_INFO),\n                token,\n                receiver,\n                amount\n            ),\n            totalSupply,\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20 with token info. \n     * Returns structure `TransferErc20AndTokenInfoMessage`.\n     */\n    function decodeTransferErc20AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc20AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC20_AND_TOKEN_INFO,\n            \"Message type is not ERC20 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc20AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721Message(\n        address token,\n        address receiver,\n        uint256 tokenId\n    ) internal pure returns (bytes memory) {\n        TransferErc721Message memory message = TransferErc721Message(\n            BaseMessage(MessageType.TRANSFER_ERC721),\n            token,\n            receiver,\n            tokenId\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721. \n     * Returns structure `TransferErc721Message`.\n     */\n    function decodeTransferErc721Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc721Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC721, \"Message type is not ERC721 transfer\");\n        return abi.decode(data, (TransferErc721Message));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        Erc721TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc721AndTokenInfoMessage memory message = TransferErc721AndTokenInfoMessage(\n            TransferErc721Message(\n                BaseMessage(MessageType.TRANSFER_ERC721_AND_TOKEN_INFO),\n                token,\n                receiver,\n                tokenId\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721 with token info. \n     * Returns structure `TransferErc721AndTokenInfoMessage`.\n     */\n    function decodeTransferErc721AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc721AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_AND_TOKEN_INFO,\n            \"Message type is not ERC721 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc721AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721MessageWithMetadata(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        string memory tokenURI\n    ) internal pure returns (bytes memory) {\n        TransferErc721MessageWithMetadata memory message = TransferErc721MessageWithMetadata(\n            TransferErc721Message(\n                BaseMessage(MessageType.TRANSFER_ERC721_WITH_METADATA),\n                token,\n                receiver,\n                tokenId\n            ),\n            tokenURI\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721. \n     * Returns structure `TransferErc721MessageWithMetadata`.\n     */\n    function decodeTransferErc721MessageWithMetadata(\n        bytes calldata data\n    ) internal pure returns (TransferErc721MessageWithMetadata memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_WITH_METADATA,\n            \"Message type is not ERC721 transfer\"\n        );\n        return abi.decode(data, (TransferErc721MessageWithMetadata));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721WithMetadataAndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        string memory tokenURI,\n        Erc721TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc721WithMetadataAndTokenInfoMessage memory message = TransferErc721WithMetadataAndTokenInfoMessage(\n            TransferErc721MessageWithMetadata(\n                TransferErc721Message(\n                    BaseMessage(MessageType.TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO),\n                    token,\n                    receiver,\n                    tokenId\n                ),\n                tokenURI\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721 with token info. \n     * Returns structure `TransferErc721WithMetadataAndTokenInfoMessage`.\n     */\n    function decodeTransferErc721WithMetadataAndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc721WithMetadataAndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO,\n            \"Message type is not ERC721 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc721WithMetadataAndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for activating user on schain. \n     * Returns encoded message.\n     */\n    function encodeActivateUserMessage(address receiver) internal pure returns (bytes memory){\n        return _encodeUserStatusMessage(receiver, true);\n    }\n\n    /**\n     * @dev Encodes message for locking user on schain. \n     * Returns encoded message.\n     */\n    function encodeLockUserMessage(address receiver) internal pure returns (bytes memory){\n        return _encodeUserStatusMessage(receiver, false);\n    }\n\n    /**\n     * @dev Decodes message for user status. \n     * Returns structure UserStatusMessage.\n     */\n    function decodeUserStatusMessage(bytes calldata data) internal pure returns (UserStatusMessage memory) {\n        require(getMessageType(data) == MessageType.USER_STATUS, \"Message type is not User Status\");\n        return abi.decode(data, (UserStatusMessage));\n    }\n\n\n    /**\n     * @dev Encodes message for allowing interchain connection.\n     * Returns encoded message.\n     */\n    function encodeInterchainConnectionMessage(bool isAllowed) internal pure returns (bytes memory) {\n        InterchainConnectionMessage memory message = InterchainConnectionMessage(\n            BaseMessage(MessageType.INTERCHAIN_CONNECTION),\n            isAllowed\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for allowing interchain connection.\n     * Returns structure `InterchainConnectionMessage`.\n     */\n    function decodeInterchainConnectionMessage(bytes calldata data)\n        internal\n        pure\n        returns (InterchainConnectionMessage memory)\n    {\n        require(getMessageType(data) == MessageType.INTERCHAIN_CONNECTION, \"Message type is not Interchain connection\");\n        return abi.decode(data, (InterchainConnectionMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155Message(\n        address token,\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        TransferErc1155Message memory message = TransferErc1155Message(\n            BaseMessage(MessageType.TRANSFER_ERC1155),\n            token,\n            receiver,\n            id,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token.\n     * Returns structure `TransferErc1155Message`.\n     */\n    function decodeTransferErc1155Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC1155, \"Message type is not ERC1155 transfer\");\n        return abi.decode(data, (TransferErc1155Message));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 with token info.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 id,\n        uint256 amount,\n        Erc1155TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc1155AndTokenInfoMessage memory message = TransferErc1155AndTokenInfoMessage(\n            TransferErc1155Message(\n                BaseMessage(MessageType.TRANSFER_ERC1155_AND_TOKEN_INFO),\n                token,\n                receiver,\n                id,\n                amount\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 with token info.\n     * Returns structure `TransferErc1155AndTokenInfoMessage`.\n     */\n    function decodeTransferErc1155AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_AND_TOKEN_INFO,\n            \"Message type is not ERC1155AndTokenInfo transfer\"\n        );\n        return abi.decode(data, (TransferErc1155AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token in batches.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155BatchMessage(\n        address token,\n        address receiver,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal pure returns (bytes memory) {\n        TransferErc1155BatchMessage memory message = TransferErc1155BatchMessage(\n            BaseMessage(MessageType.TRANSFER_ERC1155_BATCH),\n            token,\n            receiver,\n            ids,\n            amounts\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token in batches.\n     * Returns structure `TransferErc1155BatchMessage`.\n     */\n    function decodeTransferErc1155BatchMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155BatchMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_BATCH,\n            \"Message type is not ERC1155Batch transfer\"\n        );\n        return abi.decode(data, (TransferErc1155BatchMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token in batches with token info.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155BatchAndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        Erc1155TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc1155BatchAndTokenInfoMessage memory message = TransferErc1155BatchAndTokenInfoMessage(\n            TransferErc1155BatchMessage(\n                BaseMessage(MessageType.TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO),\n                token,\n                receiver,\n                ids,\n                amounts\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token in batches with token info.\n     * Returns structure `TransferErc1155BatchAndTokenInfoMessage`.\n     */\n    function decodeTransferErc1155BatchAndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155BatchAndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO,\n            \"Message type is not ERC1155BatchAndTokenInfo transfer\"\n        );\n        return abi.decode(data, (TransferErc1155BatchAndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring user status on schain.\n     * Returns encoded message.\n     */\n    function _encodeUserStatusMessage(address receiver, bool isActive) private pure returns (bytes memory) {\n        UserStatusMessage memory message = UserStatusMessage(\n            BaseMessage(MessageType.USER_STATUS),\n            receiver,\n            isActive\n        );\n        return abi.encode(message);\n    }\n\n}"
             },
@@ -403,11 +409,11 @@
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   RevertableERC20.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2022-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\ninterface IRevertableERC20 {\n    function enable() external;\n    function disable() external;\n    function mint(address account, uint amount) external;\n}\n\ncontract RevertableERC20 is IRevertableERC20, ERC20Upgradeable {\n    bool public enabled = true;\n\n    constructor(string memory name, string memory symbol) initializer {\n        super.__ERC20_init(name, symbol);\n    }\n\n    function enable() external override {\n        enabled = true;\n    }\n\n    function disable() external override {\n        enabled = false;\n    }\n\n    function mint(address account, uint amount) external override {\n        _mint(account, amount);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    )\n        internal\n        override\n    {\n        require(enabled, \"Transfers are disabled\");\n        super._transfer(from, to, amount);\n    }\n}"
             },
             "contracts/thirdparty/ERC1155ReceiverUpgradeableWithoutGap.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol\";\n\nabstract contract ERC1155ReceiverUpgradeableWithoutGap is\n    Initializable,\n    ERC165Upgradeable,\n    IERC1155ReceiverUpgradeable\n{\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165Upgradeable)\n        returns (bool)\n    {\n        return interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function __ERC1155Receiver_init() internal initializer {\n        __ERC165_init_unchained();\n        __ERC1155Receiver_init_unchained();\n    }\n\n    // solhint-disable-next-line func-name-mixedcase, no-empty-blocks\n    function __ERC1155Receiver_init_unchained() internal initializer {\n    }\n}"
             }
         }
     },
-    "name": "CommunityLocker",
+    "name": "TokenManagerERC20",
     "solcLongVersion": "0.8.16+commit.07a7930e",
     "solcVersion": "0.8.16"
 }
```

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/ERC1155OnChain.json` & `ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/ERC1155OnChain.json`

 * *Files identical despite different names*

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/ERC1155OnChain.meta.json` & `ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/CommunityLocker.meta.json`

 * *Files 1% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.8745592948717948%*

 * *Differences: {"'input'": "{'sources': {'@skalenetwork/skale-manager-interfaces/IWallets.sol': {'content': '// "*

 * *            'SPDX-License-Identifier: AGPL-3.0-only\\n\\n/*\\n    IWallets - SKALE Manager '*

 * *            'Interfaces\\n    Copyright (C) 2021-Present SKALE Labs\\n    @author Dmytro '*

 * *            'Stebaeiv\\n\\n    SKALE Manager Interfaces is free software: you can redistribute it '*

 * *            'and/or modify\\n    it under the terms of the GNU Affero General Public License as '*

 * *            'published\\n    by […]*

```diff
@@ -218,22 +218,28 @@
             },
             "@skalenetwork/ima-interfaces/schain/tokens/IEthErc20.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   IEthErc20 - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\n\ninterface IEthErc20 {\n    function mint(address account, uint256 amount) external;\n    function forceBurn(address account, uint256 amount) external;\n    function initialize(address tokenManagerEthAddress) external;\n}"
             },
             "@skalenetwork/skale-manager-interfaces/IContractManager.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IContractManager.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IContractManager {\n    /**\n     * @dev Emitted when contract is upgraded.\n     */\n    event ContractUpgraded(string contractsName, address contractsAddress);\n\n    function initialize() external;\n    function setContractsAddress(string calldata contractsName, address newContractsAddress) external;\n    function contracts(bytes32 nameHash) external view returns (address);\n    function getDelegationPeriodManager() external view returns (address);\n    function getBounty() external view returns (address);\n    function getValidatorService() external view returns (address);\n    function getTimeHelpers() external view returns (address);\n    function getConstantsHolder() external view returns (address);\n    function getSkaleToken() external view returns (address);\n    function getTokenState() external view returns (address);\n    function getPunisher() external view returns (address);\n    function getContract(string calldata name) external view returns (address);\n}"
             },
+            "@skalenetwork/skale-manager-interfaces/INodes.sol": {
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    INodes.sol - SKALE Manager\n    Copyright (C) 2018-Present SKALE Labs\n    @author Artem Payvin\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"./utils/IRandom.sol\";\n\ninterface INodes {\n    // All Nodes states\n    enum NodeStatus {Active, Leaving, Left, In_Maintenance}\n\n    struct Node {\n        string name;\n        bytes4 ip;\n        bytes4 publicIP;\n        uint16 port;\n        bytes32[2] publicKey;\n        uint startBlock;\n        uint lastRewardDate;\n        uint finishTime;\n        NodeStatus status;\n        uint validatorId;\n    }\n\n    // struct to note which Nodes and which number of Nodes owned by user\n    struct CreatedNodes {\n        mapping (uint => bool) isNodeExist;\n        uint numberOfNodes;\n    }\n\n    struct SpaceManaging {\n        uint8 freeSpace;\n        uint indexInSpaceMap;\n    }\n\n    struct NodeCreationParams {\n        string name;\n        bytes4 ip;\n        bytes4 publicIp;\n        uint16 port;\n        bytes32[2] publicKey;\n        uint16 nonce;\n        string domainName;\n    }\n    \n    /**\n     * @dev Emitted when a node is created.\n     */\n    event NodeCreated(\n        uint nodeIndex,\n        address owner,\n        string name,\n        bytes4 ip,\n        bytes4 publicIP,\n        uint16 port,\n        uint16 nonce,\n        string domainName\n    );\n\n    /**\n     * @dev Emitted when a node completes a network exit.\n     */\n    event ExitCompleted(\n        uint nodeIndex\n    );\n\n    /**\n     * @dev Emitted when a node begins to exit from the network.\n     */\n    event ExitInitialized(\n        uint nodeIndex,\n        uint startLeavingPeriod\n    );\n\n    /**\n     * @dev Emitted when a node set to in compliant or compliant.\n     */\n    event IncompliantNode(\n        uint indexed nodeIndex,\n        bool status\n    );\n\n    /**\n     * @dev Emitted when a node set to in maintenance or from in maintenance.\n     */\n    event MaintenanceNode(\n        uint indexed nodeIndex,\n        bool status\n    );\n\n    /**\n     * @dev Emitted when a node status changed.\n     */\n    event IPChanged(\n        uint indexed nodeIndex,\n        bytes4 previousIP,\n        bytes4 newIP\n    );\n    \n    function removeSpaceFromNode(uint nodeIndex, uint8 space) external returns (bool);\n    function addSpaceToNode(uint nodeIndex, uint8 space) external;\n    function changeNodeLastRewardDate(uint nodeIndex) external;\n    function changeNodeFinishTime(uint nodeIndex, uint time) external;\n    function createNode(address from, NodeCreationParams calldata params) external;\n    function initExit(uint nodeIndex) external;\n    function completeExit(uint nodeIndex) external returns (bool);\n    function deleteNodeForValidator(uint validatorId, uint nodeIndex) external;\n    function checkPossibilityCreatingNode(address nodeAddress) external;\n    function checkPossibilityToMaintainNode(uint validatorId, uint nodeIndex) external returns (bool);\n    function setNodeInMaintenance(uint nodeIndex) external;\n    function removeNodeFromInMaintenance(uint nodeIndex) external;\n    function setNodeIncompliant(uint nodeIndex) external;\n    function setNodeCompliant(uint nodeIndex) external;\n    function setDomainName(uint nodeIndex, string memory domainName) external;\n    function makeNodeVisible(uint nodeIndex) external;\n    function makeNodeInvisible(uint nodeIndex) external;\n    function changeIP(uint nodeIndex, bytes4 newIP, bytes4 newPublicIP) external;\n    function numberOfActiveNodes() external view returns (uint);\n    function incompliant(uint nodeIndex) external view returns (bool);\n    function getRandomNodeWithFreeSpace(\n        uint8 freeSpace,\n        IRandom.RandomGenerator memory randomGenerator\n    )\n        external\n        view\n        returns (uint);\n    function isTimeForReward(uint nodeIndex) external view returns (bool);\n    function getNodeIP(uint nodeIndex) external view returns (bytes4);\n    function getNodeDomainName(uint nodeIndex) external view returns (string memory);\n    function getNodePort(uint nodeIndex) external view returns (uint16);\n    function getNodePublicKey(uint nodeIndex) external view returns (bytes32[2] memory);\n    function getNodeAddress(uint nodeIndex) external view returns (address);\n    function getNodeFinishTime(uint nodeIndex) external view returns (uint);\n    function isNodeLeft(uint nodeIndex) external view returns (bool);\n    function isNodeInMaintenance(uint nodeIndex) external view returns (bool);\n    function getNodeLastRewardDate(uint nodeIndex) external view returns (uint);\n    function getNodeNextRewardDate(uint nodeIndex) external view returns (uint);\n    function getNumberOfNodes() external view returns (uint);\n    function getNumberOnlineNodes() external view returns (uint);\n    function getActiveNodeIds() external view returns (uint[] memory activeNodeIds);\n    function getNodeStatus(uint nodeIndex) external view returns (NodeStatus);\n    function getValidatorNodeIndexes(uint validatorId) external view returns (uint[] memory);\n    function countNodesWithFreeSpace(uint8 freeSpace) external view returns (uint count);\n    function getValidatorId(uint nodeIndex) external view returns (uint);\n    function isNodeExist(address from, uint nodeIndex) external view returns (bool);\n    function isNodeActive(uint nodeIndex) external view returns (bool);\n    function isNodeLeaving(uint nodeIndex) external view returns (bool);\n}\n"
+            },
             "@skalenetwork/skale-manager-interfaces/ISchains.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchains.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchains {\n\n    struct SchainOption {\n        string name;\n        bytes value;\n    }\n    \n    /**\n     * @dev Emitted when an schain is created.\n     */\n    event SchainCreated(\n        string name,\n        address owner,\n        uint partOfNode,\n        uint lifetime,\n        uint numberOfNodes,\n        uint deposit,\n        uint16 nonce,\n        bytes32 schainHash\n    );\n\n    /**\n     * @dev Emitted when an schain is deleted.\n     */\n    event SchainDeleted(\n        address owner,\n        string name,\n        bytes32 indexed schainHash\n    );\n\n    /**\n     * @dev Emitted when a node in an schain is rotated.\n     */\n    event NodeRotated(\n        bytes32 schainHash,\n        uint oldNode,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a node is added to an schain.\n     */\n    event NodeAdded(\n        bytes32 schainHash,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a group of nodes is created for an schain.\n     */\n    event SchainNodes(\n        string name,\n        bytes32 schainHash,\n        uint[] nodesInGroup\n    );\n\n    function addSchain(address from, uint deposit, bytes calldata data) external;\n    function addSchainByFoundation(\n        uint lifetime,\n        uint8 typeOfSchain,\n        uint16 nonce,\n        string calldata name,\n        address schainOwner,\n        address schainOriginator,\n        SchainOption[] calldata options\n    )\n        external\n        payable;\n    function deleteSchain(address from, string calldata name) external;\n    function deleteSchainByRoot(string calldata name) external;\n    function restartSchainCreation(string calldata name) external;\n    function verifySchainSignature(\n        uint256 signA,\n        uint256 signB,\n        bytes32 hash,\n        uint256 counter,\n        uint256 hashA,\n        uint256 hashB,\n        string calldata schainName\n    )\n        external\n        view\n        returns (bool);\n    function getSchainPrice(uint typeOfSchain, uint lifetime) external view returns (uint);\n    function getOption(bytes32 schainHash, string calldata optionName) external view returns (bytes memory);\n    function getOptions(bytes32 schainHash) external view returns (SchainOption[] memory);\n}"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchains.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchains {\n\n    struct SchainOption {\n        string name;\n        bytes value;\n    }\n    \n    /**\n     * @dev Emitted when an schain is created.\n     */\n    event SchainCreated(\n        string name,\n        address owner,\n        uint partOfNode,\n        uint lifetime,\n        uint numberOfNodes,\n        uint deposit,\n        uint16 nonce,\n        bytes32 schainHash\n    );\n\n    /**\n     * @dev Emitted when an schain is deleted.\n     */\n    event SchainDeleted(\n        address owner,\n        string name,\n        bytes32 indexed schainHash\n    );\n\n    /**\n     * @dev Emitted when a node in an schain is rotated.\n     */\n    event NodeRotated(\n        bytes32 schainHash,\n        uint oldNode,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a node is added to an schain.\n     */\n    event NodeAdded(\n        bytes32 schainHash,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a group of nodes is created for an schain.\n     */\n    event SchainNodes(\n        string name,\n        bytes32 schainHash,\n        uint[] nodesInGroup\n    );\n\n    function addSchain(address from, uint deposit, bytes calldata data) external;\n    function addSchainByFoundation(\n        uint lifetime,\n        uint8 typeOfSchain,\n        uint16 nonce,\n        string calldata name,\n        address schainOwner,\n        address schainOriginator,\n        SchainOption[] calldata options\n    )\n        external\n        payable;\n    function deleteSchain(address from, string calldata name) external;\n    function deleteSchainByRoot(string calldata name) external;\n    function restartSchainCreation(string calldata name) external;\n    function verifySchainSignature(\n        uint256 signA,\n        uint256 signB,\n        bytes32 hash,\n        uint256 counter,\n        uint256 hashA,\n        uint256 hashB,\n        string calldata schainName\n    )\n        external\n        view\n        returns (bool);\n    function getSchainPrice(uint typeOfSchain, uint lifetime) external view returns (uint);\n    function getOption(bytes32 schainHash, string calldata optionName) external view returns (bytes memory);\n    function getOptions(bytes32 schainHash) external view returns (SchainOption[] memory);\n}\n"
             },
             "@skalenetwork/skale-manager-interfaces/ISchainsInternal.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchainsInternal - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchainsInternal {\n    struct Schain {\n        string name;\n        address owner;\n        uint indexInOwnerList;\n        uint8 partOfNode;\n        uint lifetime;\n        uint startDate;\n        uint startBlock;\n        uint deposit;\n        uint64 index;\n        uint generation;\n        address originator;\n    }\n\n    struct SchainType {\n        uint8 partOfNode;\n        uint numberOfNodes;\n    }\n\n    /**\n     * @dev Emitted when schain type added.\n     */\n    event SchainTypeAdded(uint indexed schainType, uint partOfNode, uint numberOfNodes);\n\n    /**\n     * @dev Emitted when schain type removed.\n     */\n    event SchainTypeRemoved(uint indexed schainType);\n\n    function initializeSchain(\n        string calldata name,\n        address from,\n        address originator,\n        uint lifetime,\n        uint deposit) external;\n    function createGroupForSchain(\n        bytes32 schainHash,\n        uint numberOfNodes,\n        uint8 partOfNode\n    )\n        external\n        returns (uint[] memory);\n    function changeLifetime(bytes32 schainHash, uint lifetime, uint deposit) external;\n    function removeSchain(bytes32 schainHash, address from) external;\n    function removeNodeFromSchain(uint nodeIndex, bytes32 schainHash) external;\n    function deleteGroup(bytes32 schainHash) external;\n    function setException(bytes32 schainHash, uint nodeIndex) external;\n    function setNodeInGroup(bytes32 schainHash, uint nodeIndex) external;\n    function removeHolesForSchain(bytes32 schainHash) external;\n    function addSchainType(uint8 partOfNode, uint numberOfNodes) external;\n    function removeSchainType(uint typeOfSchain) external;\n    function setNumberOfSchainTypes(uint newNumberOfSchainTypes) external;\n    function removeNodeFromAllExceptionSchains(uint nodeIndex) external;\n    function removeAllNodesFromSchainExceptions(bytes32 schainHash) external;\n    function makeSchainNodesInvisible(bytes32 schainHash) external;\n    function makeSchainNodesVisible(bytes32 schainHash) external;\n    function newGeneration() external;\n    function addSchainForNode(uint nodeIndex, bytes32 schainHash) external;\n    function removeSchainForNode(uint nodeIndex, uint schainIndex) external;\n    function removeNodeFromExceptions(bytes32 schainHash, uint nodeIndex) external;\n    function isSchainActive(bytes32 schainHash) external view returns (bool);\n    function schainsAtSystem(uint index) external view returns (bytes32);\n    function numberOfSchains() external view returns (uint64);\n    function getSchains() external view returns (bytes32[] memory);\n    function getSchainsPartOfNode(bytes32 schainHash) external view returns (uint8);\n    function getSchainListSize(address from) external view returns (uint);\n    function getSchainHashesByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainIdsByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainHashesForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainIdsForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainOwner(bytes32 schainHash) external view returns (address);\n    function getSchainOriginator(bytes32 schainHash) external view returns (address);\n    function isSchainNameAvailable(string calldata name) external view returns (bool);\n    function isTimeExpired(bytes32 schainHash) external view returns (bool);\n    function isOwnerAddress(address from, bytes32 schainId) external view returns (bool);\n    function getSchainName(bytes32 schainHash) external view returns (string memory);\n    function getActiveSchain(uint nodeIndex) external view returns (bytes32);\n    function getActiveSchains(uint nodeIndex) external view returns (bytes32[] memory activeSchains);\n    function getNumberOfNodesInGroup(bytes32 schainHash) external view returns (uint);\n    function getNodesInGroup(bytes32 schainHash) external view returns (uint[] memory);\n    function isNodeAddressesInGroup(bytes32 schainId, address sender) external view returns (bool);\n    function getNodeIndexInGroup(bytes32 schainHash, uint nodeId) external view returns (uint);\n    function isAnyFreeNode(bytes32 schainHash) external view returns (bool);\n    function checkException(bytes32 schainHash, uint nodeIndex) external view returns (bool);\n    function checkHoleForSchain(bytes32 schainHash, uint indexOfNode) external view returns (bool);\n    function checkSchainOnNode(uint nodeIndex, bytes32 schainHash) external view returns (bool);\n    function getSchainType(uint typeOfSchain) external view returns(uint8, uint);\n    function getGeneration(bytes32 schainHash) external view returns (uint);\n    function isSchainExist(bytes32 schainHash) external view returns (bool);\n}"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchainsInternal - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"./INodes.sol\";\n\ninterface ISchainsInternal {\n    struct Schain {\n        string name;\n        address owner;\n        uint indexInOwnerList;\n        uint8 partOfNode;\n        uint lifetime;\n        uint startDate;\n        uint startBlock;\n        uint deposit;\n        uint64 index;\n        uint generation;\n        address originator;\n    }\n\n    struct SchainType {\n        uint8 partOfNode;\n        uint numberOfNodes;\n    }\n\n    /**\n     * @dev Emitted when schain type added.\n     */\n    event SchainTypeAdded(uint indexed schainType, uint partOfNode, uint numberOfNodes);\n\n    /**\n     * @dev Emitted when schain type removed.\n     */\n    event SchainTypeRemoved(uint indexed schainType);\n\n    function initializeSchain(\n        string calldata name,\n        address from,\n        address originator,\n        uint lifetime,\n        uint deposit) external;\n    function createGroupForSchain(\n        bytes32 schainHash,\n        uint numberOfNodes,\n        uint8 partOfNode\n    )\n        external\n        returns (uint[] memory);\n    function changeLifetime(bytes32 schainHash, uint lifetime, uint deposit) external;\n    function removeSchain(bytes32 schainHash, address from) external;\n    function removeNodeFromSchain(uint nodeIndex, bytes32 schainHash) external;\n    function deleteGroup(bytes32 schainHash) external;\n    function setException(bytes32 schainHash, uint nodeIndex) external;\n    function setNodeInGroup(bytes32 schainHash, uint nodeIndex) external;\n    function removeHolesForSchain(bytes32 schainHash) external;\n    function addSchainType(uint8 partOfNode, uint numberOfNodes) external;\n    function removeSchainType(uint typeOfSchain) external;\n    function setNumberOfSchainTypes(uint newNumberOfSchainTypes) external;\n    function removeNodeFromAllExceptionSchains(uint nodeIndex) external;\n    function removeAllNodesFromSchainExceptions(bytes32 schainHash) external;\n    function makeSchainNodesInvisible(bytes32 schainHash) external;\n    function makeSchainNodesVisible(bytes32 schainHash) external;\n    function newGeneration() external;\n    function addSchainForNode(INodes nodes,uint nodeIndex, bytes32 schainHash) external;\n    function removeSchainForNode(uint nodeIndex, uint schainIndex) external;\n    function removeNodeFromExceptions(bytes32 schainHash, uint nodeIndex) external;\n    function isSchainActive(bytes32 schainHash) external view returns (bool);\n    function schainsAtSystem(uint index) external view returns (bytes32);\n    function numberOfSchains() external view returns (uint64);\n    function getSchains() external view returns (bytes32[] memory);\n    function getSchainsPartOfNode(bytes32 schainHash) external view returns (uint8);\n    function getSchainListSize(address from) external view returns (uint);\n    function getSchainHashesByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainHashesForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainOwner(bytes32 schainHash) external view returns (address);\n    function getSchainOriginator(bytes32 schainHash) external view returns (address);\n    function isSchainNameAvailable(string calldata name) external view returns (bool);\n    function isTimeExpired(bytes32 schainHash) external view returns (bool);\n    function isOwnerAddress(address from, bytes32 schainHash) external view returns (bool);\n    function getSchainName(bytes32 schainHash) external view returns (string memory);\n    function getActiveSchain(uint nodeIndex) external view returns (bytes32);\n    function getActiveSchains(uint nodeIndex) external view returns (bytes32[] memory activeSchains);\n    function getNumberOfNodesInGroup(bytes32 schainHash) external view returns (uint);\n    function getNodesInGroup(bytes32 schainHash) external view returns (uint[] memory);\n    function isNodeAddressesInGroup(bytes32 schainHash, address sender) external view returns (bool);\n    function getNodeIndexInGroup(bytes32 schainHash, uint nodeHash) external view returns (uint);\n    function isAnyFreeNode(bytes32 schainHash) external view returns (bool);\n    function checkException(bytes32 schainHash, uint nodeIndex) external view returns (bool);\n    function checkHoleForSchain(bytes32 schainHash, uint indexOfNode) external view returns (bool);\n    function checkSchainOnNode(uint nodeIndex, bytes32 schainHash) external view returns (bool);\n    function getSchainType(uint typeOfSchain) external view returns(uint8, uint);\n    function getGeneration(bytes32 schainHash) external view returns (uint);\n    function isSchainExist(bytes32 schainHash) external view returns (bool);\n}"
             },
             "@skalenetwork/skale-manager-interfaces/IWallets.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IWallets - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IWallets {\n    /**\n     * @dev Emitted when the validator wallet was funded\n     */\n    event ValidatorWalletRecharged(address sponsor, uint amount, uint validatorId);\n\n    /**\n     * @dev Emitted when the schain wallet was funded\n     */\n    event SchainWalletRecharged(address sponsor, uint amount, bytes32 schainHash);\n\n    /**\n     * @dev Emitted when the node received a refund from validator to its wallet\n     */\n    event NodeRefundedByValidator(address node, uint validatorId, uint amount);\n\n    /**\n     * @dev Emitted when the node received a refund from schain to its wallet\n     */\n    event NodeRefundedBySchain(address node, bytes32 schainHash, uint amount);\n\n    /**\n     * @dev Emitted when the validator withdrawn funds from validator wallet\n     */\n    event WithdrawFromValidatorWallet(uint indexed validatorId, uint amount);\n\n    /**\n     * @dev Emitted when the schain owner withdrawn funds from schain wallet\n     */\n    event WithdrawFromSchainWallet(bytes32 indexed schainHash, uint amount);\n\n    receive() external payable;\n    function refundGasByValidator(uint validatorId, address payable spender, uint spentGas) external;\n    function refundGasByValidatorToSchain(uint validatorId, bytes32 schainHash) external;\n    function refundGasBySchain(bytes32 schainId, address payable spender, uint spentGas, bool isDebt) external;\n    function withdrawFundsFromSchainWallet(address payable schainOwner, bytes32 schainHash) external;\n    function withdrawFundsFromValidatorWallet(uint amount) external;\n    function rechargeValidatorWallet(uint validatorId) external payable;\n    function rechargeSchainWallet(bytes32 schainId) external payable;\n    function getSchainBalance(bytes32 schainHash) external view returns (uint);\n    function getValidatorBalance(uint validatorId) external view returns (uint);\n}\n"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IWallets - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IWallets {\n    receive() external payable;\n    function refundGasByValidator(uint validatorId, address payable spender, uint gasLimit) external;\n    function refundGasByValidatorToSchain(uint validatorId, bytes32 schainHash) external;\n    function refundGasBySchain(bytes32 schainId, address payable spender, uint spentGas, bool isDebt) external;\n    function withdrawFundsFromSchainWallet(address payable schainOwner, bytes32 schainHash) external;\n    function withdrawFundsFromValidatorWallet(uint amount) external;\n    function rechargeValidatorWallet(uint validatorId) external payable;\n    function rechargeSchainWallet(bytes32 schainId) external payable;\n    function getSchainBalance(bytes32 schainHash) external view returns (uint);\n    function getValidatorBalance(uint validatorId) external view returns (uint);\n}\n"
+            },
+            "@skalenetwork/skale-manager-interfaces/utils/IRandom.sol": {
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IRandom.sol - SKALE Manager Interfaces\n    Copyright (C) 2022-Present SKALE Labs\n    @author Dmytro Stebaiev\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\n\ninterface IRandom {\n    struct RandomGenerator {\n        uint seed;\n    }\n}"
             },
             "contracts/MessageProxy.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   MessageProxy.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/IGasReimbursable.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageProxy.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageReceiver.sol\";\n\n\n/**\n * @title MessageProxy\n * @dev Abstract contract for MessageProxyForMainnet and MessageProxyForSchain.\n */\nabstract contract MessageProxy is AccessControlEnumerableUpgradeable, IMessageProxy {\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    /**\n     * @dev Structure that stores counters for outgoing and incoming messages.\n     */\n    struct ConnectedChainInfo {\n        // message counters start with 0\n        uint256 incomingMessageCounter;\n        uint256 outgoingMessageCounter;\n        bool inited;\n        uint256 lastOutgoingMessageBlockId;\n    }\n\n    bytes32 public constant MAINNET_HASH = keccak256(abi.encodePacked(\"Mainnet\"));\n    bytes32 public constant CHAIN_CONNECTOR_ROLE = keccak256(\"CHAIN_CONNECTOR_ROLE\");\n    bytes32 public constant EXTRA_CONTRACT_REGISTRAR_ROLE = keccak256(\"EXTRA_CONTRACT_REGISTRAR_ROLE\");\n    bytes32 public constant CONSTANT_SETTER_ROLE = keccak256(\"CONSTANT_SETTER_ROLE\");\n    uint256 public constant MESSAGES_LENGTH = 10;\n    uint256 public constant REVERT_REASON_LENGTH = 64;\n\n    //   schainHash => ConnectedChainInfo\n    mapping(bytes32 => ConnectedChainInfo) public connectedChains;\n    //   schainHash => contract address => allowed\n    mapping(bytes32 => mapping(address => bool)) private _deprecatedRegistryContracts;\n\n    uint256 public gasLimit;\n\n    /**\n     * @dev Emitted for every outgoing message to schain.\n     */\n    event OutgoingMessage(\n        bytes32 indexed dstChainHash,\n        uint256 indexed msgCounter,\n        address indexed srcContract,\n        address dstContract,\n        bytes data\n    );\n\n    /**\n     * @dev Emitted when function `postMessage` returns revert.\n     *  Used to prevent stuck loop inside function `postIncomingMessages`.\n     */\n    event PostMessageError(\n        uint256 indexed msgCounter,\n        bytes message\n    );\n\n    /**\n     * @dev Emitted when gas limit per one call of `postMessage` was changed.\n     */\n    event GasLimitWasChanged(\n        uint256 oldValue,\n        uint256 newValue\n    );\n\n    /**\n     * @dev Emitted when the version was updated\n     */\n    event VersionUpdated(string oldVersion, string newVersion);\n\n    /**\n     * @dev Emitted when extra contract was added.\n     */\n    event ExtraContractRegistered(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Emitted when extra contract was removed.\n     */\n    event ExtraContractRemoved(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Emitted when referenced to previous outgoing message.\n     */\n    event PreviousMessageReference (\n        uint256 currentMessage,\n        uint256 previousOutgoingMessageBlockId\n    );\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CHAIN_CONNECTOR_ROLE}.\n     */\n    modifier onlyChainConnector() {\n        require(hasRole(CHAIN_CONNECTOR_ROLE, msg.sender), \"CHAIN_CONNECTOR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {EXTRA_CONTRACT_REGISTRAR_ROLE}.\n     */\n    modifier onlyExtraContractRegistrar() {\n        require(hasRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender), \"EXTRA_CONTRACT_REGISTRAR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CONSTANT_SETTER_ROLE}.\n     */\n    modifier onlyConstantSetter() {\n        require(hasRole(CONSTANT_SETTER_ROLE, msg.sender), \"Not enough permissions to set constant\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {DEFAULT_ADMIN_ROLE}.\n     */\n    modifier onlyOwner() {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"DEFAULT_ADMIN_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Sets gasLimit to a new value.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CONSTANT_SETTER_ROLE.\n     */\n    function setNewGasLimit(uint256 newGasLimit) external override onlyConstantSetter {\n        emit GasLimitWasChanged(gasLimit, newGasLimit);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Virtual function for `postIncomingMessages`.\n     */\n    function postIncomingMessages(\n        string calldata fromSchainName,\n        uint256 startingCounter,\n        Message[] calldata messages,\n        Signature calldata sign\n    )\n        external\n        virtual\n        override;\n\n    /**\n     * @dev Allows `msg.sender` to register extra contract for all schains\n     * for being able to transfer messages from custom contracts.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     * - Passed address should be contract.\n     * - Extra contract must not be registered.\n     */\n    function registerExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is already registered\");\n        _getRegistryContracts()[bytes32(0)].add(extraContract);\n        emit ExtraContractRegistered(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Allows `msg.sender` to remove extra contract for all schains.\n     * Extra contract will no longer be able to send messages through MessageProxy.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     */\n    function removeExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[bytes32(0)].remove(extraContract);\n        emit ExtraContractRemoved(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Should return length of contract registered by schainHash.\n     */\n    function getContractRegisteredLength(bytes32 schainHash) external view override returns (uint256) {\n        return _getRegistryContracts()[schainHash].length();\n    }\n\n    /**\n     * @dev Should return a range of contracts registered by schainHash.\n     *\n     * Requirements:\n     * range should be less or equal 10 contracts\n     */\n    function getContractRegisteredRange(\n        bytes32 schainHash,\n        uint256 from,\n        uint256 to\n    )\n        external\n        view\n        override\n        returns (address[] memory contractsInRange)\n    {\n        require(\n            from < to && to - from <= 10 && to <= _getRegistryContracts()[schainHash].length(),\n            \"Range is incorrect\"\n        );\n        contractsInRange = new address[](to - from);\n        for (uint256 i = from; i < to; i++) {\n            contractsInRange[i - from] = _getRegistryContracts()[schainHash].at(i);\n        }\n    }\n\n    /**\n     * @dev Returns number of outgoing messages.\n     *\n     * Requirements:\n     *\n     * - Target schain  must be initialized.\n     */\n    function getOutgoingMessagesCounter(string calldata targetSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 dstChainHash = keccak256(abi.encodePacked(targetSchainName));\n        require(connectedChains[dstChainHash].inited, \"Destination chain is not initialized\");\n        return connectedChains[dstChainHash].outgoingMessageCounter;\n    }\n\n\n    /**\n     * @dev Should return block number of the last message transferred to schain\n     */\n    function getLastOutgoingMessageBlockId(string memory targetSchainName) external view override returns (uint) {\n        bytes32 dstChainHash = keccak256(abi.encodePacked(targetSchainName));\n        require(connectedChains[dstChainHash].inited, \"Destination chain is not initialized\");\n        return connectedChains[dstChainHash].lastOutgoingMessageBlockId;\n    }\n\n    /**\n     * @dev Returns number of incoming messages.\n     *\n     * Requirements:\n     *\n     * - Source schain must be initialized.\n     */\n    function getIncomingMessagesCounter(string calldata fromSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 srcChainHash = keccak256(abi.encodePacked(fromSchainName));\n        require(connectedChains[srcChainHash].inited, \"Source chain is not initialized\");\n        return connectedChains[srcChainHash].incomingMessageCounter;\n    }\n\n    function initializeMessageProxy(uint newGasLimit) public initializer {\n        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(CHAIN_CONNECTOR_ROLE, msg.sender);\n        _setupRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender);\n        _setupRole(CONSTANT_SETTER_ROLE, msg.sender);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Posts message from this contract to `targetChainHash` MessageProxy contract.\n     * This is called by a smart contract to make a cross-chain call.\n     *\n     * Emits an {OutgoingMessage} event.\n     *\n     * Requirements:\n     *\n     * - Target chain must be initialized.\n     * - Target chain must be registered as external contract.\n     */\n    function postOutgoingMessage(\n        bytes32 targetChainHash,\n        address targetContract,\n        bytes memory data\n    )\n        public\n        override\n        virtual\n    {\n        require(connectedChains[targetChainHash].inited, \"Destination chain is not initialized\");\n        _authorizeOutgoingMessageSender(targetChainHash);\n\n        uint outgoingMessageCounter = connectedChains[targetChainHash].outgoingMessageCounter;\n        emit OutgoingMessage(\n            targetChainHash,\n            outgoingMessageCounter,\n            msg.sender,\n            targetContract,\n            data\n        );\n        emit PreviousMessageReference(\n            outgoingMessageCounter,\n            connectedChains[targetChainHash].lastOutgoingMessageBlockId\n        );\n        connectedChains[targetChainHash].outgoingMessageCounter++;\n        connectedChains[targetChainHash].lastOutgoingMessageBlockId = block.number;\n    }\n\n    /**\n     * @dev Allows CHAIN_CONNECTOR_ROLE to remove connected chain from this contract.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CHAIN_CONNECTOR_ROLE.\n     * - `schainName` must be initialized.\n     */\n    function removeConnectedChain(string memory schainName) public virtual override onlyChainConnector {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(connectedChains[schainHash].inited, \"Chain is not initialized\");\n        delete connectedChains[schainHash];\n    }\n\n    /**\n     * @dev Checks whether chain is currently connected.\n     */\n    function isConnectedChain(\n        string memory schainName\n    )\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return connectedChains[keccak256(abi.encodePacked(schainName))].inited;\n    }\n\n    /**\n     * @dev Checks whether contract is currently registered as extra contract.\n     */\n    function isContractRegistered(\n        bytes32 schainHash,\n        address contractAddress\n    )\n        public\n        view\n        override\n        returns (bool)\n    {\n        return _getRegistryContracts()[schainHash].contains(contractAddress);\n    }\n\n    /**\n     * @dev Allows MessageProxy to register extra contract for being able to transfer messages from custom contracts.\n     *\n     * Requirements:\n     *\n     * - Extra contract address must be contract.\n     * - Extra contract must not be registered.\n     * - Extra contract must not be registered for all chains.\n     */\n    function _registerExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {\n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is already registered\");\n        require(\n            !_getRegistryContracts()[bytes32(0)].contains(extraContract),\n            \"Extra contract is already registered for all chains\"\n        );\n\n        _getRegistryContracts()[chainHash].add(extraContract);\n        emit ExtraContractRegistered(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to remove extra contract,\n     * thus `extraContract` will no longer be available to transfer messages from mainnet to schain.\n     *\n     * Requirements:\n     *\n     * - Extra contract must be registered.\n     */\n    function _removeExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {\n        require(_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[chainHash].remove(extraContract);\n        emit ExtraContractRemoved(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to connect schain with MessageProxyOnMainnet for transferring messages.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CHAIN_CONNECTOR_ROLE.\n     * - SKALE chain must not be connected.\n     */\n    function _addConnectedChain(bytes32 schainHash) internal onlyChainConnector {\n        require(!connectedChains[schainHash].inited,\"Chain is already connected\");\n        connectedChains[schainHash] = ConnectedChainInfo({\n            incomingMessageCounter: 0,\n            outgoingMessageCounter: 0,\n            inited: true,\n            lastOutgoingMessageBlockId: 0\n        });\n    }\n\n    /**\n     * @dev Allows MessageProxy to send messages from schain to mainnet.\n     * Destination contract must implement `postMessage` method.\n     */\n    function _callReceiverContract(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n    {\n        if (!message.destinationContract.isContract()) {\n            emit PostMessageError(\n                counter,\n                \"Destination contract is not a contract\"\n            );\n            return;\n        }\n        try IMessageReceiver(message.destinationContract).postMessage{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) {\n            return;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                _getSlice(bytes(reason), REVERT_REASON_LENGTH)\n            );\n        } catch Panic(uint errorCode) {\n               emit PostMessageError(\n                counter,\n                abi.encodePacked(errorCode)\n            );\n        } catch (bytes memory revertData) {\n            emit PostMessageError(\n                counter,\n                _getSlice(revertData, REVERT_REASON_LENGTH)\n            );\n        }\n    }\n\n    /**\n     * @dev Returns receiver of message.\n     */\n    function _getGasPayer(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n        returns (address)\n    {\n        try IGasReimbursable(message.destinationContract).gasPayer{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) returns (address receiver) {\n            return receiver;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                _getSlice(bytes(reason), REVERT_REASON_LENGTH)\n            );\n            return address(0);\n        } catch Panic(uint errorCode) {\n               emit PostMessageError(\n                counter,\n                abi.encodePacked(errorCode)\n            );\n            return address(0);\n        } catch (bytes memory revertData) {\n            emit PostMessageError(\n                counter,\n                _getSlice(revertData, REVERT_REASON_LENGTH)\n            );\n            return address(0);\n        }\n    }\n\n    /**\n     * @dev Checks whether msg.sender is registered as custom extra contract.\n     */\n    function _authorizeOutgoingMessageSender(bytes32 targetChainHash) internal view virtual {\n        require(\n            isContractRegistered(bytes32(0), msg.sender) || isContractRegistered(targetChainHash, msg.sender),\n            \"Sender contract is not registered\"\n        );\n    }\n\n    /**\n     * @dev Returns list of registered custom extra contracts.\n     */\n    function _getRegistryContracts()\n        internal\n        view\n        virtual\n        returns (mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) storage);\n\n    /**\n     * @dev Returns hash of message array.\n     */\n    function _hashedArray(\n        Message[] calldata messages,\n        uint256 startingCounter,\n        string calldata fromChainName\n    )\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32 sourceHash = keccak256(abi.encodePacked(fromChainName));\n        bytes32 hash = keccak256(abi.encodePacked(sourceHash, bytes32(startingCounter)));\n        for (uint256 i = 0; i < messages.length; i++) {\n            hash = keccak256(\n                abi.encodePacked(\n                    abi.encode(\n                        hash,\n                        messages[i].sender,\n                        messages[i].destinationContract\n                    ),\n                    messages[i].data\n                )\n            );\n        }\n        return hash;\n    }\n\n    function _getSlice(bytes memory text, uint end) private pure returns (bytes memory) {\n        uint slicedEnd = end < text.length ? end : text.length;\n        bytes memory sliced = new bytes(slicedEnd);\n        for(uint i = 0; i < slicedEnd; i++){\n            sliced[i] = text[i];\n        }\n        return sliced;\n    }\n}\n"
             },
             "contracts/Messages.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   Messages.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\n\n/**\n * @title Messages\n * @dev Library for encoding and decoding messages\n * for transferring from Mainnet to Schain and vice versa.\n */\nlibrary Messages {\n\n    /**\n     * @dev Enumerator that describes all supported message types.\n     */\n    enum MessageType {\n        EMPTY,\n        TRANSFER_ETH,\n        TRANSFER_ERC20,\n        TRANSFER_ERC20_AND_TOTAL_SUPPLY,\n        TRANSFER_ERC20_AND_TOKEN_INFO,\n        TRANSFER_ERC721,\n        TRANSFER_ERC721_AND_TOKEN_INFO,\n        USER_STATUS,\n        INTERCHAIN_CONNECTION,\n        TRANSFER_ERC1155,\n        TRANSFER_ERC1155_AND_TOKEN_INFO,\n        TRANSFER_ERC1155_BATCH,\n        TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO,\n        TRANSFER_ERC721_WITH_METADATA,\n        TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO\n    }\n\n    /**\n     * @dev Structure for base message.\n     */\n    struct BaseMessage {\n        MessageType messageType;\n    }\n\n    /**\n     * @dev Structure for describing ETH.\n     */\n    struct TransferEthMessage {\n        BaseMessage message;\n        address receiver;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for user status.\n     */\n    struct UserStatusMessage {\n        BaseMessage message;\n        address receiver;\n        bool isActive;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 token.\n     */\n    struct TransferErc20Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC20 token.\n     */\n    struct Erc20TokenInfo {\n        string name;\n        uint8 decimals;\n        string symbol;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token supply.\n     */\n    struct TransferErc20AndTotalSupplyMessage {\n        TransferErc20Message baseErc20transfer;\n        uint256 totalSupply;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token info.\n     */\n    struct TransferErc20AndTokenInfoMessage {\n        TransferErc20Message baseErc20transfer;\n        uint256 totalSupply;\n        Erc20TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing base ERC721.\n     */\n    struct TransferErc721Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 tokenId;\n    }\n\n    /**\n     * @dev Structure for describing base ERC721 with metadata.\n     */\n    struct TransferErc721MessageWithMetadata {\n        TransferErc721Message erc721message;\n        string tokenURI;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token info.\n     */\n    struct Erc721TokenInfo {\n        string name;\n        string symbol;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC721 token.\n     */\n    struct TransferErc721AndTokenInfoMessage {\n        TransferErc721Message baseErc721transfer;\n        Erc721TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC721 token with metadata.\n     */\n    struct TransferErc721WithMetadataAndTokenInfoMessage {\n        TransferErc721MessageWithMetadata baseErc721transferWithMetadata;\n        Erc721TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing whether interchain connection is allowed.\n     */\n    struct InterchainConnectionMessage {\n        BaseMessage message;\n        bool isAllowed;\n    }\n\n    /**\n     * @dev Structure for describing whether interchain connection is allowed.\n     */\n    struct TransferErc1155Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 id;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for describing ERC1155 token in batches.\n     */\n    struct TransferErc1155BatchMessage {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256[] ids;\n        uint256[] amounts;\n    }\n\n    /**\n     * @dev Structure for describing ERC1155 token info.\n     */\n    struct Erc1155TokenInfo {\n        string uri;\n    }\n\n    /**\n     * @dev Structure for describing message for transferring ERC1155 token with info.\n     */\n    struct TransferErc1155AndTokenInfoMessage {\n        TransferErc1155Message baseErc1155transfer;\n        Erc1155TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing message for transferring ERC1155 token in batches with info.\n     */\n    struct TransferErc1155BatchAndTokenInfoMessage {\n        TransferErc1155BatchMessage baseErc1155Batchtransfer;\n        Erc1155TokenInfo tokenInfo;\n    }\n\n\n    /**\n     * @dev Returns type of message for encoded data.\n     */\n    function getMessageType(bytes calldata data) internal pure returns (MessageType) {\n        uint256 firstWord = abi.decode(data, (uint256));\n        if (firstWord % 32 == 0) {\n            return getMessageType(data[firstWord:]);\n        } else {\n            return abi.decode(data, (Messages.MessageType));\n        }\n    }\n\n    /**\n     * @dev Encodes message for transferring ETH. Returns encoded message.\n     */\n    function encodeTransferEthMessage(address receiver, uint256 amount) internal pure returns (bytes memory) {\n        TransferEthMessage memory message = TransferEthMessage(\n            BaseMessage(MessageType.TRANSFER_ETH),\n            receiver,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ETH. Returns structure `TransferEthMessage`.\n     */\n    function decodeTransferEthMessage(\n        bytes calldata data\n    ) internal pure returns (TransferEthMessage memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ETH, \"Message type is not ETH transfer\");\n        return abi.decode(data, (TransferEthMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ETH. Returns encoded message.\n     */\n    function encodeTransferErc20Message(\n        address token,\n        address receiver,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        TransferErc20Message memory message = TransferErc20Message(\n            BaseMessage(MessageType.TRANSFER_ERC20),\n            token,\n            receiver,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC20 with total supply. Returns encoded message.\n     */\n    function encodeTransferErc20AndTotalSupplyMessage(\n        address token,\n        address receiver,\n        uint256 amount,\n        uint256 totalSupply\n    ) internal pure returns (bytes memory) {\n        TransferErc20AndTotalSupplyMessage memory message = TransferErc20AndTotalSupplyMessage(\n            TransferErc20Message(\n                BaseMessage(MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY),\n                token,\n                receiver,\n                amount\n            ),\n            totalSupply\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20. Returns structure `TransferErc20Message`.\n     */\n    function decodeTransferErc20Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc20Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC20, \"Message type is not ERC20 transfer\");\n        return abi.decode(data, (TransferErc20Message));\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20 with total supply. \n     * Returns structure `TransferErc20AndTotalSupplyMessage`.\n     */\n    function decodeTransferErc20AndTotalSupplyMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc20AndTotalSupplyMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY,\n            \"Message type is not ERC20 transfer and total supply\"\n        );\n        return abi.decode(data, (TransferErc20AndTotalSupplyMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC20 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc20AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 amount,\n        uint256 totalSupply,\n        Erc20TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc20AndTokenInfoMessage memory message = TransferErc20AndTokenInfoMessage(\n            TransferErc20Message(\n                BaseMessage(MessageType.TRANSFER_ERC20_AND_TOKEN_INFO),\n                token,\n                receiver,\n                amount\n            ),\n            totalSupply,\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20 with token info. \n     * Returns structure `TransferErc20AndTokenInfoMessage`.\n     */\n    function decodeTransferErc20AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc20AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC20_AND_TOKEN_INFO,\n            \"Message type is not ERC20 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc20AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721Message(\n        address token,\n        address receiver,\n        uint256 tokenId\n    ) internal pure returns (bytes memory) {\n        TransferErc721Message memory message = TransferErc721Message(\n            BaseMessage(MessageType.TRANSFER_ERC721),\n            token,\n            receiver,\n            tokenId\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721. \n     * Returns structure `TransferErc721Message`.\n     */\n    function decodeTransferErc721Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc721Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC721, \"Message type is not ERC721 transfer\");\n        return abi.decode(data, (TransferErc721Message));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        Erc721TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc721AndTokenInfoMessage memory message = TransferErc721AndTokenInfoMessage(\n            TransferErc721Message(\n                BaseMessage(MessageType.TRANSFER_ERC721_AND_TOKEN_INFO),\n                token,\n                receiver,\n                tokenId\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721 with token info. \n     * Returns structure `TransferErc721AndTokenInfoMessage`.\n     */\n    function decodeTransferErc721AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc721AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_AND_TOKEN_INFO,\n            \"Message type is not ERC721 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc721AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721MessageWithMetadata(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        string memory tokenURI\n    ) internal pure returns (bytes memory) {\n        TransferErc721MessageWithMetadata memory message = TransferErc721MessageWithMetadata(\n            TransferErc721Message(\n                BaseMessage(MessageType.TRANSFER_ERC721_WITH_METADATA),\n                token,\n                receiver,\n                tokenId\n            ),\n            tokenURI\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721. \n     * Returns structure `TransferErc721MessageWithMetadata`.\n     */\n    function decodeTransferErc721MessageWithMetadata(\n        bytes calldata data\n    ) internal pure returns (TransferErc721MessageWithMetadata memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_WITH_METADATA,\n            \"Message type is not ERC721 transfer\"\n        );\n        return abi.decode(data, (TransferErc721MessageWithMetadata));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721WithMetadataAndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        string memory tokenURI,\n        Erc721TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc721WithMetadataAndTokenInfoMessage memory message = TransferErc721WithMetadataAndTokenInfoMessage(\n            TransferErc721MessageWithMetadata(\n                TransferErc721Message(\n                    BaseMessage(MessageType.TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO),\n                    token,\n                    receiver,\n                    tokenId\n                ),\n                tokenURI\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721 with token info. \n     * Returns structure `TransferErc721WithMetadataAndTokenInfoMessage`.\n     */\n    function decodeTransferErc721WithMetadataAndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc721WithMetadataAndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO,\n            \"Message type is not ERC721 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc721WithMetadataAndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for activating user on schain. \n     * Returns encoded message.\n     */\n    function encodeActivateUserMessage(address receiver) internal pure returns (bytes memory){\n        return _encodeUserStatusMessage(receiver, true);\n    }\n\n    /**\n     * @dev Encodes message for locking user on schain. \n     * Returns encoded message.\n     */\n    function encodeLockUserMessage(address receiver) internal pure returns (bytes memory){\n        return _encodeUserStatusMessage(receiver, false);\n    }\n\n    /**\n     * @dev Decodes message for user status. \n     * Returns structure UserStatusMessage.\n     */\n    function decodeUserStatusMessage(bytes calldata data) internal pure returns (UserStatusMessage memory) {\n        require(getMessageType(data) == MessageType.USER_STATUS, \"Message type is not User Status\");\n        return abi.decode(data, (UserStatusMessage));\n    }\n\n\n    /**\n     * @dev Encodes message for allowing interchain connection.\n     * Returns encoded message.\n     */\n    function encodeInterchainConnectionMessage(bool isAllowed) internal pure returns (bytes memory) {\n        InterchainConnectionMessage memory message = InterchainConnectionMessage(\n            BaseMessage(MessageType.INTERCHAIN_CONNECTION),\n            isAllowed\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for allowing interchain connection.\n     * Returns structure `InterchainConnectionMessage`.\n     */\n    function decodeInterchainConnectionMessage(bytes calldata data)\n        internal\n        pure\n        returns (InterchainConnectionMessage memory)\n    {\n        require(getMessageType(data) == MessageType.INTERCHAIN_CONNECTION, \"Message type is not Interchain connection\");\n        return abi.decode(data, (InterchainConnectionMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155Message(\n        address token,\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        TransferErc1155Message memory message = TransferErc1155Message(\n            BaseMessage(MessageType.TRANSFER_ERC1155),\n            token,\n            receiver,\n            id,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token.\n     * Returns structure `TransferErc1155Message`.\n     */\n    function decodeTransferErc1155Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC1155, \"Message type is not ERC1155 transfer\");\n        return abi.decode(data, (TransferErc1155Message));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 with token info.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 id,\n        uint256 amount,\n        Erc1155TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc1155AndTokenInfoMessage memory message = TransferErc1155AndTokenInfoMessage(\n            TransferErc1155Message(\n                BaseMessage(MessageType.TRANSFER_ERC1155_AND_TOKEN_INFO),\n                token,\n                receiver,\n                id,\n                amount\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 with token info.\n     * Returns structure `TransferErc1155AndTokenInfoMessage`.\n     */\n    function decodeTransferErc1155AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_AND_TOKEN_INFO,\n            \"Message type is not ERC1155AndTokenInfo transfer\"\n        );\n        return abi.decode(data, (TransferErc1155AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token in batches.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155BatchMessage(\n        address token,\n        address receiver,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal pure returns (bytes memory) {\n        TransferErc1155BatchMessage memory message = TransferErc1155BatchMessage(\n            BaseMessage(MessageType.TRANSFER_ERC1155_BATCH),\n            token,\n            receiver,\n            ids,\n            amounts\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token in batches.\n     * Returns structure `TransferErc1155BatchMessage`.\n     */\n    function decodeTransferErc1155BatchMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155BatchMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_BATCH,\n            \"Message type is not ERC1155Batch transfer\"\n        );\n        return abi.decode(data, (TransferErc1155BatchMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token in batches with token info.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155BatchAndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        Erc1155TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc1155BatchAndTokenInfoMessage memory message = TransferErc1155BatchAndTokenInfoMessage(\n            TransferErc1155BatchMessage(\n                BaseMessage(MessageType.TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO),\n                token,\n                receiver,\n                ids,\n                amounts\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token in batches with token info.\n     * Returns structure `TransferErc1155BatchAndTokenInfoMessage`.\n     */\n    function decodeTransferErc1155BatchAndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155BatchAndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO,\n            \"Message type is not ERC1155BatchAndTokenInfo transfer\"\n        );\n        return abi.decode(data, (TransferErc1155BatchAndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring user status on schain.\n     * Returns encoded message.\n     */\n    function _encodeUserStatusMessage(address receiver, bool isActive) private pure returns (bytes memory) {\n        UserStatusMessage memory message = UserStatusMessage(\n            BaseMessage(MessageType.USER_STATUS),\n            receiver,\n            isActive\n        );\n        return abi.encode(message);\n    }\n\n}"
             },
@@ -403,11 +409,11 @@
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   RevertableERC20.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2022-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\ninterface IRevertableERC20 {\n    function enable() external;\n    function disable() external;\n    function mint(address account, uint amount) external;\n}\n\ncontract RevertableERC20 is IRevertableERC20, ERC20Upgradeable {\n    bool public enabled = true;\n\n    constructor(string memory name, string memory symbol) initializer {\n        super.__ERC20_init(name, symbol);\n    }\n\n    function enable() external override {\n        enabled = true;\n    }\n\n    function disable() external override {\n        enabled = false;\n    }\n\n    function mint(address account, uint amount) external override {\n        _mint(account, amount);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    )\n        internal\n        override\n    {\n        require(enabled, \"Transfers are disabled\");\n        super._transfer(from, to, amount);\n    }\n}"
             },
             "contracts/thirdparty/ERC1155ReceiverUpgradeableWithoutGap.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol\";\n\nabstract contract ERC1155ReceiverUpgradeableWithoutGap is\n    Initializable,\n    ERC165Upgradeable,\n    IERC1155ReceiverUpgradeable\n{\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165Upgradeable)\n        returns (bool)\n    {\n        return interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function __ERC1155Receiver_init() internal initializer {\n        __ERC165_init_unchained();\n        __ERC1155Receiver_init_unchained();\n    }\n\n    // solhint-disable-next-line func-name-mixedcase, no-empty-blocks\n    function __ERC1155Receiver_init_unchained() internal initializer {\n    }\n}"
             }
         }
     },
-    "name": "ERC1155OnChain",
+    "name": "CommunityLocker",
     "solcLongVersion": "0.8.16+commit.07a7930e",
     "solcVersion": "0.8.16"
 }
```

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/ERC20OnChain.json` & `ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/ERC20OnChain.json`

 * *Files identical despite different names*

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/ERC20OnChain.meta.json` & `ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/ERC1155OnChain.meta.json`

 * *Files 1% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.8745592948717948%*

 * *Differences: {"'input'": "{'sources': {'@skalenetwork/skale-manager-interfaces/IWallets.sol': {'content': '// "*

 * *            'SPDX-License-Identifier: AGPL-3.0-only\\n\\n/*\\n    IWallets - SKALE Manager '*

 * *            'Interfaces\\n    Copyright (C) 2021-Present SKALE Labs\\n    @author Dmytro '*

 * *            'Stebaeiv\\n\\n    SKALE Manager Interfaces is free software: you can redistribute it '*

 * *            'and/or modify\\n    it under the terms of the GNU Affero General Public License as '*

 * *            'published\\n    by […]*

```diff
@@ -218,22 +218,28 @@
             },
             "@skalenetwork/ima-interfaces/schain/tokens/IEthErc20.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   IEthErc20 - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\n\ninterface IEthErc20 {\n    function mint(address account, uint256 amount) external;\n    function forceBurn(address account, uint256 amount) external;\n    function initialize(address tokenManagerEthAddress) external;\n}"
             },
             "@skalenetwork/skale-manager-interfaces/IContractManager.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IContractManager.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IContractManager {\n    /**\n     * @dev Emitted when contract is upgraded.\n     */\n    event ContractUpgraded(string contractsName, address contractsAddress);\n\n    function initialize() external;\n    function setContractsAddress(string calldata contractsName, address newContractsAddress) external;\n    function contracts(bytes32 nameHash) external view returns (address);\n    function getDelegationPeriodManager() external view returns (address);\n    function getBounty() external view returns (address);\n    function getValidatorService() external view returns (address);\n    function getTimeHelpers() external view returns (address);\n    function getConstantsHolder() external view returns (address);\n    function getSkaleToken() external view returns (address);\n    function getTokenState() external view returns (address);\n    function getPunisher() external view returns (address);\n    function getContract(string calldata name) external view returns (address);\n}"
             },
+            "@skalenetwork/skale-manager-interfaces/INodes.sol": {
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    INodes.sol - SKALE Manager\n    Copyright (C) 2018-Present SKALE Labs\n    @author Artem Payvin\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"./utils/IRandom.sol\";\n\ninterface INodes {\n    // All Nodes states\n    enum NodeStatus {Active, Leaving, Left, In_Maintenance}\n\n    struct Node {\n        string name;\n        bytes4 ip;\n        bytes4 publicIP;\n        uint16 port;\n        bytes32[2] publicKey;\n        uint startBlock;\n        uint lastRewardDate;\n        uint finishTime;\n        NodeStatus status;\n        uint validatorId;\n    }\n\n    // struct to note which Nodes and which number of Nodes owned by user\n    struct CreatedNodes {\n        mapping (uint => bool) isNodeExist;\n        uint numberOfNodes;\n    }\n\n    struct SpaceManaging {\n        uint8 freeSpace;\n        uint indexInSpaceMap;\n    }\n\n    struct NodeCreationParams {\n        string name;\n        bytes4 ip;\n        bytes4 publicIp;\n        uint16 port;\n        bytes32[2] publicKey;\n        uint16 nonce;\n        string domainName;\n    }\n    \n    /**\n     * @dev Emitted when a node is created.\n     */\n    event NodeCreated(\n        uint nodeIndex,\n        address owner,\n        string name,\n        bytes4 ip,\n        bytes4 publicIP,\n        uint16 port,\n        uint16 nonce,\n        string domainName\n    );\n\n    /**\n     * @dev Emitted when a node completes a network exit.\n     */\n    event ExitCompleted(\n        uint nodeIndex\n    );\n\n    /**\n     * @dev Emitted when a node begins to exit from the network.\n     */\n    event ExitInitialized(\n        uint nodeIndex,\n        uint startLeavingPeriod\n    );\n\n    /**\n     * @dev Emitted when a node set to in compliant or compliant.\n     */\n    event IncompliantNode(\n        uint indexed nodeIndex,\n        bool status\n    );\n\n    /**\n     * @dev Emitted when a node set to in maintenance or from in maintenance.\n     */\n    event MaintenanceNode(\n        uint indexed nodeIndex,\n        bool status\n    );\n\n    /**\n     * @dev Emitted when a node status changed.\n     */\n    event IPChanged(\n        uint indexed nodeIndex,\n        bytes4 previousIP,\n        bytes4 newIP\n    );\n    \n    function removeSpaceFromNode(uint nodeIndex, uint8 space) external returns (bool);\n    function addSpaceToNode(uint nodeIndex, uint8 space) external;\n    function changeNodeLastRewardDate(uint nodeIndex) external;\n    function changeNodeFinishTime(uint nodeIndex, uint time) external;\n    function createNode(address from, NodeCreationParams calldata params) external;\n    function initExit(uint nodeIndex) external;\n    function completeExit(uint nodeIndex) external returns (bool);\n    function deleteNodeForValidator(uint validatorId, uint nodeIndex) external;\n    function checkPossibilityCreatingNode(address nodeAddress) external;\n    function checkPossibilityToMaintainNode(uint validatorId, uint nodeIndex) external returns (bool);\n    function setNodeInMaintenance(uint nodeIndex) external;\n    function removeNodeFromInMaintenance(uint nodeIndex) external;\n    function setNodeIncompliant(uint nodeIndex) external;\n    function setNodeCompliant(uint nodeIndex) external;\n    function setDomainName(uint nodeIndex, string memory domainName) external;\n    function makeNodeVisible(uint nodeIndex) external;\n    function makeNodeInvisible(uint nodeIndex) external;\n    function changeIP(uint nodeIndex, bytes4 newIP, bytes4 newPublicIP) external;\n    function numberOfActiveNodes() external view returns (uint);\n    function incompliant(uint nodeIndex) external view returns (bool);\n    function getRandomNodeWithFreeSpace(\n        uint8 freeSpace,\n        IRandom.RandomGenerator memory randomGenerator\n    )\n        external\n        view\n        returns (uint);\n    function isTimeForReward(uint nodeIndex) external view returns (bool);\n    function getNodeIP(uint nodeIndex) external view returns (bytes4);\n    function getNodeDomainName(uint nodeIndex) external view returns (string memory);\n    function getNodePort(uint nodeIndex) external view returns (uint16);\n    function getNodePublicKey(uint nodeIndex) external view returns (bytes32[2] memory);\n    function getNodeAddress(uint nodeIndex) external view returns (address);\n    function getNodeFinishTime(uint nodeIndex) external view returns (uint);\n    function isNodeLeft(uint nodeIndex) external view returns (bool);\n    function isNodeInMaintenance(uint nodeIndex) external view returns (bool);\n    function getNodeLastRewardDate(uint nodeIndex) external view returns (uint);\n    function getNodeNextRewardDate(uint nodeIndex) external view returns (uint);\n    function getNumberOfNodes() external view returns (uint);\n    function getNumberOnlineNodes() external view returns (uint);\n    function getActiveNodeIds() external view returns (uint[] memory activeNodeIds);\n    function getNodeStatus(uint nodeIndex) external view returns (NodeStatus);\n    function getValidatorNodeIndexes(uint validatorId) external view returns (uint[] memory);\n    function countNodesWithFreeSpace(uint8 freeSpace) external view returns (uint count);\n    function getValidatorId(uint nodeIndex) external view returns (uint);\n    function isNodeExist(address from, uint nodeIndex) external view returns (bool);\n    function isNodeActive(uint nodeIndex) external view returns (bool);\n    function isNodeLeaving(uint nodeIndex) external view returns (bool);\n}\n"
+            },
             "@skalenetwork/skale-manager-interfaces/ISchains.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchains.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchains {\n\n    struct SchainOption {\n        string name;\n        bytes value;\n    }\n    \n    /**\n     * @dev Emitted when an schain is created.\n     */\n    event SchainCreated(\n        string name,\n        address owner,\n        uint partOfNode,\n        uint lifetime,\n        uint numberOfNodes,\n        uint deposit,\n        uint16 nonce,\n        bytes32 schainHash\n    );\n\n    /**\n     * @dev Emitted when an schain is deleted.\n     */\n    event SchainDeleted(\n        address owner,\n        string name,\n        bytes32 indexed schainHash\n    );\n\n    /**\n     * @dev Emitted when a node in an schain is rotated.\n     */\n    event NodeRotated(\n        bytes32 schainHash,\n        uint oldNode,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a node is added to an schain.\n     */\n    event NodeAdded(\n        bytes32 schainHash,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a group of nodes is created for an schain.\n     */\n    event SchainNodes(\n        string name,\n        bytes32 schainHash,\n        uint[] nodesInGroup\n    );\n\n    function addSchain(address from, uint deposit, bytes calldata data) external;\n    function addSchainByFoundation(\n        uint lifetime,\n        uint8 typeOfSchain,\n        uint16 nonce,\n        string calldata name,\n        address schainOwner,\n        address schainOriginator,\n        SchainOption[] calldata options\n    )\n        external\n        payable;\n    function deleteSchain(address from, string calldata name) external;\n    function deleteSchainByRoot(string calldata name) external;\n    function restartSchainCreation(string calldata name) external;\n    function verifySchainSignature(\n        uint256 signA,\n        uint256 signB,\n        bytes32 hash,\n        uint256 counter,\n        uint256 hashA,\n        uint256 hashB,\n        string calldata schainName\n    )\n        external\n        view\n        returns (bool);\n    function getSchainPrice(uint typeOfSchain, uint lifetime) external view returns (uint);\n    function getOption(bytes32 schainHash, string calldata optionName) external view returns (bytes memory);\n    function getOptions(bytes32 schainHash) external view returns (SchainOption[] memory);\n}"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchains.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchains {\n\n    struct SchainOption {\n        string name;\n        bytes value;\n    }\n    \n    /**\n     * @dev Emitted when an schain is created.\n     */\n    event SchainCreated(\n        string name,\n        address owner,\n        uint partOfNode,\n        uint lifetime,\n        uint numberOfNodes,\n        uint deposit,\n        uint16 nonce,\n        bytes32 schainHash\n    );\n\n    /**\n     * @dev Emitted when an schain is deleted.\n     */\n    event SchainDeleted(\n        address owner,\n        string name,\n        bytes32 indexed schainHash\n    );\n\n    /**\n     * @dev Emitted when a node in an schain is rotated.\n     */\n    event NodeRotated(\n        bytes32 schainHash,\n        uint oldNode,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a node is added to an schain.\n     */\n    event NodeAdded(\n        bytes32 schainHash,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a group of nodes is created for an schain.\n     */\n    event SchainNodes(\n        string name,\n        bytes32 schainHash,\n        uint[] nodesInGroup\n    );\n\n    function addSchain(address from, uint deposit, bytes calldata data) external;\n    function addSchainByFoundation(\n        uint lifetime,\n        uint8 typeOfSchain,\n        uint16 nonce,\n        string calldata name,\n        address schainOwner,\n        address schainOriginator,\n        SchainOption[] calldata options\n    )\n        external\n        payable;\n    function deleteSchain(address from, string calldata name) external;\n    function deleteSchainByRoot(string calldata name) external;\n    function restartSchainCreation(string calldata name) external;\n    function verifySchainSignature(\n        uint256 signA,\n        uint256 signB,\n        bytes32 hash,\n        uint256 counter,\n        uint256 hashA,\n        uint256 hashB,\n        string calldata schainName\n    )\n        external\n        view\n        returns (bool);\n    function getSchainPrice(uint typeOfSchain, uint lifetime) external view returns (uint);\n    function getOption(bytes32 schainHash, string calldata optionName) external view returns (bytes memory);\n    function getOptions(bytes32 schainHash) external view returns (SchainOption[] memory);\n}\n"
             },
             "@skalenetwork/skale-manager-interfaces/ISchainsInternal.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchainsInternal - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchainsInternal {\n    struct Schain {\n        string name;\n        address owner;\n        uint indexInOwnerList;\n        uint8 partOfNode;\n        uint lifetime;\n        uint startDate;\n        uint startBlock;\n        uint deposit;\n        uint64 index;\n        uint generation;\n        address originator;\n    }\n\n    struct SchainType {\n        uint8 partOfNode;\n        uint numberOfNodes;\n    }\n\n    /**\n     * @dev Emitted when schain type added.\n     */\n    event SchainTypeAdded(uint indexed schainType, uint partOfNode, uint numberOfNodes);\n\n    /**\n     * @dev Emitted when schain type removed.\n     */\n    event SchainTypeRemoved(uint indexed schainType);\n\n    function initializeSchain(\n        string calldata name,\n        address from,\n        address originator,\n        uint lifetime,\n        uint deposit) external;\n    function createGroupForSchain(\n        bytes32 schainHash,\n        uint numberOfNodes,\n        uint8 partOfNode\n    )\n        external\n        returns (uint[] memory);\n    function changeLifetime(bytes32 schainHash, uint lifetime, uint deposit) external;\n    function removeSchain(bytes32 schainHash, address from) external;\n    function removeNodeFromSchain(uint nodeIndex, bytes32 schainHash) external;\n    function deleteGroup(bytes32 schainHash) external;\n    function setException(bytes32 schainHash, uint nodeIndex) external;\n    function setNodeInGroup(bytes32 schainHash, uint nodeIndex) external;\n    function removeHolesForSchain(bytes32 schainHash) external;\n    function addSchainType(uint8 partOfNode, uint numberOfNodes) external;\n    function removeSchainType(uint typeOfSchain) external;\n    function setNumberOfSchainTypes(uint newNumberOfSchainTypes) external;\n    function removeNodeFromAllExceptionSchains(uint nodeIndex) external;\n    function removeAllNodesFromSchainExceptions(bytes32 schainHash) external;\n    function makeSchainNodesInvisible(bytes32 schainHash) external;\n    function makeSchainNodesVisible(bytes32 schainHash) external;\n    function newGeneration() external;\n    function addSchainForNode(uint nodeIndex, bytes32 schainHash) external;\n    function removeSchainForNode(uint nodeIndex, uint schainIndex) external;\n    function removeNodeFromExceptions(bytes32 schainHash, uint nodeIndex) external;\n    function isSchainActive(bytes32 schainHash) external view returns (bool);\n    function schainsAtSystem(uint index) external view returns (bytes32);\n    function numberOfSchains() external view returns (uint64);\n    function getSchains() external view returns (bytes32[] memory);\n    function getSchainsPartOfNode(bytes32 schainHash) external view returns (uint8);\n    function getSchainListSize(address from) external view returns (uint);\n    function getSchainHashesByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainIdsByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainHashesForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainIdsForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainOwner(bytes32 schainHash) external view returns (address);\n    function getSchainOriginator(bytes32 schainHash) external view returns (address);\n    function isSchainNameAvailable(string calldata name) external view returns (bool);\n    function isTimeExpired(bytes32 schainHash) external view returns (bool);\n    function isOwnerAddress(address from, bytes32 schainId) external view returns (bool);\n    function getSchainName(bytes32 schainHash) external view returns (string memory);\n    function getActiveSchain(uint nodeIndex) external view returns (bytes32);\n    function getActiveSchains(uint nodeIndex) external view returns (bytes32[] memory activeSchains);\n    function getNumberOfNodesInGroup(bytes32 schainHash) external view returns (uint);\n    function getNodesInGroup(bytes32 schainHash) external view returns (uint[] memory);\n    function isNodeAddressesInGroup(bytes32 schainId, address sender) external view returns (bool);\n    function getNodeIndexInGroup(bytes32 schainHash, uint nodeId) external view returns (uint);\n    function isAnyFreeNode(bytes32 schainHash) external view returns (bool);\n    function checkException(bytes32 schainHash, uint nodeIndex) external view returns (bool);\n    function checkHoleForSchain(bytes32 schainHash, uint indexOfNode) external view returns (bool);\n    function checkSchainOnNode(uint nodeIndex, bytes32 schainHash) external view returns (bool);\n    function getSchainType(uint typeOfSchain) external view returns(uint8, uint);\n    function getGeneration(bytes32 schainHash) external view returns (uint);\n    function isSchainExist(bytes32 schainHash) external view returns (bool);\n}"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchainsInternal - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"./INodes.sol\";\n\ninterface ISchainsInternal {\n    struct Schain {\n        string name;\n        address owner;\n        uint indexInOwnerList;\n        uint8 partOfNode;\n        uint lifetime;\n        uint startDate;\n        uint startBlock;\n        uint deposit;\n        uint64 index;\n        uint generation;\n        address originator;\n    }\n\n    struct SchainType {\n        uint8 partOfNode;\n        uint numberOfNodes;\n    }\n\n    /**\n     * @dev Emitted when schain type added.\n     */\n    event SchainTypeAdded(uint indexed schainType, uint partOfNode, uint numberOfNodes);\n\n    /**\n     * @dev Emitted when schain type removed.\n     */\n    event SchainTypeRemoved(uint indexed schainType);\n\n    function initializeSchain(\n        string calldata name,\n        address from,\n        address originator,\n        uint lifetime,\n        uint deposit) external;\n    function createGroupForSchain(\n        bytes32 schainHash,\n        uint numberOfNodes,\n        uint8 partOfNode\n    )\n        external\n        returns (uint[] memory);\n    function changeLifetime(bytes32 schainHash, uint lifetime, uint deposit) external;\n    function removeSchain(bytes32 schainHash, address from) external;\n    function removeNodeFromSchain(uint nodeIndex, bytes32 schainHash) external;\n    function deleteGroup(bytes32 schainHash) external;\n    function setException(bytes32 schainHash, uint nodeIndex) external;\n    function setNodeInGroup(bytes32 schainHash, uint nodeIndex) external;\n    function removeHolesForSchain(bytes32 schainHash) external;\n    function addSchainType(uint8 partOfNode, uint numberOfNodes) external;\n    function removeSchainType(uint typeOfSchain) external;\n    function setNumberOfSchainTypes(uint newNumberOfSchainTypes) external;\n    function removeNodeFromAllExceptionSchains(uint nodeIndex) external;\n    function removeAllNodesFromSchainExceptions(bytes32 schainHash) external;\n    function makeSchainNodesInvisible(bytes32 schainHash) external;\n    function makeSchainNodesVisible(bytes32 schainHash) external;\n    function newGeneration() external;\n    function addSchainForNode(INodes nodes,uint nodeIndex, bytes32 schainHash) external;\n    function removeSchainForNode(uint nodeIndex, uint schainIndex) external;\n    function removeNodeFromExceptions(bytes32 schainHash, uint nodeIndex) external;\n    function isSchainActive(bytes32 schainHash) external view returns (bool);\n    function schainsAtSystem(uint index) external view returns (bytes32);\n    function numberOfSchains() external view returns (uint64);\n    function getSchains() external view returns (bytes32[] memory);\n    function getSchainsPartOfNode(bytes32 schainHash) external view returns (uint8);\n    function getSchainListSize(address from) external view returns (uint);\n    function getSchainHashesByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainHashesForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainOwner(bytes32 schainHash) external view returns (address);\n    function getSchainOriginator(bytes32 schainHash) external view returns (address);\n    function isSchainNameAvailable(string calldata name) external view returns (bool);\n    function isTimeExpired(bytes32 schainHash) external view returns (bool);\n    function isOwnerAddress(address from, bytes32 schainHash) external view returns (bool);\n    function getSchainName(bytes32 schainHash) external view returns (string memory);\n    function getActiveSchain(uint nodeIndex) external view returns (bytes32);\n    function getActiveSchains(uint nodeIndex) external view returns (bytes32[] memory activeSchains);\n    function getNumberOfNodesInGroup(bytes32 schainHash) external view returns (uint);\n    function getNodesInGroup(bytes32 schainHash) external view returns (uint[] memory);\n    function isNodeAddressesInGroup(bytes32 schainHash, address sender) external view returns (bool);\n    function getNodeIndexInGroup(bytes32 schainHash, uint nodeHash) external view returns (uint);\n    function isAnyFreeNode(bytes32 schainHash) external view returns (bool);\n    function checkException(bytes32 schainHash, uint nodeIndex) external view returns (bool);\n    function checkHoleForSchain(bytes32 schainHash, uint indexOfNode) external view returns (bool);\n    function checkSchainOnNode(uint nodeIndex, bytes32 schainHash) external view returns (bool);\n    function getSchainType(uint typeOfSchain) external view returns(uint8, uint);\n    function getGeneration(bytes32 schainHash) external view returns (uint);\n    function isSchainExist(bytes32 schainHash) external view returns (bool);\n}"
             },
             "@skalenetwork/skale-manager-interfaces/IWallets.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IWallets - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IWallets {\n    /**\n     * @dev Emitted when the validator wallet was funded\n     */\n    event ValidatorWalletRecharged(address sponsor, uint amount, uint validatorId);\n\n    /**\n     * @dev Emitted when the schain wallet was funded\n     */\n    event SchainWalletRecharged(address sponsor, uint amount, bytes32 schainHash);\n\n    /**\n     * @dev Emitted when the node received a refund from validator to its wallet\n     */\n    event NodeRefundedByValidator(address node, uint validatorId, uint amount);\n\n    /**\n     * @dev Emitted when the node received a refund from schain to its wallet\n     */\n    event NodeRefundedBySchain(address node, bytes32 schainHash, uint amount);\n\n    /**\n     * @dev Emitted when the validator withdrawn funds from validator wallet\n     */\n    event WithdrawFromValidatorWallet(uint indexed validatorId, uint amount);\n\n    /**\n     * @dev Emitted when the schain owner withdrawn funds from schain wallet\n     */\n    event WithdrawFromSchainWallet(bytes32 indexed schainHash, uint amount);\n\n    receive() external payable;\n    function refundGasByValidator(uint validatorId, address payable spender, uint spentGas) external;\n    function refundGasByValidatorToSchain(uint validatorId, bytes32 schainHash) external;\n    function refundGasBySchain(bytes32 schainId, address payable spender, uint spentGas, bool isDebt) external;\n    function withdrawFundsFromSchainWallet(address payable schainOwner, bytes32 schainHash) external;\n    function withdrawFundsFromValidatorWallet(uint amount) external;\n    function rechargeValidatorWallet(uint validatorId) external payable;\n    function rechargeSchainWallet(bytes32 schainId) external payable;\n    function getSchainBalance(bytes32 schainHash) external view returns (uint);\n    function getValidatorBalance(uint validatorId) external view returns (uint);\n}\n"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IWallets - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IWallets {\n    receive() external payable;\n    function refundGasByValidator(uint validatorId, address payable spender, uint gasLimit) external;\n    function refundGasByValidatorToSchain(uint validatorId, bytes32 schainHash) external;\n    function refundGasBySchain(bytes32 schainId, address payable spender, uint spentGas, bool isDebt) external;\n    function withdrawFundsFromSchainWallet(address payable schainOwner, bytes32 schainHash) external;\n    function withdrawFundsFromValidatorWallet(uint amount) external;\n    function rechargeValidatorWallet(uint validatorId) external payable;\n    function rechargeSchainWallet(bytes32 schainId) external payable;\n    function getSchainBalance(bytes32 schainHash) external view returns (uint);\n    function getValidatorBalance(uint validatorId) external view returns (uint);\n}\n"
+            },
+            "@skalenetwork/skale-manager-interfaces/utils/IRandom.sol": {
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IRandom.sol - SKALE Manager Interfaces\n    Copyright (C) 2022-Present SKALE Labs\n    @author Dmytro Stebaiev\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\n\ninterface IRandom {\n    struct RandomGenerator {\n        uint seed;\n    }\n}"
             },
             "contracts/MessageProxy.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   MessageProxy.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/IGasReimbursable.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageProxy.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageReceiver.sol\";\n\n\n/**\n * @title MessageProxy\n * @dev Abstract contract for MessageProxyForMainnet and MessageProxyForSchain.\n */\nabstract contract MessageProxy is AccessControlEnumerableUpgradeable, IMessageProxy {\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    /**\n     * @dev Structure that stores counters for outgoing and incoming messages.\n     */\n    struct ConnectedChainInfo {\n        // message counters start with 0\n        uint256 incomingMessageCounter;\n        uint256 outgoingMessageCounter;\n        bool inited;\n        uint256 lastOutgoingMessageBlockId;\n    }\n\n    bytes32 public constant MAINNET_HASH = keccak256(abi.encodePacked(\"Mainnet\"));\n    bytes32 public constant CHAIN_CONNECTOR_ROLE = keccak256(\"CHAIN_CONNECTOR_ROLE\");\n    bytes32 public constant EXTRA_CONTRACT_REGISTRAR_ROLE = keccak256(\"EXTRA_CONTRACT_REGISTRAR_ROLE\");\n    bytes32 public constant CONSTANT_SETTER_ROLE = keccak256(\"CONSTANT_SETTER_ROLE\");\n    uint256 public constant MESSAGES_LENGTH = 10;\n    uint256 public constant REVERT_REASON_LENGTH = 64;\n\n    //   schainHash => ConnectedChainInfo\n    mapping(bytes32 => ConnectedChainInfo) public connectedChains;\n    //   schainHash => contract address => allowed\n    mapping(bytes32 => mapping(address => bool)) private _deprecatedRegistryContracts;\n\n    uint256 public gasLimit;\n\n    /**\n     * @dev Emitted for every outgoing message to schain.\n     */\n    event OutgoingMessage(\n        bytes32 indexed dstChainHash,\n        uint256 indexed msgCounter,\n        address indexed srcContract,\n        address dstContract,\n        bytes data\n    );\n\n    /**\n     * @dev Emitted when function `postMessage` returns revert.\n     *  Used to prevent stuck loop inside function `postIncomingMessages`.\n     */\n    event PostMessageError(\n        uint256 indexed msgCounter,\n        bytes message\n    );\n\n    /**\n     * @dev Emitted when gas limit per one call of `postMessage` was changed.\n     */\n    event GasLimitWasChanged(\n        uint256 oldValue,\n        uint256 newValue\n    );\n\n    /**\n     * @dev Emitted when the version was updated\n     */\n    event VersionUpdated(string oldVersion, string newVersion);\n\n    /**\n     * @dev Emitted when extra contract was added.\n     */\n    event ExtraContractRegistered(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Emitted when extra contract was removed.\n     */\n    event ExtraContractRemoved(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Emitted when referenced to previous outgoing message.\n     */\n    event PreviousMessageReference (\n        uint256 currentMessage,\n        uint256 previousOutgoingMessageBlockId\n    );\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CHAIN_CONNECTOR_ROLE}.\n     */\n    modifier onlyChainConnector() {\n        require(hasRole(CHAIN_CONNECTOR_ROLE, msg.sender), \"CHAIN_CONNECTOR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {EXTRA_CONTRACT_REGISTRAR_ROLE}.\n     */\n    modifier onlyExtraContractRegistrar() {\n        require(hasRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender), \"EXTRA_CONTRACT_REGISTRAR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CONSTANT_SETTER_ROLE}.\n     */\n    modifier onlyConstantSetter() {\n        require(hasRole(CONSTANT_SETTER_ROLE, msg.sender), \"Not enough permissions to set constant\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {DEFAULT_ADMIN_ROLE}.\n     */\n    modifier onlyOwner() {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"DEFAULT_ADMIN_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Sets gasLimit to a new value.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CONSTANT_SETTER_ROLE.\n     */\n    function setNewGasLimit(uint256 newGasLimit) external override onlyConstantSetter {\n        emit GasLimitWasChanged(gasLimit, newGasLimit);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Virtual function for `postIncomingMessages`.\n     */\n    function postIncomingMessages(\n        string calldata fromSchainName,\n        uint256 startingCounter,\n        Message[] calldata messages,\n        Signature calldata sign\n    )\n        external\n        virtual\n        override;\n\n    /**\n     * @dev Allows `msg.sender` to register extra contract for all schains\n     * for being able to transfer messages from custom contracts.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     * - Passed address should be contract.\n     * - Extra contract must not be registered.\n     */\n    function registerExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is already registered\");\n        _getRegistryContracts()[bytes32(0)].add(extraContract);\n        emit ExtraContractRegistered(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Allows `msg.sender` to remove extra contract for all schains.\n     * Extra contract will no longer be able to send messages through MessageProxy.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     */\n    function removeExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[bytes32(0)].remove(extraContract);\n        emit ExtraContractRemoved(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Should return length of contract registered by schainHash.\n     */\n    function getContractRegisteredLength(bytes32 schainHash) external view override returns (uint256) {\n        return _getRegistryContracts()[schainHash].length();\n    }\n\n    /**\n     * @dev Should return a range of contracts registered by schainHash.\n     *\n     * Requirements:\n     * range should be less or equal 10 contracts\n     */\n    function getContractRegisteredRange(\n        bytes32 schainHash,\n        uint256 from,\n        uint256 to\n    )\n        external\n        view\n        override\n        returns (address[] memory contractsInRange)\n    {\n        require(\n            from < to && to - from <= 10 && to <= _getRegistryContracts()[schainHash].length(),\n            \"Range is incorrect\"\n        );\n        contractsInRange = new address[](to - from);\n        for (uint256 i = from; i < to; i++) {\n            contractsInRange[i - from] = _getRegistryContracts()[schainHash].at(i);\n        }\n    }\n\n    /**\n     * @dev Returns number of outgoing messages.\n     *\n     * Requirements:\n     *\n     * - Target schain  must be initialized.\n     */\n    function getOutgoingMessagesCounter(string calldata targetSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 dstChainHash = keccak256(abi.encodePacked(targetSchainName));\n        require(connectedChains[dstChainHash].inited, \"Destination chain is not initialized\");\n        return connectedChains[dstChainHash].outgoingMessageCounter;\n    }\n\n\n    /**\n     * @dev Should return block number of the last message transferred to schain\n     */\n    function getLastOutgoingMessageBlockId(string memory targetSchainName) external view override returns (uint) {\n        bytes32 dstChainHash = keccak256(abi.encodePacked(targetSchainName));\n        require(connectedChains[dstChainHash].inited, \"Destination chain is not initialized\");\n        return connectedChains[dstChainHash].lastOutgoingMessageBlockId;\n    }\n\n    /**\n     * @dev Returns number of incoming messages.\n     *\n     * Requirements:\n     *\n     * - Source schain must be initialized.\n     */\n    function getIncomingMessagesCounter(string calldata fromSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 srcChainHash = keccak256(abi.encodePacked(fromSchainName));\n        require(connectedChains[srcChainHash].inited, \"Source chain is not initialized\");\n        return connectedChains[srcChainHash].incomingMessageCounter;\n    }\n\n    function initializeMessageProxy(uint newGasLimit) public initializer {\n        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(CHAIN_CONNECTOR_ROLE, msg.sender);\n        _setupRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender);\n        _setupRole(CONSTANT_SETTER_ROLE, msg.sender);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Posts message from this contract to `targetChainHash` MessageProxy contract.\n     * This is called by a smart contract to make a cross-chain call.\n     *\n     * Emits an {OutgoingMessage} event.\n     *\n     * Requirements:\n     *\n     * - Target chain must be initialized.\n     * - Target chain must be registered as external contract.\n     */\n    function postOutgoingMessage(\n        bytes32 targetChainHash,\n        address targetContract,\n        bytes memory data\n    )\n        public\n        override\n        virtual\n    {\n        require(connectedChains[targetChainHash].inited, \"Destination chain is not initialized\");\n        _authorizeOutgoingMessageSender(targetChainHash);\n\n        uint outgoingMessageCounter = connectedChains[targetChainHash].outgoingMessageCounter;\n        emit OutgoingMessage(\n            targetChainHash,\n            outgoingMessageCounter,\n            msg.sender,\n            targetContract,\n            data\n        );\n        emit PreviousMessageReference(\n            outgoingMessageCounter,\n            connectedChains[targetChainHash].lastOutgoingMessageBlockId\n        );\n        connectedChains[targetChainHash].outgoingMessageCounter++;\n        connectedChains[targetChainHash].lastOutgoingMessageBlockId = block.number;\n    }\n\n    /**\n     * @dev Allows CHAIN_CONNECTOR_ROLE to remove connected chain from this contract.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CHAIN_CONNECTOR_ROLE.\n     * - `schainName` must be initialized.\n     */\n    function removeConnectedChain(string memory schainName) public virtual override onlyChainConnector {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(connectedChains[schainHash].inited, \"Chain is not initialized\");\n        delete connectedChains[schainHash];\n    }\n\n    /**\n     * @dev Checks whether chain is currently connected.\n     */\n    function isConnectedChain(\n        string memory schainName\n    )\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return connectedChains[keccak256(abi.encodePacked(schainName))].inited;\n    }\n\n    /**\n     * @dev Checks whether contract is currently registered as extra contract.\n     */\n    function isContractRegistered(\n        bytes32 schainHash,\n        address contractAddress\n    )\n        public\n        view\n        override\n        returns (bool)\n    {\n        return _getRegistryContracts()[schainHash].contains(contractAddress);\n    }\n\n    /**\n     * @dev Allows MessageProxy to register extra contract for being able to transfer messages from custom contracts.\n     *\n     * Requirements:\n     *\n     * - Extra contract address must be contract.\n     * - Extra contract must not be registered.\n     * - Extra contract must not be registered for all chains.\n     */\n    function _registerExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {\n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is already registered\");\n        require(\n            !_getRegistryContracts()[bytes32(0)].contains(extraContract),\n            \"Extra contract is already registered for all chains\"\n        );\n\n        _getRegistryContracts()[chainHash].add(extraContract);\n        emit ExtraContractRegistered(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to remove extra contract,\n     * thus `extraContract` will no longer be available to transfer messages from mainnet to schain.\n     *\n     * Requirements:\n     *\n     * - Extra contract must be registered.\n     */\n    function _removeExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {\n        require(_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[chainHash].remove(extraContract);\n        emit ExtraContractRemoved(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to connect schain with MessageProxyOnMainnet for transferring messages.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CHAIN_CONNECTOR_ROLE.\n     * - SKALE chain must not be connected.\n     */\n    function _addConnectedChain(bytes32 schainHash) internal onlyChainConnector {\n        require(!connectedChains[schainHash].inited,\"Chain is already connected\");\n        connectedChains[schainHash] = ConnectedChainInfo({\n            incomingMessageCounter: 0,\n            outgoingMessageCounter: 0,\n            inited: true,\n            lastOutgoingMessageBlockId: 0\n        });\n    }\n\n    /**\n     * @dev Allows MessageProxy to send messages from schain to mainnet.\n     * Destination contract must implement `postMessage` method.\n     */\n    function _callReceiverContract(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n    {\n        if (!message.destinationContract.isContract()) {\n            emit PostMessageError(\n                counter,\n                \"Destination contract is not a contract\"\n            );\n            return;\n        }\n        try IMessageReceiver(message.destinationContract).postMessage{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) {\n            return;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                _getSlice(bytes(reason), REVERT_REASON_LENGTH)\n            );\n        } catch Panic(uint errorCode) {\n               emit PostMessageError(\n                counter,\n                abi.encodePacked(errorCode)\n            );\n        } catch (bytes memory revertData) {\n            emit PostMessageError(\n                counter,\n                _getSlice(revertData, REVERT_REASON_LENGTH)\n            );\n        }\n    }\n\n    /**\n     * @dev Returns receiver of message.\n     */\n    function _getGasPayer(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n        returns (address)\n    {\n        try IGasReimbursable(message.destinationContract).gasPayer{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) returns (address receiver) {\n            return receiver;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                _getSlice(bytes(reason), REVERT_REASON_LENGTH)\n            );\n            return address(0);\n        } catch Panic(uint errorCode) {\n               emit PostMessageError(\n                counter,\n                abi.encodePacked(errorCode)\n            );\n            return address(0);\n        } catch (bytes memory revertData) {\n            emit PostMessageError(\n                counter,\n                _getSlice(revertData, REVERT_REASON_LENGTH)\n            );\n            return address(0);\n        }\n    }\n\n    /**\n     * @dev Checks whether msg.sender is registered as custom extra contract.\n     */\n    function _authorizeOutgoingMessageSender(bytes32 targetChainHash) internal view virtual {\n        require(\n            isContractRegistered(bytes32(0), msg.sender) || isContractRegistered(targetChainHash, msg.sender),\n            \"Sender contract is not registered\"\n        );\n    }\n\n    /**\n     * @dev Returns list of registered custom extra contracts.\n     */\n    function _getRegistryContracts()\n        internal\n        view\n        virtual\n        returns (mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) storage);\n\n    /**\n     * @dev Returns hash of message array.\n     */\n    function _hashedArray(\n        Message[] calldata messages,\n        uint256 startingCounter,\n        string calldata fromChainName\n    )\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32 sourceHash = keccak256(abi.encodePacked(fromChainName));\n        bytes32 hash = keccak256(abi.encodePacked(sourceHash, bytes32(startingCounter)));\n        for (uint256 i = 0; i < messages.length; i++) {\n            hash = keccak256(\n                abi.encodePacked(\n                    abi.encode(\n                        hash,\n                        messages[i].sender,\n                        messages[i].destinationContract\n                    ),\n                    messages[i].data\n                )\n            );\n        }\n        return hash;\n    }\n\n    function _getSlice(bytes memory text, uint end) private pure returns (bytes memory) {\n        uint slicedEnd = end < text.length ? end : text.length;\n        bytes memory sliced = new bytes(slicedEnd);\n        for(uint i = 0; i < slicedEnd; i++){\n            sliced[i] = text[i];\n        }\n        return sliced;\n    }\n}\n"
             },
             "contracts/Messages.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   Messages.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\n\n/**\n * @title Messages\n * @dev Library for encoding and decoding messages\n * for transferring from Mainnet to Schain and vice versa.\n */\nlibrary Messages {\n\n    /**\n     * @dev Enumerator that describes all supported message types.\n     */\n    enum MessageType {\n        EMPTY,\n        TRANSFER_ETH,\n        TRANSFER_ERC20,\n        TRANSFER_ERC20_AND_TOTAL_SUPPLY,\n        TRANSFER_ERC20_AND_TOKEN_INFO,\n        TRANSFER_ERC721,\n        TRANSFER_ERC721_AND_TOKEN_INFO,\n        USER_STATUS,\n        INTERCHAIN_CONNECTION,\n        TRANSFER_ERC1155,\n        TRANSFER_ERC1155_AND_TOKEN_INFO,\n        TRANSFER_ERC1155_BATCH,\n        TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO,\n        TRANSFER_ERC721_WITH_METADATA,\n        TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO\n    }\n\n    /**\n     * @dev Structure for base message.\n     */\n    struct BaseMessage {\n        MessageType messageType;\n    }\n\n    /**\n     * @dev Structure for describing ETH.\n     */\n    struct TransferEthMessage {\n        BaseMessage message;\n        address receiver;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for user status.\n     */\n    struct UserStatusMessage {\n        BaseMessage message;\n        address receiver;\n        bool isActive;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 token.\n     */\n    struct TransferErc20Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC20 token.\n     */\n    struct Erc20TokenInfo {\n        string name;\n        uint8 decimals;\n        string symbol;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token supply.\n     */\n    struct TransferErc20AndTotalSupplyMessage {\n        TransferErc20Message baseErc20transfer;\n        uint256 totalSupply;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token info.\n     */\n    struct TransferErc20AndTokenInfoMessage {\n        TransferErc20Message baseErc20transfer;\n        uint256 totalSupply;\n        Erc20TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing base ERC721.\n     */\n    struct TransferErc721Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 tokenId;\n    }\n\n    /**\n     * @dev Structure for describing base ERC721 with metadata.\n     */\n    struct TransferErc721MessageWithMetadata {\n        TransferErc721Message erc721message;\n        string tokenURI;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token info.\n     */\n    struct Erc721TokenInfo {\n        string name;\n        string symbol;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC721 token.\n     */\n    struct TransferErc721AndTokenInfoMessage {\n        TransferErc721Message baseErc721transfer;\n        Erc721TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC721 token with metadata.\n     */\n    struct TransferErc721WithMetadataAndTokenInfoMessage {\n        TransferErc721MessageWithMetadata baseErc721transferWithMetadata;\n        Erc721TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing whether interchain connection is allowed.\n     */\n    struct InterchainConnectionMessage {\n        BaseMessage message;\n        bool isAllowed;\n    }\n\n    /**\n     * @dev Structure for describing whether interchain connection is allowed.\n     */\n    struct TransferErc1155Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 id;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for describing ERC1155 token in batches.\n     */\n    struct TransferErc1155BatchMessage {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256[] ids;\n        uint256[] amounts;\n    }\n\n    /**\n     * @dev Structure for describing ERC1155 token info.\n     */\n    struct Erc1155TokenInfo {\n        string uri;\n    }\n\n    /**\n     * @dev Structure for describing message for transferring ERC1155 token with info.\n     */\n    struct TransferErc1155AndTokenInfoMessage {\n        TransferErc1155Message baseErc1155transfer;\n        Erc1155TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing message for transferring ERC1155 token in batches with info.\n     */\n    struct TransferErc1155BatchAndTokenInfoMessage {\n        TransferErc1155BatchMessage baseErc1155Batchtransfer;\n        Erc1155TokenInfo tokenInfo;\n    }\n\n\n    /**\n     * @dev Returns type of message for encoded data.\n     */\n    function getMessageType(bytes calldata data) internal pure returns (MessageType) {\n        uint256 firstWord = abi.decode(data, (uint256));\n        if (firstWord % 32 == 0) {\n            return getMessageType(data[firstWord:]);\n        } else {\n            return abi.decode(data, (Messages.MessageType));\n        }\n    }\n\n    /**\n     * @dev Encodes message for transferring ETH. Returns encoded message.\n     */\n    function encodeTransferEthMessage(address receiver, uint256 amount) internal pure returns (bytes memory) {\n        TransferEthMessage memory message = TransferEthMessage(\n            BaseMessage(MessageType.TRANSFER_ETH),\n            receiver,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ETH. Returns structure `TransferEthMessage`.\n     */\n    function decodeTransferEthMessage(\n        bytes calldata data\n    ) internal pure returns (TransferEthMessage memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ETH, \"Message type is not ETH transfer\");\n        return abi.decode(data, (TransferEthMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ETH. Returns encoded message.\n     */\n    function encodeTransferErc20Message(\n        address token,\n        address receiver,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        TransferErc20Message memory message = TransferErc20Message(\n            BaseMessage(MessageType.TRANSFER_ERC20),\n            token,\n            receiver,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC20 with total supply. Returns encoded message.\n     */\n    function encodeTransferErc20AndTotalSupplyMessage(\n        address token,\n        address receiver,\n        uint256 amount,\n        uint256 totalSupply\n    ) internal pure returns (bytes memory) {\n        TransferErc20AndTotalSupplyMessage memory message = TransferErc20AndTotalSupplyMessage(\n            TransferErc20Message(\n                BaseMessage(MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY),\n                token,\n                receiver,\n                amount\n            ),\n            totalSupply\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20. Returns structure `TransferErc20Message`.\n     */\n    function decodeTransferErc20Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc20Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC20, \"Message type is not ERC20 transfer\");\n        return abi.decode(data, (TransferErc20Message));\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20 with total supply. \n     * Returns structure `TransferErc20AndTotalSupplyMessage`.\n     */\n    function decodeTransferErc20AndTotalSupplyMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc20AndTotalSupplyMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY,\n            \"Message type is not ERC20 transfer and total supply\"\n        );\n        return abi.decode(data, (TransferErc20AndTotalSupplyMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC20 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc20AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 amount,\n        uint256 totalSupply,\n        Erc20TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc20AndTokenInfoMessage memory message = TransferErc20AndTokenInfoMessage(\n            TransferErc20Message(\n                BaseMessage(MessageType.TRANSFER_ERC20_AND_TOKEN_INFO),\n                token,\n                receiver,\n                amount\n            ),\n            totalSupply,\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20 with token info. \n     * Returns structure `TransferErc20AndTokenInfoMessage`.\n     */\n    function decodeTransferErc20AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc20AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC20_AND_TOKEN_INFO,\n            \"Message type is not ERC20 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc20AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721Message(\n        address token,\n        address receiver,\n        uint256 tokenId\n    ) internal pure returns (bytes memory) {\n        TransferErc721Message memory message = TransferErc721Message(\n            BaseMessage(MessageType.TRANSFER_ERC721),\n            token,\n            receiver,\n            tokenId\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721. \n     * Returns structure `TransferErc721Message`.\n     */\n    function decodeTransferErc721Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc721Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC721, \"Message type is not ERC721 transfer\");\n        return abi.decode(data, (TransferErc721Message));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        Erc721TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc721AndTokenInfoMessage memory message = TransferErc721AndTokenInfoMessage(\n            TransferErc721Message(\n                BaseMessage(MessageType.TRANSFER_ERC721_AND_TOKEN_INFO),\n                token,\n                receiver,\n                tokenId\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721 with token info. \n     * Returns structure `TransferErc721AndTokenInfoMessage`.\n     */\n    function decodeTransferErc721AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc721AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_AND_TOKEN_INFO,\n            \"Message type is not ERC721 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc721AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721MessageWithMetadata(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        string memory tokenURI\n    ) internal pure returns (bytes memory) {\n        TransferErc721MessageWithMetadata memory message = TransferErc721MessageWithMetadata(\n            TransferErc721Message(\n                BaseMessage(MessageType.TRANSFER_ERC721_WITH_METADATA),\n                token,\n                receiver,\n                tokenId\n            ),\n            tokenURI\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721. \n     * Returns structure `TransferErc721MessageWithMetadata`.\n     */\n    function decodeTransferErc721MessageWithMetadata(\n        bytes calldata data\n    ) internal pure returns (TransferErc721MessageWithMetadata memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_WITH_METADATA,\n            \"Message type is not ERC721 transfer\"\n        );\n        return abi.decode(data, (TransferErc721MessageWithMetadata));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721WithMetadataAndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        string memory tokenURI,\n        Erc721TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc721WithMetadataAndTokenInfoMessage memory message = TransferErc721WithMetadataAndTokenInfoMessage(\n            TransferErc721MessageWithMetadata(\n                TransferErc721Message(\n                    BaseMessage(MessageType.TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO),\n                    token,\n                    receiver,\n                    tokenId\n                ),\n                tokenURI\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721 with token info. \n     * Returns structure `TransferErc721WithMetadataAndTokenInfoMessage`.\n     */\n    function decodeTransferErc721WithMetadataAndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc721WithMetadataAndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO,\n            \"Message type is not ERC721 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc721WithMetadataAndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for activating user on schain. \n     * Returns encoded message.\n     */\n    function encodeActivateUserMessage(address receiver) internal pure returns (bytes memory){\n        return _encodeUserStatusMessage(receiver, true);\n    }\n\n    /**\n     * @dev Encodes message for locking user on schain. \n     * Returns encoded message.\n     */\n    function encodeLockUserMessage(address receiver) internal pure returns (bytes memory){\n        return _encodeUserStatusMessage(receiver, false);\n    }\n\n    /**\n     * @dev Decodes message for user status. \n     * Returns structure UserStatusMessage.\n     */\n    function decodeUserStatusMessage(bytes calldata data) internal pure returns (UserStatusMessage memory) {\n        require(getMessageType(data) == MessageType.USER_STATUS, \"Message type is not User Status\");\n        return abi.decode(data, (UserStatusMessage));\n    }\n\n\n    /**\n     * @dev Encodes message for allowing interchain connection.\n     * Returns encoded message.\n     */\n    function encodeInterchainConnectionMessage(bool isAllowed) internal pure returns (bytes memory) {\n        InterchainConnectionMessage memory message = InterchainConnectionMessage(\n            BaseMessage(MessageType.INTERCHAIN_CONNECTION),\n            isAllowed\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for allowing interchain connection.\n     * Returns structure `InterchainConnectionMessage`.\n     */\n    function decodeInterchainConnectionMessage(bytes calldata data)\n        internal\n        pure\n        returns (InterchainConnectionMessage memory)\n    {\n        require(getMessageType(data) == MessageType.INTERCHAIN_CONNECTION, \"Message type is not Interchain connection\");\n        return abi.decode(data, (InterchainConnectionMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155Message(\n        address token,\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        TransferErc1155Message memory message = TransferErc1155Message(\n            BaseMessage(MessageType.TRANSFER_ERC1155),\n            token,\n            receiver,\n            id,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token.\n     * Returns structure `TransferErc1155Message`.\n     */\n    function decodeTransferErc1155Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC1155, \"Message type is not ERC1155 transfer\");\n        return abi.decode(data, (TransferErc1155Message));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 with token info.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 id,\n        uint256 amount,\n        Erc1155TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc1155AndTokenInfoMessage memory message = TransferErc1155AndTokenInfoMessage(\n            TransferErc1155Message(\n                BaseMessage(MessageType.TRANSFER_ERC1155_AND_TOKEN_INFO),\n                token,\n                receiver,\n                id,\n                amount\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 with token info.\n     * Returns structure `TransferErc1155AndTokenInfoMessage`.\n     */\n    function decodeTransferErc1155AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_AND_TOKEN_INFO,\n            \"Message type is not ERC1155AndTokenInfo transfer\"\n        );\n        return abi.decode(data, (TransferErc1155AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token in batches.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155BatchMessage(\n        address token,\n        address receiver,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal pure returns (bytes memory) {\n        TransferErc1155BatchMessage memory message = TransferErc1155BatchMessage(\n            BaseMessage(MessageType.TRANSFER_ERC1155_BATCH),\n            token,\n            receiver,\n            ids,\n            amounts\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token in batches.\n     * Returns structure `TransferErc1155BatchMessage`.\n     */\n    function decodeTransferErc1155BatchMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155BatchMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_BATCH,\n            \"Message type is not ERC1155Batch transfer\"\n        );\n        return abi.decode(data, (TransferErc1155BatchMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token in batches with token info.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155BatchAndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        Erc1155TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc1155BatchAndTokenInfoMessage memory message = TransferErc1155BatchAndTokenInfoMessage(\n            TransferErc1155BatchMessage(\n                BaseMessage(MessageType.TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO),\n                token,\n                receiver,\n                ids,\n                amounts\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token in batches with token info.\n     * Returns structure `TransferErc1155BatchAndTokenInfoMessage`.\n     */\n    function decodeTransferErc1155BatchAndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155BatchAndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO,\n            \"Message type is not ERC1155BatchAndTokenInfo transfer\"\n        );\n        return abi.decode(data, (TransferErc1155BatchAndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring user status on schain.\n     * Returns encoded message.\n     */\n    function _encodeUserStatusMessage(address receiver, bool isActive) private pure returns (bytes memory) {\n        UserStatusMessage memory message = UserStatusMessage(\n            BaseMessage(MessageType.USER_STATUS),\n            receiver,\n            isActive\n        );\n        return abi.encode(message);\n    }\n\n}"
             },
@@ -403,11 +409,11 @@
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   RevertableERC20.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2022-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\ninterface IRevertableERC20 {\n    function enable() external;\n    function disable() external;\n    function mint(address account, uint amount) external;\n}\n\ncontract RevertableERC20 is IRevertableERC20, ERC20Upgradeable {\n    bool public enabled = true;\n\n    constructor(string memory name, string memory symbol) initializer {\n        super.__ERC20_init(name, symbol);\n    }\n\n    function enable() external override {\n        enabled = true;\n    }\n\n    function disable() external override {\n        enabled = false;\n    }\n\n    function mint(address account, uint amount) external override {\n        _mint(account, amount);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    )\n        internal\n        override\n    {\n        require(enabled, \"Transfers are disabled\");\n        super._transfer(from, to, amount);\n    }\n}"
             },
             "contracts/thirdparty/ERC1155ReceiverUpgradeableWithoutGap.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol\";\n\nabstract contract ERC1155ReceiverUpgradeableWithoutGap is\n    Initializable,\n    ERC165Upgradeable,\n    IERC1155ReceiverUpgradeable\n{\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165Upgradeable)\n        returns (bool)\n    {\n        return interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function __ERC1155Receiver_init() internal initializer {\n        __ERC165_init_unchained();\n        __ERC1155Receiver_init_unchained();\n    }\n\n    // solhint-disable-next-line func-name-mixedcase, no-empty-blocks\n    function __ERC1155Receiver_init_unchained() internal initializer {\n    }\n}"
             }
         }
     },
-    "name": "ERC20OnChain",
+    "name": "ERC1155OnChain",
     "solcLongVersion": "0.8.16+commit.07a7930e",
     "solcVersion": "0.8.16"
 }
```

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/ERC721OnChain.json` & `ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/ERC721OnChain.json`

 * *Files identical despite different names*

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/ERC721OnChain.meta.json` & `ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/ERC20OnChain.meta.json`

 * *Files 1% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.8745592948717948%*

 * *Differences: {"'input'": "{'sources': {'@skalenetwork/skale-manager-interfaces/IWallets.sol': {'content': '// "*

 * *            'SPDX-License-Identifier: AGPL-3.0-only\\n\\n/*\\n    IWallets - SKALE Manager '*

 * *            'Interfaces\\n    Copyright (C) 2021-Present SKALE Labs\\n    @author Dmytro '*

 * *            'Stebaeiv\\n\\n    SKALE Manager Interfaces is free software: you can redistribute it '*

 * *            'and/or modify\\n    it under the terms of the GNU Affero General Public License as '*

 * *            'published\\n    by […]*

```diff
@@ -218,22 +218,28 @@
             },
             "@skalenetwork/ima-interfaces/schain/tokens/IEthErc20.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   IEthErc20 - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\n\ninterface IEthErc20 {\n    function mint(address account, uint256 amount) external;\n    function forceBurn(address account, uint256 amount) external;\n    function initialize(address tokenManagerEthAddress) external;\n}"
             },
             "@skalenetwork/skale-manager-interfaces/IContractManager.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IContractManager.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IContractManager {\n    /**\n     * @dev Emitted when contract is upgraded.\n     */\n    event ContractUpgraded(string contractsName, address contractsAddress);\n\n    function initialize() external;\n    function setContractsAddress(string calldata contractsName, address newContractsAddress) external;\n    function contracts(bytes32 nameHash) external view returns (address);\n    function getDelegationPeriodManager() external view returns (address);\n    function getBounty() external view returns (address);\n    function getValidatorService() external view returns (address);\n    function getTimeHelpers() external view returns (address);\n    function getConstantsHolder() external view returns (address);\n    function getSkaleToken() external view returns (address);\n    function getTokenState() external view returns (address);\n    function getPunisher() external view returns (address);\n    function getContract(string calldata name) external view returns (address);\n}"
             },
+            "@skalenetwork/skale-manager-interfaces/INodes.sol": {
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    INodes.sol - SKALE Manager\n    Copyright (C) 2018-Present SKALE Labs\n    @author Artem Payvin\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"./utils/IRandom.sol\";\n\ninterface INodes {\n    // All Nodes states\n    enum NodeStatus {Active, Leaving, Left, In_Maintenance}\n\n    struct Node {\n        string name;\n        bytes4 ip;\n        bytes4 publicIP;\n        uint16 port;\n        bytes32[2] publicKey;\n        uint startBlock;\n        uint lastRewardDate;\n        uint finishTime;\n        NodeStatus status;\n        uint validatorId;\n    }\n\n    // struct to note which Nodes and which number of Nodes owned by user\n    struct CreatedNodes {\n        mapping (uint => bool) isNodeExist;\n        uint numberOfNodes;\n    }\n\n    struct SpaceManaging {\n        uint8 freeSpace;\n        uint indexInSpaceMap;\n    }\n\n    struct NodeCreationParams {\n        string name;\n        bytes4 ip;\n        bytes4 publicIp;\n        uint16 port;\n        bytes32[2] publicKey;\n        uint16 nonce;\n        string domainName;\n    }\n    \n    /**\n     * @dev Emitted when a node is created.\n     */\n    event NodeCreated(\n        uint nodeIndex,\n        address owner,\n        string name,\n        bytes4 ip,\n        bytes4 publicIP,\n        uint16 port,\n        uint16 nonce,\n        string domainName\n    );\n\n    /**\n     * @dev Emitted when a node completes a network exit.\n     */\n    event ExitCompleted(\n        uint nodeIndex\n    );\n\n    /**\n     * @dev Emitted when a node begins to exit from the network.\n     */\n    event ExitInitialized(\n        uint nodeIndex,\n        uint startLeavingPeriod\n    );\n\n    /**\n     * @dev Emitted when a node set to in compliant or compliant.\n     */\n    event IncompliantNode(\n        uint indexed nodeIndex,\n        bool status\n    );\n\n    /**\n     * @dev Emitted when a node set to in maintenance or from in maintenance.\n     */\n    event MaintenanceNode(\n        uint indexed nodeIndex,\n        bool status\n    );\n\n    /**\n     * @dev Emitted when a node status changed.\n     */\n    event IPChanged(\n        uint indexed nodeIndex,\n        bytes4 previousIP,\n        bytes4 newIP\n    );\n    \n    function removeSpaceFromNode(uint nodeIndex, uint8 space) external returns (bool);\n    function addSpaceToNode(uint nodeIndex, uint8 space) external;\n    function changeNodeLastRewardDate(uint nodeIndex) external;\n    function changeNodeFinishTime(uint nodeIndex, uint time) external;\n    function createNode(address from, NodeCreationParams calldata params) external;\n    function initExit(uint nodeIndex) external;\n    function completeExit(uint nodeIndex) external returns (bool);\n    function deleteNodeForValidator(uint validatorId, uint nodeIndex) external;\n    function checkPossibilityCreatingNode(address nodeAddress) external;\n    function checkPossibilityToMaintainNode(uint validatorId, uint nodeIndex) external returns (bool);\n    function setNodeInMaintenance(uint nodeIndex) external;\n    function removeNodeFromInMaintenance(uint nodeIndex) external;\n    function setNodeIncompliant(uint nodeIndex) external;\n    function setNodeCompliant(uint nodeIndex) external;\n    function setDomainName(uint nodeIndex, string memory domainName) external;\n    function makeNodeVisible(uint nodeIndex) external;\n    function makeNodeInvisible(uint nodeIndex) external;\n    function changeIP(uint nodeIndex, bytes4 newIP, bytes4 newPublicIP) external;\n    function numberOfActiveNodes() external view returns (uint);\n    function incompliant(uint nodeIndex) external view returns (bool);\n    function getRandomNodeWithFreeSpace(\n        uint8 freeSpace,\n        IRandom.RandomGenerator memory randomGenerator\n    )\n        external\n        view\n        returns (uint);\n    function isTimeForReward(uint nodeIndex) external view returns (bool);\n    function getNodeIP(uint nodeIndex) external view returns (bytes4);\n    function getNodeDomainName(uint nodeIndex) external view returns (string memory);\n    function getNodePort(uint nodeIndex) external view returns (uint16);\n    function getNodePublicKey(uint nodeIndex) external view returns (bytes32[2] memory);\n    function getNodeAddress(uint nodeIndex) external view returns (address);\n    function getNodeFinishTime(uint nodeIndex) external view returns (uint);\n    function isNodeLeft(uint nodeIndex) external view returns (bool);\n    function isNodeInMaintenance(uint nodeIndex) external view returns (bool);\n    function getNodeLastRewardDate(uint nodeIndex) external view returns (uint);\n    function getNodeNextRewardDate(uint nodeIndex) external view returns (uint);\n    function getNumberOfNodes() external view returns (uint);\n    function getNumberOnlineNodes() external view returns (uint);\n    function getActiveNodeIds() external view returns (uint[] memory activeNodeIds);\n    function getNodeStatus(uint nodeIndex) external view returns (NodeStatus);\n    function getValidatorNodeIndexes(uint validatorId) external view returns (uint[] memory);\n    function countNodesWithFreeSpace(uint8 freeSpace) external view returns (uint count);\n    function getValidatorId(uint nodeIndex) external view returns (uint);\n    function isNodeExist(address from, uint nodeIndex) external view returns (bool);\n    function isNodeActive(uint nodeIndex) external view returns (bool);\n    function isNodeLeaving(uint nodeIndex) external view returns (bool);\n}\n"
+            },
             "@skalenetwork/skale-manager-interfaces/ISchains.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchains.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchains {\n\n    struct SchainOption {\n        string name;\n        bytes value;\n    }\n    \n    /**\n     * @dev Emitted when an schain is created.\n     */\n    event SchainCreated(\n        string name,\n        address owner,\n        uint partOfNode,\n        uint lifetime,\n        uint numberOfNodes,\n        uint deposit,\n        uint16 nonce,\n        bytes32 schainHash\n    );\n\n    /**\n     * @dev Emitted when an schain is deleted.\n     */\n    event SchainDeleted(\n        address owner,\n        string name,\n        bytes32 indexed schainHash\n    );\n\n    /**\n     * @dev Emitted when a node in an schain is rotated.\n     */\n    event NodeRotated(\n        bytes32 schainHash,\n        uint oldNode,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a node is added to an schain.\n     */\n    event NodeAdded(\n        bytes32 schainHash,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a group of nodes is created for an schain.\n     */\n    event SchainNodes(\n        string name,\n        bytes32 schainHash,\n        uint[] nodesInGroup\n    );\n\n    function addSchain(address from, uint deposit, bytes calldata data) external;\n    function addSchainByFoundation(\n        uint lifetime,\n        uint8 typeOfSchain,\n        uint16 nonce,\n        string calldata name,\n        address schainOwner,\n        address schainOriginator,\n        SchainOption[] calldata options\n    )\n        external\n        payable;\n    function deleteSchain(address from, string calldata name) external;\n    function deleteSchainByRoot(string calldata name) external;\n    function restartSchainCreation(string calldata name) external;\n    function verifySchainSignature(\n        uint256 signA,\n        uint256 signB,\n        bytes32 hash,\n        uint256 counter,\n        uint256 hashA,\n        uint256 hashB,\n        string calldata schainName\n    )\n        external\n        view\n        returns (bool);\n    function getSchainPrice(uint typeOfSchain, uint lifetime) external view returns (uint);\n    function getOption(bytes32 schainHash, string calldata optionName) external view returns (bytes memory);\n    function getOptions(bytes32 schainHash) external view returns (SchainOption[] memory);\n}"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchains.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchains {\n\n    struct SchainOption {\n        string name;\n        bytes value;\n    }\n    \n    /**\n     * @dev Emitted when an schain is created.\n     */\n    event SchainCreated(\n        string name,\n        address owner,\n        uint partOfNode,\n        uint lifetime,\n        uint numberOfNodes,\n        uint deposit,\n        uint16 nonce,\n        bytes32 schainHash\n    );\n\n    /**\n     * @dev Emitted when an schain is deleted.\n     */\n    event SchainDeleted(\n        address owner,\n        string name,\n        bytes32 indexed schainHash\n    );\n\n    /**\n     * @dev Emitted when a node in an schain is rotated.\n     */\n    event NodeRotated(\n        bytes32 schainHash,\n        uint oldNode,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a node is added to an schain.\n     */\n    event NodeAdded(\n        bytes32 schainHash,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a group of nodes is created for an schain.\n     */\n    event SchainNodes(\n        string name,\n        bytes32 schainHash,\n        uint[] nodesInGroup\n    );\n\n    function addSchain(address from, uint deposit, bytes calldata data) external;\n    function addSchainByFoundation(\n        uint lifetime,\n        uint8 typeOfSchain,\n        uint16 nonce,\n        string calldata name,\n        address schainOwner,\n        address schainOriginator,\n        SchainOption[] calldata options\n    )\n        external\n        payable;\n    function deleteSchain(address from, string calldata name) external;\n    function deleteSchainByRoot(string calldata name) external;\n    function restartSchainCreation(string calldata name) external;\n    function verifySchainSignature(\n        uint256 signA,\n        uint256 signB,\n        bytes32 hash,\n        uint256 counter,\n        uint256 hashA,\n        uint256 hashB,\n        string calldata schainName\n    )\n        external\n        view\n        returns (bool);\n    function getSchainPrice(uint typeOfSchain, uint lifetime) external view returns (uint);\n    function getOption(bytes32 schainHash, string calldata optionName) external view returns (bytes memory);\n    function getOptions(bytes32 schainHash) external view returns (SchainOption[] memory);\n}\n"
             },
             "@skalenetwork/skale-manager-interfaces/ISchainsInternal.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchainsInternal - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchainsInternal {\n    struct Schain {\n        string name;\n        address owner;\n        uint indexInOwnerList;\n        uint8 partOfNode;\n        uint lifetime;\n        uint startDate;\n        uint startBlock;\n        uint deposit;\n        uint64 index;\n        uint generation;\n        address originator;\n    }\n\n    struct SchainType {\n        uint8 partOfNode;\n        uint numberOfNodes;\n    }\n\n    /**\n     * @dev Emitted when schain type added.\n     */\n    event SchainTypeAdded(uint indexed schainType, uint partOfNode, uint numberOfNodes);\n\n    /**\n     * @dev Emitted when schain type removed.\n     */\n    event SchainTypeRemoved(uint indexed schainType);\n\n    function initializeSchain(\n        string calldata name,\n        address from,\n        address originator,\n        uint lifetime,\n        uint deposit) external;\n    function createGroupForSchain(\n        bytes32 schainHash,\n        uint numberOfNodes,\n        uint8 partOfNode\n    )\n        external\n        returns (uint[] memory);\n    function changeLifetime(bytes32 schainHash, uint lifetime, uint deposit) external;\n    function removeSchain(bytes32 schainHash, address from) external;\n    function removeNodeFromSchain(uint nodeIndex, bytes32 schainHash) external;\n    function deleteGroup(bytes32 schainHash) external;\n    function setException(bytes32 schainHash, uint nodeIndex) external;\n    function setNodeInGroup(bytes32 schainHash, uint nodeIndex) external;\n    function removeHolesForSchain(bytes32 schainHash) external;\n    function addSchainType(uint8 partOfNode, uint numberOfNodes) external;\n    function removeSchainType(uint typeOfSchain) external;\n    function setNumberOfSchainTypes(uint newNumberOfSchainTypes) external;\n    function removeNodeFromAllExceptionSchains(uint nodeIndex) external;\n    function removeAllNodesFromSchainExceptions(bytes32 schainHash) external;\n    function makeSchainNodesInvisible(bytes32 schainHash) external;\n    function makeSchainNodesVisible(bytes32 schainHash) external;\n    function newGeneration() external;\n    function addSchainForNode(uint nodeIndex, bytes32 schainHash) external;\n    function removeSchainForNode(uint nodeIndex, uint schainIndex) external;\n    function removeNodeFromExceptions(bytes32 schainHash, uint nodeIndex) external;\n    function isSchainActive(bytes32 schainHash) external view returns (bool);\n    function schainsAtSystem(uint index) external view returns (bytes32);\n    function numberOfSchains() external view returns (uint64);\n    function getSchains() external view returns (bytes32[] memory);\n    function getSchainsPartOfNode(bytes32 schainHash) external view returns (uint8);\n    function getSchainListSize(address from) external view returns (uint);\n    function getSchainHashesByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainIdsByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainHashesForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainIdsForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainOwner(bytes32 schainHash) external view returns (address);\n    function getSchainOriginator(bytes32 schainHash) external view returns (address);\n    function isSchainNameAvailable(string calldata name) external view returns (bool);\n    function isTimeExpired(bytes32 schainHash) external view returns (bool);\n    function isOwnerAddress(address from, bytes32 schainId) external view returns (bool);\n    function getSchainName(bytes32 schainHash) external view returns (string memory);\n    function getActiveSchain(uint nodeIndex) external view returns (bytes32);\n    function getActiveSchains(uint nodeIndex) external view returns (bytes32[] memory activeSchains);\n    function getNumberOfNodesInGroup(bytes32 schainHash) external view returns (uint);\n    function getNodesInGroup(bytes32 schainHash) external view returns (uint[] memory);\n    function isNodeAddressesInGroup(bytes32 schainId, address sender) external view returns (bool);\n    function getNodeIndexInGroup(bytes32 schainHash, uint nodeId) external view returns (uint);\n    function isAnyFreeNode(bytes32 schainHash) external view returns (bool);\n    function checkException(bytes32 schainHash, uint nodeIndex) external view returns (bool);\n    function checkHoleForSchain(bytes32 schainHash, uint indexOfNode) external view returns (bool);\n    function checkSchainOnNode(uint nodeIndex, bytes32 schainHash) external view returns (bool);\n    function getSchainType(uint typeOfSchain) external view returns(uint8, uint);\n    function getGeneration(bytes32 schainHash) external view returns (uint);\n    function isSchainExist(bytes32 schainHash) external view returns (bool);\n}"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchainsInternal - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"./INodes.sol\";\n\ninterface ISchainsInternal {\n    struct Schain {\n        string name;\n        address owner;\n        uint indexInOwnerList;\n        uint8 partOfNode;\n        uint lifetime;\n        uint startDate;\n        uint startBlock;\n        uint deposit;\n        uint64 index;\n        uint generation;\n        address originator;\n    }\n\n    struct SchainType {\n        uint8 partOfNode;\n        uint numberOfNodes;\n    }\n\n    /**\n     * @dev Emitted when schain type added.\n     */\n    event SchainTypeAdded(uint indexed schainType, uint partOfNode, uint numberOfNodes);\n\n    /**\n     * @dev Emitted when schain type removed.\n     */\n    event SchainTypeRemoved(uint indexed schainType);\n\n    function initializeSchain(\n        string calldata name,\n        address from,\n        address originator,\n        uint lifetime,\n        uint deposit) external;\n    function createGroupForSchain(\n        bytes32 schainHash,\n        uint numberOfNodes,\n        uint8 partOfNode\n    )\n        external\n        returns (uint[] memory);\n    function changeLifetime(bytes32 schainHash, uint lifetime, uint deposit) external;\n    function removeSchain(bytes32 schainHash, address from) external;\n    function removeNodeFromSchain(uint nodeIndex, bytes32 schainHash) external;\n    function deleteGroup(bytes32 schainHash) external;\n    function setException(bytes32 schainHash, uint nodeIndex) external;\n    function setNodeInGroup(bytes32 schainHash, uint nodeIndex) external;\n    function removeHolesForSchain(bytes32 schainHash) external;\n    function addSchainType(uint8 partOfNode, uint numberOfNodes) external;\n    function removeSchainType(uint typeOfSchain) external;\n    function setNumberOfSchainTypes(uint newNumberOfSchainTypes) external;\n    function removeNodeFromAllExceptionSchains(uint nodeIndex) external;\n    function removeAllNodesFromSchainExceptions(bytes32 schainHash) external;\n    function makeSchainNodesInvisible(bytes32 schainHash) external;\n    function makeSchainNodesVisible(bytes32 schainHash) external;\n    function newGeneration() external;\n    function addSchainForNode(INodes nodes,uint nodeIndex, bytes32 schainHash) external;\n    function removeSchainForNode(uint nodeIndex, uint schainIndex) external;\n    function removeNodeFromExceptions(bytes32 schainHash, uint nodeIndex) external;\n    function isSchainActive(bytes32 schainHash) external view returns (bool);\n    function schainsAtSystem(uint index) external view returns (bytes32);\n    function numberOfSchains() external view returns (uint64);\n    function getSchains() external view returns (bytes32[] memory);\n    function getSchainsPartOfNode(bytes32 schainHash) external view returns (uint8);\n    function getSchainListSize(address from) external view returns (uint);\n    function getSchainHashesByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainHashesForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainOwner(bytes32 schainHash) external view returns (address);\n    function getSchainOriginator(bytes32 schainHash) external view returns (address);\n    function isSchainNameAvailable(string calldata name) external view returns (bool);\n    function isTimeExpired(bytes32 schainHash) external view returns (bool);\n    function isOwnerAddress(address from, bytes32 schainHash) external view returns (bool);\n    function getSchainName(bytes32 schainHash) external view returns (string memory);\n    function getActiveSchain(uint nodeIndex) external view returns (bytes32);\n    function getActiveSchains(uint nodeIndex) external view returns (bytes32[] memory activeSchains);\n    function getNumberOfNodesInGroup(bytes32 schainHash) external view returns (uint);\n    function getNodesInGroup(bytes32 schainHash) external view returns (uint[] memory);\n    function isNodeAddressesInGroup(bytes32 schainHash, address sender) external view returns (bool);\n    function getNodeIndexInGroup(bytes32 schainHash, uint nodeHash) external view returns (uint);\n    function isAnyFreeNode(bytes32 schainHash) external view returns (bool);\n    function checkException(bytes32 schainHash, uint nodeIndex) external view returns (bool);\n    function checkHoleForSchain(bytes32 schainHash, uint indexOfNode) external view returns (bool);\n    function checkSchainOnNode(uint nodeIndex, bytes32 schainHash) external view returns (bool);\n    function getSchainType(uint typeOfSchain) external view returns(uint8, uint);\n    function getGeneration(bytes32 schainHash) external view returns (uint);\n    function isSchainExist(bytes32 schainHash) external view returns (bool);\n}"
             },
             "@skalenetwork/skale-manager-interfaces/IWallets.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IWallets - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IWallets {\n    /**\n     * @dev Emitted when the validator wallet was funded\n     */\n    event ValidatorWalletRecharged(address sponsor, uint amount, uint validatorId);\n\n    /**\n     * @dev Emitted when the schain wallet was funded\n     */\n    event SchainWalletRecharged(address sponsor, uint amount, bytes32 schainHash);\n\n    /**\n     * @dev Emitted when the node received a refund from validator to its wallet\n     */\n    event NodeRefundedByValidator(address node, uint validatorId, uint amount);\n\n    /**\n     * @dev Emitted when the node received a refund from schain to its wallet\n     */\n    event NodeRefundedBySchain(address node, bytes32 schainHash, uint amount);\n\n    /**\n     * @dev Emitted when the validator withdrawn funds from validator wallet\n     */\n    event WithdrawFromValidatorWallet(uint indexed validatorId, uint amount);\n\n    /**\n     * @dev Emitted when the schain owner withdrawn funds from schain wallet\n     */\n    event WithdrawFromSchainWallet(bytes32 indexed schainHash, uint amount);\n\n    receive() external payable;\n    function refundGasByValidator(uint validatorId, address payable spender, uint spentGas) external;\n    function refundGasByValidatorToSchain(uint validatorId, bytes32 schainHash) external;\n    function refundGasBySchain(bytes32 schainId, address payable spender, uint spentGas, bool isDebt) external;\n    function withdrawFundsFromSchainWallet(address payable schainOwner, bytes32 schainHash) external;\n    function withdrawFundsFromValidatorWallet(uint amount) external;\n    function rechargeValidatorWallet(uint validatorId) external payable;\n    function rechargeSchainWallet(bytes32 schainId) external payable;\n    function getSchainBalance(bytes32 schainHash) external view returns (uint);\n    function getValidatorBalance(uint validatorId) external view returns (uint);\n}\n"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IWallets - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IWallets {\n    receive() external payable;\n    function refundGasByValidator(uint validatorId, address payable spender, uint gasLimit) external;\n    function refundGasByValidatorToSchain(uint validatorId, bytes32 schainHash) external;\n    function refundGasBySchain(bytes32 schainId, address payable spender, uint spentGas, bool isDebt) external;\n    function withdrawFundsFromSchainWallet(address payable schainOwner, bytes32 schainHash) external;\n    function withdrawFundsFromValidatorWallet(uint amount) external;\n    function rechargeValidatorWallet(uint validatorId) external payable;\n    function rechargeSchainWallet(bytes32 schainId) external payable;\n    function getSchainBalance(bytes32 schainHash) external view returns (uint);\n    function getValidatorBalance(uint validatorId) external view returns (uint);\n}\n"
+            },
+            "@skalenetwork/skale-manager-interfaces/utils/IRandom.sol": {
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IRandom.sol - SKALE Manager Interfaces\n    Copyright (C) 2022-Present SKALE Labs\n    @author Dmytro Stebaiev\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\n\ninterface IRandom {\n    struct RandomGenerator {\n        uint seed;\n    }\n}"
             },
             "contracts/MessageProxy.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   MessageProxy.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/IGasReimbursable.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageProxy.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageReceiver.sol\";\n\n\n/**\n * @title MessageProxy\n * @dev Abstract contract for MessageProxyForMainnet and MessageProxyForSchain.\n */\nabstract contract MessageProxy is AccessControlEnumerableUpgradeable, IMessageProxy {\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    /**\n     * @dev Structure that stores counters for outgoing and incoming messages.\n     */\n    struct ConnectedChainInfo {\n        // message counters start with 0\n        uint256 incomingMessageCounter;\n        uint256 outgoingMessageCounter;\n        bool inited;\n        uint256 lastOutgoingMessageBlockId;\n    }\n\n    bytes32 public constant MAINNET_HASH = keccak256(abi.encodePacked(\"Mainnet\"));\n    bytes32 public constant CHAIN_CONNECTOR_ROLE = keccak256(\"CHAIN_CONNECTOR_ROLE\");\n    bytes32 public constant EXTRA_CONTRACT_REGISTRAR_ROLE = keccak256(\"EXTRA_CONTRACT_REGISTRAR_ROLE\");\n    bytes32 public constant CONSTANT_SETTER_ROLE = keccak256(\"CONSTANT_SETTER_ROLE\");\n    uint256 public constant MESSAGES_LENGTH = 10;\n    uint256 public constant REVERT_REASON_LENGTH = 64;\n\n    //   schainHash => ConnectedChainInfo\n    mapping(bytes32 => ConnectedChainInfo) public connectedChains;\n    //   schainHash => contract address => allowed\n    mapping(bytes32 => mapping(address => bool)) private _deprecatedRegistryContracts;\n\n    uint256 public gasLimit;\n\n    /**\n     * @dev Emitted for every outgoing message to schain.\n     */\n    event OutgoingMessage(\n        bytes32 indexed dstChainHash,\n        uint256 indexed msgCounter,\n        address indexed srcContract,\n        address dstContract,\n        bytes data\n    );\n\n    /**\n     * @dev Emitted when function `postMessage` returns revert.\n     *  Used to prevent stuck loop inside function `postIncomingMessages`.\n     */\n    event PostMessageError(\n        uint256 indexed msgCounter,\n        bytes message\n    );\n\n    /**\n     * @dev Emitted when gas limit per one call of `postMessage` was changed.\n     */\n    event GasLimitWasChanged(\n        uint256 oldValue,\n        uint256 newValue\n    );\n\n    /**\n     * @dev Emitted when the version was updated\n     */\n    event VersionUpdated(string oldVersion, string newVersion);\n\n    /**\n     * @dev Emitted when extra contract was added.\n     */\n    event ExtraContractRegistered(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Emitted when extra contract was removed.\n     */\n    event ExtraContractRemoved(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Emitted when referenced to previous outgoing message.\n     */\n    event PreviousMessageReference (\n        uint256 currentMessage,\n        uint256 previousOutgoingMessageBlockId\n    );\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CHAIN_CONNECTOR_ROLE}.\n     */\n    modifier onlyChainConnector() {\n        require(hasRole(CHAIN_CONNECTOR_ROLE, msg.sender), \"CHAIN_CONNECTOR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {EXTRA_CONTRACT_REGISTRAR_ROLE}.\n     */\n    modifier onlyExtraContractRegistrar() {\n        require(hasRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender), \"EXTRA_CONTRACT_REGISTRAR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CONSTANT_SETTER_ROLE}.\n     */\n    modifier onlyConstantSetter() {\n        require(hasRole(CONSTANT_SETTER_ROLE, msg.sender), \"Not enough permissions to set constant\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {DEFAULT_ADMIN_ROLE}.\n     */\n    modifier onlyOwner() {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"DEFAULT_ADMIN_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Sets gasLimit to a new value.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CONSTANT_SETTER_ROLE.\n     */\n    function setNewGasLimit(uint256 newGasLimit) external override onlyConstantSetter {\n        emit GasLimitWasChanged(gasLimit, newGasLimit);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Virtual function for `postIncomingMessages`.\n     */\n    function postIncomingMessages(\n        string calldata fromSchainName,\n        uint256 startingCounter,\n        Message[] calldata messages,\n        Signature calldata sign\n    )\n        external\n        virtual\n        override;\n\n    /**\n     * @dev Allows `msg.sender` to register extra contract for all schains\n     * for being able to transfer messages from custom contracts.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     * - Passed address should be contract.\n     * - Extra contract must not be registered.\n     */\n    function registerExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is already registered\");\n        _getRegistryContracts()[bytes32(0)].add(extraContract);\n        emit ExtraContractRegistered(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Allows `msg.sender` to remove extra contract for all schains.\n     * Extra contract will no longer be able to send messages through MessageProxy.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     */\n    function removeExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[bytes32(0)].remove(extraContract);\n        emit ExtraContractRemoved(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Should return length of contract registered by schainHash.\n     */\n    function getContractRegisteredLength(bytes32 schainHash) external view override returns (uint256) {\n        return _getRegistryContracts()[schainHash].length();\n    }\n\n    /**\n     * @dev Should return a range of contracts registered by schainHash.\n     *\n     * Requirements:\n     * range should be less or equal 10 contracts\n     */\n    function getContractRegisteredRange(\n        bytes32 schainHash,\n        uint256 from,\n        uint256 to\n    )\n        external\n        view\n        override\n        returns (address[] memory contractsInRange)\n    {\n        require(\n            from < to && to - from <= 10 && to <= _getRegistryContracts()[schainHash].length(),\n            \"Range is incorrect\"\n        );\n        contractsInRange = new address[](to - from);\n        for (uint256 i = from; i < to; i++) {\n            contractsInRange[i - from] = _getRegistryContracts()[schainHash].at(i);\n        }\n    }\n\n    /**\n     * @dev Returns number of outgoing messages.\n     *\n     * Requirements:\n     *\n     * - Target schain  must be initialized.\n     */\n    function getOutgoingMessagesCounter(string calldata targetSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 dstChainHash = keccak256(abi.encodePacked(targetSchainName));\n        require(connectedChains[dstChainHash].inited, \"Destination chain is not initialized\");\n        return connectedChains[dstChainHash].outgoingMessageCounter;\n    }\n\n\n    /**\n     * @dev Should return block number of the last message transferred to schain\n     */\n    function getLastOutgoingMessageBlockId(string memory targetSchainName) external view override returns (uint) {\n        bytes32 dstChainHash = keccak256(abi.encodePacked(targetSchainName));\n        require(connectedChains[dstChainHash].inited, \"Destination chain is not initialized\");\n        return connectedChains[dstChainHash].lastOutgoingMessageBlockId;\n    }\n\n    /**\n     * @dev Returns number of incoming messages.\n     *\n     * Requirements:\n     *\n     * - Source schain must be initialized.\n     */\n    function getIncomingMessagesCounter(string calldata fromSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 srcChainHash = keccak256(abi.encodePacked(fromSchainName));\n        require(connectedChains[srcChainHash].inited, \"Source chain is not initialized\");\n        return connectedChains[srcChainHash].incomingMessageCounter;\n    }\n\n    function initializeMessageProxy(uint newGasLimit) public initializer {\n        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(CHAIN_CONNECTOR_ROLE, msg.sender);\n        _setupRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender);\n        _setupRole(CONSTANT_SETTER_ROLE, msg.sender);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Posts message from this contract to `targetChainHash` MessageProxy contract.\n     * This is called by a smart contract to make a cross-chain call.\n     *\n     * Emits an {OutgoingMessage} event.\n     *\n     * Requirements:\n     *\n     * - Target chain must be initialized.\n     * - Target chain must be registered as external contract.\n     */\n    function postOutgoingMessage(\n        bytes32 targetChainHash,\n        address targetContract,\n        bytes memory data\n    )\n        public\n        override\n        virtual\n    {\n        require(connectedChains[targetChainHash].inited, \"Destination chain is not initialized\");\n        _authorizeOutgoingMessageSender(targetChainHash);\n\n        uint outgoingMessageCounter = connectedChains[targetChainHash].outgoingMessageCounter;\n        emit OutgoingMessage(\n            targetChainHash,\n            outgoingMessageCounter,\n            msg.sender,\n            targetContract,\n            data\n        );\n        emit PreviousMessageReference(\n            outgoingMessageCounter,\n            connectedChains[targetChainHash].lastOutgoingMessageBlockId\n        );\n        connectedChains[targetChainHash].outgoingMessageCounter++;\n        connectedChains[targetChainHash].lastOutgoingMessageBlockId = block.number;\n    }\n\n    /**\n     * @dev Allows CHAIN_CONNECTOR_ROLE to remove connected chain from this contract.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CHAIN_CONNECTOR_ROLE.\n     * - `schainName` must be initialized.\n     */\n    function removeConnectedChain(string memory schainName) public virtual override onlyChainConnector {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(connectedChains[schainHash].inited, \"Chain is not initialized\");\n        delete connectedChains[schainHash];\n    }\n\n    /**\n     * @dev Checks whether chain is currently connected.\n     */\n    function isConnectedChain(\n        string memory schainName\n    )\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return connectedChains[keccak256(abi.encodePacked(schainName))].inited;\n    }\n\n    /**\n     * @dev Checks whether contract is currently registered as extra contract.\n     */\n    function isContractRegistered(\n        bytes32 schainHash,\n        address contractAddress\n    )\n        public\n        view\n        override\n        returns (bool)\n    {\n        return _getRegistryContracts()[schainHash].contains(contractAddress);\n    }\n\n    /**\n     * @dev Allows MessageProxy to register extra contract for being able to transfer messages from custom contracts.\n     *\n     * Requirements:\n     *\n     * - Extra contract address must be contract.\n     * - Extra contract must not be registered.\n     * - Extra contract must not be registered for all chains.\n     */\n    function _registerExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {\n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is already registered\");\n        require(\n            !_getRegistryContracts()[bytes32(0)].contains(extraContract),\n            \"Extra contract is already registered for all chains\"\n        );\n\n        _getRegistryContracts()[chainHash].add(extraContract);\n        emit ExtraContractRegistered(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to remove extra contract,\n     * thus `extraContract` will no longer be available to transfer messages from mainnet to schain.\n     *\n     * Requirements:\n     *\n     * - Extra contract must be registered.\n     */\n    function _removeExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {\n        require(_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[chainHash].remove(extraContract);\n        emit ExtraContractRemoved(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to connect schain with MessageProxyOnMainnet for transferring messages.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CHAIN_CONNECTOR_ROLE.\n     * - SKALE chain must not be connected.\n     */\n    function _addConnectedChain(bytes32 schainHash) internal onlyChainConnector {\n        require(!connectedChains[schainHash].inited,\"Chain is already connected\");\n        connectedChains[schainHash] = ConnectedChainInfo({\n            incomingMessageCounter: 0,\n            outgoingMessageCounter: 0,\n            inited: true,\n            lastOutgoingMessageBlockId: 0\n        });\n    }\n\n    /**\n     * @dev Allows MessageProxy to send messages from schain to mainnet.\n     * Destination contract must implement `postMessage` method.\n     */\n    function _callReceiverContract(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n    {\n        if (!message.destinationContract.isContract()) {\n            emit PostMessageError(\n                counter,\n                \"Destination contract is not a contract\"\n            );\n            return;\n        }\n        try IMessageReceiver(message.destinationContract).postMessage{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) {\n            return;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                _getSlice(bytes(reason), REVERT_REASON_LENGTH)\n            );\n        } catch Panic(uint errorCode) {\n               emit PostMessageError(\n                counter,\n                abi.encodePacked(errorCode)\n            );\n        } catch (bytes memory revertData) {\n            emit PostMessageError(\n                counter,\n                _getSlice(revertData, REVERT_REASON_LENGTH)\n            );\n        }\n    }\n\n    /**\n     * @dev Returns receiver of message.\n     */\n    function _getGasPayer(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n        returns (address)\n    {\n        try IGasReimbursable(message.destinationContract).gasPayer{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) returns (address receiver) {\n            return receiver;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                _getSlice(bytes(reason), REVERT_REASON_LENGTH)\n            );\n            return address(0);\n        } catch Panic(uint errorCode) {\n               emit PostMessageError(\n                counter,\n                abi.encodePacked(errorCode)\n            );\n            return address(0);\n        } catch (bytes memory revertData) {\n            emit PostMessageError(\n                counter,\n                _getSlice(revertData, REVERT_REASON_LENGTH)\n            );\n            return address(0);\n        }\n    }\n\n    /**\n     * @dev Checks whether msg.sender is registered as custom extra contract.\n     */\n    function _authorizeOutgoingMessageSender(bytes32 targetChainHash) internal view virtual {\n        require(\n            isContractRegistered(bytes32(0), msg.sender) || isContractRegistered(targetChainHash, msg.sender),\n            \"Sender contract is not registered\"\n        );\n    }\n\n    /**\n     * @dev Returns list of registered custom extra contracts.\n     */\n    function _getRegistryContracts()\n        internal\n        view\n        virtual\n        returns (mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) storage);\n\n    /**\n     * @dev Returns hash of message array.\n     */\n    function _hashedArray(\n        Message[] calldata messages,\n        uint256 startingCounter,\n        string calldata fromChainName\n    )\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32 sourceHash = keccak256(abi.encodePacked(fromChainName));\n        bytes32 hash = keccak256(abi.encodePacked(sourceHash, bytes32(startingCounter)));\n        for (uint256 i = 0; i < messages.length; i++) {\n            hash = keccak256(\n                abi.encodePacked(\n                    abi.encode(\n                        hash,\n                        messages[i].sender,\n                        messages[i].destinationContract\n                    ),\n                    messages[i].data\n                )\n            );\n        }\n        return hash;\n    }\n\n    function _getSlice(bytes memory text, uint end) private pure returns (bytes memory) {\n        uint slicedEnd = end < text.length ? end : text.length;\n        bytes memory sliced = new bytes(slicedEnd);\n        for(uint i = 0; i < slicedEnd; i++){\n            sliced[i] = text[i];\n        }\n        return sliced;\n    }\n}\n"
             },
             "contracts/Messages.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   Messages.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\n\n/**\n * @title Messages\n * @dev Library for encoding and decoding messages\n * for transferring from Mainnet to Schain and vice versa.\n */\nlibrary Messages {\n\n    /**\n     * @dev Enumerator that describes all supported message types.\n     */\n    enum MessageType {\n        EMPTY,\n        TRANSFER_ETH,\n        TRANSFER_ERC20,\n        TRANSFER_ERC20_AND_TOTAL_SUPPLY,\n        TRANSFER_ERC20_AND_TOKEN_INFO,\n        TRANSFER_ERC721,\n        TRANSFER_ERC721_AND_TOKEN_INFO,\n        USER_STATUS,\n        INTERCHAIN_CONNECTION,\n        TRANSFER_ERC1155,\n        TRANSFER_ERC1155_AND_TOKEN_INFO,\n        TRANSFER_ERC1155_BATCH,\n        TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO,\n        TRANSFER_ERC721_WITH_METADATA,\n        TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO\n    }\n\n    /**\n     * @dev Structure for base message.\n     */\n    struct BaseMessage {\n        MessageType messageType;\n    }\n\n    /**\n     * @dev Structure for describing ETH.\n     */\n    struct TransferEthMessage {\n        BaseMessage message;\n        address receiver;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for user status.\n     */\n    struct UserStatusMessage {\n        BaseMessage message;\n        address receiver;\n        bool isActive;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 token.\n     */\n    struct TransferErc20Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC20 token.\n     */\n    struct Erc20TokenInfo {\n        string name;\n        uint8 decimals;\n        string symbol;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token supply.\n     */\n    struct TransferErc20AndTotalSupplyMessage {\n        TransferErc20Message baseErc20transfer;\n        uint256 totalSupply;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token info.\n     */\n    struct TransferErc20AndTokenInfoMessage {\n        TransferErc20Message baseErc20transfer;\n        uint256 totalSupply;\n        Erc20TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing base ERC721.\n     */\n    struct TransferErc721Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 tokenId;\n    }\n\n    /**\n     * @dev Structure for describing base ERC721 with metadata.\n     */\n    struct TransferErc721MessageWithMetadata {\n        TransferErc721Message erc721message;\n        string tokenURI;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token info.\n     */\n    struct Erc721TokenInfo {\n        string name;\n        string symbol;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC721 token.\n     */\n    struct TransferErc721AndTokenInfoMessage {\n        TransferErc721Message baseErc721transfer;\n        Erc721TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC721 token with metadata.\n     */\n    struct TransferErc721WithMetadataAndTokenInfoMessage {\n        TransferErc721MessageWithMetadata baseErc721transferWithMetadata;\n        Erc721TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing whether interchain connection is allowed.\n     */\n    struct InterchainConnectionMessage {\n        BaseMessage message;\n        bool isAllowed;\n    }\n\n    /**\n     * @dev Structure for describing whether interchain connection is allowed.\n     */\n    struct TransferErc1155Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 id;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for describing ERC1155 token in batches.\n     */\n    struct TransferErc1155BatchMessage {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256[] ids;\n        uint256[] amounts;\n    }\n\n    /**\n     * @dev Structure for describing ERC1155 token info.\n     */\n    struct Erc1155TokenInfo {\n        string uri;\n    }\n\n    /**\n     * @dev Structure for describing message for transferring ERC1155 token with info.\n     */\n    struct TransferErc1155AndTokenInfoMessage {\n        TransferErc1155Message baseErc1155transfer;\n        Erc1155TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing message for transferring ERC1155 token in batches with info.\n     */\n    struct TransferErc1155BatchAndTokenInfoMessage {\n        TransferErc1155BatchMessage baseErc1155Batchtransfer;\n        Erc1155TokenInfo tokenInfo;\n    }\n\n\n    /**\n     * @dev Returns type of message for encoded data.\n     */\n    function getMessageType(bytes calldata data) internal pure returns (MessageType) {\n        uint256 firstWord = abi.decode(data, (uint256));\n        if (firstWord % 32 == 0) {\n            return getMessageType(data[firstWord:]);\n        } else {\n            return abi.decode(data, (Messages.MessageType));\n        }\n    }\n\n    /**\n     * @dev Encodes message for transferring ETH. Returns encoded message.\n     */\n    function encodeTransferEthMessage(address receiver, uint256 amount) internal pure returns (bytes memory) {\n        TransferEthMessage memory message = TransferEthMessage(\n            BaseMessage(MessageType.TRANSFER_ETH),\n            receiver,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ETH. Returns structure `TransferEthMessage`.\n     */\n    function decodeTransferEthMessage(\n        bytes calldata data\n    ) internal pure returns (TransferEthMessage memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ETH, \"Message type is not ETH transfer\");\n        return abi.decode(data, (TransferEthMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ETH. Returns encoded message.\n     */\n    function encodeTransferErc20Message(\n        address token,\n        address receiver,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        TransferErc20Message memory message = TransferErc20Message(\n            BaseMessage(MessageType.TRANSFER_ERC20),\n            token,\n            receiver,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC20 with total supply. Returns encoded message.\n     */\n    function encodeTransferErc20AndTotalSupplyMessage(\n        address token,\n        address receiver,\n        uint256 amount,\n        uint256 totalSupply\n    ) internal pure returns (bytes memory) {\n        TransferErc20AndTotalSupplyMessage memory message = TransferErc20AndTotalSupplyMessage(\n            TransferErc20Message(\n                BaseMessage(MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY),\n                token,\n                receiver,\n                amount\n            ),\n            totalSupply\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20. Returns structure `TransferErc20Message`.\n     */\n    function decodeTransferErc20Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc20Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC20, \"Message type is not ERC20 transfer\");\n        return abi.decode(data, (TransferErc20Message));\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20 with total supply. \n     * Returns structure `TransferErc20AndTotalSupplyMessage`.\n     */\n    function decodeTransferErc20AndTotalSupplyMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc20AndTotalSupplyMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY,\n            \"Message type is not ERC20 transfer and total supply\"\n        );\n        return abi.decode(data, (TransferErc20AndTotalSupplyMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC20 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc20AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 amount,\n        uint256 totalSupply,\n        Erc20TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc20AndTokenInfoMessage memory message = TransferErc20AndTokenInfoMessage(\n            TransferErc20Message(\n                BaseMessage(MessageType.TRANSFER_ERC20_AND_TOKEN_INFO),\n                token,\n                receiver,\n                amount\n            ),\n            totalSupply,\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20 with token info. \n     * Returns structure `TransferErc20AndTokenInfoMessage`.\n     */\n    function decodeTransferErc20AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc20AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC20_AND_TOKEN_INFO,\n            \"Message type is not ERC20 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc20AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721Message(\n        address token,\n        address receiver,\n        uint256 tokenId\n    ) internal pure returns (bytes memory) {\n        TransferErc721Message memory message = TransferErc721Message(\n            BaseMessage(MessageType.TRANSFER_ERC721),\n            token,\n            receiver,\n            tokenId\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721. \n     * Returns structure `TransferErc721Message`.\n     */\n    function decodeTransferErc721Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc721Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC721, \"Message type is not ERC721 transfer\");\n        return abi.decode(data, (TransferErc721Message));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        Erc721TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc721AndTokenInfoMessage memory message = TransferErc721AndTokenInfoMessage(\n            TransferErc721Message(\n                BaseMessage(MessageType.TRANSFER_ERC721_AND_TOKEN_INFO),\n                token,\n                receiver,\n                tokenId\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721 with token info. \n     * Returns structure `TransferErc721AndTokenInfoMessage`.\n     */\n    function decodeTransferErc721AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc721AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_AND_TOKEN_INFO,\n            \"Message type is not ERC721 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc721AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721MessageWithMetadata(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        string memory tokenURI\n    ) internal pure returns (bytes memory) {\n        TransferErc721MessageWithMetadata memory message = TransferErc721MessageWithMetadata(\n            TransferErc721Message(\n                BaseMessage(MessageType.TRANSFER_ERC721_WITH_METADATA),\n                token,\n                receiver,\n                tokenId\n            ),\n            tokenURI\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721. \n     * Returns structure `TransferErc721MessageWithMetadata`.\n     */\n    function decodeTransferErc721MessageWithMetadata(\n        bytes calldata data\n    ) internal pure returns (TransferErc721MessageWithMetadata memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_WITH_METADATA,\n            \"Message type is not ERC721 transfer\"\n        );\n        return abi.decode(data, (TransferErc721MessageWithMetadata));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721WithMetadataAndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        string memory tokenURI,\n        Erc721TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc721WithMetadataAndTokenInfoMessage memory message = TransferErc721WithMetadataAndTokenInfoMessage(\n            TransferErc721MessageWithMetadata(\n                TransferErc721Message(\n                    BaseMessage(MessageType.TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO),\n                    token,\n                    receiver,\n                    tokenId\n                ),\n                tokenURI\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721 with token info. \n     * Returns structure `TransferErc721WithMetadataAndTokenInfoMessage`.\n     */\n    function decodeTransferErc721WithMetadataAndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc721WithMetadataAndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO,\n            \"Message type is not ERC721 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc721WithMetadataAndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for activating user on schain. \n     * Returns encoded message.\n     */\n    function encodeActivateUserMessage(address receiver) internal pure returns (bytes memory){\n        return _encodeUserStatusMessage(receiver, true);\n    }\n\n    /**\n     * @dev Encodes message for locking user on schain. \n     * Returns encoded message.\n     */\n    function encodeLockUserMessage(address receiver) internal pure returns (bytes memory){\n        return _encodeUserStatusMessage(receiver, false);\n    }\n\n    /**\n     * @dev Decodes message for user status. \n     * Returns structure UserStatusMessage.\n     */\n    function decodeUserStatusMessage(bytes calldata data) internal pure returns (UserStatusMessage memory) {\n        require(getMessageType(data) == MessageType.USER_STATUS, \"Message type is not User Status\");\n        return abi.decode(data, (UserStatusMessage));\n    }\n\n\n    /**\n     * @dev Encodes message for allowing interchain connection.\n     * Returns encoded message.\n     */\n    function encodeInterchainConnectionMessage(bool isAllowed) internal pure returns (bytes memory) {\n        InterchainConnectionMessage memory message = InterchainConnectionMessage(\n            BaseMessage(MessageType.INTERCHAIN_CONNECTION),\n            isAllowed\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for allowing interchain connection.\n     * Returns structure `InterchainConnectionMessage`.\n     */\n    function decodeInterchainConnectionMessage(bytes calldata data)\n        internal\n        pure\n        returns (InterchainConnectionMessage memory)\n    {\n        require(getMessageType(data) == MessageType.INTERCHAIN_CONNECTION, \"Message type is not Interchain connection\");\n        return abi.decode(data, (InterchainConnectionMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155Message(\n        address token,\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        TransferErc1155Message memory message = TransferErc1155Message(\n            BaseMessage(MessageType.TRANSFER_ERC1155),\n            token,\n            receiver,\n            id,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token.\n     * Returns structure `TransferErc1155Message`.\n     */\n    function decodeTransferErc1155Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC1155, \"Message type is not ERC1155 transfer\");\n        return abi.decode(data, (TransferErc1155Message));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 with token info.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 id,\n        uint256 amount,\n        Erc1155TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc1155AndTokenInfoMessage memory message = TransferErc1155AndTokenInfoMessage(\n            TransferErc1155Message(\n                BaseMessage(MessageType.TRANSFER_ERC1155_AND_TOKEN_INFO),\n                token,\n                receiver,\n                id,\n                amount\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 with token info.\n     * Returns structure `TransferErc1155AndTokenInfoMessage`.\n     */\n    function decodeTransferErc1155AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_AND_TOKEN_INFO,\n            \"Message type is not ERC1155AndTokenInfo transfer\"\n        );\n        return abi.decode(data, (TransferErc1155AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token in batches.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155BatchMessage(\n        address token,\n        address receiver,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal pure returns (bytes memory) {\n        TransferErc1155BatchMessage memory message = TransferErc1155BatchMessage(\n            BaseMessage(MessageType.TRANSFER_ERC1155_BATCH),\n            token,\n            receiver,\n            ids,\n            amounts\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token in batches.\n     * Returns structure `TransferErc1155BatchMessage`.\n     */\n    function decodeTransferErc1155BatchMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155BatchMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_BATCH,\n            \"Message type is not ERC1155Batch transfer\"\n        );\n        return abi.decode(data, (TransferErc1155BatchMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token in batches with token info.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155BatchAndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        Erc1155TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc1155BatchAndTokenInfoMessage memory message = TransferErc1155BatchAndTokenInfoMessage(\n            TransferErc1155BatchMessage(\n                BaseMessage(MessageType.TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO),\n                token,\n                receiver,\n                ids,\n                amounts\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token in batches with token info.\n     * Returns structure `TransferErc1155BatchAndTokenInfoMessage`.\n     */\n    function decodeTransferErc1155BatchAndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155BatchAndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO,\n            \"Message type is not ERC1155BatchAndTokenInfo transfer\"\n        );\n        return abi.decode(data, (TransferErc1155BatchAndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring user status on schain.\n     * Returns encoded message.\n     */\n    function _encodeUserStatusMessage(address receiver, bool isActive) private pure returns (bytes memory) {\n        UserStatusMessage memory message = UserStatusMessage(\n            BaseMessage(MessageType.USER_STATUS),\n            receiver,\n            isActive\n        );\n        return abi.encode(message);\n    }\n\n}"
             },
@@ -403,11 +409,11 @@
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   RevertableERC20.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2022-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\ninterface IRevertableERC20 {\n    function enable() external;\n    function disable() external;\n    function mint(address account, uint amount) external;\n}\n\ncontract RevertableERC20 is IRevertableERC20, ERC20Upgradeable {\n    bool public enabled = true;\n\n    constructor(string memory name, string memory symbol) initializer {\n        super.__ERC20_init(name, symbol);\n    }\n\n    function enable() external override {\n        enabled = true;\n    }\n\n    function disable() external override {\n        enabled = false;\n    }\n\n    function mint(address account, uint amount) external override {\n        _mint(account, amount);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    )\n        internal\n        override\n    {\n        require(enabled, \"Transfers are disabled\");\n        super._transfer(from, to, amount);\n    }\n}"
             },
             "contracts/thirdparty/ERC1155ReceiverUpgradeableWithoutGap.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol\";\n\nabstract contract ERC1155ReceiverUpgradeableWithoutGap is\n    Initializable,\n    ERC165Upgradeable,\n    IERC1155ReceiverUpgradeable\n{\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165Upgradeable)\n        returns (bool)\n    {\n        return interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function __ERC1155Receiver_init() internal initializer {\n        __ERC165_init_unchained();\n        __ERC1155Receiver_init_unchained();\n    }\n\n    // solhint-disable-next-line func-name-mixedcase, no-empty-blocks\n    function __ERC1155Receiver_init_unchained() internal initializer {\n    }\n}"
             }
         }
     },
-    "name": "ERC721OnChain",
+    "name": "ERC20OnChain",
     "solcLongVersion": "0.8.16+commit.07a7930e",
     "solcVersion": "0.8.16"
 }
```

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/EthErc20.json` & `ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/EthErc20.json`

 * *Files identical despite different names*

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/EthErc20.meta.json` & `ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/ERC721OnChain.meta.json`

 * *Files 1% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.8745592948717948%*

 * *Differences: {"'input'": "{'sources': {'@skalenetwork/skale-manager-interfaces/IWallets.sol': {'content': '// "*

 * *            'SPDX-License-Identifier: AGPL-3.0-only\\n\\n/*\\n    IWallets - SKALE Manager '*

 * *            'Interfaces\\n    Copyright (C) 2021-Present SKALE Labs\\n    @author Dmytro '*

 * *            'Stebaeiv\\n\\n    SKALE Manager Interfaces is free software: you can redistribute it '*

 * *            'and/or modify\\n    it under the terms of the GNU Affero General Public License as '*

 * *            'published\\n    by […]*

```diff
@@ -218,22 +218,28 @@
             },
             "@skalenetwork/ima-interfaces/schain/tokens/IEthErc20.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   IEthErc20 - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\n\ninterface IEthErc20 {\n    function mint(address account, uint256 amount) external;\n    function forceBurn(address account, uint256 amount) external;\n    function initialize(address tokenManagerEthAddress) external;\n}"
             },
             "@skalenetwork/skale-manager-interfaces/IContractManager.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IContractManager.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IContractManager {\n    /**\n     * @dev Emitted when contract is upgraded.\n     */\n    event ContractUpgraded(string contractsName, address contractsAddress);\n\n    function initialize() external;\n    function setContractsAddress(string calldata contractsName, address newContractsAddress) external;\n    function contracts(bytes32 nameHash) external view returns (address);\n    function getDelegationPeriodManager() external view returns (address);\n    function getBounty() external view returns (address);\n    function getValidatorService() external view returns (address);\n    function getTimeHelpers() external view returns (address);\n    function getConstantsHolder() external view returns (address);\n    function getSkaleToken() external view returns (address);\n    function getTokenState() external view returns (address);\n    function getPunisher() external view returns (address);\n    function getContract(string calldata name) external view returns (address);\n}"
             },
+            "@skalenetwork/skale-manager-interfaces/INodes.sol": {
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    INodes.sol - SKALE Manager\n    Copyright (C) 2018-Present SKALE Labs\n    @author Artem Payvin\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"./utils/IRandom.sol\";\n\ninterface INodes {\n    // All Nodes states\n    enum NodeStatus {Active, Leaving, Left, In_Maintenance}\n\n    struct Node {\n        string name;\n        bytes4 ip;\n        bytes4 publicIP;\n        uint16 port;\n        bytes32[2] publicKey;\n        uint startBlock;\n        uint lastRewardDate;\n        uint finishTime;\n        NodeStatus status;\n        uint validatorId;\n    }\n\n    // struct to note which Nodes and which number of Nodes owned by user\n    struct CreatedNodes {\n        mapping (uint => bool) isNodeExist;\n        uint numberOfNodes;\n    }\n\n    struct SpaceManaging {\n        uint8 freeSpace;\n        uint indexInSpaceMap;\n    }\n\n    struct NodeCreationParams {\n        string name;\n        bytes4 ip;\n        bytes4 publicIp;\n        uint16 port;\n        bytes32[2] publicKey;\n        uint16 nonce;\n        string domainName;\n    }\n    \n    /**\n     * @dev Emitted when a node is created.\n     */\n    event NodeCreated(\n        uint nodeIndex,\n        address owner,\n        string name,\n        bytes4 ip,\n        bytes4 publicIP,\n        uint16 port,\n        uint16 nonce,\n        string domainName\n    );\n\n    /**\n     * @dev Emitted when a node completes a network exit.\n     */\n    event ExitCompleted(\n        uint nodeIndex\n    );\n\n    /**\n     * @dev Emitted when a node begins to exit from the network.\n     */\n    event ExitInitialized(\n        uint nodeIndex,\n        uint startLeavingPeriod\n    );\n\n    /**\n     * @dev Emitted when a node set to in compliant or compliant.\n     */\n    event IncompliantNode(\n        uint indexed nodeIndex,\n        bool status\n    );\n\n    /**\n     * @dev Emitted when a node set to in maintenance or from in maintenance.\n     */\n    event MaintenanceNode(\n        uint indexed nodeIndex,\n        bool status\n    );\n\n    /**\n     * @dev Emitted when a node status changed.\n     */\n    event IPChanged(\n        uint indexed nodeIndex,\n        bytes4 previousIP,\n        bytes4 newIP\n    );\n    \n    function removeSpaceFromNode(uint nodeIndex, uint8 space) external returns (bool);\n    function addSpaceToNode(uint nodeIndex, uint8 space) external;\n    function changeNodeLastRewardDate(uint nodeIndex) external;\n    function changeNodeFinishTime(uint nodeIndex, uint time) external;\n    function createNode(address from, NodeCreationParams calldata params) external;\n    function initExit(uint nodeIndex) external;\n    function completeExit(uint nodeIndex) external returns (bool);\n    function deleteNodeForValidator(uint validatorId, uint nodeIndex) external;\n    function checkPossibilityCreatingNode(address nodeAddress) external;\n    function checkPossibilityToMaintainNode(uint validatorId, uint nodeIndex) external returns (bool);\n    function setNodeInMaintenance(uint nodeIndex) external;\n    function removeNodeFromInMaintenance(uint nodeIndex) external;\n    function setNodeIncompliant(uint nodeIndex) external;\n    function setNodeCompliant(uint nodeIndex) external;\n    function setDomainName(uint nodeIndex, string memory domainName) external;\n    function makeNodeVisible(uint nodeIndex) external;\n    function makeNodeInvisible(uint nodeIndex) external;\n    function changeIP(uint nodeIndex, bytes4 newIP, bytes4 newPublicIP) external;\n    function numberOfActiveNodes() external view returns (uint);\n    function incompliant(uint nodeIndex) external view returns (bool);\n    function getRandomNodeWithFreeSpace(\n        uint8 freeSpace,\n        IRandom.RandomGenerator memory randomGenerator\n    )\n        external\n        view\n        returns (uint);\n    function isTimeForReward(uint nodeIndex) external view returns (bool);\n    function getNodeIP(uint nodeIndex) external view returns (bytes4);\n    function getNodeDomainName(uint nodeIndex) external view returns (string memory);\n    function getNodePort(uint nodeIndex) external view returns (uint16);\n    function getNodePublicKey(uint nodeIndex) external view returns (bytes32[2] memory);\n    function getNodeAddress(uint nodeIndex) external view returns (address);\n    function getNodeFinishTime(uint nodeIndex) external view returns (uint);\n    function isNodeLeft(uint nodeIndex) external view returns (bool);\n    function isNodeInMaintenance(uint nodeIndex) external view returns (bool);\n    function getNodeLastRewardDate(uint nodeIndex) external view returns (uint);\n    function getNodeNextRewardDate(uint nodeIndex) external view returns (uint);\n    function getNumberOfNodes() external view returns (uint);\n    function getNumberOnlineNodes() external view returns (uint);\n    function getActiveNodeIds() external view returns (uint[] memory activeNodeIds);\n    function getNodeStatus(uint nodeIndex) external view returns (NodeStatus);\n    function getValidatorNodeIndexes(uint validatorId) external view returns (uint[] memory);\n    function countNodesWithFreeSpace(uint8 freeSpace) external view returns (uint count);\n    function getValidatorId(uint nodeIndex) external view returns (uint);\n    function isNodeExist(address from, uint nodeIndex) external view returns (bool);\n    function isNodeActive(uint nodeIndex) external view returns (bool);\n    function isNodeLeaving(uint nodeIndex) external view returns (bool);\n}\n"
+            },
             "@skalenetwork/skale-manager-interfaces/ISchains.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchains.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchains {\n\n    struct SchainOption {\n        string name;\n        bytes value;\n    }\n    \n    /**\n     * @dev Emitted when an schain is created.\n     */\n    event SchainCreated(\n        string name,\n        address owner,\n        uint partOfNode,\n        uint lifetime,\n        uint numberOfNodes,\n        uint deposit,\n        uint16 nonce,\n        bytes32 schainHash\n    );\n\n    /**\n     * @dev Emitted when an schain is deleted.\n     */\n    event SchainDeleted(\n        address owner,\n        string name,\n        bytes32 indexed schainHash\n    );\n\n    /**\n     * @dev Emitted when a node in an schain is rotated.\n     */\n    event NodeRotated(\n        bytes32 schainHash,\n        uint oldNode,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a node is added to an schain.\n     */\n    event NodeAdded(\n        bytes32 schainHash,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a group of nodes is created for an schain.\n     */\n    event SchainNodes(\n        string name,\n        bytes32 schainHash,\n        uint[] nodesInGroup\n    );\n\n    function addSchain(address from, uint deposit, bytes calldata data) external;\n    function addSchainByFoundation(\n        uint lifetime,\n        uint8 typeOfSchain,\n        uint16 nonce,\n        string calldata name,\n        address schainOwner,\n        address schainOriginator,\n        SchainOption[] calldata options\n    )\n        external\n        payable;\n    function deleteSchain(address from, string calldata name) external;\n    function deleteSchainByRoot(string calldata name) external;\n    function restartSchainCreation(string calldata name) external;\n    function verifySchainSignature(\n        uint256 signA,\n        uint256 signB,\n        bytes32 hash,\n        uint256 counter,\n        uint256 hashA,\n        uint256 hashB,\n        string calldata schainName\n    )\n        external\n        view\n        returns (bool);\n    function getSchainPrice(uint typeOfSchain, uint lifetime) external view returns (uint);\n    function getOption(bytes32 schainHash, string calldata optionName) external view returns (bytes memory);\n    function getOptions(bytes32 schainHash) external view returns (SchainOption[] memory);\n}"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchains.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchains {\n\n    struct SchainOption {\n        string name;\n        bytes value;\n    }\n    \n    /**\n     * @dev Emitted when an schain is created.\n     */\n    event SchainCreated(\n        string name,\n        address owner,\n        uint partOfNode,\n        uint lifetime,\n        uint numberOfNodes,\n        uint deposit,\n        uint16 nonce,\n        bytes32 schainHash\n    );\n\n    /**\n     * @dev Emitted when an schain is deleted.\n     */\n    event SchainDeleted(\n        address owner,\n        string name,\n        bytes32 indexed schainHash\n    );\n\n    /**\n     * @dev Emitted when a node in an schain is rotated.\n     */\n    event NodeRotated(\n        bytes32 schainHash,\n        uint oldNode,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a node is added to an schain.\n     */\n    event NodeAdded(\n        bytes32 schainHash,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a group of nodes is created for an schain.\n     */\n    event SchainNodes(\n        string name,\n        bytes32 schainHash,\n        uint[] nodesInGroup\n    );\n\n    function addSchain(address from, uint deposit, bytes calldata data) external;\n    function addSchainByFoundation(\n        uint lifetime,\n        uint8 typeOfSchain,\n        uint16 nonce,\n        string calldata name,\n        address schainOwner,\n        address schainOriginator,\n        SchainOption[] calldata options\n    )\n        external\n        payable;\n    function deleteSchain(address from, string calldata name) external;\n    function deleteSchainByRoot(string calldata name) external;\n    function restartSchainCreation(string calldata name) external;\n    function verifySchainSignature(\n        uint256 signA,\n        uint256 signB,\n        bytes32 hash,\n        uint256 counter,\n        uint256 hashA,\n        uint256 hashB,\n        string calldata schainName\n    )\n        external\n        view\n        returns (bool);\n    function getSchainPrice(uint typeOfSchain, uint lifetime) external view returns (uint);\n    function getOption(bytes32 schainHash, string calldata optionName) external view returns (bytes memory);\n    function getOptions(bytes32 schainHash) external view returns (SchainOption[] memory);\n}\n"
             },
             "@skalenetwork/skale-manager-interfaces/ISchainsInternal.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchainsInternal - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchainsInternal {\n    struct Schain {\n        string name;\n        address owner;\n        uint indexInOwnerList;\n        uint8 partOfNode;\n        uint lifetime;\n        uint startDate;\n        uint startBlock;\n        uint deposit;\n        uint64 index;\n        uint generation;\n        address originator;\n    }\n\n    struct SchainType {\n        uint8 partOfNode;\n        uint numberOfNodes;\n    }\n\n    /**\n     * @dev Emitted when schain type added.\n     */\n    event SchainTypeAdded(uint indexed schainType, uint partOfNode, uint numberOfNodes);\n\n    /**\n     * @dev Emitted when schain type removed.\n     */\n    event SchainTypeRemoved(uint indexed schainType);\n\n    function initializeSchain(\n        string calldata name,\n        address from,\n        address originator,\n        uint lifetime,\n        uint deposit) external;\n    function createGroupForSchain(\n        bytes32 schainHash,\n        uint numberOfNodes,\n        uint8 partOfNode\n    )\n        external\n        returns (uint[] memory);\n    function changeLifetime(bytes32 schainHash, uint lifetime, uint deposit) external;\n    function removeSchain(bytes32 schainHash, address from) external;\n    function removeNodeFromSchain(uint nodeIndex, bytes32 schainHash) external;\n    function deleteGroup(bytes32 schainHash) external;\n    function setException(bytes32 schainHash, uint nodeIndex) external;\n    function setNodeInGroup(bytes32 schainHash, uint nodeIndex) external;\n    function removeHolesForSchain(bytes32 schainHash) external;\n    function addSchainType(uint8 partOfNode, uint numberOfNodes) external;\n    function removeSchainType(uint typeOfSchain) external;\n    function setNumberOfSchainTypes(uint newNumberOfSchainTypes) external;\n    function removeNodeFromAllExceptionSchains(uint nodeIndex) external;\n    function removeAllNodesFromSchainExceptions(bytes32 schainHash) external;\n    function makeSchainNodesInvisible(bytes32 schainHash) external;\n    function makeSchainNodesVisible(bytes32 schainHash) external;\n    function newGeneration() external;\n    function addSchainForNode(uint nodeIndex, bytes32 schainHash) external;\n    function removeSchainForNode(uint nodeIndex, uint schainIndex) external;\n    function removeNodeFromExceptions(bytes32 schainHash, uint nodeIndex) external;\n    function isSchainActive(bytes32 schainHash) external view returns (bool);\n    function schainsAtSystem(uint index) external view returns (bytes32);\n    function numberOfSchains() external view returns (uint64);\n    function getSchains() external view returns (bytes32[] memory);\n    function getSchainsPartOfNode(bytes32 schainHash) external view returns (uint8);\n    function getSchainListSize(address from) external view returns (uint);\n    function getSchainHashesByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainIdsByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainHashesForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainIdsForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainOwner(bytes32 schainHash) external view returns (address);\n    function getSchainOriginator(bytes32 schainHash) external view returns (address);\n    function isSchainNameAvailable(string calldata name) external view returns (bool);\n    function isTimeExpired(bytes32 schainHash) external view returns (bool);\n    function isOwnerAddress(address from, bytes32 schainId) external view returns (bool);\n    function getSchainName(bytes32 schainHash) external view returns (string memory);\n    function getActiveSchain(uint nodeIndex) external view returns (bytes32);\n    function getActiveSchains(uint nodeIndex) external view returns (bytes32[] memory activeSchains);\n    function getNumberOfNodesInGroup(bytes32 schainHash) external view returns (uint);\n    function getNodesInGroup(bytes32 schainHash) external view returns (uint[] memory);\n    function isNodeAddressesInGroup(bytes32 schainId, address sender) external view returns (bool);\n    function getNodeIndexInGroup(bytes32 schainHash, uint nodeId) external view returns (uint);\n    function isAnyFreeNode(bytes32 schainHash) external view returns (bool);\n    function checkException(bytes32 schainHash, uint nodeIndex) external view returns (bool);\n    function checkHoleForSchain(bytes32 schainHash, uint indexOfNode) external view returns (bool);\n    function checkSchainOnNode(uint nodeIndex, bytes32 schainHash) external view returns (bool);\n    function getSchainType(uint typeOfSchain) external view returns(uint8, uint);\n    function getGeneration(bytes32 schainHash) external view returns (uint);\n    function isSchainExist(bytes32 schainHash) external view returns (bool);\n}"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchainsInternal - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"./INodes.sol\";\n\ninterface ISchainsInternal {\n    struct Schain {\n        string name;\n        address owner;\n        uint indexInOwnerList;\n        uint8 partOfNode;\n        uint lifetime;\n        uint startDate;\n        uint startBlock;\n        uint deposit;\n        uint64 index;\n        uint generation;\n        address originator;\n    }\n\n    struct SchainType {\n        uint8 partOfNode;\n        uint numberOfNodes;\n    }\n\n    /**\n     * @dev Emitted when schain type added.\n     */\n    event SchainTypeAdded(uint indexed schainType, uint partOfNode, uint numberOfNodes);\n\n    /**\n     * @dev Emitted when schain type removed.\n     */\n    event SchainTypeRemoved(uint indexed schainType);\n\n    function initializeSchain(\n        string calldata name,\n        address from,\n        address originator,\n        uint lifetime,\n        uint deposit) external;\n    function createGroupForSchain(\n        bytes32 schainHash,\n        uint numberOfNodes,\n        uint8 partOfNode\n    )\n        external\n        returns (uint[] memory);\n    function changeLifetime(bytes32 schainHash, uint lifetime, uint deposit) external;\n    function removeSchain(bytes32 schainHash, address from) external;\n    function removeNodeFromSchain(uint nodeIndex, bytes32 schainHash) external;\n    function deleteGroup(bytes32 schainHash) external;\n    function setException(bytes32 schainHash, uint nodeIndex) external;\n    function setNodeInGroup(bytes32 schainHash, uint nodeIndex) external;\n    function removeHolesForSchain(bytes32 schainHash) external;\n    function addSchainType(uint8 partOfNode, uint numberOfNodes) external;\n    function removeSchainType(uint typeOfSchain) external;\n    function setNumberOfSchainTypes(uint newNumberOfSchainTypes) external;\n    function removeNodeFromAllExceptionSchains(uint nodeIndex) external;\n    function removeAllNodesFromSchainExceptions(bytes32 schainHash) external;\n    function makeSchainNodesInvisible(bytes32 schainHash) external;\n    function makeSchainNodesVisible(bytes32 schainHash) external;\n    function newGeneration() external;\n    function addSchainForNode(INodes nodes,uint nodeIndex, bytes32 schainHash) external;\n    function removeSchainForNode(uint nodeIndex, uint schainIndex) external;\n    function removeNodeFromExceptions(bytes32 schainHash, uint nodeIndex) external;\n    function isSchainActive(bytes32 schainHash) external view returns (bool);\n    function schainsAtSystem(uint index) external view returns (bytes32);\n    function numberOfSchains() external view returns (uint64);\n    function getSchains() external view returns (bytes32[] memory);\n    function getSchainsPartOfNode(bytes32 schainHash) external view returns (uint8);\n    function getSchainListSize(address from) external view returns (uint);\n    function getSchainHashesByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainHashesForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainOwner(bytes32 schainHash) external view returns (address);\n    function getSchainOriginator(bytes32 schainHash) external view returns (address);\n    function isSchainNameAvailable(string calldata name) external view returns (bool);\n    function isTimeExpired(bytes32 schainHash) external view returns (bool);\n    function isOwnerAddress(address from, bytes32 schainHash) external view returns (bool);\n    function getSchainName(bytes32 schainHash) external view returns (string memory);\n    function getActiveSchain(uint nodeIndex) external view returns (bytes32);\n    function getActiveSchains(uint nodeIndex) external view returns (bytes32[] memory activeSchains);\n    function getNumberOfNodesInGroup(bytes32 schainHash) external view returns (uint);\n    function getNodesInGroup(bytes32 schainHash) external view returns (uint[] memory);\n    function isNodeAddressesInGroup(bytes32 schainHash, address sender) external view returns (bool);\n    function getNodeIndexInGroup(bytes32 schainHash, uint nodeHash) external view returns (uint);\n    function isAnyFreeNode(bytes32 schainHash) external view returns (bool);\n    function checkException(bytes32 schainHash, uint nodeIndex) external view returns (bool);\n    function checkHoleForSchain(bytes32 schainHash, uint indexOfNode) external view returns (bool);\n    function checkSchainOnNode(uint nodeIndex, bytes32 schainHash) external view returns (bool);\n    function getSchainType(uint typeOfSchain) external view returns(uint8, uint);\n    function getGeneration(bytes32 schainHash) external view returns (uint);\n    function isSchainExist(bytes32 schainHash) external view returns (bool);\n}"
             },
             "@skalenetwork/skale-manager-interfaces/IWallets.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IWallets - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IWallets {\n    /**\n     * @dev Emitted when the validator wallet was funded\n     */\n    event ValidatorWalletRecharged(address sponsor, uint amount, uint validatorId);\n\n    /**\n     * @dev Emitted when the schain wallet was funded\n     */\n    event SchainWalletRecharged(address sponsor, uint amount, bytes32 schainHash);\n\n    /**\n     * @dev Emitted when the node received a refund from validator to its wallet\n     */\n    event NodeRefundedByValidator(address node, uint validatorId, uint amount);\n\n    /**\n     * @dev Emitted when the node received a refund from schain to its wallet\n     */\n    event NodeRefundedBySchain(address node, bytes32 schainHash, uint amount);\n\n    /**\n     * @dev Emitted when the validator withdrawn funds from validator wallet\n     */\n    event WithdrawFromValidatorWallet(uint indexed validatorId, uint amount);\n\n    /**\n     * @dev Emitted when the schain owner withdrawn funds from schain wallet\n     */\n    event WithdrawFromSchainWallet(bytes32 indexed schainHash, uint amount);\n\n    receive() external payable;\n    function refundGasByValidator(uint validatorId, address payable spender, uint spentGas) external;\n    function refundGasByValidatorToSchain(uint validatorId, bytes32 schainHash) external;\n    function refundGasBySchain(bytes32 schainId, address payable spender, uint spentGas, bool isDebt) external;\n    function withdrawFundsFromSchainWallet(address payable schainOwner, bytes32 schainHash) external;\n    function withdrawFundsFromValidatorWallet(uint amount) external;\n    function rechargeValidatorWallet(uint validatorId) external payable;\n    function rechargeSchainWallet(bytes32 schainId) external payable;\n    function getSchainBalance(bytes32 schainHash) external view returns (uint);\n    function getValidatorBalance(uint validatorId) external view returns (uint);\n}\n"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IWallets - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IWallets {\n    receive() external payable;\n    function refundGasByValidator(uint validatorId, address payable spender, uint gasLimit) external;\n    function refundGasByValidatorToSchain(uint validatorId, bytes32 schainHash) external;\n    function refundGasBySchain(bytes32 schainId, address payable spender, uint spentGas, bool isDebt) external;\n    function withdrawFundsFromSchainWallet(address payable schainOwner, bytes32 schainHash) external;\n    function withdrawFundsFromValidatorWallet(uint amount) external;\n    function rechargeValidatorWallet(uint validatorId) external payable;\n    function rechargeSchainWallet(bytes32 schainId) external payable;\n    function getSchainBalance(bytes32 schainHash) external view returns (uint);\n    function getValidatorBalance(uint validatorId) external view returns (uint);\n}\n"
+            },
+            "@skalenetwork/skale-manager-interfaces/utils/IRandom.sol": {
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IRandom.sol - SKALE Manager Interfaces\n    Copyright (C) 2022-Present SKALE Labs\n    @author Dmytro Stebaiev\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\n\ninterface IRandom {\n    struct RandomGenerator {\n        uint seed;\n    }\n}"
             },
             "contracts/MessageProxy.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   MessageProxy.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/IGasReimbursable.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageProxy.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageReceiver.sol\";\n\n\n/**\n * @title MessageProxy\n * @dev Abstract contract for MessageProxyForMainnet and MessageProxyForSchain.\n */\nabstract contract MessageProxy is AccessControlEnumerableUpgradeable, IMessageProxy {\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    /**\n     * @dev Structure that stores counters for outgoing and incoming messages.\n     */\n    struct ConnectedChainInfo {\n        // message counters start with 0\n        uint256 incomingMessageCounter;\n        uint256 outgoingMessageCounter;\n        bool inited;\n        uint256 lastOutgoingMessageBlockId;\n    }\n\n    bytes32 public constant MAINNET_HASH = keccak256(abi.encodePacked(\"Mainnet\"));\n    bytes32 public constant CHAIN_CONNECTOR_ROLE = keccak256(\"CHAIN_CONNECTOR_ROLE\");\n    bytes32 public constant EXTRA_CONTRACT_REGISTRAR_ROLE = keccak256(\"EXTRA_CONTRACT_REGISTRAR_ROLE\");\n    bytes32 public constant CONSTANT_SETTER_ROLE = keccak256(\"CONSTANT_SETTER_ROLE\");\n    uint256 public constant MESSAGES_LENGTH = 10;\n    uint256 public constant REVERT_REASON_LENGTH = 64;\n\n    //   schainHash => ConnectedChainInfo\n    mapping(bytes32 => ConnectedChainInfo) public connectedChains;\n    //   schainHash => contract address => allowed\n    mapping(bytes32 => mapping(address => bool)) private _deprecatedRegistryContracts;\n\n    uint256 public gasLimit;\n\n    /**\n     * @dev Emitted for every outgoing message to schain.\n     */\n    event OutgoingMessage(\n        bytes32 indexed dstChainHash,\n        uint256 indexed msgCounter,\n        address indexed srcContract,\n        address dstContract,\n        bytes data\n    );\n\n    /**\n     * @dev Emitted when function `postMessage` returns revert.\n     *  Used to prevent stuck loop inside function `postIncomingMessages`.\n     */\n    event PostMessageError(\n        uint256 indexed msgCounter,\n        bytes message\n    );\n\n    /**\n     * @dev Emitted when gas limit per one call of `postMessage` was changed.\n     */\n    event GasLimitWasChanged(\n        uint256 oldValue,\n        uint256 newValue\n    );\n\n    /**\n     * @dev Emitted when the version was updated\n     */\n    event VersionUpdated(string oldVersion, string newVersion);\n\n    /**\n     * @dev Emitted when extra contract was added.\n     */\n    event ExtraContractRegistered(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Emitted when extra contract was removed.\n     */\n    event ExtraContractRemoved(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Emitted when referenced to previous outgoing message.\n     */\n    event PreviousMessageReference (\n        uint256 currentMessage,\n        uint256 previousOutgoingMessageBlockId\n    );\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CHAIN_CONNECTOR_ROLE}.\n     */\n    modifier onlyChainConnector() {\n        require(hasRole(CHAIN_CONNECTOR_ROLE, msg.sender), \"CHAIN_CONNECTOR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {EXTRA_CONTRACT_REGISTRAR_ROLE}.\n     */\n    modifier onlyExtraContractRegistrar() {\n        require(hasRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender), \"EXTRA_CONTRACT_REGISTRAR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CONSTANT_SETTER_ROLE}.\n     */\n    modifier onlyConstantSetter() {\n        require(hasRole(CONSTANT_SETTER_ROLE, msg.sender), \"Not enough permissions to set constant\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {DEFAULT_ADMIN_ROLE}.\n     */\n    modifier onlyOwner() {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"DEFAULT_ADMIN_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Sets gasLimit to a new value.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CONSTANT_SETTER_ROLE.\n     */\n    function setNewGasLimit(uint256 newGasLimit) external override onlyConstantSetter {\n        emit GasLimitWasChanged(gasLimit, newGasLimit);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Virtual function for `postIncomingMessages`.\n     */\n    function postIncomingMessages(\n        string calldata fromSchainName,\n        uint256 startingCounter,\n        Message[] calldata messages,\n        Signature calldata sign\n    )\n        external\n        virtual\n        override;\n\n    /**\n     * @dev Allows `msg.sender` to register extra contract for all schains\n     * for being able to transfer messages from custom contracts.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     * - Passed address should be contract.\n     * - Extra contract must not be registered.\n     */\n    function registerExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is already registered\");\n        _getRegistryContracts()[bytes32(0)].add(extraContract);\n        emit ExtraContractRegistered(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Allows `msg.sender` to remove extra contract for all schains.\n     * Extra contract will no longer be able to send messages through MessageProxy.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     */\n    function removeExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[bytes32(0)].remove(extraContract);\n        emit ExtraContractRemoved(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Should return length of contract registered by schainHash.\n     */\n    function getContractRegisteredLength(bytes32 schainHash) external view override returns (uint256) {\n        return _getRegistryContracts()[schainHash].length();\n    }\n\n    /**\n     * @dev Should return a range of contracts registered by schainHash.\n     *\n     * Requirements:\n     * range should be less or equal 10 contracts\n     */\n    function getContractRegisteredRange(\n        bytes32 schainHash,\n        uint256 from,\n        uint256 to\n    )\n        external\n        view\n        override\n        returns (address[] memory contractsInRange)\n    {\n        require(\n            from < to && to - from <= 10 && to <= _getRegistryContracts()[schainHash].length(),\n            \"Range is incorrect\"\n        );\n        contractsInRange = new address[](to - from);\n        for (uint256 i = from; i < to; i++) {\n            contractsInRange[i - from] = _getRegistryContracts()[schainHash].at(i);\n        }\n    }\n\n    /**\n     * @dev Returns number of outgoing messages.\n     *\n     * Requirements:\n     *\n     * - Target schain  must be initialized.\n     */\n    function getOutgoingMessagesCounter(string calldata targetSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 dstChainHash = keccak256(abi.encodePacked(targetSchainName));\n        require(connectedChains[dstChainHash].inited, \"Destination chain is not initialized\");\n        return connectedChains[dstChainHash].outgoingMessageCounter;\n    }\n\n\n    /**\n     * @dev Should return block number of the last message transferred to schain\n     */\n    function getLastOutgoingMessageBlockId(string memory targetSchainName) external view override returns (uint) {\n        bytes32 dstChainHash = keccak256(abi.encodePacked(targetSchainName));\n        require(connectedChains[dstChainHash].inited, \"Destination chain is not initialized\");\n        return connectedChains[dstChainHash].lastOutgoingMessageBlockId;\n    }\n\n    /**\n     * @dev Returns number of incoming messages.\n     *\n     * Requirements:\n     *\n     * - Source schain must be initialized.\n     */\n    function getIncomingMessagesCounter(string calldata fromSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 srcChainHash = keccak256(abi.encodePacked(fromSchainName));\n        require(connectedChains[srcChainHash].inited, \"Source chain is not initialized\");\n        return connectedChains[srcChainHash].incomingMessageCounter;\n    }\n\n    function initializeMessageProxy(uint newGasLimit) public initializer {\n        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(CHAIN_CONNECTOR_ROLE, msg.sender);\n        _setupRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender);\n        _setupRole(CONSTANT_SETTER_ROLE, msg.sender);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Posts message from this contract to `targetChainHash` MessageProxy contract.\n     * This is called by a smart contract to make a cross-chain call.\n     *\n     * Emits an {OutgoingMessage} event.\n     *\n     * Requirements:\n     *\n     * - Target chain must be initialized.\n     * - Target chain must be registered as external contract.\n     */\n    function postOutgoingMessage(\n        bytes32 targetChainHash,\n        address targetContract,\n        bytes memory data\n    )\n        public\n        override\n        virtual\n    {\n        require(connectedChains[targetChainHash].inited, \"Destination chain is not initialized\");\n        _authorizeOutgoingMessageSender(targetChainHash);\n\n        uint outgoingMessageCounter = connectedChains[targetChainHash].outgoingMessageCounter;\n        emit OutgoingMessage(\n            targetChainHash,\n            outgoingMessageCounter,\n            msg.sender,\n            targetContract,\n            data\n        );\n        emit PreviousMessageReference(\n            outgoingMessageCounter,\n            connectedChains[targetChainHash].lastOutgoingMessageBlockId\n        );\n        connectedChains[targetChainHash].outgoingMessageCounter++;\n        connectedChains[targetChainHash].lastOutgoingMessageBlockId = block.number;\n    }\n\n    /**\n     * @dev Allows CHAIN_CONNECTOR_ROLE to remove connected chain from this contract.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CHAIN_CONNECTOR_ROLE.\n     * - `schainName` must be initialized.\n     */\n    function removeConnectedChain(string memory schainName) public virtual override onlyChainConnector {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(connectedChains[schainHash].inited, \"Chain is not initialized\");\n        delete connectedChains[schainHash];\n    }\n\n    /**\n     * @dev Checks whether chain is currently connected.\n     */\n    function isConnectedChain(\n        string memory schainName\n    )\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return connectedChains[keccak256(abi.encodePacked(schainName))].inited;\n    }\n\n    /**\n     * @dev Checks whether contract is currently registered as extra contract.\n     */\n    function isContractRegistered(\n        bytes32 schainHash,\n        address contractAddress\n    )\n        public\n        view\n        override\n        returns (bool)\n    {\n        return _getRegistryContracts()[schainHash].contains(contractAddress);\n    }\n\n    /**\n     * @dev Allows MessageProxy to register extra contract for being able to transfer messages from custom contracts.\n     *\n     * Requirements:\n     *\n     * - Extra contract address must be contract.\n     * - Extra contract must not be registered.\n     * - Extra contract must not be registered for all chains.\n     */\n    function _registerExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {\n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is already registered\");\n        require(\n            !_getRegistryContracts()[bytes32(0)].contains(extraContract),\n            \"Extra contract is already registered for all chains\"\n        );\n\n        _getRegistryContracts()[chainHash].add(extraContract);\n        emit ExtraContractRegistered(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to remove extra contract,\n     * thus `extraContract` will no longer be available to transfer messages from mainnet to schain.\n     *\n     * Requirements:\n     *\n     * - Extra contract must be registered.\n     */\n    function _removeExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {\n        require(_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[chainHash].remove(extraContract);\n        emit ExtraContractRemoved(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to connect schain with MessageProxyOnMainnet for transferring messages.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CHAIN_CONNECTOR_ROLE.\n     * - SKALE chain must not be connected.\n     */\n    function _addConnectedChain(bytes32 schainHash) internal onlyChainConnector {\n        require(!connectedChains[schainHash].inited,\"Chain is already connected\");\n        connectedChains[schainHash] = ConnectedChainInfo({\n            incomingMessageCounter: 0,\n            outgoingMessageCounter: 0,\n            inited: true,\n            lastOutgoingMessageBlockId: 0\n        });\n    }\n\n    /**\n     * @dev Allows MessageProxy to send messages from schain to mainnet.\n     * Destination contract must implement `postMessage` method.\n     */\n    function _callReceiverContract(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n    {\n        if (!message.destinationContract.isContract()) {\n            emit PostMessageError(\n                counter,\n                \"Destination contract is not a contract\"\n            );\n            return;\n        }\n        try IMessageReceiver(message.destinationContract).postMessage{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) {\n            return;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                _getSlice(bytes(reason), REVERT_REASON_LENGTH)\n            );\n        } catch Panic(uint errorCode) {\n               emit PostMessageError(\n                counter,\n                abi.encodePacked(errorCode)\n            );\n        } catch (bytes memory revertData) {\n            emit PostMessageError(\n                counter,\n                _getSlice(revertData, REVERT_REASON_LENGTH)\n            );\n        }\n    }\n\n    /**\n     * @dev Returns receiver of message.\n     */\n    function _getGasPayer(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n        returns (address)\n    {\n        try IGasReimbursable(message.destinationContract).gasPayer{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) returns (address receiver) {\n            return receiver;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                _getSlice(bytes(reason), REVERT_REASON_LENGTH)\n            );\n            return address(0);\n        } catch Panic(uint errorCode) {\n               emit PostMessageError(\n                counter,\n                abi.encodePacked(errorCode)\n            );\n            return address(0);\n        } catch (bytes memory revertData) {\n            emit PostMessageError(\n                counter,\n                _getSlice(revertData, REVERT_REASON_LENGTH)\n            );\n            return address(0);\n        }\n    }\n\n    /**\n     * @dev Checks whether msg.sender is registered as custom extra contract.\n     */\n    function _authorizeOutgoingMessageSender(bytes32 targetChainHash) internal view virtual {\n        require(\n            isContractRegistered(bytes32(0), msg.sender) || isContractRegistered(targetChainHash, msg.sender),\n            \"Sender contract is not registered\"\n        );\n    }\n\n    /**\n     * @dev Returns list of registered custom extra contracts.\n     */\n    function _getRegistryContracts()\n        internal\n        view\n        virtual\n        returns (mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) storage);\n\n    /**\n     * @dev Returns hash of message array.\n     */\n    function _hashedArray(\n        Message[] calldata messages,\n        uint256 startingCounter,\n        string calldata fromChainName\n    )\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32 sourceHash = keccak256(abi.encodePacked(fromChainName));\n        bytes32 hash = keccak256(abi.encodePacked(sourceHash, bytes32(startingCounter)));\n        for (uint256 i = 0; i < messages.length; i++) {\n            hash = keccak256(\n                abi.encodePacked(\n                    abi.encode(\n                        hash,\n                        messages[i].sender,\n                        messages[i].destinationContract\n                    ),\n                    messages[i].data\n                )\n            );\n        }\n        return hash;\n    }\n\n    function _getSlice(bytes memory text, uint end) private pure returns (bytes memory) {\n        uint slicedEnd = end < text.length ? end : text.length;\n        bytes memory sliced = new bytes(slicedEnd);\n        for(uint i = 0; i < slicedEnd; i++){\n            sliced[i] = text[i];\n        }\n        return sliced;\n    }\n}\n"
             },
             "contracts/Messages.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   Messages.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\n\n/**\n * @title Messages\n * @dev Library for encoding and decoding messages\n * for transferring from Mainnet to Schain and vice versa.\n */\nlibrary Messages {\n\n    /**\n     * @dev Enumerator that describes all supported message types.\n     */\n    enum MessageType {\n        EMPTY,\n        TRANSFER_ETH,\n        TRANSFER_ERC20,\n        TRANSFER_ERC20_AND_TOTAL_SUPPLY,\n        TRANSFER_ERC20_AND_TOKEN_INFO,\n        TRANSFER_ERC721,\n        TRANSFER_ERC721_AND_TOKEN_INFO,\n        USER_STATUS,\n        INTERCHAIN_CONNECTION,\n        TRANSFER_ERC1155,\n        TRANSFER_ERC1155_AND_TOKEN_INFO,\n        TRANSFER_ERC1155_BATCH,\n        TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO,\n        TRANSFER_ERC721_WITH_METADATA,\n        TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO\n    }\n\n    /**\n     * @dev Structure for base message.\n     */\n    struct BaseMessage {\n        MessageType messageType;\n    }\n\n    /**\n     * @dev Structure for describing ETH.\n     */\n    struct TransferEthMessage {\n        BaseMessage message;\n        address receiver;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for user status.\n     */\n    struct UserStatusMessage {\n        BaseMessage message;\n        address receiver;\n        bool isActive;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 token.\n     */\n    struct TransferErc20Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC20 token.\n     */\n    struct Erc20TokenInfo {\n        string name;\n        uint8 decimals;\n        string symbol;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token supply.\n     */\n    struct TransferErc20AndTotalSupplyMessage {\n        TransferErc20Message baseErc20transfer;\n        uint256 totalSupply;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token info.\n     */\n    struct TransferErc20AndTokenInfoMessage {\n        TransferErc20Message baseErc20transfer;\n        uint256 totalSupply;\n        Erc20TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing base ERC721.\n     */\n    struct TransferErc721Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 tokenId;\n    }\n\n    /**\n     * @dev Structure for describing base ERC721 with metadata.\n     */\n    struct TransferErc721MessageWithMetadata {\n        TransferErc721Message erc721message;\n        string tokenURI;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token info.\n     */\n    struct Erc721TokenInfo {\n        string name;\n        string symbol;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC721 token.\n     */\n    struct TransferErc721AndTokenInfoMessage {\n        TransferErc721Message baseErc721transfer;\n        Erc721TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC721 token with metadata.\n     */\n    struct TransferErc721WithMetadataAndTokenInfoMessage {\n        TransferErc721MessageWithMetadata baseErc721transferWithMetadata;\n        Erc721TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing whether interchain connection is allowed.\n     */\n    struct InterchainConnectionMessage {\n        BaseMessage message;\n        bool isAllowed;\n    }\n\n    /**\n     * @dev Structure for describing whether interchain connection is allowed.\n     */\n    struct TransferErc1155Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 id;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for describing ERC1155 token in batches.\n     */\n    struct TransferErc1155BatchMessage {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256[] ids;\n        uint256[] amounts;\n    }\n\n    /**\n     * @dev Structure for describing ERC1155 token info.\n     */\n    struct Erc1155TokenInfo {\n        string uri;\n    }\n\n    /**\n     * @dev Structure for describing message for transferring ERC1155 token with info.\n     */\n    struct TransferErc1155AndTokenInfoMessage {\n        TransferErc1155Message baseErc1155transfer;\n        Erc1155TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing message for transferring ERC1155 token in batches with info.\n     */\n    struct TransferErc1155BatchAndTokenInfoMessage {\n        TransferErc1155BatchMessage baseErc1155Batchtransfer;\n        Erc1155TokenInfo tokenInfo;\n    }\n\n\n    /**\n     * @dev Returns type of message for encoded data.\n     */\n    function getMessageType(bytes calldata data) internal pure returns (MessageType) {\n        uint256 firstWord = abi.decode(data, (uint256));\n        if (firstWord % 32 == 0) {\n            return getMessageType(data[firstWord:]);\n        } else {\n            return abi.decode(data, (Messages.MessageType));\n        }\n    }\n\n    /**\n     * @dev Encodes message for transferring ETH. Returns encoded message.\n     */\n    function encodeTransferEthMessage(address receiver, uint256 amount) internal pure returns (bytes memory) {\n        TransferEthMessage memory message = TransferEthMessage(\n            BaseMessage(MessageType.TRANSFER_ETH),\n            receiver,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ETH. Returns structure `TransferEthMessage`.\n     */\n    function decodeTransferEthMessage(\n        bytes calldata data\n    ) internal pure returns (TransferEthMessage memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ETH, \"Message type is not ETH transfer\");\n        return abi.decode(data, (TransferEthMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ETH. Returns encoded message.\n     */\n    function encodeTransferErc20Message(\n        address token,\n        address receiver,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        TransferErc20Message memory message = TransferErc20Message(\n            BaseMessage(MessageType.TRANSFER_ERC20),\n            token,\n            receiver,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC20 with total supply. Returns encoded message.\n     */\n    function encodeTransferErc20AndTotalSupplyMessage(\n        address token,\n        address receiver,\n        uint256 amount,\n        uint256 totalSupply\n    ) internal pure returns (bytes memory) {\n        TransferErc20AndTotalSupplyMessage memory message = TransferErc20AndTotalSupplyMessage(\n            TransferErc20Message(\n                BaseMessage(MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY),\n                token,\n                receiver,\n                amount\n            ),\n            totalSupply\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20. Returns structure `TransferErc20Message`.\n     */\n    function decodeTransferErc20Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc20Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC20, \"Message type is not ERC20 transfer\");\n        return abi.decode(data, (TransferErc20Message));\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20 with total supply. \n     * Returns structure `TransferErc20AndTotalSupplyMessage`.\n     */\n    function decodeTransferErc20AndTotalSupplyMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc20AndTotalSupplyMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY,\n            \"Message type is not ERC20 transfer and total supply\"\n        );\n        return abi.decode(data, (TransferErc20AndTotalSupplyMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC20 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc20AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 amount,\n        uint256 totalSupply,\n        Erc20TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc20AndTokenInfoMessage memory message = TransferErc20AndTokenInfoMessage(\n            TransferErc20Message(\n                BaseMessage(MessageType.TRANSFER_ERC20_AND_TOKEN_INFO),\n                token,\n                receiver,\n                amount\n            ),\n            totalSupply,\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20 with token info. \n     * Returns structure `TransferErc20AndTokenInfoMessage`.\n     */\n    function decodeTransferErc20AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc20AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC20_AND_TOKEN_INFO,\n            \"Message type is not ERC20 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc20AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721Message(\n        address token,\n        address receiver,\n        uint256 tokenId\n    ) internal pure returns (bytes memory) {\n        TransferErc721Message memory message = TransferErc721Message(\n            BaseMessage(MessageType.TRANSFER_ERC721),\n            token,\n            receiver,\n            tokenId\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721. \n     * Returns structure `TransferErc721Message`.\n     */\n    function decodeTransferErc721Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc721Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC721, \"Message type is not ERC721 transfer\");\n        return abi.decode(data, (TransferErc721Message));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        Erc721TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc721AndTokenInfoMessage memory message = TransferErc721AndTokenInfoMessage(\n            TransferErc721Message(\n                BaseMessage(MessageType.TRANSFER_ERC721_AND_TOKEN_INFO),\n                token,\n                receiver,\n                tokenId\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721 with token info. \n     * Returns structure `TransferErc721AndTokenInfoMessage`.\n     */\n    function decodeTransferErc721AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc721AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_AND_TOKEN_INFO,\n            \"Message type is not ERC721 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc721AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721MessageWithMetadata(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        string memory tokenURI\n    ) internal pure returns (bytes memory) {\n        TransferErc721MessageWithMetadata memory message = TransferErc721MessageWithMetadata(\n            TransferErc721Message(\n                BaseMessage(MessageType.TRANSFER_ERC721_WITH_METADATA),\n                token,\n                receiver,\n                tokenId\n            ),\n            tokenURI\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721. \n     * Returns structure `TransferErc721MessageWithMetadata`.\n     */\n    function decodeTransferErc721MessageWithMetadata(\n        bytes calldata data\n    ) internal pure returns (TransferErc721MessageWithMetadata memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_WITH_METADATA,\n            \"Message type is not ERC721 transfer\"\n        );\n        return abi.decode(data, (TransferErc721MessageWithMetadata));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721WithMetadataAndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        string memory tokenURI,\n        Erc721TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc721WithMetadataAndTokenInfoMessage memory message = TransferErc721WithMetadataAndTokenInfoMessage(\n            TransferErc721MessageWithMetadata(\n                TransferErc721Message(\n                    BaseMessage(MessageType.TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO),\n                    token,\n                    receiver,\n                    tokenId\n                ),\n                tokenURI\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721 with token info. \n     * Returns structure `TransferErc721WithMetadataAndTokenInfoMessage`.\n     */\n    function decodeTransferErc721WithMetadataAndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc721WithMetadataAndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO,\n            \"Message type is not ERC721 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc721WithMetadataAndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for activating user on schain. \n     * Returns encoded message.\n     */\n    function encodeActivateUserMessage(address receiver) internal pure returns (bytes memory){\n        return _encodeUserStatusMessage(receiver, true);\n    }\n\n    /**\n     * @dev Encodes message for locking user on schain. \n     * Returns encoded message.\n     */\n    function encodeLockUserMessage(address receiver) internal pure returns (bytes memory){\n        return _encodeUserStatusMessage(receiver, false);\n    }\n\n    /**\n     * @dev Decodes message for user status. \n     * Returns structure UserStatusMessage.\n     */\n    function decodeUserStatusMessage(bytes calldata data) internal pure returns (UserStatusMessage memory) {\n        require(getMessageType(data) == MessageType.USER_STATUS, \"Message type is not User Status\");\n        return abi.decode(data, (UserStatusMessage));\n    }\n\n\n    /**\n     * @dev Encodes message for allowing interchain connection.\n     * Returns encoded message.\n     */\n    function encodeInterchainConnectionMessage(bool isAllowed) internal pure returns (bytes memory) {\n        InterchainConnectionMessage memory message = InterchainConnectionMessage(\n            BaseMessage(MessageType.INTERCHAIN_CONNECTION),\n            isAllowed\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for allowing interchain connection.\n     * Returns structure `InterchainConnectionMessage`.\n     */\n    function decodeInterchainConnectionMessage(bytes calldata data)\n        internal\n        pure\n        returns (InterchainConnectionMessage memory)\n    {\n        require(getMessageType(data) == MessageType.INTERCHAIN_CONNECTION, \"Message type is not Interchain connection\");\n        return abi.decode(data, (InterchainConnectionMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155Message(\n        address token,\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        TransferErc1155Message memory message = TransferErc1155Message(\n            BaseMessage(MessageType.TRANSFER_ERC1155),\n            token,\n            receiver,\n            id,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token.\n     * Returns structure `TransferErc1155Message`.\n     */\n    function decodeTransferErc1155Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC1155, \"Message type is not ERC1155 transfer\");\n        return abi.decode(data, (TransferErc1155Message));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 with token info.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 id,\n        uint256 amount,\n        Erc1155TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc1155AndTokenInfoMessage memory message = TransferErc1155AndTokenInfoMessage(\n            TransferErc1155Message(\n                BaseMessage(MessageType.TRANSFER_ERC1155_AND_TOKEN_INFO),\n                token,\n                receiver,\n                id,\n                amount\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 with token info.\n     * Returns structure `TransferErc1155AndTokenInfoMessage`.\n     */\n    function decodeTransferErc1155AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_AND_TOKEN_INFO,\n            \"Message type is not ERC1155AndTokenInfo transfer\"\n        );\n        return abi.decode(data, (TransferErc1155AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token in batches.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155BatchMessage(\n        address token,\n        address receiver,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal pure returns (bytes memory) {\n        TransferErc1155BatchMessage memory message = TransferErc1155BatchMessage(\n            BaseMessage(MessageType.TRANSFER_ERC1155_BATCH),\n            token,\n            receiver,\n            ids,\n            amounts\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token in batches.\n     * Returns structure `TransferErc1155BatchMessage`.\n     */\n    function decodeTransferErc1155BatchMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155BatchMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_BATCH,\n            \"Message type is not ERC1155Batch transfer\"\n        );\n        return abi.decode(data, (TransferErc1155BatchMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token in batches with token info.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155BatchAndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        Erc1155TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc1155BatchAndTokenInfoMessage memory message = TransferErc1155BatchAndTokenInfoMessage(\n            TransferErc1155BatchMessage(\n                BaseMessage(MessageType.TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO),\n                token,\n                receiver,\n                ids,\n                amounts\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token in batches with token info.\n     * Returns structure `TransferErc1155BatchAndTokenInfoMessage`.\n     */\n    function decodeTransferErc1155BatchAndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155BatchAndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO,\n            \"Message type is not ERC1155BatchAndTokenInfo transfer\"\n        );\n        return abi.decode(data, (TransferErc1155BatchAndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring user status on schain.\n     * Returns encoded message.\n     */\n    function _encodeUserStatusMessage(address receiver, bool isActive) private pure returns (bytes memory) {\n        UserStatusMessage memory message = UserStatusMessage(\n            BaseMessage(MessageType.USER_STATUS),\n            receiver,\n            isActive\n        );\n        return abi.encode(message);\n    }\n\n}"
             },
@@ -403,11 +409,11 @@
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   RevertableERC20.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2022-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\ninterface IRevertableERC20 {\n    function enable() external;\n    function disable() external;\n    function mint(address account, uint amount) external;\n}\n\ncontract RevertableERC20 is IRevertableERC20, ERC20Upgradeable {\n    bool public enabled = true;\n\n    constructor(string memory name, string memory symbol) initializer {\n        super.__ERC20_init(name, symbol);\n    }\n\n    function enable() external override {\n        enabled = true;\n    }\n\n    function disable() external override {\n        enabled = false;\n    }\n\n    function mint(address account, uint amount) external override {\n        _mint(account, amount);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    )\n        internal\n        override\n    {\n        require(enabled, \"Transfers are disabled\");\n        super._transfer(from, to, amount);\n    }\n}"
             },
             "contracts/thirdparty/ERC1155ReceiverUpgradeableWithoutGap.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol\";\n\nabstract contract ERC1155ReceiverUpgradeableWithoutGap is\n    Initializable,\n    ERC165Upgradeable,\n    IERC1155ReceiverUpgradeable\n{\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165Upgradeable)\n        returns (bool)\n    {\n        return interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function __ERC1155Receiver_init() internal initializer {\n        __ERC165_init_unchained();\n        __ERC1155Receiver_init_unchained();\n    }\n\n    // solhint-disable-next-line func-name-mixedcase, no-empty-blocks\n    function __ERC1155Receiver_init_unchained() internal initializer {\n    }\n}"
             }
         }
     },
-    "name": "EthErc20",
+    "name": "ERC721OnChain",
     "solcLongVersion": "0.8.16+commit.07a7930e",
     "solcVersion": "0.8.16"
 }
```

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/KeyStorage.json` & `ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/KeyStorage.json`

 * *Files identical despite different names*

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/KeyStorage.meta.json` & `ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/EthErc20.meta.json`

 * *Files 1% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.8745592948717948%*

 * *Differences: {"'input'": "{'sources': {'@skalenetwork/skale-manager-interfaces/IWallets.sol': {'content': '// "*

 * *            'SPDX-License-Identifier: AGPL-3.0-only\\n\\n/*\\n    IWallets - SKALE Manager '*

 * *            'Interfaces\\n    Copyright (C) 2021-Present SKALE Labs\\n    @author Dmytro '*

 * *            'Stebaeiv\\n\\n    SKALE Manager Interfaces is free software: you can redistribute it '*

 * *            'and/or modify\\n    it under the terms of the GNU Affero General Public License as '*

 * *            'published\\n    by […]*

```diff
@@ -218,22 +218,28 @@
             },
             "@skalenetwork/ima-interfaces/schain/tokens/IEthErc20.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   IEthErc20 - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\n\ninterface IEthErc20 {\n    function mint(address account, uint256 amount) external;\n    function forceBurn(address account, uint256 amount) external;\n    function initialize(address tokenManagerEthAddress) external;\n}"
             },
             "@skalenetwork/skale-manager-interfaces/IContractManager.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IContractManager.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IContractManager {\n    /**\n     * @dev Emitted when contract is upgraded.\n     */\n    event ContractUpgraded(string contractsName, address contractsAddress);\n\n    function initialize() external;\n    function setContractsAddress(string calldata contractsName, address newContractsAddress) external;\n    function contracts(bytes32 nameHash) external view returns (address);\n    function getDelegationPeriodManager() external view returns (address);\n    function getBounty() external view returns (address);\n    function getValidatorService() external view returns (address);\n    function getTimeHelpers() external view returns (address);\n    function getConstantsHolder() external view returns (address);\n    function getSkaleToken() external view returns (address);\n    function getTokenState() external view returns (address);\n    function getPunisher() external view returns (address);\n    function getContract(string calldata name) external view returns (address);\n}"
             },
+            "@skalenetwork/skale-manager-interfaces/INodes.sol": {
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    INodes.sol - SKALE Manager\n    Copyright (C) 2018-Present SKALE Labs\n    @author Artem Payvin\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"./utils/IRandom.sol\";\n\ninterface INodes {\n    // All Nodes states\n    enum NodeStatus {Active, Leaving, Left, In_Maintenance}\n\n    struct Node {\n        string name;\n        bytes4 ip;\n        bytes4 publicIP;\n        uint16 port;\n        bytes32[2] publicKey;\n        uint startBlock;\n        uint lastRewardDate;\n        uint finishTime;\n        NodeStatus status;\n        uint validatorId;\n    }\n\n    // struct to note which Nodes and which number of Nodes owned by user\n    struct CreatedNodes {\n        mapping (uint => bool) isNodeExist;\n        uint numberOfNodes;\n    }\n\n    struct SpaceManaging {\n        uint8 freeSpace;\n        uint indexInSpaceMap;\n    }\n\n    struct NodeCreationParams {\n        string name;\n        bytes4 ip;\n        bytes4 publicIp;\n        uint16 port;\n        bytes32[2] publicKey;\n        uint16 nonce;\n        string domainName;\n    }\n    \n    /**\n     * @dev Emitted when a node is created.\n     */\n    event NodeCreated(\n        uint nodeIndex,\n        address owner,\n        string name,\n        bytes4 ip,\n        bytes4 publicIP,\n        uint16 port,\n        uint16 nonce,\n        string domainName\n    );\n\n    /**\n     * @dev Emitted when a node completes a network exit.\n     */\n    event ExitCompleted(\n        uint nodeIndex\n    );\n\n    /**\n     * @dev Emitted when a node begins to exit from the network.\n     */\n    event ExitInitialized(\n        uint nodeIndex,\n        uint startLeavingPeriod\n    );\n\n    /**\n     * @dev Emitted when a node set to in compliant or compliant.\n     */\n    event IncompliantNode(\n        uint indexed nodeIndex,\n        bool status\n    );\n\n    /**\n     * @dev Emitted when a node set to in maintenance or from in maintenance.\n     */\n    event MaintenanceNode(\n        uint indexed nodeIndex,\n        bool status\n    );\n\n    /**\n     * @dev Emitted when a node status changed.\n     */\n    event IPChanged(\n        uint indexed nodeIndex,\n        bytes4 previousIP,\n        bytes4 newIP\n    );\n    \n    function removeSpaceFromNode(uint nodeIndex, uint8 space) external returns (bool);\n    function addSpaceToNode(uint nodeIndex, uint8 space) external;\n    function changeNodeLastRewardDate(uint nodeIndex) external;\n    function changeNodeFinishTime(uint nodeIndex, uint time) external;\n    function createNode(address from, NodeCreationParams calldata params) external;\n    function initExit(uint nodeIndex) external;\n    function completeExit(uint nodeIndex) external returns (bool);\n    function deleteNodeForValidator(uint validatorId, uint nodeIndex) external;\n    function checkPossibilityCreatingNode(address nodeAddress) external;\n    function checkPossibilityToMaintainNode(uint validatorId, uint nodeIndex) external returns (bool);\n    function setNodeInMaintenance(uint nodeIndex) external;\n    function removeNodeFromInMaintenance(uint nodeIndex) external;\n    function setNodeIncompliant(uint nodeIndex) external;\n    function setNodeCompliant(uint nodeIndex) external;\n    function setDomainName(uint nodeIndex, string memory domainName) external;\n    function makeNodeVisible(uint nodeIndex) external;\n    function makeNodeInvisible(uint nodeIndex) external;\n    function changeIP(uint nodeIndex, bytes4 newIP, bytes4 newPublicIP) external;\n    function numberOfActiveNodes() external view returns (uint);\n    function incompliant(uint nodeIndex) external view returns (bool);\n    function getRandomNodeWithFreeSpace(\n        uint8 freeSpace,\n        IRandom.RandomGenerator memory randomGenerator\n    )\n        external\n        view\n        returns (uint);\n    function isTimeForReward(uint nodeIndex) external view returns (bool);\n    function getNodeIP(uint nodeIndex) external view returns (bytes4);\n    function getNodeDomainName(uint nodeIndex) external view returns (string memory);\n    function getNodePort(uint nodeIndex) external view returns (uint16);\n    function getNodePublicKey(uint nodeIndex) external view returns (bytes32[2] memory);\n    function getNodeAddress(uint nodeIndex) external view returns (address);\n    function getNodeFinishTime(uint nodeIndex) external view returns (uint);\n    function isNodeLeft(uint nodeIndex) external view returns (bool);\n    function isNodeInMaintenance(uint nodeIndex) external view returns (bool);\n    function getNodeLastRewardDate(uint nodeIndex) external view returns (uint);\n    function getNodeNextRewardDate(uint nodeIndex) external view returns (uint);\n    function getNumberOfNodes() external view returns (uint);\n    function getNumberOnlineNodes() external view returns (uint);\n    function getActiveNodeIds() external view returns (uint[] memory activeNodeIds);\n    function getNodeStatus(uint nodeIndex) external view returns (NodeStatus);\n    function getValidatorNodeIndexes(uint validatorId) external view returns (uint[] memory);\n    function countNodesWithFreeSpace(uint8 freeSpace) external view returns (uint count);\n    function getValidatorId(uint nodeIndex) external view returns (uint);\n    function isNodeExist(address from, uint nodeIndex) external view returns (bool);\n    function isNodeActive(uint nodeIndex) external view returns (bool);\n    function isNodeLeaving(uint nodeIndex) external view returns (bool);\n}\n"
+            },
             "@skalenetwork/skale-manager-interfaces/ISchains.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchains.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchains {\n\n    struct SchainOption {\n        string name;\n        bytes value;\n    }\n    \n    /**\n     * @dev Emitted when an schain is created.\n     */\n    event SchainCreated(\n        string name,\n        address owner,\n        uint partOfNode,\n        uint lifetime,\n        uint numberOfNodes,\n        uint deposit,\n        uint16 nonce,\n        bytes32 schainHash\n    );\n\n    /**\n     * @dev Emitted when an schain is deleted.\n     */\n    event SchainDeleted(\n        address owner,\n        string name,\n        bytes32 indexed schainHash\n    );\n\n    /**\n     * @dev Emitted when a node in an schain is rotated.\n     */\n    event NodeRotated(\n        bytes32 schainHash,\n        uint oldNode,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a node is added to an schain.\n     */\n    event NodeAdded(\n        bytes32 schainHash,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a group of nodes is created for an schain.\n     */\n    event SchainNodes(\n        string name,\n        bytes32 schainHash,\n        uint[] nodesInGroup\n    );\n\n    function addSchain(address from, uint deposit, bytes calldata data) external;\n    function addSchainByFoundation(\n        uint lifetime,\n        uint8 typeOfSchain,\n        uint16 nonce,\n        string calldata name,\n        address schainOwner,\n        address schainOriginator,\n        SchainOption[] calldata options\n    )\n        external\n        payable;\n    function deleteSchain(address from, string calldata name) external;\n    function deleteSchainByRoot(string calldata name) external;\n    function restartSchainCreation(string calldata name) external;\n    function verifySchainSignature(\n        uint256 signA,\n        uint256 signB,\n        bytes32 hash,\n        uint256 counter,\n        uint256 hashA,\n        uint256 hashB,\n        string calldata schainName\n    )\n        external\n        view\n        returns (bool);\n    function getSchainPrice(uint typeOfSchain, uint lifetime) external view returns (uint);\n    function getOption(bytes32 schainHash, string calldata optionName) external view returns (bytes memory);\n    function getOptions(bytes32 schainHash) external view returns (SchainOption[] memory);\n}"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchains.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchains {\n\n    struct SchainOption {\n        string name;\n        bytes value;\n    }\n    \n    /**\n     * @dev Emitted when an schain is created.\n     */\n    event SchainCreated(\n        string name,\n        address owner,\n        uint partOfNode,\n        uint lifetime,\n        uint numberOfNodes,\n        uint deposit,\n        uint16 nonce,\n        bytes32 schainHash\n    );\n\n    /**\n     * @dev Emitted when an schain is deleted.\n     */\n    event SchainDeleted(\n        address owner,\n        string name,\n        bytes32 indexed schainHash\n    );\n\n    /**\n     * @dev Emitted when a node in an schain is rotated.\n     */\n    event NodeRotated(\n        bytes32 schainHash,\n        uint oldNode,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a node is added to an schain.\n     */\n    event NodeAdded(\n        bytes32 schainHash,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a group of nodes is created for an schain.\n     */\n    event SchainNodes(\n        string name,\n        bytes32 schainHash,\n        uint[] nodesInGroup\n    );\n\n    function addSchain(address from, uint deposit, bytes calldata data) external;\n    function addSchainByFoundation(\n        uint lifetime,\n        uint8 typeOfSchain,\n        uint16 nonce,\n        string calldata name,\n        address schainOwner,\n        address schainOriginator,\n        SchainOption[] calldata options\n    )\n        external\n        payable;\n    function deleteSchain(address from, string calldata name) external;\n    function deleteSchainByRoot(string calldata name) external;\n    function restartSchainCreation(string calldata name) external;\n    function verifySchainSignature(\n        uint256 signA,\n        uint256 signB,\n        bytes32 hash,\n        uint256 counter,\n        uint256 hashA,\n        uint256 hashB,\n        string calldata schainName\n    )\n        external\n        view\n        returns (bool);\n    function getSchainPrice(uint typeOfSchain, uint lifetime) external view returns (uint);\n    function getOption(bytes32 schainHash, string calldata optionName) external view returns (bytes memory);\n    function getOptions(bytes32 schainHash) external view returns (SchainOption[] memory);\n}\n"
             },
             "@skalenetwork/skale-manager-interfaces/ISchainsInternal.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchainsInternal - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchainsInternal {\n    struct Schain {\n        string name;\n        address owner;\n        uint indexInOwnerList;\n        uint8 partOfNode;\n        uint lifetime;\n        uint startDate;\n        uint startBlock;\n        uint deposit;\n        uint64 index;\n        uint generation;\n        address originator;\n    }\n\n    struct SchainType {\n        uint8 partOfNode;\n        uint numberOfNodes;\n    }\n\n    /**\n     * @dev Emitted when schain type added.\n     */\n    event SchainTypeAdded(uint indexed schainType, uint partOfNode, uint numberOfNodes);\n\n    /**\n     * @dev Emitted when schain type removed.\n     */\n    event SchainTypeRemoved(uint indexed schainType);\n\n    function initializeSchain(\n        string calldata name,\n        address from,\n        address originator,\n        uint lifetime,\n        uint deposit) external;\n    function createGroupForSchain(\n        bytes32 schainHash,\n        uint numberOfNodes,\n        uint8 partOfNode\n    )\n        external\n        returns (uint[] memory);\n    function changeLifetime(bytes32 schainHash, uint lifetime, uint deposit) external;\n    function removeSchain(bytes32 schainHash, address from) external;\n    function removeNodeFromSchain(uint nodeIndex, bytes32 schainHash) external;\n    function deleteGroup(bytes32 schainHash) external;\n    function setException(bytes32 schainHash, uint nodeIndex) external;\n    function setNodeInGroup(bytes32 schainHash, uint nodeIndex) external;\n    function removeHolesForSchain(bytes32 schainHash) external;\n    function addSchainType(uint8 partOfNode, uint numberOfNodes) external;\n    function removeSchainType(uint typeOfSchain) external;\n    function setNumberOfSchainTypes(uint newNumberOfSchainTypes) external;\n    function removeNodeFromAllExceptionSchains(uint nodeIndex) external;\n    function removeAllNodesFromSchainExceptions(bytes32 schainHash) external;\n    function makeSchainNodesInvisible(bytes32 schainHash) external;\n    function makeSchainNodesVisible(bytes32 schainHash) external;\n    function newGeneration() external;\n    function addSchainForNode(uint nodeIndex, bytes32 schainHash) external;\n    function removeSchainForNode(uint nodeIndex, uint schainIndex) external;\n    function removeNodeFromExceptions(bytes32 schainHash, uint nodeIndex) external;\n    function isSchainActive(bytes32 schainHash) external view returns (bool);\n    function schainsAtSystem(uint index) external view returns (bytes32);\n    function numberOfSchains() external view returns (uint64);\n    function getSchains() external view returns (bytes32[] memory);\n    function getSchainsPartOfNode(bytes32 schainHash) external view returns (uint8);\n    function getSchainListSize(address from) external view returns (uint);\n    function getSchainHashesByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainIdsByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainHashesForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainIdsForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainOwner(bytes32 schainHash) external view returns (address);\n    function getSchainOriginator(bytes32 schainHash) external view returns (address);\n    function isSchainNameAvailable(string calldata name) external view returns (bool);\n    function isTimeExpired(bytes32 schainHash) external view returns (bool);\n    function isOwnerAddress(address from, bytes32 schainId) external view returns (bool);\n    function getSchainName(bytes32 schainHash) external view returns (string memory);\n    function getActiveSchain(uint nodeIndex) external view returns (bytes32);\n    function getActiveSchains(uint nodeIndex) external view returns (bytes32[] memory activeSchains);\n    function getNumberOfNodesInGroup(bytes32 schainHash) external view returns (uint);\n    function getNodesInGroup(bytes32 schainHash) external view returns (uint[] memory);\n    function isNodeAddressesInGroup(bytes32 schainId, address sender) external view returns (bool);\n    function getNodeIndexInGroup(bytes32 schainHash, uint nodeId) external view returns (uint);\n    function isAnyFreeNode(bytes32 schainHash) external view returns (bool);\n    function checkException(bytes32 schainHash, uint nodeIndex) external view returns (bool);\n    function checkHoleForSchain(bytes32 schainHash, uint indexOfNode) external view returns (bool);\n    function checkSchainOnNode(uint nodeIndex, bytes32 schainHash) external view returns (bool);\n    function getSchainType(uint typeOfSchain) external view returns(uint8, uint);\n    function getGeneration(bytes32 schainHash) external view returns (uint);\n    function isSchainExist(bytes32 schainHash) external view returns (bool);\n}"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchainsInternal - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"./INodes.sol\";\n\ninterface ISchainsInternal {\n    struct Schain {\n        string name;\n        address owner;\n        uint indexInOwnerList;\n        uint8 partOfNode;\n        uint lifetime;\n        uint startDate;\n        uint startBlock;\n        uint deposit;\n        uint64 index;\n        uint generation;\n        address originator;\n    }\n\n    struct SchainType {\n        uint8 partOfNode;\n        uint numberOfNodes;\n    }\n\n    /**\n     * @dev Emitted when schain type added.\n     */\n    event SchainTypeAdded(uint indexed schainType, uint partOfNode, uint numberOfNodes);\n\n    /**\n     * @dev Emitted when schain type removed.\n     */\n    event SchainTypeRemoved(uint indexed schainType);\n\n    function initializeSchain(\n        string calldata name,\n        address from,\n        address originator,\n        uint lifetime,\n        uint deposit) external;\n    function createGroupForSchain(\n        bytes32 schainHash,\n        uint numberOfNodes,\n        uint8 partOfNode\n    )\n        external\n        returns (uint[] memory);\n    function changeLifetime(bytes32 schainHash, uint lifetime, uint deposit) external;\n    function removeSchain(bytes32 schainHash, address from) external;\n    function removeNodeFromSchain(uint nodeIndex, bytes32 schainHash) external;\n    function deleteGroup(bytes32 schainHash) external;\n    function setException(bytes32 schainHash, uint nodeIndex) external;\n    function setNodeInGroup(bytes32 schainHash, uint nodeIndex) external;\n    function removeHolesForSchain(bytes32 schainHash) external;\n    function addSchainType(uint8 partOfNode, uint numberOfNodes) external;\n    function removeSchainType(uint typeOfSchain) external;\n    function setNumberOfSchainTypes(uint newNumberOfSchainTypes) external;\n    function removeNodeFromAllExceptionSchains(uint nodeIndex) external;\n    function removeAllNodesFromSchainExceptions(bytes32 schainHash) external;\n    function makeSchainNodesInvisible(bytes32 schainHash) external;\n    function makeSchainNodesVisible(bytes32 schainHash) external;\n    function newGeneration() external;\n    function addSchainForNode(INodes nodes,uint nodeIndex, bytes32 schainHash) external;\n    function removeSchainForNode(uint nodeIndex, uint schainIndex) external;\n    function removeNodeFromExceptions(bytes32 schainHash, uint nodeIndex) external;\n    function isSchainActive(bytes32 schainHash) external view returns (bool);\n    function schainsAtSystem(uint index) external view returns (bytes32);\n    function numberOfSchains() external view returns (uint64);\n    function getSchains() external view returns (bytes32[] memory);\n    function getSchainsPartOfNode(bytes32 schainHash) external view returns (uint8);\n    function getSchainListSize(address from) external view returns (uint);\n    function getSchainHashesByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainHashesForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainOwner(bytes32 schainHash) external view returns (address);\n    function getSchainOriginator(bytes32 schainHash) external view returns (address);\n    function isSchainNameAvailable(string calldata name) external view returns (bool);\n    function isTimeExpired(bytes32 schainHash) external view returns (bool);\n    function isOwnerAddress(address from, bytes32 schainHash) external view returns (bool);\n    function getSchainName(bytes32 schainHash) external view returns (string memory);\n    function getActiveSchain(uint nodeIndex) external view returns (bytes32);\n    function getActiveSchains(uint nodeIndex) external view returns (bytes32[] memory activeSchains);\n    function getNumberOfNodesInGroup(bytes32 schainHash) external view returns (uint);\n    function getNodesInGroup(bytes32 schainHash) external view returns (uint[] memory);\n    function isNodeAddressesInGroup(bytes32 schainHash, address sender) external view returns (bool);\n    function getNodeIndexInGroup(bytes32 schainHash, uint nodeHash) external view returns (uint);\n    function isAnyFreeNode(bytes32 schainHash) external view returns (bool);\n    function checkException(bytes32 schainHash, uint nodeIndex) external view returns (bool);\n    function checkHoleForSchain(bytes32 schainHash, uint indexOfNode) external view returns (bool);\n    function checkSchainOnNode(uint nodeIndex, bytes32 schainHash) external view returns (bool);\n    function getSchainType(uint typeOfSchain) external view returns(uint8, uint);\n    function getGeneration(bytes32 schainHash) external view returns (uint);\n    function isSchainExist(bytes32 schainHash) external view returns (bool);\n}"
             },
             "@skalenetwork/skale-manager-interfaces/IWallets.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IWallets - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IWallets {\n    /**\n     * @dev Emitted when the validator wallet was funded\n     */\n    event ValidatorWalletRecharged(address sponsor, uint amount, uint validatorId);\n\n    /**\n     * @dev Emitted when the schain wallet was funded\n     */\n    event SchainWalletRecharged(address sponsor, uint amount, bytes32 schainHash);\n\n    /**\n     * @dev Emitted when the node received a refund from validator to its wallet\n     */\n    event NodeRefundedByValidator(address node, uint validatorId, uint amount);\n\n    /**\n     * @dev Emitted when the node received a refund from schain to its wallet\n     */\n    event NodeRefundedBySchain(address node, bytes32 schainHash, uint amount);\n\n    /**\n     * @dev Emitted when the validator withdrawn funds from validator wallet\n     */\n    event WithdrawFromValidatorWallet(uint indexed validatorId, uint amount);\n\n    /**\n     * @dev Emitted when the schain owner withdrawn funds from schain wallet\n     */\n    event WithdrawFromSchainWallet(bytes32 indexed schainHash, uint amount);\n\n    receive() external payable;\n    function refundGasByValidator(uint validatorId, address payable spender, uint spentGas) external;\n    function refundGasByValidatorToSchain(uint validatorId, bytes32 schainHash) external;\n    function refundGasBySchain(bytes32 schainId, address payable spender, uint spentGas, bool isDebt) external;\n    function withdrawFundsFromSchainWallet(address payable schainOwner, bytes32 schainHash) external;\n    function withdrawFundsFromValidatorWallet(uint amount) external;\n    function rechargeValidatorWallet(uint validatorId) external payable;\n    function rechargeSchainWallet(bytes32 schainId) external payable;\n    function getSchainBalance(bytes32 schainHash) external view returns (uint);\n    function getValidatorBalance(uint validatorId) external view returns (uint);\n}\n"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IWallets - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IWallets {\n    receive() external payable;\n    function refundGasByValidator(uint validatorId, address payable spender, uint gasLimit) external;\n    function refundGasByValidatorToSchain(uint validatorId, bytes32 schainHash) external;\n    function refundGasBySchain(bytes32 schainId, address payable spender, uint spentGas, bool isDebt) external;\n    function withdrawFundsFromSchainWallet(address payable schainOwner, bytes32 schainHash) external;\n    function withdrawFundsFromValidatorWallet(uint amount) external;\n    function rechargeValidatorWallet(uint validatorId) external payable;\n    function rechargeSchainWallet(bytes32 schainId) external payable;\n    function getSchainBalance(bytes32 schainHash) external view returns (uint);\n    function getValidatorBalance(uint validatorId) external view returns (uint);\n}\n"
+            },
+            "@skalenetwork/skale-manager-interfaces/utils/IRandom.sol": {
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IRandom.sol - SKALE Manager Interfaces\n    Copyright (C) 2022-Present SKALE Labs\n    @author Dmytro Stebaiev\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\n\ninterface IRandom {\n    struct RandomGenerator {\n        uint seed;\n    }\n}"
             },
             "contracts/MessageProxy.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   MessageProxy.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/IGasReimbursable.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageProxy.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageReceiver.sol\";\n\n\n/**\n * @title MessageProxy\n * @dev Abstract contract for MessageProxyForMainnet and MessageProxyForSchain.\n */\nabstract contract MessageProxy is AccessControlEnumerableUpgradeable, IMessageProxy {\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    /**\n     * @dev Structure that stores counters for outgoing and incoming messages.\n     */\n    struct ConnectedChainInfo {\n        // message counters start with 0\n        uint256 incomingMessageCounter;\n        uint256 outgoingMessageCounter;\n        bool inited;\n        uint256 lastOutgoingMessageBlockId;\n    }\n\n    bytes32 public constant MAINNET_HASH = keccak256(abi.encodePacked(\"Mainnet\"));\n    bytes32 public constant CHAIN_CONNECTOR_ROLE = keccak256(\"CHAIN_CONNECTOR_ROLE\");\n    bytes32 public constant EXTRA_CONTRACT_REGISTRAR_ROLE = keccak256(\"EXTRA_CONTRACT_REGISTRAR_ROLE\");\n    bytes32 public constant CONSTANT_SETTER_ROLE = keccak256(\"CONSTANT_SETTER_ROLE\");\n    uint256 public constant MESSAGES_LENGTH = 10;\n    uint256 public constant REVERT_REASON_LENGTH = 64;\n\n    //   schainHash => ConnectedChainInfo\n    mapping(bytes32 => ConnectedChainInfo) public connectedChains;\n    //   schainHash => contract address => allowed\n    mapping(bytes32 => mapping(address => bool)) private _deprecatedRegistryContracts;\n\n    uint256 public gasLimit;\n\n    /**\n     * @dev Emitted for every outgoing message to schain.\n     */\n    event OutgoingMessage(\n        bytes32 indexed dstChainHash,\n        uint256 indexed msgCounter,\n        address indexed srcContract,\n        address dstContract,\n        bytes data\n    );\n\n    /**\n     * @dev Emitted when function `postMessage` returns revert.\n     *  Used to prevent stuck loop inside function `postIncomingMessages`.\n     */\n    event PostMessageError(\n        uint256 indexed msgCounter,\n        bytes message\n    );\n\n    /**\n     * @dev Emitted when gas limit per one call of `postMessage` was changed.\n     */\n    event GasLimitWasChanged(\n        uint256 oldValue,\n        uint256 newValue\n    );\n\n    /**\n     * @dev Emitted when the version was updated\n     */\n    event VersionUpdated(string oldVersion, string newVersion);\n\n    /**\n     * @dev Emitted when extra contract was added.\n     */\n    event ExtraContractRegistered(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Emitted when extra contract was removed.\n     */\n    event ExtraContractRemoved(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Emitted when referenced to previous outgoing message.\n     */\n    event PreviousMessageReference (\n        uint256 currentMessage,\n        uint256 previousOutgoingMessageBlockId\n    );\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CHAIN_CONNECTOR_ROLE}.\n     */\n    modifier onlyChainConnector() {\n        require(hasRole(CHAIN_CONNECTOR_ROLE, msg.sender), \"CHAIN_CONNECTOR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {EXTRA_CONTRACT_REGISTRAR_ROLE}.\n     */\n    modifier onlyExtraContractRegistrar() {\n        require(hasRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender), \"EXTRA_CONTRACT_REGISTRAR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CONSTANT_SETTER_ROLE}.\n     */\n    modifier onlyConstantSetter() {\n        require(hasRole(CONSTANT_SETTER_ROLE, msg.sender), \"Not enough permissions to set constant\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {DEFAULT_ADMIN_ROLE}.\n     */\n    modifier onlyOwner() {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"DEFAULT_ADMIN_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Sets gasLimit to a new value.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CONSTANT_SETTER_ROLE.\n     */\n    function setNewGasLimit(uint256 newGasLimit) external override onlyConstantSetter {\n        emit GasLimitWasChanged(gasLimit, newGasLimit);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Virtual function for `postIncomingMessages`.\n     */\n    function postIncomingMessages(\n        string calldata fromSchainName,\n        uint256 startingCounter,\n        Message[] calldata messages,\n        Signature calldata sign\n    )\n        external\n        virtual\n        override;\n\n    /**\n     * @dev Allows `msg.sender` to register extra contract for all schains\n     * for being able to transfer messages from custom contracts.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     * - Passed address should be contract.\n     * - Extra contract must not be registered.\n     */\n    function registerExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is already registered\");\n        _getRegistryContracts()[bytes32(0)].add(extraContract);\n        emit ExtraContractRegistered(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Allows `msg.sender` to remove extra contract for all schains.\n     * Extra contract will no longer be able to send messages through MessageProxy.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     */\n    function removeExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[bytes32(0)].remove(extraContract);\n        emit ExtraContractRemoved(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Should return length of contract registered by schainHash.\n     */\n    function getContractRegisteredLength(bytes32 schainHash) external view override returns (uint256) {\n        return _getRegistryContracts()[schainHash].length();\n    }\n\n    /**\n     * @dev Should return a range of contracts registered by schainHash.\n     *\n     * Requirements:\n     * range should be less or equal 10 contracts\n     */\n    function getContractRegisteredRange(\n        bytes32 schainHash,\n        uint256 from,\n        uint256 to\n    )\n        external\n        view\n        override\n        returns (address[] memory contractsInRange)\n    {\n        require(\n            from < to && to - from <= 10 && to <= _getRegistryContracts()[schainHash].length(),\n            \"Range is incorrect\"\n        );\n        contractsInRange = new address[](to - from);\n        for (uint256 i = from; i < to; i++) {\n            contractsInRange[i - from] = _getRegistryContracts()[schainHash].at(i);\n        }\n    }\n\n    /**\n     * @dev Returns number of outgoing messages.\n     *\n     * Requirements:\n     *\n     * - Target schain  must be initialized.\n     */\n    function getOutgoingMessagesCounter(string calldata targetSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 dstChainHash = keccak256(abi.encodePacked(targetSchainName));\n        require(connectedChains[dstChainHash].inited, \"Destination chain is not initialized\");\n        return connectedChains[dstChainHash].outgoingMessageCounter;\n    }\n\n\n    /**\n     * @dev Should return block number of the last message transferred to schain\n     */\n    function getLastOutgoingMessageBlockId(string memory targetSchainName) external view override returns (uint) {\n        bytes32 dstChainHash = keccak256(abi.encodePacked(targetSchainName));\n        require(connectedChains[dstChainHash].inited, \"Destination chain is not initialized\");\n        return connectedChains[dstChainHash].lastOutgoingMessageBlockId;\n    }\n\n    /**\n     * @dev Returns number of incoming messages.\n     *\n     * Requirements:\n     *\n     * - Source schain must be initialized.\n     */\n    function getIncomingMessagesCounter(string calldata fromSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 srcChainHash = keccak256(abi.encodePacked(fromSchainName));\n        require(connectedChains[srcChainHash].inited, \"Source chain is not initialized\");\n        return connectedChains[srcChainHash].incomingMessageCounter;\n    }\n\n    function initializeMessageProxy(uint newGasLimit) public initializer {\n        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(CHAIN_CONNECTOR_ROLE, msg.sender);\n        _setupRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender);\n        _setupRole(CONSTANT_SETTER_ROLE, msg.sender);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Posts message from this contract to `targetChainHash` MessageProxy contract.\n     * This is called by a smart contract to make a cross-chain call.\n     *\n     * Emits an {OutgoingMessage} event.\n     *\n     * Requirements:\n     *\n     * - Target chain must be initialized.\n     * - Target chain must be registered as external contract.\n     */\n    function postOutgoingMessage(\n        bytes32 targetChainHash,\n        address targetContract,\n        bytes memory data\n    )\n        public\n        override\n        virtual\n    {\n        require(connectedChains[targetChainHash].inited, \"Destination chain is not initialized\");\n        _authorizeOutgoingMessageSender(targetChainHash);\n\n        uint outgoingMessageCounter = connectedChains[targetChainHash].outgoingMessageCounter;\n        emit OutgoingMessage(\n            targetChainHash,\n            outgoingMessageCounter,\n            msg.sender,\n            targetContract,\n            data\n        );\n        emit PreviousMessageReference(\n            outgoingMessageCounter,\n            connectedChains[targetChainHash].lastOutgoingMessageBlockId\n        );\n        connectedChains[targetChainHash].outgoingMessageCounter++;\n        connectedChains[targetChainHash].lastOutgoingMessageBlockId = block.number;\n    }\n\n    /**\n     * @dev Allows CHAIN_CONNECTOR_ROLE to remove connected chain from this contract.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CHAIN_CONNECTOR_ROLE.\n     * - `schainName` must be initialized.\n     */\n    function removeConnectedChain(string memory schainName) public virtual override onlyChainConnector {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(connectedChains[schainHash].inited, \"Chain is not initialized\");\n        delete connectedChains[schainHash];\n    }\n\n    /**\n     * @dev Checks whether chain is currently connected.\n     */\n    function isConnectedChain(\n        string memory schainName\n    )\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return connectedChains[keccak256(abi.encodePacked(schainName))].inited;\n    }\n\n    /**\n     * @dev Checks whether contract is currently registered as extra contract.\n     */\n    function isContractRegistered(\n        bytes32 schainHash,\n        address contractAddress\n    )\n        public\n        view\n        override\n        returns (bool)\n    {\n        return _getRegistryContracts()[schainHash].contains(contractAddress);\n    }\n\n    /**\n     * @dev Allows MessageProxy to register extra contract for being able to transfer messages from custom contracts.\n     *\n     * Requirements:\n     *\n     * - Extra contract address must be contract.\n     * - Extra contract must not be registered.\n     * - Extra contract must not be registered for all chains.\n     */\n    function _registerExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {\n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is already registered\");\n        require(\n            !_getRegistryContracts()[bytes32(0)].contains(extraContract),\n            \"Extra contract is already registered for all chains\"\n        );\n\n        _getRegistryContracts()[chainHash].add(extraContract);\n        emit ExtraContractRegistered(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to remove extra contract,\n     * thus `extraContract` will no longer be available to transfer messages from mainnet to schain.\n     *\n     * Requirements:\n     *\n     * - Extra contract must be registered.\n     */\n    function _removeExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {\n        require(_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[chainHash].remove(extraContract);\n        emit ExtraContractRemoved(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to connect schain with MessageProxyOnMainnet for transferring messages.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CHAIN_CONNECTOR_ROLE.\n     * - SKALE chain must not be connected.\n     */\n    function _addConnectedChain(bytes32 schainHash) internal onlyChainConnector {\n        require(!connectedChains[schainHash].inited,\"Chain is already connected\");\n        connectedChains[schainHash] = ConnectedChainInfo({\n            incomingMessageCounter: 0,\n            outgoingMessageCounter: 0,\n            inited: true,\n            lastOutgoingMessageBlockId: 0\n        });\n    }\n\n    /**\n     * @dev Allows MessageProxy to send messages from schain to mainnet.\n     * Destination contract must implement `postMessage` method.\n     */\n    function _callReceiverContract(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n    {\n        if (!message.destinationContract.isContract()) {\n            emit PostMessageError(\n                counter,\n                \"Destination contract is not a contract\"\n            );\n            return;\n        }\n        try IMessageReceiver(message.destinationContract).postMessage{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) {\n            return;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                _getSlice(bytes(reason), REVERT_REASON_LENGTH)\n            );\n        } catch Panic(uint errorCode) {\n               emit PostMessageError(\n                counter,\n                abi.encodePacked(errorCode)\n            );\n        } catch (bytes memory revertData) {\n            emit PostMessageError(\n                counter,\n                _getSlice(revertData, REVERT_REASON_LENGTH)\n            );\n        }\n    }\n\n    /**\n     * @dev Returns receiver of message.\n     */\n    function _getGasPayer(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n        returns (address)\n    {\n        try IGasReimbursable(message.destinationContract).gasPayer{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) returns (address receiver) {\n            return receiver;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                _getSlice(bytes(reason), REVERT_REASON_LENGTH)\n            );\n            return address(0);\n        } catch Panic(uint errorCode) {\n               emit PostMessageError(\n                counter,\n                abi.encodePacked(errorCode)\n            );\n            return address(0);\n        } catch (bytes memory revertData) {\n            emit PostMessageError(\n                counter,\n                _getSlice(revertData, REVERT_REASON_LENGTH)\n            );\n            return address(0);\n        }\n    }\n\n    /**\n     * @dev Checks whether msg.sender is registered as custom extra contract.\n     */\n    function _authorizeOutgoingMessageSender(bytes32 targetChainHash) internal view virtual {\n        require(\n            isContractRegistered(bytes32(0), msg.sender) || isContractRegistered(targetChainHash, msg.sender),\n            \"Sender contract is not registered\"\n        );\n    }\n\n    /**\n     * @dev Returns list of registered custom extra contracts.\n     */\n    function _getRegistryContracts()\n        internal\n        view\n        virtual\n        returns (mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) storage);\n\n    /**\n     * @dev Returns hash of message array.\n     */\n    function _hashedArray(\n        Message[] calldata messages,\n        uint256 startingCounter,\n        string calldata fromChainName\n    )\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32 sourceHash = keccak256(abi.encodePacked(fromChainName));\n        bytes32 hash = keccak256(abi.encodePacked(sourceHash, bytes32(startingCounter)));\n        for (uint256 i = 0; i < messages.length; i++) {\n            hash = keccak256(\n                abi.encodePacked(\n                    abi.encode(\n                        hash,\n                        messages[i].sender,\n                        messages[i].destinationContract\n                    ),\n                    messages[i].data\n                )\n            );\n        }\n        return hash;\n    }\n\n    function _getSlice(bytes memory text, uint end) private pure returns (bytes memory) {\n        uint slicedEnd = end < text.length ? end : text.length;\n        bytes memory sliced = new bytes(slicedEnd);\n        for(uint i = 0; i < slicedEnd; i++){\n            sliced[i] = text[i];\n        }\n        return sliced;\n    }\n}\n"
             },
             "contracts/Messages.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   Messages.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\n\n/**\n * @title Messages\n * @dev Library for encoding and decoding messages\n * for transferring from Mainnet to Schain and vice versa.\n */\nlibrary Messages {\n\n    /**\n     * @dev Enumerator that describes all supported message types.\n     */\n    enum MessageType {\n        EMPTY,\n        TRANSFER_ETH,\n        TRANSFER_ERC20,\n        TRANSFER_ERC20_AND_TOTAL_SUPPLY,\n        TRANSFER_ERC20_AND_TOKEN_INFO,\n        TRANSFER_ERC721,\n        TRANSFER_ERC721_AND_TOKEN_INFO,\n        USER_STATUS,\n        INTERCHAIN_CONNECTION,\n        TRANSFER_ERC1155,\n        TRANSFER_ERC1155_AND_TOKEN_INFO,\n        TRANSFER_ERC1155_BATCH,\n        TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO,\n        TRANSFER_ERC721_WITH_METADATA,\n        TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO\n    }\n\n    /**\n     * @dev Structure for base message.\n     */\n    struct BaseMessage {\n        MessageType messageType;\n    }\n\n    /**\n     * @dev Structure for describing ETH.\n     */\n    struct TransferEthMessage {\n        BaseMessage message;\n        address receiver;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for user status.\n     */\n    struct UserStatusMessage {\n        BaseMessage message;\n        address receiver;\n        bool isActive;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 token.\n     */\n    struct TransferErc20Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC20 token.\n     */\n    struct Erc20TokenInfo {\n        string name;\n        uint8 decimals;\n        string symbol;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token supply.\n     */\n    struct TransferErc20AndTotalSupplyMessage {\n        TransferErc20Message baseErc20transfer;\n        uint256 totalSupply;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token info.\n     */\n    struct TransferErc20AndTokenInfoMessage {\n        TransferErc20Message baseErc20transfer;\n        uint256 totalSupply;\n        Erc20TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing base ERC721.\n     */\n    struct TransferErc721Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 tokenId;\n    }\n\n    /**\n     * @dev Structure for describing base ERC721 with metadata.\n     */\n    struct TransferErc721MessageWithMetadata {\n        TransferErc721Message erc721message;\n        string tokenURI;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token info.\n     */\n    struct Erc721TokenInfo {\n        string name;\n        string symbol;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC721 token.\n     */\n    struct TransferErc721AndTokenInfoMessage {\n        TransferErc721Message baseErc721transfer;\n        Erc721TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC721 token with metadata.\n     */\n    struct TransferErc721WithMetadataAndTokenInfoMessage {\n        TransferErc721MessageWithMetadata baseErc721transferWithMetadata;\n        Erc721TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing whether interchain connection is allowed.\n     */\n    struct InterchainConnectionMessage {\n        BaseMessage message;\n        bool isAllowed;\n    }\n\n    /**\n     * @dev Structure for describing whether interchain connection is allowed.\n     */\n    struct TransferErc1155Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 id;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for describing ERC1155 token in batches.\n     */\n    struct TransferErc1155BatchMessage {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256[] ids;\n        uint256[] amounts;\n    }\n\n    /**\n     * @dev Structure for describing ERC1155 token info.\n     */\n    struct Erc1155TokenInfo {\n        string uri;\n    }\n\n    /**\n     * @dev Structure for describing message for transferring ERC1155 token with info.\n     */\n    struct TransferErc1155AndTokenInfoMessage {\n        TransferErc1155Message baseErc1155transfer;\n        Erc1155TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing message for transferring ERC1155 token in batches with info.\n     */\n    struct TransferErc1155BatchAndTokenInfoMessage {\n        TransferErc1155BatchMessage baseErc1155Batchtransfer;\n        Erc1155TokenInfo tokenInfo;\n    }\n\n\n    /**\n     * @dev Returns type of message for encoded data.\n     */\n    function getMessageType(bytes calldata data) internal pure returns (MessageType) {\n        uint256 firstWord = abi.decode(data, (uint256));\n        if (firstWord % 32 == 0) {\n            return getMessageType(data[firstWord:]);\n        } else {\n            return abi.decode(data, (Messages.MessageType));\n        }\n    }\n\n    /**\n     * @dev Encodes message for transferring ETH. Returns encoded message.\n     */\n    function encodeTransferEthMessage(address receiver, uint256 amount) internal pure returns (bytes memory) {\n        TransferEthMessage memory message = TransferEthMessage(\n            BaseMessage(MessageType.TRANSFER_ETH),\n            receiver,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ETH. Returns structure `TransferEthMessage`.\n     */\n    function decodeTransferEthMessage(\n        bytes calldata data\n    ) internal pure returns (TransferEthMessage memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ETH, \"Message type is not ETH transfer\");\n        return abi.decode(data, (TransferEthMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ETH. Returns encoded message.\n     */\n    function encodeTransferErc20Message(\n        address token,\n        address receiver,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        TransferErc20Message memory message = TransferErc20Message(\n            BaseMessage(MessageType.TRANSFER_ERC20),\n            token,\n            receiver,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC20 with total supply. Returns encoded message.\n     */\n    function encodeTransferErc20AndTotalSupplyMessage(\n        address token,\n        address receiver,\n        uint256 amount,\n        uint256 totalSupply\n    ) internal pure returns (bytes memory) {\n        TransferErc20AndTotalSupplyMessage memory message = TransferErc20AndTotalSupplyMessage(\n            TransferErc20Message(\n                BaseMessage(MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY),\n                token,\n                receiver,\n                amount\n            ),\n            totalSupply\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20. Returns structure `TransferErc20Message`.\n     */\n    function decodeTransferErc20Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc20Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC20, \"Message type is not ERC20 transfer\");\n        return abi.decode(data, (TransferErc20Message));\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20 with total supply. \n     * Returns structure `TransferErc20AndTotalSupplyMessage`.\n     */\n    function decodeTransferErc20AndTotalSupplyMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc20AndTotalSupplyMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY,\n            \"Message type is not ERC20 transfer and total supply\"\n        );\n        return abi.decode(data, (TransferErc20AndTotalSupplyMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC20 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc20AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 amount,\n        uint256 totalSupply,\n        Erc20TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc20AndTokenInfoMessage memory message = TransferErc20AndTokenInfoMessage(\n            TransferErc20Message(\n                BaseMessage(MessageType.TRANSFER_ERC20_AND_TOKEN_INFO),\n                token,\n                receiver,\n                amount\n            ),\n            totalSupply,\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20 with token info. \n     * Returns structure `TransferErc20AndTokenInfoMessage`.\n     */\n    function decodeTransferErc20AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc20AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC20_AND_TOKEN_INFO,\n            \"Message type is not ERC20 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc20AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721Message(\n        address token,\n        address receiver,\n        uint256 tokenId\n    ) internal pure returns (bytes memory) {\n        TransferErc721Message memory message = TransferErc721Message(\n            BaseMessage(MessageType.TRANSFER_ERC721),\n            token,\n            receiver,\n            tokenId\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721. \n     * Returns structure `TransferErc721Message`.\n     */\n    function decodeTransferErc721Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc721Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC721, \"Message type is not ERC721 transfer\");\n        return abi.decode(data, (TransferErc721Message));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        Erc721TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc721AndTokenInfoMessage memory message = TransferErc721AndTokenInfoMessage(\n            TransferErc721Message(\n                BaseMessage(MessageType.TRANSFER_ERC721_AND_TOKEN_INFO),\n                token,\n                receiver,\n                tokenId\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721 with token info. \n     * Returns structure `TransferErc721AndTokenInfoMessage`.\n     */\n    function decodeTransferErc721AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc721AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_AND_TOKEN_INFO,\n            \"Message type is not ERC721 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc721AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721MessageWithMetadata(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        string memory tokenURI\n    ) internal pure returns (bytes memory) {\n        TransferErc721MessageWithMetadata memory message = TransferErc721MessageWithMetadata(\n            TransferErc721Message(\n                BaseMessage(MessageType.TRANSFER_ERC721_WITH_METADATA),\n                token,\n                receiver,\n                tokenId\n            ),\n            tokenURI\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721. \n     * Returns structure `TransferErc721MessageWithMetadata`.\n     */\n    function decodeTransferErc721MessageWithMetadata(\n        bytes calldata data\n    ) internal pure returns (TransferErc721MessageWithMetadata memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_WITH_METADATA,\n            \"Message type is not ERC721 transfer\"\n        );\n        return abi.decode(data, (TransferErc721MessageWithMetadata));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721WithMetadataAndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        string memory tokenURI,\n        Erc721TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc721WithMetadataAndTokenInfoMessage memory message = TransferErc721WithMetadataAndTokenInfoMessage(\n            TransferErc721MessageWithMetadata(\n                TransferErc721Message(\n                    BaseMessage(MessageType.TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO),\n                    token,\n                    receiver,\n                    tokenId\n                ),\n                tokenURI\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721 with token info. \n     * Returns structure `TransferErc721WithMetadataAndTokenInfoMessage`.\n     */\n    function decodeTransferErc721WithMetadataAndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc721WithMetadataAndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO,\n            \"Message type is not ERC721 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc721WithMetadataAndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for activating user on schain. \n     * Returns encoded message.\n     */\n    function encodeActivateUserMessage(address receiver) internal pure returns (bytes memory){\n        return _encodeUserStatusMessage(receiver, true);\n    }\n\n    /**\n     * @dev Encodes message for locking user on schain. \n     * Returns encoded message.\n     */\n    function encodeLockUserMessage(address receiver) internal pure returns (bytes memory){\n        return _encodeUserStatusMessage(receiver, false);\n    }\n\n    /**\n     * @dev Decodes message for user status. \n     * Returns structure UserStatusMessage.\n     */\n    function decodeUserStatusMessage(bytes calldata data) internal pure returns (UserStatusMessage memory) {\n        require(getMessageType(data) == MessageType.USER_STATUS, \"Message type is not User Status\");\n        return abi.decode(data, (UserStatusMessage));\n    }\n\n\n    /**\n     * @dev Encodes message for allowing interchain connection.\n     * Returns encoded message.\n     */\n    function encodeInterchainConnectionMessage(bool isAllowed) internal pure returns (bytes memory) {\n        InterchainConnectionMessage memory message = InterchainConnectionMessage(\n            BaseMessage(MessageType.INTERCHAIN_CONNECTION),\n            isAllowed\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for allowing interchain connection.\n     * Returns structure `InterchainConnectionMessage`.\n     */\n    function decodeInterchainConnectionMessage(bytes calldata data)\n        internal\n        pure\n        returns (InterchainConnectionMessage memory)\n    {\n        require(getMessageType(data) == MessageType.INTERCHAIN_CONNECTION, \"Message type is not Interchain connection\");\n        return abi.decode(data, (InterchainConnectionMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155Message(\n        address token,\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        TransferErc1155Message memory message = TransferErc1155Message(\n            BaseMessage(MessageType.TRANSFER_ERC1155),\n            token,\n            receiver,\n            id,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token.\n     * Returns structure `TransferErc1155Message`.\n     */\n    function decodeTransferErc1155Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC1155, \"Message type is not ERC1155 transfer\");\n        return abi.decode(data, (TransferErc1155Message));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 with token info.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 id,\n        uint256 amount,\n        Erc1155TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc1155AndTokenInfoMessage memory message = TransferErc1155AndTokenInfoMessage(\n            TransferErc1155Message(\n                BaseMessage(MessageType.TRANSFER_ERC1155_AND_TOKEN_INFO),\n                token,\n                receiver,\n                id,\n                amount\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 with token info.\n     * Returns structure `TransferErc1155AndTokenInfoMessage`.\n     */\n    function decodeTransferErc1155AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_AND_TOKEN_INFO,\n            \"Message type is not ERC1155AndTokenInfo transfer\"\n        );\n        return abi.decode(data, (TransferErc1155AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token in batches.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155BatchMessage(\n        address token,\n        address receiver,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal pure returns (bytes memory) {\n        TransferErc1155BatchMessage memory message = TransferErc1155BatchMessage(\n            BaseMessage(MessageType.TRANSFER_ERC1155_BATCH),\n            token,\n            receiver,\n            ids,\n            amounts\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token in batches.\n     * Returns structure `TransferErc1155BatchMessage`.\n     */\n    function decodeTransferErc1155BatchMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155BatchMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_BATCH,\n            \"Message type is not ERC1155Batch transfer\"\n        );\n        return abi.decode(data, (TransferErc1155BatchMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token in batches with token info.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155BatchAndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        Erc1155TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc1155BatchAndTokenInfoMessage memory message = TransferErc1155BatchAndTokenInfoMessage(\n            TransferErc1155BatchMessage(\n                BaseMessage(MessageType.TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO),\n                token,\n                receiver,\n                ids,\n                amounts\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token in batches with token info.\n     * Returns structure `TransferErc1155BatchAndTokenInfoMessage`.\n     */\n    function decodeTransferErc1155BatchAndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155BatchAndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO,\n            \"Message type is not ERC1155BatchAndTokenInfo transfer\"\n        );\n        return abi.decode(data, (TransferErc1155BatchAndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring user status on schain.\n     * Returns encoded message.\n     */\n    function _encodeUserStatusMessage(address receiver, bool isActive) private pure returns (bytes memory) {\n        UserStatusMessage memory message = UserStatusMessage(\n            BaseMessage(MessageType.USER_STATUS),\n            receiver,\n            isActive\n        );\n        return abi.encode(message);\n    }\n\n}"
             },
@@ -403,11 +409,11 @@
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   RevertableERC20.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2022-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\ninterface IRevertableERC20 {\n    function enable() external;\n    function disable() external;\n    function mint(address account, uint amount) external;\n}\n\ncontract RevertableERC20 is IRevertableERC20, ERC20Upgradeable {\n    bool public enabled = true;\n\n    constructor(string memory name, string memory symbol) initializer {\n        super.__ERC20_init(name, symbol);\n    }\n\n    function enable() external override {\n        enabled = true;\n    }\n\n    function disable() external override {\n        enabled = false;\n    }\n\n    function mint(address account, uint amount) external override {\n        _mint(account, amount);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    )\n        internal\n        override\n    {\n        require(enabled, \"Transfers are disabled\");\n        super._transfer(from, to, amount);\n    }\n}"
             },
             "contracts/thirdparty/ERC1155ReceiverUpgradeableWithoutGap.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol\";\n\nabstract contract ERC1155ReceiverUpgradeableWithoutGap is\n    Initializable,\n    ERC165Upgradeable,\n    IERC1155ReceiverUpgradeable\n{\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165Upgradeable)\n        returns (bool)\n    {\n        return interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function __ERC1155Receiver_init() internal initializer {\n        __ERC165_init_unchained();\n        __ERC1155Receiver_init_unchained();\n    }\n\n    // solhint-disable-next-line func-name-mixedcase, no-empty-blocks\n    function __ERC1155Receiver_init_unchained() internal initializer {\n    }\n}"
             }
         }
     },
-    "name": "KeyStorage",
+    "name": "EthErc20",
     "solcLongVersion": "0.8.16+commit.07a7930e",
     "solcVersion": "0.8.16"
 }
```

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/MessageProxyForSchain.json` & `ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/MessageProxyForSchain.json`

 * *Files identical despite different names*

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/MessageProxyForSchain.meta.json` & `ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/KeyStorage.meta.json`

 * *Files 1% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.8745592948717948%*

 * *Differences: {"'input'": "{'sources': {'@skalenetwork/skale-manager-interfaces/IWallets.sol': {'content': '// "*

 * *            'SPDX-License-Identifier: AGPL-3.0-only\\n\\n/*\\n    IWallets - SKALE Manager '*

 * *            'Interfaces\\n    Copyright (C) 2021-Present SKALE Labs\\n    @author Dmytro '*

 * *            'Stebaeiv\\n\\n    SKALE Manager Interfaces is free software: you can redistribute it '*

 * *            'and/or modify\\n    it under the terms of the GNU Affero General Public License as '*

 * *            'published\\n    by […]*

```diff
@@ -218,22 +218,28 @@
             },
             "@skalenetwork/ima-interfaces/schain/tokens/IEthErc20.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   IEthErc20 - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\n\ninterface IEthErc20 {\n    function mint(address account, uint256 amount) external;\n    function forceBurn(address account, uint256 amount) external;\n    function initialize(address tokenManagerEthAddress) external;\n}"
             },
             "@skalenetwork/skale-manager-interfaces/IContractManager.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IContractManager.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IContractManager {\n    /**\n     * @dev Emitted when contract is upgraded.\n     */\n    event ContractUpgraded(string contractsName, address contractsAddress);\n\n    function initialize() external;\n    function setContractsAddress(string calldata contractsName, address newContractsAddress) external;\n    function contracts(bytes32 nameHash) external view returns (address);\n    function getDelegationPeriodManager() external view returns (address);\n    function getBounty() external view returns (address);\n    function getValidatorService() external view returns (address);\n    function getTimeHelpers() external view returns (address);\n    function getConstantsHolder() external view returns (address);\n    function getSkaleToken() external view returns (address);\n    function getTokenState() external view returns (address);\n    function getPunisher() external view returns (address);\n    function getContract(string calldata name) external view returns (address);\n}"
             },
+            "@skalenetwork/skale-manager-interfaces/INodes.sol": {
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    INodes.sol - SKALE Manager\n    Copyright (C) 2018-Present SKALE Labs\n    @author Artem Payvin\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"./utils/IRandom.sol\";\n\ninterface INodes {\n    // All Nodes states\n    enum NodeStatus {Active, Leaving, Left, In_Maintenance}\n\n    struct Node {\n        string name;\n        bytes4 ip;\n        bytes4 publicIP;\n        uint16 port;\n        bytes32[2] publicKey;\n        uint startBlock;\n        uint lastRewardDate;\n        uint finishTime;\n        NodeStatus status;\n        uint validatorId;\n    }\n\n    // struct to note which Nodes and which number of Nodes owned by user\n    struct CreatedNodes {\n        mapping (uint => bool) isNodeExist;\n        uint numberOfNodes;\n    }\n\n    struct SpaceManaging {\n        uint8 freeSpace;\n        uint indexInSpaceMap;\n    }\n\n    struct NodeCreationParams {\n        string name;\n        bytes4 ip;\n        bytes4 publicIp;\n        uint16 port;\n        bytes32[2] publicKey;\n        uint16 nonce;\n        string domainName;\n    }\n    \n    /**\n     * @dev Emitted when a node is created.\n     */\n    event NodeCreated(\n        uint nodeIndex,\n        address owner,\n        string name,\n        bytes4 ip,\n        bytes4 publicIP,\n        uint16 port,\n        uint16 nonce,\n        string domainName\n    );\n\n    /**\n     * @dev Emitted when a node completes a network exit.\n     */\n    event ExitCompleted(\n        uint nodeIndex\n    );\n\n    /**\n     * @dev Emitted when a node begins to exit from the network.\n     */\n    event ExitInitialized(\n        uint nodeIndex,\n        uint startLeavingPeriod\n    );\n\n    /**\n     * @dev Emitted when a node set to in compliant or compliant.\n     */\n    event IncompliantNode(\n        uint indexed nodeIndex,\n        bool status\n    );\n\n    /**\n     * @dev Emitted when a node set to in maintenance or from in maintenance.\n     */\n    event MaintenanceNode(\n        uint indexed nodeIndex,\n        bool status\n    );\n\n    /**\n     * @dev Emitted when a node status changed.\n     */\n    event IPChanged(\n        uint indexed nodeIndex,\n        bytes4 previousIP,\n        bytes4 newIP\n    );\n    \n    function removeSpaceFromNode(uint nodeIndex, uint8 space) external returns (bool);\n    function addSpaceToNode(uint nodeIndex, uint8 space) external;\n    function changeNodeLastRewardDate(uint nodeIndex) external;\n    function changeNodeFinishTime(uint nodeIndex, uint time) external;\n    function createNode(address from, NodeCreationParams calldata params) external;\n    function initExit(uint nodeIndex) external;\n    function completeExit(uint nodeIndex) external returns (bool);\n    function deleteNodeForValidator(uint validatorId, uint nodeIndex) external;\n    function checkPossibilityCreatingNode(address nodeAddress) external;\n    function checkPossibilityToMaintainNode(uint validatorId, uint nodeIndex) external returns (bool);\n    function setNodeInMaintenance(uint nodeIndex) external;\n    function removeNodeFromInMaintenance(uint nodeIndex) external;\n    function setNodeIncompliant(uint nodeIndex) external;\n    function setNodeCompliant(uint nodeIndex) external;\n    function setDomainName(uint nodeIndex, string memory domainName) external;\n    function makeNodeVisible(uint nodeIndex) external;\n    function makeNodeInvisible(uint nodeIndex) external;\n    function changeIP(uint nodeIndex, bytes4 newIP, bytes4 newPublicIP) external;\n    function numberOfActiveNodes() external view returns (uint);\n    function incompliant(uint nodeIndex) external view returns (bool);\n    function getRandomNodeWithFreeSpace(\n        uint8 freeSpace,\n        IRandom.RandomGenerator memory randomGenerator\n    )\n        external\n        view\n        returns (uint);\n    function isTimeForReward(uint nodeIndex) external view returns (bool);\n    function getNodeIP(uint nodeIndex) external view returns (bytes4);\n    function getNodeDomainName(uint nodeIndex) external view returns (string memory);\n    function getNodePort(uint nodeIndex) external view returns (uint16);\n    function getNodePublicKey(uint nodeIndex) external view returns (bytes32[2] memory);\n    function getNodeAddress(uint nodeIndex) external view returns (address);\n    function getNodeFinishTime(uint nodeIndex) external view returns (uint);\n    function isNodeLeft(uint nodeIndex) external view returns (bool);\n    function isNodeInMaintenance(uint nodeIndex) external view returns (bool);\n    function getNodeLastRewardDate(uint nodeIndex) external view returns (uint);\n    function getNodeNextRewardDate(uint nodeIndex) external view returns (uint);\n    function getNumberOfNodes() external view returns (uint);\n    function getNumberOnlineNodes() external view returns (uint);\n    function getActiveNodeIds() external view returns (uint[] memory activeNodeIds);\n    function getNodeStatus(uint nodeIndex) external view returns (NodeStatus);\n    function getValidatorNodeIndexes(uint validatorId) external view returns (uint[] memory);\n    function countNodesWithFreeSpace(uint8 freeSpace) external view returns (uint count);\n    function getValidatorId(uint nodeIndex) external view returns (uint);\n    function isNodeExist(address from, uint nodeIndex) external view returns (bool);\n    function isNodeActive(uint nodeIndex) external view returns (bool);\n    function isNodeLeaving(uint nodeIndex) external view returns (bool);\n}\n"
+            },
             "@skalenetwork/skale-manager-interfaces/ISchains.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchains.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchains {\n\n    struct SchainOption {\n        string name;\n        bytes value;\n    }\n    \n    /**\n     * @dev Emitted when an schain is created.\n     */\n    event SchainCreated(\n        string name,\n        address owner,\n        uint partOfNode,\n        uint lifetime,\n        uint numberOfNodes,\n        uint deposit,\n        uint16 nonce,\n        bytes32 schainHash\n    );\n\n    /**\n     * @dev Emitted when an schain is deleted.\n     */\n    event SchainDeleted(\n        address owner,\n        string name,\n        bytes32 indexed schainHash\n    );\n\n    /**\n     * @dev Emitted when a node in an schain is rotated.\n     */\n    event NodeRotated(\n        bytes32 schainHash,\n        uint oldNode,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a node is added to an schain.\n     */\n    event NodeAdded(\n        bytes32 schainHash,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a group of nodes is created for an schain.\n     */\n    event SchainNodes(\n        string name,\n        bytes32 schainHash,\n        uint[] nodesInGroup\n    );\n\n    function addSchain(address from, uint deposit, bytes calldata data) external;\n    function addSchainByFoundation(\n        uint lifetime,\n        uint8 typeOfSchain,\n        uint16 nonce,\n        string calldata name,\n        address schainOwner,\n        address schainOriginator,\n        SchainOption[] calldata options\n    )\n        external\n        payable;\n    function deleteSchain(address from, string calldata name) external;\n    function deleteSchainByRoot(string calldata name) external;\n    function restartSchainCreation(string calldata name) external;\n    function verifySchainSignature(\n        uint256 signA,\n        uint256 signB,\n        bytes32 hash,\n        uint256 counter,\n        uint256 hashA,\n        uint256 hashB,\n        string calldata schainName\n    )\n        external\n        view\n        returns (bool);\n    function getSchainPrice(uint typeOfSchain, uint lifetime) external view returns (uint);\n    function getOption(bytes32 schainHash, string calldata optionName) external view returns (bytes memory);\n    function getOptions(bytes32 schainHash) external view returns (SchainOption[] memory);\n}"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchains.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchains {\n\n    struct SchainOption {\n        string name;\n        bytes value;\n    }\n    \n    /**\n     * @dev Emitted when an schain is created.\n     */\n    event SchainCreated(\n        string name,\n        address owner,\n        uint partOfNode,\n        uint lifetime,\n        uint numberOfNodes,\n        uint deposit,\n        uint16 nonce,\n        bytes32 schainHash\n    );\n\n    /**\n     * @dev Emitted when an schain is deleted.\n     */\n    event SchainDeleted(\n        address owner,\n        string name,\n        bytes32 indexed schainHash\n    );\n\n    /**\n     * @dev Emitted when a node in an schain is rotated.\n     */\n    event NodeRotated(\n        bytes32 schainHash,\n        uint oldNode,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a node is added to an schain.\n     */\n    event NodeAdded(\n        bytes32 schainHash,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a group of nodes is created for an schain.\n     */\n    event SchainNodes(\n        string name,\n        bytes32 schainHash,\n        uint[] nodesInGroup\n    );\n\n    function addSchain(address from, uint deposit, bytes calldata data) external;\n    function addSchainByFoundation(\n        uint lifetime,\n        uint8 typeOfSchain,\n        uint16 nonce,\n        string calldata name,\n        address schainOwner,\n        address schainOriginator,\n        SchainOption[] calldata options\n    )\n        external\n        payable;\n    function deleteSchain(address from, string calldata name) external;\n    function deleteSchainByRoot(string calldata name) external;\n    function restartSchainCreation(string calldata name) external;\n    function verifySchainSignature(\n        uint256 signA,\n        uint256 signB,\n        bytes32 hash,\n        uint256 counter,\n        uint256 hashA,\n        uint256 hashB,\n        string calldata schainName\n    )\n        external\n        view\n        returns (bool);\n    function getSchainPrice(uint typeOfSchain, uint lifetime) external view returns (uint);\n    function getOption(bytes32 schainHash, string calldata optionName) external view returns (bytes memory);\n    function getOptions(bytes32 schainHash) external view returns (SchainOption[] memory);\n}\n"
             },
             "@skalenetwork/skale-manager-interfaces/ISchainsInternal.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchainsInternal - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchainsInternal {\n    struct Schain {\n        string name;\n        address owner;\n        uint indexInOwnerList;\n        uint8 partOfNode;\n        uint lifetime;\n        uint startDate;\n        uint startBlock;\n        uint deposit;\n        uint64 index;\n        uint generation;\n        address originator;\n    }\n\n    struct SchainType {\n        uint8 partOfNode;\n        uint numberOfNodes;\n    }\n\n    /**\n     * @dev Emitted when schain type added.\n     */\n    event SchainTypeAdded(uint indexed schainType, uint partOfNode, uint numberOfNodes);\n\n    /**\n     * @dev Emitted when schain type removed.\n     */\n    event SchainTypeRemoved(uint indexed schainType);\n\n    function initializeSchain(\n        string calldata name,\n        address from,\n        address originator,\n        uint lifetime,\n        uint deposit) external;\n    function createGroupForSchain(\n        bytes32 schainHash,\n        uint numberOfNodes,\n        uint8 partOfNode\n    )\n        external\n        returns (uint[] memory);\n    function changeLifetime(bytes32 schainHash, uint lifetime, uint deposit) external;\n    function removeSchain(bytes32 schainHash, address from) external;\n    function removeNodeFromSchain(uint nodeIndex, bytes32 schainHash) external;\n    function deleteGroup(bytes32 schainHash) external;\n    function setException(bytes32 schainHash, uint nodeIndex) external;\n    function setNodeInGroup(bytes32 schainHash, uint nodeIndex) external;\n    function removeHolesForSchain(bytes32 schainHash) external;\n    function addSchainType(uint8 partOfNode, uint numberOfNodes) external;\n    function removeSchainType(uint typeOfSchain) external;\n    function setNumberOfSchainTypes(uint newNumberOfSchainTypes) external;\n    function removeNodeFromAllExceptionSchains(uint nodeIndex) external;\n    function removeAllNodesFromSchainExceptions(bytes32 schainHash) external;\n    function makeSchainNodesInvisible(bytes32 schainHash) external;\n    function makeSchainNodesVisible(bytes32 schainHash) external;\n    function newGeneration() external;\n    function addSchainForNode(uint nodeIndex, bytes32 schainHash) external;\n    function removeSchainForNode(uint nodeIndex, uint schainIndex) external;\n    function removeNodeFromExceptions(bytes32 schainHash, uint nodeIndex) external;\n    function isSchainActive(bytes32 schainHash) external view returns (bool);\n    function schainsAtSystem(uint index) external view returns (bytes32);\n    function numberOfSchains() external view returns (uint64);\n    function getSchains() external view returns (bytes32[] memory);\n    function getSchainsPartOfNode(bytes32 schainHash) external view returns (uint8);\n    function getSchainListSize(address from) external view returns (uint);\n    function getSchainHashesByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainIdsByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainHashesForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainIdsForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainOwner(bytes32 schainHash) external view returns (address);\n    function getSchainOriginator(bytes32 schainHash) external view returns (address);\n    function isSchainNameAvailable(string calldata name) external view returns (bool);\n    function isTimeExpired(bytes32 schainHash) external view returns (bool);\n    function isOwnerAddress(address from, bytes32 schainId) external view returns (bool);\n    function getSchainName(bytes32 schainHash) external view returns (string memory);\n    function getActiveSchain(uint nodeIndex) external view returns (bytes32);\n    function getActiveSchains(uint nodeIndex) external view returns (bytes32[] memory activeSchains);\n    function getNumberOfNodesInGroup(bytes32 schainHash) external view returns (uint);\n    function getNodesInGroup(bytes32 schainHash) external view returns (uint[] memory);\n    function isNodeAddressesInGroup(bytes32 schainId, address sender) external view returns (bool);\n    function getNodeIndexInGroup(bytes32 schainHash, uint nodeId) external view returns (uint);\n    function isAnyFreeNode(bytes32 schainHash) external view returns (bool);\n    function checkException(bytes32 schainHash, uint nodeIndex) external view returns (bool);\n    function checkHoleForSchain(bytes32 schainHash, uint indexOfNode) external view returns (bool);\n    function checkSchainOnNode(uint nodeIndex, bytes32 schainHash) external view returns (bool);\n    function getSchainType(uint typeOfSchain) external view returns(uint8, uint);\n    function getGeneration(bytes32 schainHash) external view returns (uint);\n    function isSchainExist(bytes32 schainHash) external view returns (bool);\n}"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchainsInternal - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"./INodes.sol\";\n\ninterface ISchainsInternal {\n    struct Schain {\n        string name;\n        address owner;\n        uint indexInOwnerList;\n        uint8 partOfNode;\n        uint lifetime;\n        uint startDate;\n        uint startBlock;\n        uint deposit;\n        uint64 index;\n        uint generation;\n        address originator;\n    }\n\n    struct SchainType {\n        uint8 partOfNode;\n        uint numberOfNodes;\n    }\n\n    /**\n     * @dev Emitted when schain type added.\n     */\n    event SchainTypeAdded(uint indexed schainType, uint partOfNode, uint numberOfNodes);\n\n    /**\n     * @dev Emitted when schain type removed.\n     */\n    event SchainTypeRemoved(uint indexed schainType);\n\n    function initializeSchain(\n        string calldata name,\n        address from,\n        address originator,\n        uint lifetime,\n        uint deposit) external;\n    function createGroupForSchain(\n        bytes32 schainHash,\n        uint numberOfNodes,\n        uint8 partOfNode\n    )\n        external\n        returns (uint[] memory);\n    function changeLifetime(bytes32 schainHash, uint lifetime, uint deposit) external;\n    function removeSchain(bytes32 schainHash, address from) external;\n    function removeNodeFromSchain(uint nodeIndex, bytes32 schainHash) external;\n    function deleteGroup(bytes32 schainHash) external;\n    function setException(bytes32 schainHash, uint nodeIndex) external;\n    function setNodeInGroup(bytes32 schainHash, uint nodeIndex) external;\n    function removeHolesForSchain(bytes32 schainHash) external;\n    function addSchainType(uint8 partOfNode, uint numberOfNodes) external;\n    function removeSchainType(uint typeOfSchain) external;\n    function setNumberOfSchainTypes(uint newNumberOfSchainTypes) external;\n    function removeNodeFromAllExceptionSchains(uint nodeIndex) external;\n    function removeAllNodesFromSchainExceptions(bytes32 schainHash) external;\n    function makeSchainNodesInvisible(bytes32 schainHash) external;\n    function makeSchainNodesVisible(bytes32 schainHash) external;\n    function newGeneration() external;\n    function addSchainForNode(INodes nodes,uint nodeIndex, bytes32 schainHash) external;\n    function removeSchainForNode(uint nodeIndex, uint schainIndex) external;\n    function removeNodeFromExceptions(bytes32 schainHash, uint nodeIndex) external;\n    function isSchainActive(bytes32 schainHash) external view returns (bool);\n    function schainsAtSystem(uint index) external view returns (bytes32);\n    function numberOfSchains() external view returns (uint64);\n    function getSchains() external view returns (bytes32[] memory);\n    function getSchainsPartOfNode(bytes32 schainHash) external view returns (uint8);\n    function getSchainListSize(address from) external view returns (uint);\n    function getSchainHashesByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainHashesForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainOwner(bytes32 schainHash) external view returns (address);\n    function getSchainOriginator(bytes32 schainHash) external view returns (address);\n    function isSchainNameAvailable(string calldata name) external view returns (bool);\n    function isTimeExpired(bytes32 schainHash) external view returns (bool);\n    function isOwnerAddress(address from, bytes32 schainHash) external view returns (bool);\n    function getSchainName(bytes32 schainHash) external view returns (string memory);\n    function getActiveSchain(uint nodeIndex) external view returns (bytes32);\n    function getActiveSchains(uint nodeIndex) external view returns (bytes32[] memory activeSchains);\n    function getNumberOfNodesInGroup(bytes32 schainHash) external view returns (uint);\n    function getNodesInGroup(bytes32 schainHash) external view returns (uint[] memory);\n    function isNodeAddressesInGroup(bytes32 schainHash, address sender) external view returns (bool);\n    function getNodeIndexInGroup(bytes32 schainHash, uint nodeHash) external view returns (uint);\n    function isAnyFreeNode(bytes32 schainHash) external view returns (bool);\n    function checkException(bytes32 schainHash, uint nodeIndex) external view returns (bool);\n    function checkHoleForSchain(bytes32 schainHash, uint indexOfNode) external view returns (bool);\n    function checkSchainOnNode(uint nodeIndex, bytes32 schainHash) external view returns (bool);\n    function getSchainType(uint typeOfSchain) external view returns(uint8, uint);\n    function getGeneration(bytes32 schainHash) external view returns (uint);\n    function isSchainExist(bytes32 schainHash) external view returns (bool);\n}"
             },
             "@skalenetwork/skale-manager-interfaces/IWallets.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IWallets - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IWallets {\n    /**\n     * @dev Emitted when the validator wallet was funded\n     */\n    event ValidatorWalletRecharged(address sponsor, uint amount, uint validatorId);\n\n    /**\n     * @dev Emitted when the schain wallet was funded\n     */\n    event SchainWalletRecharged(address sponsor, uint amount, bytes32 schainHash);\n\n    /**\n     * @dev Emitted when the node received a refund from validator to its wallet\n     */\n    event NodeRefundedByValidator(address node, uint validatorId, uint amount);\n\n    /**\n     * @dev Emitted when the node received a refund from schain to its wallet\n     */\n    event NodeRefundedBySchain(address node, bytes32 schainHash, uint amount);\n\n    /**\n     * @dev Emitted when the validator withdrawn funds from validator wallet\n     */\n    event WithdrawFromValidatorWallet(uint indexed validatorId, uint amount);\n\n    /**\n     * @dev Emitted when the schain owner withdrawn funds from schain wallet\n     */\n    event WithdrawFromSchainWallet(bytes32 indexed schainHash, uint amount);\n\n    receive() external payable;\n    function refundGasByValidator(uint validatorId, address payable spender, uint spentGas) external;\n    function refundGasByValidatorToSchain(uint validatorId, bytes32 schainHash) external;\n    function refundGasBySchain(bytes32 schainId, address payable spender, uint spentGas, bool isDebt) external;\n    function withdrawFundsFromSchainWallet(address payable schainOwner, bytes32 schainHash) external;\n    function withdrawFundsFromValidatorWallet(uint amount) external;\n    function rechargeValidatorWallet(uint validatorId) external payable;\n    function rechargeSchainWallet(bytes32 schainId) external payable;\n    function getSchainBalance(bytes32 schainHash) external view returns (uint);\n    function getValidatorBalance(uint validatorId) external view returns (uint);\n}\n"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IWallets - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IWallets {\n    receive() external payable;\n    function refundGasByValidator(uint validatorId, address payable spender, uint gasLimit) external;\n    function refundGasByValidatorToSchain(uint validatorId, bytes32 schainHash) external;\n    function refundGasBySchain(bytes32 schainId, address payable spender, uint spentGas, bool isDebt) external;\n    function withdrawFundsFromSchainWallet(address payable schainOwner, bytes32 schainHash) external;\n    function withdrawFundsFromValidatorWallet(uint amount) external;\n    function rechargeValidatorWallet(uint validatorId) external payable;\n    function rechargeSchainWallet(bytes32 schainId) external payable;\n    function getSchainBalance(bytes32 schainHash) external view returns (uint);\n    function getValidatorBalance(uint validatorId) external view returns (uint);\n}\n"
+            },
+            "@skalenetwork/skale-manager-interfaces/utils/IRandom.sol": {
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IRandom.sol - SKALE Manager Interfaces\n    Copyright (C) 2022-Present SKALE Labs\n    @author Dmytro Stebaiev\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\n\ninterface IRandom {\n    struct RandomGenerator {\n        uint seed;\n    }\n}"
             },
             "contracts/MessageProxy.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   MessageProxy.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/IGasReimbursable.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageProxy.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageReceiver.sol\";\n\n\n/**\n * @title MessageProxy\n * @dev Abstract contract for MessageProxyForMainnet and MessageProxyForSchain.\n */\nabstract contract MessageProxy is AccessControlEnumerableUpgradeable, IMessageProxy {\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    /**\n     * @dev Structure that stores counters for outgoing and incoming messages.\n     */\n    struct ConnectedChainInfo {\n        // message counters start with 0\n        uint256 incomingMessageCounter;\n        uint256 outgoingMessageCounter;\n        bool inited;\n        uint256 lastOutgoingMessageBlockId;\n    }\n\n    bytes32 public constant MAINNET_HASH = keccak256(abi.encodePacked(\"Mainnet\"));\n    bytes32 public constant CHAIN_CONNECTOR_ROLE = keccak256(\"CHAIN_CONNECTOR_ROLE\");\n    bytes32 public constant EXTRA_CONTRACT_REGISTRAR_ROLE = keccak256(\"EXTRA_CONTRACT_REGISTRAR_ROLE\");\n    bytes32 public constant CONSTANT_SETTER_ROLE = keccak256(\"CONSTANT_SETTER_ROLE\");\n    uint256 public constant MESSAGES_LENGTH = 10;\n    uint256 public constant REVERT_REASON_LENGTH = 64;\n\n    //   schainHash => ConnectedChainInfo\n    mapping(bytes32 => ConnectedChainInfo) public connectedChains;\n    //   schainHash => contract address => allowed\n    mapping(bytes32 => mapping(address => bool)) private _deprecatedRegistryContracts;\n\n    uint256 public gasLimit;\n\n    /**\n     * @dev Emitted for every outgoing message to schain.\n     */\n    event OutgoingMessage(\n        bytes32 indexed dstChainHash,\n        uint256 indexed msgCounter,\n        address indexed srcContract,\n        address dstContract,\n        bytes data\n    );\n\n    /**\n     * @dev Emitted when function `postMessage` returns revert.\n     *  Used to prevent stuck loop inside function `postIncomingMessages`.\n     */\n    event PostMessageError(\n        uint256 indexed msgCounter,\n        bytes message\n    );\n\n    /**\n     * @dev Emitted when gas limit per one call of `postMessage` was changed.\n     */\n    event GasLimitWasChanged(\n        uint256 oldValue,\n        uint256 newValue\n    );\n\n    /**\n     * @dev Emitted when the version was updated\n     */\n    event VersionUpdated(string oldVersion, string newVersion);\n\n    /**\n     * @dev Emitted when extra contract was added.\n     */\n    event ExtraContractRegistered(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Emitted when extra contract was removed.\n     */\n    event ExtraContractRemoved(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Emitted when referenced to previous outgoing message.\n     */\n    event PreviousMessageReference (\n        uint256 currentMessage,\n        uint256 previousOutgoingMessageBlockId\n    );\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CHAIN_CONNECTOR_ROLE}.\n     */\n    modifier onlyChainConnector() {\n        require(hasRole(CHAIN_CONNECTOR_ROLE, msg.sender), \"CHAIN_CONNECTOR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {EXTRA_CONTRACT_REGISTRAR_ROLE}.\n     */\n    modifier onlyExtraContractRegistrar() {\n        require(hasRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender), \"EXTRA_CONTRACT_REGISTRAR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CONSTANT_SETTER_ROLE}.\n     */\n    modifier onlyConstantSetter() {\n        require(hasRole(CONSTANT_SETTER_ROLE, msg.sender), \"Not enough permissions to set constant\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {DEFAULT_ADMIN_ROLE}.\n     */\n    modifier onlyOwner() {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"DEFAULT_ADMIN_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Sets gasLimit to a new value.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CONSTANT_SETTER_ROLE.\n     */\n    function setNewGasLimit(uint256 newGasLimit) external override onlyConstantSetter {\n        emit GasLimitWasChanged(gasLimit, newGasLimit);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Virtual function for `postIncomingMessages`.\n     */\n    function postIncomingMessages(\n        string calldata fromSchainName,\n        uint256 startingCounter,\n        Message[] calldata messages,\n        Signature calldata sign\n    )\n        external\n        virtual\n        override;\n\n    /**\n     * @dev Allows `msg.sender` to register extra contract for all schains\n     * for being able to transfer messages from custom contracts.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     * - Passed address should be contract.\n     * - Extra contract must not be registered.\n     */\n    function registerExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is already registered\");\n        _getRegistryContracts()[bytes32(0)].add(extraContract);\n        emit ExtraContractRegistered(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Allows `msg.sender` to remove extra contract for all schains.\n     * Extra contract will no longer be able to send messages through MessageProxy.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     */\n    function removeExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[bytes32(0)].remove(extraContract);\n        emit ExtraContractRemoved(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Should return length of contract registered by schainHash.\n     */\n    function getContractRegisteredLength(bytes32 schainHash) external view override returns (uint256) {\n        return _getRegistryContracts()[schainHash].length();\n    }\n\n    /**\n     * @dev Should return a range of contracts registered by schainHash.\n     *\n     * Requirements:\n     * range should be less or equal 10 contracts\n     */\n    function getContractRegisteredRange(\n        bytes32 schainHash,\n        uint256 from,\n        uint256 to\n    )\n        external\n        view\n        override\n        returns (address[] memory contractsInRange)\n    {\n        require(\n            from < to && to - from <= 10 && to <= _getRegistryContracts()[schainHash].length(),\n            \"Range is incorrect\"\n        );\n        contractsInRange = new address[](to - from);\n        for (uint256 i = from; i < to; i++) {\n            contractsInRange[i - from] = _getRegistryContracts()[schainHash].at(i);\n        }\n    }\n\n    /**\n     * @dev Returns number of outgoing messages.\n     *\n     * Requirements:\n     *\n     * - Target schain  must be initialized.\n     */\n    function getOutgoingMessagesCounter(string calldata targetSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 dstChainHash = keccak256(abi.encodePacked(targetSchainName));\n        require(connectedChains[dstChainHash].inited, \"Destination chain is not initialized\");\n        return connectedChains[dstChainHash].outgoingMessageCounter;\n    }\n\n\n    /**\n     * @dev Should return block number of the last message transferred to schain\n     */\n    function getLastOutgoingMessageBlockId(string memory targetSchainName) external view override returns (uint) {\n        bytes32 dstChainHash = keccak256(abi.encodePacked(targetSchainName));\n        require(connectedChains[dstChainHash].inited, \"Destination chain is not initialized\");\n        return connectedChains[dstChainHash].lastOutgoingMessageBlockId;\n    }\n\n    /**\n     * @dev Returns number of incoming messages.\n     *\n     * Requirements:\n     *\n     * - Source schain must be initialized.\n     */\n    function getIncomingMessagesCounter(string calldata fromSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 srcChainHash = keccak256(abi.encodePacked(fromSchainName));\n        require(connectedChains[srcChainHash].inited, \"Source chain is not initialized\");\n        return connectedChains[srcChainHash].incomingMessageCounter;\n    }\n\n    function initializeMessageProxy(uint newGasLimit) public initializer {\n        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(CHAIN_CONNECTOR_ROLE, msg.sender);\n        _setupRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender);\n        _setupRole(CONSTANT_SETTER_ROLE, msg.sender);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Posts message from this contract to `targetChainHash` MessageProxy contract.\n     * This is called by a smart contract to make a cross-chain call.\n     *\n     * Emits an {OutgoingMessage} event.\n     *\n     * Requirements:\n     *\n     * - Target chain must be initialized.\n     * - Target chain must be registered as external contract.\n     */\n    function postOutgoingMessage(\n        bytes32 targetChainHash,\n        address targetContract,\n        bytes memory data\n    )\n        public\n        override\n        virtual\n    {\n        require(connectedChains[targetChainHash].inited, \"Destination chain is not initialized\");\n        _authorizeOutgoingMessageSender(targetChainHash);\n\n        uint outgoingMessageCounter = connectedChains[targetChainHash].outgoingMessageCounter;\n        emit OutgoingMessage(\n            targetChainHash,\n            outgoingMessageCounter,\n            msg.sender,\n            targetContract,\n            data\n        );\n        emit PreviousMessageReference(\n            outgoingMessageCounter,\n            connectedChains[targetChainHash].lastOutgoingMessageBlockId\n        );\n        connectedChains[targetChainHash].outgoingMessageCounter++;\n        connectedChains[targetChainHash].lastOutgoingMessageBlockId = block.number;\n    }\n\n    /**\n     * @dev Allows CHAIN_CONNECTOR_ROLE to remove connected chain from this contract.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CHAIN_CONNECTOR_ROLE.\n     * - `schainName` must be initialized.\n     */\n    function removeConnectedChain(string memory schainName) public virtual override onlyChainConnector {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(connectedChains[schainHash].inited, \"Chain is not initialized\");\n        delete connectedChains[schainHash];\n    }\n\n    /**\n     * @dev Checks whether chain is currently connected.\n     */\n    function isConnectedChain(\n        string memory schainName\n    )\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return connectedChains[keccak256(abi.encodePacked(schainName))].inited;\n    }\n\n    /**\n     * @dev Checks whether contract is currently registered as extra contract.\n     */\n    function isContractRegistered(\n        bytes32 schainHash,\n        address contractAddress\n    )\n        public\n        view\n        override\n        returns (bool)\n    {\n        return _getRegistryContracts()[schainHash].contains(contractAddress);\n    }\n\n    /**\n     * @dev Allows MessageProxy to register extra contract for being able to transfer messages from custom contracts.\n     *\n     * Requirements:\n     *\n     * - Extra contract address must be contract.\n     * - Extra contract must not be registered.\n     * - Extra contract must not be registered for all chains.\n     */\n    function _registerExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {\n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is already registered\");\n        require(\n            !_getRegistryContracts()[bytes32(0)].contains(extraContract),\n            \"Extra contract is already registered for all chains\"\n        );\n\n        _getRegistryContracts()[chainHash].add(extraContract);\n        emit ExtraContractRegistered(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to remove extra contract,\n     * thus `extraContract` will no longer be available to transfer messages from mainnet to schain.\n     *\n     * Requirements:\n     *\n     * - Extra contract must be registered.\n     */\n    function _removeExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {\n        require(_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[chainHash].remove(extraContract);\n        emit ExtraContractRemoved(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to connect schain with MessageProxyOnMainnet for transferring messages.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CHAIN_CONNECTOR_ROLE.\n     * - SKALE chain must not be connected.\n     */\n    function _addConnectedChain(bytes32 schainHash) internal onlyChainConnector {\n        require(!connectedChains[schainHash].inited,\"Chain is already connected\");\n        connectedChains[schainHash] = ConnectedChainInfo({\n            incomingMessageCounter: 0,\n            outgoingMessageCounter: 0,\n            inited: true,\n            lastOutgoingMessageBlockId: 0\n        });\n    }\n\n    /**\n     * @dev Allows MessageProxy to send messages from schain to mainnet.\n     * Destination contract must implement `postMessage` method.\n     */\n    function _callReceiverContract(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n    {\n        if (!message.destinationContract.isContract()) {\n            emit PostMessageError(\n                counter,\n                \"Destination contract is not a contract\"\n            );\n            return;\n        }\n        try IMessageReceiver(message.destinationContract).postMessage{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) {\n            return;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                _getSlice(bytes(reason), REVERT_REASON_LENGTH)\n            );\n        } catch Panic(uint errorCode) {\n               emit PostMessageError(\n                counter,\n                abi.encodePacked(errorCode)\n            );\n        } catch (bytes memory revertData) {\n            emit PostMessageError(\n                counter,\n                _getSlice(revertData, REVERT_REASON_LENGTH)\n            );\n        }\n    }\n\n    /**\n     * @dev Returns receiver of message.\n     */\n    function _getGasPayer(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n        returns (address)\n    {\n        try IGasReimbursable(message.destinationContract).gasPayer{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) returns (address receiver) {\n            return receiver;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                _getSlice(bytes(reason), REVERT_REASON_LENGTH)\n            );\n            return address(0);\n        } catch Panic(uint errorCode) {\n               emit PostMessageError(\n                counter,\n                abi.encodePacked(errorCode)\n            );\n            return address(0);\n        } catch (bytes memory revertData) {\n            emit PostMessageError(\n                counter,\n                _getSlice(revertData, REVERT_REASON_LENGTH)\n            );\n            return address(0);\n        }\n    }\n\n    /**\n     * @dev Checks whether msg.sender is registered as custom extra contract.\n     */\n    function _authorizeOutgoingMessageSender(bytes32 targetChainHash) internal view virtual {\n        require(\n            isContractRegistered(bytes32(0), msg.sender) || isContractRegistered(targetChainHash, msg.sender),\n            \"Sender contract is not registered\"\n        );\n    }\n\n    /**\n     * @dev Returns list of registered custom extra contracts.\n     */\n    function _getRegistryContracts()\n        internal\n        view\n        virtual\n        returns (mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) storage);\n\n    /**\n     * @dev Returns hash of message array.\n     */\n    function _hashedArray(\n        Message[] calldata messages,\n        uint256 startingCounter,\n        string calldata fromChainName\n    )\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32 sourceHash = keccak256(abi.encodePacked(fromChainName));\n        bytes32 hash = keccak256(abi.encodePacked(sourceHash, bytes32(startingCounter)));\n        for (uint256 i = 0; i < messages.length; i++) {\n            hash = keccak256(\n                abi.encodePacked(\n                    abi.encode(\n                        hash,\n                        messages[i].sender,\n                        messages[i].destinationContract\n                    ),\n                    messages[i].data\n                )\n            );\n        }\n        return hash;\n    }\n\n    function _getSlice(bytes memory text, uint end) private pure returns (bytes memory) {\n        uint slicedEnd = end < text.length ? end : text.length;\n        bytes memory sliced = new bytes(slicedEnd);\n        for(uint i = 0; i < slicedEnd; i++){\n            sliced[i] = text[i];\n        }\n        return sliced;\n    }\n}\n"
             },
             "contracts/Messages.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   Messages.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\n\n/**\n * @title Messages\n * @dev Library for encoding and decoding messages\n * for transferring from Mainnet to Schain and vice versa.\n */\nlibrary Messages {\n\n    /**\n     * @dev Enumerator that describes all supported message types.\n     */\n    enum MessageType {\n        EMPTY,\n        TRANSFER_ETH,\n        TRANSFER_ERC20,\n        TRANSFER_ERC20_AND_TOTAL_SUPPLY,\n        TRANSFER_ERC20_AND_TOKEN_INFO,\n        TRANSFER_ERC721,\n        TRANSFER_ERC721_AND_TOKEN_INFO,\n        USER_STATUS,\n        INTERCHAIN_CONNECTION,\n        TRANSFER_ERC1155,\n        TRANSFER_ERC1155_AND_TOKEN_INFO,\n        TRANSFER_ERC1155_BATCH,\n        TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO,\n        TRANSFER_ERC721_WITH_METADATA,\n        TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO\n    }\n\n    /**\n     * @dev Structure for base message.\n     */\n    struct BaseMessage {\n        MessageType messageType;\n    }\n\n    /**\n     * @dev Structure for describing ETH.\n     */\n    struct TransferEthMessage {\n        BaseMessage message;\n        address receiver;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for user status.\n     */\n    struct UserStatusMessage {\n        BaseMessage message;\n        address receiver;\n        bool isActive;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 token.\n     */\n    struct TransferErc20Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC20 token.\n     */\n    struct Erc20TokenInfo {\n        string name;\n        uint8 decimals;\n        string symbol;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token supply.\n     */\n    struct TransferErc20AndTotalSupplyMessage {\n        TransferErc20Message baseErc20transfer;\n        uint256 totalSupply;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token info.\n     */\n    struct TransferErc20AndTokenInfoMessage {\n        TransferErc20Message baseErc20transfer;\n        uint256 totalSupply;\n        Erc20TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing base ERC721.\n     */\n    struct TransferErc721Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 tokenId;\n    }\n\n    /**\n     * @dev Structure for describing base ERC721 with metadata.\n     */\n    struct TransferErc721MessageWithMetadata {\n        TransferErc721Message erc721message;\n        string tokenURI;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token info.\n     */\n    struct Erc721TokenInfo {\n        string name;\n        string symbol;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC721 token.\n     */\n    struct TransferErc721AndTokenInfoMessage {\n        TransferErc721Message baseErc721transfer;\n        Erc721TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC721 token with metadata.\n     */\n    struct TransferErc721WithMetadataAndTokenInfoMessage {\n        TransferErc721MessageWithMetadata baseErc721transferWithMetadata;\n        Erc721TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing whether interchain connection is allowed.\n     */\n    struct InterchainConnectionMessage {\n        BaseMessage message;\n        bool isAllowed;\n    }\n\n    /**\n     * @dev Structure for describing whether interchain connection is allowed.\n     */\n    struct TransferErc1155Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 id;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for describing ERC1155 token in batches.\n     */\n    struct TransferErc1155BatchMessage {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256[] ids;\n        uint256[] amounts;\n    }\n\n    /**\n     * @dev Structure for describing ERC1155 token info.\n     */\n    struct Erc1155TokenInfo {\n        string uri;\n    }\n\n    /**\n     * @dev Structure for describing message for transferring ERC1155 token with info.\n     */\n    struct TransferErc1155AndTokenInfoMessage {\n        TransferErc1155Message baseErc1155transfer;\n        Erc1155TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing message for transferring ERC1155 token in batches with info.\n     */\n    struct TransferErc1155BatchAndTokenInfoMessage {\n        TransferErc1155BatchMessage baseErc1155Batchtransfer;\n        Erc1155TokenInfo tokenInfo;\n    }\n\n\n    /**\n     * @dev Returns type of message for encoded data.\n     */\n    function getMessageType(bytes calldata data) internal pure returns (MessageType) {\n        uint256 firstWord = abi.decode(data, (uint256));\n        if (firstWord % 32 == 0) {\n            return getMessageType(data[firstWord:]);\n        } else {\n            return abi.decode(data, (Messages.MessageType));\n        }\n    }\n\n    /**\n     * @dev Encodes message for transferring ETH. Returns encoded message.\n     */\n    function encodeTransferEthMessage(address receiver, uint256 amount) internal pure returns (bytes memory) {\n        TransferEthMessage memory message = TransferEthMessage(\n            BaseMessage(MessageType.TRANSFER_ETH),\n            receiver,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ETH. Returns structure `TransferEthMessage`.\n     */\n    function decodeTransferEthMessage(\n        bytes calldata data\n    ) internal pure returns (TransferEthMessage memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ETH, \"Message type is not ETH transfer\");\n        return abi.decode(data, (TransferEthMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ETH. Returns encoded message.\n     */\n    function encodeTransferErc20Message(\n        address token,\n        address receiver,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        TransferErc20Message memory message = TransferErc20Message(\n            BaseMessage(MessageType.TRANSFER_ERC20),\n            token,\n            receiver,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC20 with total supply. Returns encoded message.\n     */\n    function encodeTransferErc20AndTotalSupplyMessage(\n        address token,\n        address receiver,\n        uint256 amount,\n        uint256 totalSupply\n    ) internal pure returns (bytes memory) {\n        TransferErc20AndTotalSupplyMessage memory message = TransferErc20AndTotalSupplyMessage(\n            TransferErc20Message(\n                BaseMessage(MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY),\n                token,\n                receiver,\n                amount\n            ),\n            totalSupply\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20. Returns structure `TransferErc20Message`.\n     */\n    function decodeTransferErc20Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc20Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC20, \"Message type is not ERC20 transfer\");\n        return abi.decode(data, (TransferErc20Message));\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20 with total supply. \n     * Returns structure `TransferErc20AndTotalSupplyMessage`.\n     */\n    function decodeTransferErc20AndTotalSupplyMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc20AndTotalSupplyMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY,\n            \"Message type is not ERC20 transfer and total supply\"\n        );\n        return abi.decode(data, (TransferErc20AndTotalSupplyMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC20 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc20AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 amount,\n        uint256 totalSupply,\n        Erc20TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc20AndTokenInfoMessage memory message = TransferErc20AndTokenInfoMessage(\n            TransferErc20Message(\n                BaseMessage(MessageType.TRANSFER_ERC20_AND_TOKEN_INFO),\n                token,\n                receiver,\n                amount\n            ),\n            totalSupply,\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20 with token info. \n     * Returns structure `TransferErc20AndTokenInfoMessage`.\n     */\n    function decodeTransferErc20AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc20AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC20_AND_TOKEN_INFO,\n            \"Message type is not ERC20 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc20AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721Message(\n        address token,\n        address receiver,\n        uint256 tokenId\n    ) internal pure returns (bytes memory) {\n        TransferErc721Message memory message = TransferErc721Message(\n            BaseMessage(MessageType.TRANSFER_ERC721),\n            token,\n            receiver,\n            tokenId\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721. \n     * Returns structure `TransferErc721Message`.\n     */\n    function decodeTransferErc721Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc721Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC721, \"Message type is not ERC721 transfer\");\n        return abi.decode(data, (TransferErc721Message));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        Erc721TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc721AndTokenInfoMessage memory message = TransferErc721AndTokenInfoMessage(\n            TransferErc721Message(\n                BaseMessage(MessageType.TRANSFER_ERC721_AND_TOKEN_INFO),\n                token,\n                receiver,\n                tokenId\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721 with token info. \n     * Returns structure `TransferErc721AndTokenInfoMessage`.\n     */\n    function decodeTransferErc721AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc721AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_AND_TOKEN_INFO,\n            \"Message type is not ERC721 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc721AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721MessageWithMetadata(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        string memory tokenURI\n    ) internal pure returns (bytes memory) {\n        TransferErc721MessageWithMetadata memory message = TransferErc721MessageWithMetadata(\n            TransferErc721Message(\n                BaseMessage(MessageType.TRANSFER_ERC721_WITH_METADATA),\n                token,\n                receiver,\n                tokenId\n            ),\n            tokenURI\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721. \n     * Returns structure `TransferErc721MessageWithMetadata`.\n     */\n    function decodeTransferErc721MessageWithMetadata(\n        bytes calldata data\n    ) internal pure returns (TransferErc721MessageWithMetadata memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_WITH_METADATA,\n            \"Message type is not ERC721 transfer\"\n        );\n        return abi.decode(data, (TransferErc721MessageWithMetadata));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721WithMetadataAndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        string memory tokenURI,\n        Erc721TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc721WithMetadataAndTokenInfoMessage memory message = TransferErc721WithMetadataAndTokenInfoMessage(\n            TransferErc721MessageWithMetadata(\n                TransferErc721Message(\n                    BaseMessage(MessageType.TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO),\n                    token,\n                    receiver,\n                    tokenId\n                ),\n                tokenURI\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721 with token info. \n     * Returns structure `TransferErc721WithMetadataAndTokenInfoMessage`.\n     */\n    function decodeTransferErc721WithMetadataAndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc721WithMetadataAndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO,\n            \"Message type is not ERC721 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc721WithMetadataAndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for activating user on schain. \n     * Returns encoded message.\n     */\n    function encodeActivateUserMessage(address receiver) internal pure returns (bytes memory){\n        return _encodeUserStatusMessage(receiver, true);\n    }\n\n    /**\n     * @dev Encodes message for locking user on schain. \n     * Returns encoded message.\n     */\n    function encodeLockUserMessage(address receiver) internal pure returns (bytes memory){\n        return _encodeUserStatusMessage(receiver, false);\n    }\n\n    /**\n     * @dev Decodes message for user status. \n     * Returns structure UserStatusMessage.\n     */\n    function decodeUserStatusMessage(bytes calldata data) internal pure returns (UserStatusMessage memory) {\n        require(getMessageType(data) == MessageType.USER_STATUS, \"Message type is not User Status\");\n        return abi.decode(data, (UserStatusMessage));\n    }\n\n\n    /**\n     * @dev Encodes message for allowing interchain connection.\n     * Returns encoded message.\n     */\n    function encodeInterchainConnectionMessage(bool isAllowed) internal pure returns (bytes memory) {\n        InterchainConnectionMessage memory message = InterchainConnectionMessage(\n            BaseMessage(MessageType.INTERCHAIN_CONNECTION),\n            isAllowed\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for allowing interchain connection.\n     * Returns structure `InterchainConnectionMessage`.\n     */\n    function decodeInterchainConnectionMessage(bytes calldata data)\n        internal\n        pure\n        returns (InterchainConnectionMessage memory)\n    {\n        require(getMessageType(data) == MessageType.INTERCHAIN_CONNECTION, \"Message type is not Interchain connection\");\n        return abi.decode(data, (InterchainConnectionMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155Message(\n        address token,\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        TransferErc1155Message memory message = TransferErc1155Message(\n            BaseMessage(MessageType.TRANSFER_ERC1155),\n            token,\n            receiver,\n            id,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token.\n     * Returns structure `TransferErc1155Message`.\n     */\n    function decodeTransferErc1155Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC1155, \"Message type is not ERC1155 transfer\");\n        return abi.decode(data, (TransferErc1155Message));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 with token info.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 id,\n        uint256 amount,\n        Erc1155TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc1155AndTokenInfoMessage memory message = TransferErc1155AndTokenInfoMessage(\n            TransferErc1155Message(\n                BaseMessage(MessageType.TRANSFER_ERC1155_AND_TOKEN_INFO),\n                token,\n                receiver,\n                id,\n                amount\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 with token info.\n     * Returns structure `TransferErc1155AndTokenInfoMessage`.\n     */\n    function decodeTransferErc1155AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_AND_TOKEN_INFO,\n            \"Message type is not ERC1155AndTokenInfo transfer\"\n        );\n        return abi.decode(data, (TransferErc1155AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token in batches.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155BatchMessage(\n        address token,\n        address receiver,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal pure returns (bytes memory) {\n        TransferErc1155BatchMessage memory message = TransferErc1155BatchMessage(\n            BaseMessage(MessageType.TRANSFER_ERC1155_BATCH),\n            token,\n            receiver,\n            ids,\n            amounts\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token in batches.\n     * Returns structure `TransferErc1155BatchMessage`.\n     */\n    function decodeTransferErc1155BatchMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155BatchMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_BATCH,\n            \"Message type is not ERC1155Batch transfer\"\n        );\n        return abi.decode(data, (TransferErc1155BatchMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token in batches with token info.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155BatchAndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        Erc1155TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc1155BatchAndTokenInfoMessage memory message = TransferErc1155BatchAndTokenInfoMessage(\n            TransferErc1155BatchMessage(\n                BaseMessage(MessageType.TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO),\n                token,\n                receiver,\n                ids,\n                amounts\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token in batches with token info.\n     * Returns structure `TransferErc1155BatchAndTokenInfoMessage`.\n     */\n    function decodeTransferErc1155BatchAndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155BatchAndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO,\n            \"Message type is not ERC1155BatchAndTokenInfo transfer\"\n        );\n        return abi.decode(data, (TransferErc1155BatchAndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring user status on schain.\n     * Returns encoded message.\n     */\n    function _encodeUserStatusMessage(address receiver, bool isActive) private pure returns (bytes memory) {\n        UserStatusMessage memory message = UserStatusMessage(\n            BaseMessage(MessageType.USER_STATUS),\n            receiver,\n            isActive\n        );\n        return abi.encode(message);\n    }\n\n}"
             },
@@ -403,11 +409,11 @@
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   RevertableERC20.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2022-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\ninterface IRevertableERC20 {\n    function enable() external;\n    function disable() external;\n    function mint(address account, uint amount) external;\n}\n\ncontract RevertableERC20 is IRevertableERC20, ERC20Upgradeable {\n    bool public enabled = true;\n\n    constructor(string memory name, string memory symbol) initializer {\n        super.__ERC20_init(name, symbol);\n    }\n\n    function enable() external override {\n        enabled = true;\n    }\n\n    function disable() external override {\n        enabled = false;\n    }\n\n    function mint(address account, uint amount) external override {\n        _mint(account, amount);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    )\n        internal\n        override\n    {\n        require(enabled, \"Transfers are disabled\");\n        super._transfer(from, to, amount);\n    }\n}"
             },
             "contracts/thirdparty/ERC1155ReceiverUpgradeableWithoutGap.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol\";\n\nabstract contract ERC1155ReceiverUpgradeableWithoutGap is\n    Initializable,\n    ERC165Upgradeable,\n    IERC1155ReceiverUpgradeable\n{\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165Upgradeable)\n        returns (bool)\n    {\n        return interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function __ERC1155Receiver_init() internal initializer {\n        __ERC165_init_unchained();\n        __ERC1155Receiver_init_unchained();\n    }\n\n    // solhint-disable-next-line func-name-mixedcase, no-empty-blocks\n    function __ERC1155Receiver_init_unchained() internal initializer {\n    }\n}"
             }
         }
     },
-    "name": "MessageProxyForSchain",
+    "name": "KeyStorage",
     "solcLongVersion": "0.8.16+commit.07a7930e",
     "solcVersion": "0.8.16"
 }
```

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/TokenManager.json` & `ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/TokenManager.json`

 * *Files identical despite different names*

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/TokenManager.meta.json` & `ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/MessageProxyForSchain.meta.json`

 * *Files 1% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.8745592948717948%*

 * *Differences: {"'input'": "{'sources': {'@skalenetwork/skale-manager-interfaces/IWallets.sol': {'content': '// "*

 * *            'SPDX-License-Identifier: AGPL-3.0-only\\n\\n/*\\n    IWallets - SKALE Manager '*

 * *            'Interfaces\\n    Copyright (C) 2021-Present SKALE Labs\\n    @author Dmytro '*

 * *            'Stebaeiv\\n\\n    SKALE Manager Interfaces is free software: you can redistribute it '*

 * *            'and/or modify\\n    it under the terms of the GNU Affero General Public License as '*

 * *            'published\\n    by […]*

```diff
@@ -218,22 +218,28 @@
             },
             "@skalenetwork/ima-interfaces/schain/tokens/IEthErc20.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   IEthErc20 - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\n\ninterface IEthErc20 {\n    function mint(address account, uint256 amount) external;\n    function forceBurn(address account, uint256 amount) external;\n    function initialize(address tokenManagerEthAddress) external;\n}"
             },
             "@skalenetwork/skale-manager-interfaces/IContractManager.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IContractManager.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IContractManager {\n    /**\n     * @dev Emitted when contract is upgraded.\n     */\n    event ContractUpgraded(string contractsName, address contractsAddress);\n\n    function initialize() external;\n    function setContractsAddress(string calldata contractsName, address newContractsAddress) external;\n    function contracts(bytes32 nameHash) external view returns (address);\n    function getDelegationPeriodManager() external view returns (address);\n    function getBounty() external view returns (address);\n    function getValidatorService() external view returns (address);\n    function getTimeHelpers() external view returns (address);\n    function getConstantsHolder() external view returns (address);\n    function getSkaleToken() external view returns (address);\n    function getTokenState() external view returns (address);\n    function getPunisher() external view returns (address);\n    function getContract(string calldata name) external view returns (address);\n}"
             },
+            "@skalenetwork/skale-manager-interfaces/INodes.sol": {
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    INodes.sol - SKALE Manager\n    Copyright (C) 2018-Present SKALE Labs\n    @author Artem Payvin\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"./utils/IRandom.sol\";\n\ninterface INodes {\n    // All Nodes states\n    enum NodeStatus {Active, Leaving, Left, In_Maintenance}\n\n    struct Node {\n        string name;\n        bytes4 ip;\n        bytes4 publicIP;\n        uint16 port;\n        bytes32[2] publicKey;\n        uint startBlock;\n        uint lastRewardDate;\n        uint finishTime;\n        NodeStatus status;\n        uint validatorId;\n    }\n\n    // struct to note which Nodes and which number of Nodes owned by user\n    struct CreatedNodes {\n        mapping (uint => bool) isNodeExist;\n        uint numberOfNodes;\n    }\n\n    struct SpaceManaging {\n        uint8 freeSpace;\n        uint indexInSpaceMap;\n    }\n\n    struct NodeCreationParams {\n        string name;\n        bytes4 ip;\n        bytes4 publicIp;\n        uint16 port;\n        bytes32[2] publicKey;\n        uint16 nonce;\n        string domainName;\n    }\n    \n    /**\n     * @dev Emitted when a node is created.\n     */\n    event NodeCreated(\n        uint nodeIndex,\n        address owner,\n        string name,\n        bytes4 ip,\n        bytes4 publicIP,\n        uint16 port,\n        uint16 nonce,\n        string domainName\n    );\n\n    /**\n     * @dev Emitted when a node completes a network exit.\n     */\n    event ExitCompleted(\n        uint nodeIndex\n    );\n\n    /**\n     * @dev Emitted when a node begins to exit from the network.\n     */\n    event ExitInitialized(\n        uint nodeIndex,\n        uint startLeavingPeriod\n    );\n\n    /**\n     * @dev Emitted when a node set to in compliant or compliant.\n     */\n    event IncompliantNode(\n        uint indexed nodeIndex,\n        bool status\n    );\n\n    /**\n     * @dev Emitted when a node set to in maintenance or from in maintenance.\n     */\n    event MaintenanceNode(\n        uint indexed nodeIndex,\n        bool status\n    );\n\n    /**\n     * @dev Emitted when a node status changed.\n     */\n    event IPChanged(\n        uint indexed nodeIndex,\n        bytes4 previousIP,\n        bytes4 newIP\n    );\n    \n    function removeSpaceFromNode(uint nodeIndex, uint8 space) external returns (bool);\n    function addSpaceToNode(uint nodeIndex, uint8 space) external;\n    function changeNodeLastRewardDate(uint nodeIndex) external;\n    function changeNodeFinishTime(uint nodeIndex, uint time) external;\n    function createNode(address from, NodeCreationParams calldata params) external;\n    function initExit(uint nodeIndex) external;\n    function completeExit(uint nodeIndex) external returns (bool);\n    function deleteNodeForValidator(uint validatorId, uint nodeIndex) external;\n    function checkPossibilityCreatingNode(address nodeAddress) external;\n    function checkPossibilityToMaintainNode(uint validatorId, uint nodeIndex) external returns (bool);\n    function setNodeInMaintenance(uint nodeIndex) external;\n    function removeNodeFromInMaintenance(uint nodeIndex) external;\n    function setNodeIncompliant(uint nodeIndex) external;\n    function setNodeCompliant(uint nodeIndex) external;\n    function setDomainName(uint nodeIndex, string memory domainName) external;\n    function makeNodeVisible(uint nodeIndex) external;\n    function makeNodeInvisible(uint nodeIndex) external;\n    function changeIP(uint nodeIndex, bytes4 newIP, bytes4 newPublicIP) external;\n    function numberOfActiveNodes() external view returns (uint);\n    function incompliant(uint nodeIndex) external view returns (bool);\n    function getRandomNodeWithFreeSpace(\n        uint8 freeSpace,\n        IRandom.RandomGenerator memory randomGenerator\n    )\n        external\n        view\n        returns (uint);\n    function isTimeForReward(uint nodeIndex) external view returns (bool);\n    function getNodeIP(uint nodeIndex) external view returns (bytes4);\n    function getNodeDomainName(uint nodeIndex) external view returns (string memory);\n    function getNodePort(uint nodeIndex) external view returns (uint16);\n    function getNodePublicKey(uint nodeIndex) external view returns (bytes32[2] memory);\n    function getNodeAddress(uint nodeIndex) external view returns (address);\n    function getNodeFinishTime(uint nodeIndex) external view returns (uint);\n    function isNodeLeft(uint nodeIndex) external view returns (bool);\n    function isNodeInMaintenance(uint nodeIndex) external view returns (bool);\n    function getNodeLastRewardDate(uint nodeIndex) external view returns (uint);\n    function getNodeNextRewardDate(uint nodeIndex) external view returns (uint);\n    function getNumberOfNodes() external view returns (uint);\n    function getNumberOnlineNodes() external view returns (uint);\n    function getActiveNodeIds() external view returns (uint[] memory activeNodeIds);\n    function getNodeStatus(uint nodeIndex) external view returns (NodeStatus);\n    function getValidatorNodeIndexes(uint validatorId) external view returns (uint[] memory);\n    function countNodesWithFreeSpace(uint8 freeSpace) external view returns (uint count);\n    function getValidatorId(uint nodeIndex) external view returns (uint);\n    function isNodeExist(address from, uint nodeIndex) external view returns (bool);\n    function isNodeActive(uint nodeIndex) external view returns (bool);\n    function isNodeLeaving(uint nodeIndex) external view returns (bool);\n}\n"
+            },
             "@skalenetwork/skale-manager-interfaces/ISchains.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchains.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchains {\n\n    struct SchainOption {\n        string name;\n        bytes value;\n    }\n    \n    /**\n     * @dev Emitted when an schain is created.\n     */\n    event SchainCreated(\n        string name,\n        address owner,\n        uint partOfNode,\n        uint lifetime,\n        uint numberOfNodes,\n        uint deposit,\n        uint16 nonce,\n        bytes32 schainHash\n    );\n\n    /**\n     * @dev Emitted when an schain is deleted.\n     */\n    event SchainDeleted(\n        address owner,\n        string name,\n        bytes32 indexed schainHash\n    );\n\n    /**\n     * @dev Emitted when a node in an schain is rotated.\n     */\n    event NodeRotated(\n        bytes32 schainHash,\n        uint oldNode,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a node is added to an schain.\n     */\n    event NodeAdded(\n        bytes32 schainHash,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a group of nodes is created for an schain.\n     */\n    event SchainNodes(\n        string name,\n        bytes32 schainHash,\n        uint[] nodesInGroup\n    );\n\n    function addSchain(address from, uint deposit, bytes calldata data) external;\n    function addSchainByFoundation(\n        uint lifetime,\n        uint8 typeOfSchain,\n        uint16 nonce,\n        string calldata name,\n        address schainOwner,\n        address schainOriginator,\n        SchainOption[] calldata options\n    )\n        external\n        payable;\n    function deleteSchain(address from, string calldata name) external;\n    function deleteSchainByRoot(string calldata name) external;\n    function restartSchainCreation(string calldata name) external;\n    function verifySchainSignature(\n        uint256 signA,\n        uint256 signB,\n        bytes32 hash,\n        uint256 counter,\n        uint256 hashA,\n        uint256 hashB,\n        string calldata schainName\n    )\n        external\n        view\n        returns (bool);\n    function getSchainPrice(uint typeOfSchain, uint lifetime) external view returns (uint);\n    function getOption(bytes32 schainHash, string calldata optionName) external view returns (bytes memory);\n    function getOptions(bytes32 schainHash) external view returns (SchainOption[] memory);\n}"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchains.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchains {\n\n    struct SchainOption {\n        string name;\n        bytes value;\n    }\n    \n    /**\n     * @dev Emitted when an schain is created.\n     */\n    event SchainCreated(\n        string name,\n        address owner,\n        uint partOfNode,\n        uint lifetime,\n        uint numberOfNodes,\n        uint deposit,\n        uint16 nonce,\n        bytes32 schainHash\n    );\n\n    /**\n     * @dev Emitted when an schain is deleted.\n     */\n    event SchainDeleted(\n        address owner,\n        string name,\n        bytes32 indexed schainHash\n    );\n\n    /**\n     * @dev Emitted when a node in an schain is rotated.\n     */\n    event NodeRotated(\n        bytes32 schainHash,\n        uint oldNode,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a node is added to an schain.\n     */\n    event NodeAdded(\n        bytes32 schainHash,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a group of nodes is created for an schain.\n     */\n    event SchainNodes(\n        string name,\n        bytes32 schainHash,\n        uint[] nodesInGroup\n    );\n\n    function addSchain(address from, uint deposit, bytes calldata data) external;\n    function addSchainByFoundation(\n        uint lifetime,\n        uint8 typeOfSchain,\n        uint16 nonce,\n        string calldata name,\n        address schainOwner,\n        address schainOriginator,\n        SchainOption[] calldata options\n    )\n        external\n        payable;\n    function deleteSchain(address from, string calldata name) external;\n    function deleteSchainByRoot(string calldata name) external;\n    function restartSchainCreation(string calldata name) external;\n    function verifySchainSignature(\n        uint256 signA,\n        uint256 signB,\n        bytes32 hash,\n        uint256 counter,\n        uint256 hashA,\n        uint256 hashB,\n        string calldata schainName\n    )\n        external\n        view\n        returns (bool);\n    function getSchainPrice(uint typeOfSchain, uint lifetime) external view returns (uint);\n    function getOption(bytes32 schainHash, string calldata optionName) external view returns (bytes memory);\n    function getOptions(bytes32 schainHash) external view returns (SchainOption[] memory);\n}\n"
             },
             "@skalenetwork/skale-manager-interfaces/ISchainsInternal.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchainsInternal - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchainsInternal {\n    struct Schain {\n        string name;\n        address owner;\n        uint indexInOwnerList;\n        uint8 partOfNode;\n        uint lifetime;\n        uint startDate;\n        uint startBlock;\n        uint deposit;\n        uint64 index;\n        uint generation;\n        address originator;\n    }\n\n    struct SchainType {\n        uint8 partOfNode;\n        uint numberOfNodes;\n    }\n\n    /**\n     * @dev Emitted when schain type added.\n     */\n    event SchainTypeAdded(uint indexed schainType, uint partOfNode, uint numberOfNodes);\n\n    /**\n     * @dev Emitted when schain type removed.\n     */\n    event SchainTypeRemoved(uint indexed schainType);\n\n    function initializeSchain(\n        string calldata name,\n        address from,\n        address originator,\n        uint lifetime,\n        uint deposit) external;\n    function createGroupForSchain(\n        bytes32 schainHash,\n        uint numberOfNodes,\n        uint8 partOfNode\n    )\n        external\n        returns (uint[] memory);\n    function changeLifetime(bytes32 schainHash, uint lifetime, uint deposit) external;\n    function removeSchain(bytes32 schainHash, address from) external;\n    function removeNodeFromSchain(uint nodeIndex, bytes32 schainHash) external;\n    function deleteGroup(bytes32 schainHash) external;\n    function setException(bytes32 schainHash, uint nodeIndex) external;\n    function setNodeInGroup(bytes32 schainHash, uint nodeIndex) external;\n    function removeHolesForSchain(bytes32 schainHash) external;\n    function addSchainType(uint8 partOfNode, uint numberOfNodes) external;\n    function removeSchainType(uint typeOfSchain) external;\n    function setNumberOfSchainTypes(uint newNumberOfSchainTypes) external;\n    function removeNodeFromAllExceptionSchains(uint nodeIndex) external;\n    function removeAllNodesFromSchainExceptions(bytes32 schainHash) external;\n    function makeSchainNodesInvisible(bytes32 schainHash) external;\n    function makeSchainNodesVisible(bytes32 schainHash) external;\n    function newGeneration() external;\n    function addSchainForNode(uint nodeIndex, bytes32 schainHash) external;\n    function removeSchainForNode(uint nodeIndex, uint schainIndex) external;\n    function removeNodeFromExceptions(bytes32 schainHash, uint nodeIndex) external;\n    function isSchainActive(bytes32 schainHash) external view returns (bool);\n    function schainsAtSystem(uint index) external view returns (bytes32);\n    function numberOfSchains() external view returns (uint64);\n    function getSchains() external view returns (bytes32[] memory);\n    function getSchainsPartOfNode(bytes32 schainHash) external view returns (uint8);\n    function getSchainListSize(address from) external view returns (uint);\n    function getSchainHashesByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainIdsByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainHashesForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainIdsForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainOwner(bytes32 schainHash) external view returns (address);\n    function getSchainOriginator(bytes32 schainHash) external view returns (address);\n    function isSchainNameAvailable(string calldata name) external view returns (bool);\n    function isTimeExpired(bytes32 schainHash) external view returns (bool);\n    function isOwnerAddress(address from, bytes32 schainId) external view returns (bool);\n    function getSchainName(bytes32 schainHash) external view returns (string memory);\n    function getActiveSchain(uint nodeIndex) external view returns (bytes32);\n    function getActiveSchains(uint nodeIndex) external view returns (bytes32[] memory activeSchains);\n    function getNumberOfNodesInGroup(bytes32 schainHash) external view returns (uint);\n    function getNodesInGroup(bytes32 schainHash) external view returns (uint[] memory);\n    function isNodeAddressesInGroup(bytes32 schainId, address sender) external view returns (bool);\n    function getNodeIndexInGroup(bytes32 schainHash, uint nodeId) external view returns (uint);\n    function isAnyFreeNode(bytes32 schainHash) external view returns (bool);\n    function checkException(bytes32 schainHash, uint nodeIndex) external view returns (bool);\n    function checkHoleForSchain(bytes32 schainHash, uint indexOfNode) external view returns (bool);\n    function checkSchainOnNode(uint nodeIndex, bytes32 schainHash) external view returns (bool);\n    function getSchainType(uint typeOfSchain) external view returns(uint8, uint);\n    function getGeneration(bytes32 schainHash) external view returns (uint);\n    function isSchainExist(bytes32 schainHash) external view returns (bool);\n}"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchainsInternal - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"./INodes.sol\";\n\ninterface ISchainsInternal {\n    struct Schain {\n        string name;\n        address owner;\n        uint indexInOwnerList;\n        uint8 partOfNode;\n        uint lifetime;\n        uint startDate;\n        uint startBlock;\n        uint deposit;\n        uint64 index;\n        uint generation;\n        address originator;\n    }\n\n    struct SchainType {\n        uint8 partOfNode;\n        uint numberOfNodes;\n    }\n\n    /**\n     * @dev Emitted when schain type added.\n     */\n    event SchainTypeAdded(uint indexed schainType, uint partOfNode, uint numberOfNodes);\n\n    /**\n     * @dev Emitted when schain type removed.\n     */\n    event SchainTypeRemoved(uint indexed schainType);\n\n    function initializeSchain(\n        string calldata name,\n        address from,\n        address originator,\n        uint lifetime,\n        uint deposit) external;\n    function createGroupForSchain(\n        bytes32 schainHash,\n        uint numberOfNodes,\n        uint8 partOfNode\n    )\n        external\n        returns (uint[] memory);\n    function changeLifetime(bytes32 schainHash, uint lifetime, uint deposit) external;\n    function removeSchain(bytes32 schainHash, address from) external;\n    function removeNodeFromSchain(uint nodeIndex, bytes32 schainHash) external;\n    function deleteGroup(bytes32 schainHash) external;\n    function setException(bytes32 schainHash, uint nodeIndex) external;\n    function setNodeInGroup(bytes32 schainHash, uint nodeIndex) external;\n    function removeHolesForSchain(bytes32 schainHash) external;\n    function addSchainType(uint8 partOfNode, uint numberOfNodes) external;\n    function removeSchainType(uint typeOfSchain) external;\n    function setNumberOfSchainTypes(uint newNumberOfSchainTypes) external;\n    function removeNodeFromAllExceptionSchains(uint nodeIndex) external;\n    function removeAllNodesFromSchainExceptions(bytes32 schainHash) external;\n    function makeSchainNodesInvisible(bytes32 schainHash) external;\n    function makeSchainNodesVisible(bytes32 schainHash) external;\n    function newGeneration() external;\n    function addSchainForNode(INodes nodes,uint nodeIndex, bytes32 schainHash) external;\n    function removeSchainForNode(uint nodeIndex, uint schainIndex) external;\n    function removeNodeFromExceptions(bytes32 schainHash, uint nodeIndex) external;\n    function isSchainActive(bytes32 schainHash) external view returns (bool);\n    function schainsAtSystem(uint index) external view returns (bytes32);\n    function numberOfSchains() external view returns (uint64);\n    function getSchains() external view returns (bytes32[] memory);\n    function getSchainsPartOfNode(bytes32 schainHash) external view returns (uint8);\n    function getSchainListSize(address from) external view returns (uint);\n    function getSchainHashesByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainHashesForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainOwner(bytes32 schainHash) external view returns (address);\n    function getSchainOriginator(bytes32 schainHash) external view returns (address);\n    function isSchainNameAvailable(string calldata name) external view returns (bool);\n    function isTimeExpired(bytes32 schainHash) external view returns (bool);\n    function isOwnerAddress(address from, bytes32 schainHash) external view returns (bool);\n    function getSchainName(bytes32 schainHash) external view returns (string memory);\n    function getActiveSchain(uint nodeIndex) external view returns (bytes32);\n    function getActiveSchains(uint nodeIndex) external view returns (bytes32[] memory activeSchains);\n    function getNumberOfNodesInGroup(bytes32 schainHash) external view returns (uint);\n    function getNodesInGroup(bytes32 schainHash) external view returns (uint[] memory);\n    function isNodeAddressesInGroup(bytes32 schainHash, address sender) external view returns (bool);\n    function getNodeIndexInGroup(bytes32 schainHash, uint nodeHash) external view returns (uint);\n    function isAnyFreeNode(bytes32 schainHash) external view returns (bool);\n    function checkException(bytes32 schainHash, uint nodeIndex) external view returns (bool);\n    function checkHoleForSchain(bytes32 schainHash, uint indexOfNode) external view returns (bool);\n    function checkSchainOnNode(uint nodeIndex, bytes32 schainHash) external view returns (bool);\n    function getSchainType(uint typeOfSchain) external view returns(uint8, uint);\n    function getGeneration(bytes32 schainHash) external view returns (uint);\n    function isSchainExist(bytes32 schainHash) external view returns (bool);\n}"
             },
             "@skalenetwork/skale-manager-interfaces/IWallets.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IWallets - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IWallets {\n    /**\n     * @dev Emitted when the validator wallet was funded\n     */\n    event ValidatorWalletRecharged(address sponsor, uint amount, uint validatorId);\n\n    /**\n     * @dev Emitted when the schain wallet was funded\n     */\n    event SchainWalletRecharged(address sponsor, uint amount, bytes32 schainHash);\n\n    /**\n     * @dev Emitted when the node received a refund from validator to its wallet\n     */\n    event NodeRefundedByValidator(address node, uint validatorId, uint amount);\n\n    /**\n     * @dev Emitted when the node received a refund from schain to its wallet\n     */\n    event NodeRefundedBySchain(address node, bytes32 schainHash, uint amount);\n\n    /**\n     * @dev Emitted when the validator withdrawn funds from validator wallet\n     */\n    event WithdrawFromValidatorWallet(uint indexed validatorId, uint amount);\n\n    /**\n     * @dev Emitted when the schain owner withdrawn funds from schain wallet\n     */\n    event WithdrawFromSchainWallet(bytes32 indexed schainHash, uint amount);\n\n    receive() external payable;\n    function refundGasByValidator(uint validatorId, address payable spender, uint spentGas) external;\n    function refundGasByValidatorToSchain(uint validatorId, bytes32 schainHash) external;\n    function refundGasBySchain(bytes32 schainId, address payable spender, uint spentGas, bool isDebt) external;\n    function withdrawFundsFromSchainWallet(address payable schainOwner, bytes32 schainHash) external;\n    function withdrawFundsFromValidatorWallet(uint amount) external;\n    function rechargeValidatorWallet(uint validatorId) external payable;\n    function rechargeSchainWallet(bytes32 schainId) external payable;\n    function getSchainBalance(bytes32 schainHash) external view returns (uint);\n    function getValidatorBalance(uint validatorId) external view returns (uint);\n}\n"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IWallets - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IWallets {\n    receive() external payable;\n    function refundGasByValidator(uint validatorId, address payable spender, uint gasLimit) external;\n    function refundGasByValidatorToSchain(uint validatorId, bytes32 schainHash) external;\n    function refundGasBySchain(bytes32 schainId, address payable spender, uint spentGas, bool isDebt) external;\n    function withdrawFundsFromSchainWallet(address payable schainOwner, bytes32 schainHash) external;\n    function withdrawFundsFromValidatorWallet(uint amount) external;\n    function rechargeValidatorWallet(uint validatorId) external payable;\n    function rechargeSchainWallet(bytes32 schainId) external payable;\n    function getSchainBalance(bytes32 schainHash) external view returns (uint);\n    function getValidatorBalance(uint validatorId) external view returns (uint);\n}\n"
+            },
+            "@skalenetwork/skale-manager-interfaces/utils/IRandom.sol": {
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IRandom.sol - SKALE Manager Interfaces\n    Copyright (C) 2022-Present SKALE Labs\n    @author Dmytro Stebaiev\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\n\ninterface IRandom {\n    struct RandomGenerator {\n        uint seed;\n    }\n}"
             },
             "contracts/MessageProxy.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   MessageProxy.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/IGasReimbursable.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageProxy.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageReceiver.sol\";\n\n\n/**\n * @title MessageProxy\n * @dev Abstract contract for MessageProxyForMainnet and MessageProxyForSchain.\n */\nabstract contract MessageProxy is AccessControlEnumerableUpgradeable, IMessageProxy {\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    /**\n     * @dev Structure that stores counters for outgoing and incoming messages.\n     */\n    struct ConnectedChainInfo {\n        // message counters start with 0\n        uint256 incomingMessageCounter;\n        uint256 outgoingMessageCounter;\n        bool inited;\n        uint256 lastOutgoingMessageBlockId;\n    }\n\n    bytes32 public constant MAINNET_HASH = keccak256(abi.encodePacked(\"Mainnet\"));\n    bytes32 public constant CHAIN_CONNECTOR_ROLE = keccak256(\"CHAIN_CONNECTOR_ROLE\");\n    bytes32 public constant EXTRA_CONTRACT_REGISTRAR_ROLE = keccak256(\"EXTRA_CONTRACT_REGISTRAR_ROLE\");\n    bytes32 public constant CONSTANT_SETTER_ROLE = keccak256(\"CONSTANT_SETTER_ROLE\");\n    uint256 public constant MESSAGES_LENGTH = 10;\n    uint256 public constant REVERT_REASON_LENGTH = 64;\n\n    //   schainHash => ConnectedChainInfo\n    mapping(bytes32 => ConnectedChainInfo) public connectedChains;\n    //   schainHash => contract address => allowed\n    mapping(bytes32 => mapping(address => bool)) private _deprecatedRegistryContracts;\n\n    uint256 public gasLimit;\n\n    /**\n     * @dev Emitted for every outgoing message to schain.\n     */\n    event OutgoingMessage(\n        bytes32 indexed dstChainHash,\n        uint256 indexed msgCounter,\n        address indexed srcContract,\n        address dstContract,\n        bytes data\n    );\n\n    /**\n     * @dev Emitted when function `postMessage` returns revert.\n     *  Used to prevent stuck loop inside function `postIncomingMessages`.\n     */\n    event PostMessageError(\n        uint256 indexed msgCounter,\n        bytes message\n    );\n\n    /**\n     * @dev Emitted when gas limit per one call of `postMessage` was changed.\n     */\n    event GasLimitWasChanged(\n        uint256 oldValue,\n        uint256 newValue\n    );\n\n    /**\n     * @dev Emitted when the version was updated\n     */\n    event VersionUpdated(string oldVersion, string newVersion);\n\n    /**\n     * @dev Emitted when extra contract was added.\n     */\n    event ExtraContractRegistered(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Emitted when extra contract was removed.\n     */\n    event ExtraContractRemoved(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Emitted when referenced to previous outgoing message.\n     */\n    event PreviousMessageReference (\n        uint256 currentMessage,\n        uint256 previousOutgoingMessageBlockId\n    );\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CHAIN_CONNECTOR_ROLE}.\n     */\n    modifier onlyChainConnector() {\n        require(hasRole(CHAIN_CONNECTOR_ROLE, msg.sender), \"CHAIN_CONNECTOR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {EXTRA_CONTRACT_REGISTRAR_ROLE}.\n     */\n    modifier onlyExtraContractRegistrar() {\n        require(hasRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender), \"EXTRA_CONTRACT_REGISTRAR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CONSTANT_SETTER_ROLE}.\n     */\n    modifier onlyConstantSetter() {\n        require(hasRole(CONSTANT_SETTER_ROLE, msg.sender), \"Not enough permissions to set constant\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {DEFAULT_ADMIN_ROLE}.\n     */\n    modifier onlyOwner() {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"DEFAULT_ADMIN_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Sets gasLimit to a new value.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CONSTANT_SETTER_ROLE.\n     */\n    function setNewGasLimit(uint256 newGasLimit) external override onlyConstantSetter {\n        emit GasLimitWasChanged(gasLimit, newGasLimit);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Virtual function for `postIncomingMessages`.\n     */\n    function postIncomingMessages(\n        string calldata fromSchainName,\n        uint256 startingCounter,\n        Message[] calldata messages,\n        Signature calldata sign\n    )\n        external\n        virtual\n        override;\n\n    /**\n     * @dev Allows `msg.sender` to register extra contract for all schains\n     * for being able to transfer messages from custom contracts.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     * - Passed address should be contract.\n     * - Extra contract must not be registered.\n     */\n    function registerExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is already registered\");\n        _getRegistryContracts()[bytes32(0)].add(extraContract);\n        emit ExtraContractRegistered(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Allows `msg.sender` to remove extra contract for all schains.\n     * Extra contract will no longer be able to send messages through MessageProxy.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     */\n    function removeExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[bytes32(0)].remove(extraContract);\n        emit ExtraContractRemoved(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Should return length of contract registered by schainHash.\n     */\n    function getContractRegisteredLength(bytes32 schainHash) external view override returns (uint256) {\n        return _getRegistryContracts()[schainHash].length();\n    }\n\n    /**\n     * @dev Should return a range of contracts registered by schainHash.\n     *\n     * Requirements:\n     * range should be less or equal 10 contracts\n     */\n    function getContractRegisteredRange(\n        bytes32 schainHash,\n        uint256 from,\n        uint256 to\n    )\n        external\n        view\n        override\n        returns (address[] memory contractsInRange)\n    {\n        require(\n            from < to && to - from <= 10 && to <= _getRegistryContracts()[schainHash].length(),\n            \"Range is incorrect\"\n        );\n        contractsInRange = new address[](to - from);\n        for (uint256 i = from; i < to; i++) {\n            contractsInRange[i - from] = _getRegistryContracts()[schainHash].at(i);\n        }\n    }\n\n    /**\n     * @dev Returns number of outgoing messages.\n     *\n     * Requirements:\n     *\n     * - Target schain  must be initialized.\n     */\n    function getOutgoingMessagesCounter(string calldata targetSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 dstChainHash = keccak256(abi.encodePacked(targetSchainName));\n        require(connectedChains[dstChainHash].inited, \"Destination chain is not initialized\");\n        return connectedChains[dstChainHash].outgoingMessageCounter;\n    }\n\n\n    /**\n     * @dev Should return block number of the last message transferred to schain\n     */\n    function getLastOutgoingMessageBlockId(string memory targetSchainName) external view override returns (uint) {\n        bytes32 dstChainHash = keccak256(abi.encodePacked(targetSchainName));\n        require(connectedChains[dstChainHash].inited, \"Destination chain is not initialized\");\n        return connectedChains[dstChainHash].lastOutgoingMessageBlockId;\n    }\n\n    /**\n     * @dev Returns number of incoming messages.\n     *\n     * Requirements:\n     *\n     * - Source schain must be initialized.\n     */\n    function getIncomingMessagesCounter(string calldata fromSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 srcChainHash = keccak256(abi.encodePacked(fromSchainName));\n        require(connectedChains[srcChainHash].inited, \"Source chain is not initialized\");\n        return connectedChains[srcChainHash].incomingMessageCounter;\n    }\n\n    function initializeMessageProxy(uint newGasLimit) public initializer {\n        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(CHAIN_CONNECTOR_ROLE, msg.sender);\n        _setupRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender);\n        _setupRole(CONSTANT_SETTER_ROLE, msg.sender);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Posts message from this contract to `targetChainHash` MessageProxy contract.\n     * This is called by a smart contract to make a cross-chain call.\n     *\n     * Emits an {OutgoingMessage} event.\n     *\n     * Requirements:\n     *\n     * - Target chain must be initialized.\n     * - Target chain must be registered as external contract.\n     */\n    function postOutgoingMessage(\n        bytes32 targetChainHash,\n        address targetContract,\n        bytes memory data\n    )\n        public\n        override\n        virtual\n    {\n        require(connectedChains[targetChainHash].inited, \"Destination chain is not initialized\");\n        _authorizeOutgoingMessageSender(targetChainHash);\n\n        uint outgoingMessageCounter = connectedChains[targetChainHash].outgoingMessageCounter;\n        emit OutgoingMessage(\n            targetChainHash,\n            outgoingMessageCounter,\n            msg.sender,\n            targetContract,\n            data\n        );\n        emit PreviousMessageReference(\n            outgoingMessageCounter,\n            connectedChains[targetChainHash].lastOutgoingMessageBlockId\n        );\n        connectedChains[targetChainHash].outgoingMessageCounter++;\n        connectedChains[targetChainHash].lastOutgoingMessageBlockId = block.number;\n    }\n\n    /**\n     * @dev Allows CHAIN_CONNECTOR_ROLE to remove connected chain from this contract.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CHAIN_CONNECTOR_ROLE.\n     * - `schainName` must be initialized.\n     */\n    function removeConnectedChain(string memory schainName) public virtual override onlyChainConnector {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(connectedChains[schainHash].inited, \"Chain is not initialized\");\n        delete connectedChains[schainHash];\n    }\n\n    /**\n     * @dev Checks whether chain is currently connected.\n     */\n    function isConnectedChain(\n        string memory schainName\n    )\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return connectedChains[keccak256(abi.encodePacked(schainName))].inited;\n    }\n\n    /**\n     * @dev Checks whether contract is currently registered as extra contract.\n     */\n    function isContractRegistered(\n        bytes32 schainHash,\n        address contractAddress\n    )\n        public\n        view\n        override\n        returns (bool)\n    {\n        return _getRegistryContracts()[schainHash].contains(contractAddress);\n    }\n\n    /**\n     * @dev Allows MessageProxy to register extra contract for being able to transfer messages from custom contracts.\n     *\n     * Requirements:\n     *\n     * - Extra contract address must be contract.\n     * - Extra contract must not be registered.\n     * - Extra contract must not be registered for all chains.\n     */\n    function _registerExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {\n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is already registered\");\n        require(\n            !_getRegistryContracts()[bytes32(0)].contains(extraContract),\n            \"Extra contract is already registered for all chains\"\n        );\n\n        _getRegistryContracts()[chainHash].add(extraContract);\n        emit ExtraContractRegistered(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to remove extra contract,\n     * thus `extraContract` will no longer be available to transfer messages from mainnet to schain.\n     *\n     * Requirements:\n     *\n     * - Extra contract must be registered.\n     */\n    function _removeExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {\n        require(_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[chainHash].remove(extraContract);\n        emit ExtraContractRemoved(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to connect schain with MessageProxyOnMainnet for transferring messages.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CHAIN_CONNECTOR_ROLE.\n     * - SKALE chain must not be connected.\n     */\n    function _addConnectedChain(bytes32 schainHash) internal onlyChainConnector {\n        require(!connectedChains[schainHash].inited,\"Chain is already connected\");\n        connectedChains[schainHash] = ConnectedChainInfo({\n            incomingMessageCounter: 0,\n            outgoingMessageCounter: 0,\n            inited: true,\n            lastOutgoingMessageBlockId: 0\n        });\n    }\n\n    /**\n     * @dev Allows MessageProxy to send messages from schain to mainnet.\n     * Destination contract must implement `postMessage` method.\n     */\n    function _callReceiverContract(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n    {\n        if (!message.destinationContract.isContract()) {\n            emit PostMessageError(\n                counter,\n                \"Destination contract is not a contract\"\n            );\n            return;\n        }\n        try IMessageReceiver(message.destinationContract).postMessage{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) {\n            return;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                _getSlice(bytes(reason), REVERT_REASON_LENGTH)\n            );\n        } catch Panic(uint errorCode) {\n               emit PostMessageError(\n                counter,\n                abi.encodePacked(errorCode)\n            );\n        } catch (bytes memory revertData) {\n            emit PostMessageError(\n                counter,\n                _getSlice(revertData, REVERT_REASON_LENGTH)\n            );\n        }\n    }\n\n    /**\n     * @dev Returns receiver of message.\n     */\n    function _getGasPayer(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n        returns (address)\n    {\n        try IGasReimbursable(message.destinationContract).gasPayer{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) returns (address receiver) {\n            return receiver;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                _getSlice(bytes(reason), REVERT_REASON_LENGTH)\n            );\n            return address(0);\n        } catch Panic(uint errorCode) {\n               emit PostMessageError(\n                counter,\n                abi.encodePacked(errorCode)\n            );\n            return address(0);\n        } catch (bytes memory revertData) {\n            emit PostMessageError(\n                counter,\n                _getSlice(revertData, REVERT_REASON_LENGTH)\n            );\n            return address(0);\n        }\n    }\n\n    /**\n     * @dev Checks whether msg.sender is registered as custom extra contract.\n     */\n    function _authorizeOutgoingMessageSender(bytes32 targetChainHash) internal view virtual {\n        require(\n            isContractRegistered(bytes32(0), msg.sender) || isContractRegistered(targetChainHash, msg.sender),\n            \"Sender contract is not registered\"\n        );\n    }\n\n    /**\n     * @dev Returns list of registered custom extra contracts.\n     */\n    function _getRegistryContracts()\n        internal\n        view\n        virtual\n        returns (mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) storage);\n\n    /**\n     * @dev Returns hash of message array.\n     */\n    function _hashedArray(\n        Message[] calldata messages,\n        uint256 startingCounter,\n        string calldata fromChainName\n    )\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32 sourceHash = keccak256(abi.encodePacked(fromChainName));\n        bytes32 hash = keccak256(abi.encodePacked(sourceHash, bytes32(startingCounter)));\n        for (uint256 i = 0; i < messages.length; i++) {\n            hash = keccak256(\n                abi.encodePacked(\n                    abi.encode(\n                        hash,\n                        messages[i].sender,\n                        messages[i].destinationContract\n                    ),\n                    messages[i].data\n                )\n            );\n        }\n        return hash;\n    }\n\n    function _getSlice(bytes memory text, uint end) private pure returns (bytes memory) {\n        uint slicedEnd = end < text.length ? end : text.length;\n        bytes memory sliced = new bytes(slicedEnd);\n        for(uint i = 0; i < slicedEnd; i++){\n            sliced[i] = text[i];\n        }\n        return sliced;\n    }\n}\n"
             },
             "contracts/Messages.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   Messages.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\n\n/**\n * @title Messages\n * @dev Library for encoding and decoding messages\n * for transferring from Mainnet to Schain and vice versa.\n */\nlibrary Messages {\n\n    /**\n     * @dev Enumerator that describes all supported message types.\n     */\n    enum MessageType {\n        EMPTY,\n        TRANSFER_ETH,\n        TRANSFER_ERC20,\n        TRANSFER_ERC20_AND_TOTAL_SUPPLY,\n        TRANSFER_ERC20_AND_TOKEN_INFO,\n        TRANSFER_ERC721,\n        TRANSFER_ERC721_AND_TOKEN_INFO,\n        USER_STATUS,\n        INTERCHAIN_CONNECTION,\n        TRANSFER_ERC1155,\n        TRANSFER_ERC1155_AND_TOKEN_INFO,\n        TRANSFER_ERC1155_BATCH,\n        TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO,\n        TRANSFER_ERC721_WITH_METADATA,\n        TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO\n    }\n\n    /**\n     * @dev Structure for base message.\n     */\n    struct BaseMessage {\n        MessageType messageType;\n    }\n\n    /**\n     * @dev Structure for describing ETH.\n     */\n    struct TransferEthMessage {\n        BaseMessage message;\n        address receiver;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for user status.\n     */\n    struct UserStatusMessage {\n        BaseMessage message;\n        address receiver;\n        bool isActive;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 token.\n     */\n    struct TransferErc20Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC20 token.\n     */\n    struct Erc20TokenInfo {\n        string name;\n        uint8 decimals;\n        string symbol;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token supply.\n     */\n    struct TransferErc20AndTotalSupplyMessage {\n        TransferErc20Message baseErc20transfer;\n        uint256 totalSupply;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token info.\n     */\n    struct TransferErc20AndTokenInfoMessage {\n        TransferErc20Message baseErc20transfer;\n        uint256 totalSupply;\n        Erc20TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing base ERC721.\n     */\n    struct TransferErc721Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 tokenId;\n    }\n\n    /**\n     * @dev Structure for describing base ERC721 with metadata.\n     */\n    struct TransferErc721MessageWithMetadata {\n        TransferErc721Message erc721message;\n        string tokenURI;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token info.\n     */\n    struct Erc721TokenInfo {\n        string name;\n        string symbol;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC721 token.\n     */\n    struct TransferErc721AndTokenInfoMessage {\n        TransferErc721Message baseErc721transfer;\n        Erc721TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC721 token with metadata.\n     */\n    struct TransferErc721WithMetadataAndTokenInfoMessage {\n        TransferErc721MessageWithMetadata baseErc721transferWithMetadata;\n        Erc721TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing whether interchain connection is allowed.\n     */\n    struct InterchainConnectionMessage {\n        BaseMessage message;\n        bool isAllowed;\n    }\n\n    /**\n     * @dev Structure for describing whether interchain connection is allowed.\n     */\n    struct TransferErc1155Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 id;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for describing ERC1155 token in batches.\n     */\n    struct TransferErc1155BatchMessage {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256[] ids;\n        uint256[] amounts;\n    }\n\n    /**\n     * @dev Structure for describing ERC1155 token info.\n     */\n    struct Erc1155TokenInfo {\n        string uri;\n    }\n\n    /**\n     * @dev Structure for describing message for transferring ERC1155 token with info.\n     */\n    struct TransferErc1155AndTokenInfoMessage {\n        TransferErc1155Message baseErc1155transfer;\n        Erc1155TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing message for transferring ERC1155 token in batches with info.\n     */\n    struct TransferErc1155BatchAndTokenInfoMessage {\n        TransferErc1155BatchMessage baseErc1155Batchtransfer;\n        Erc1155TokenInfo tokenInfo;\n    }\n\n\n    /**\n     * @dev Returns type of message for encoded data.\n     */\n    function getMessageType(bytes calldata data) internal pure returns (MessageType) {\n        uint256 firstWord = abi.decode(data, (uint256));\n        if (firstWord % 32 == 0) {\n            return getMessageType(data[firstWord:]);\n        } else {\n            return abi.decode(data, (Messages.MessageType));\n        }\n    }\n\n    /**\n     * @dev Encodes message for transferring ETH. Returns encoded message.\n     */\n    function encodeTransferEthMessage(address receiver, uint256 amount) internal pure returns (bytes memory) {\n        TransferEthMessage memory message = TransferEthMessage(\n            BaseMessage(MessageType.TRANSFER_ETH),\n            receiver,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ETH. Returns structure `TransferEthMessage`.\n     */\n    function decodeTransferEthMessage(\n        bytes calldata data\n    ) internal pure returns (TransferEthMessage memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ETH, \"Message type is not ETH transfer\");\n        return abi.decode(data, (TransferEthMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ETH. Returns encoded message.\n     */\n    function encodeTransferErc20Message(\n        address token,\n        address receiver,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        TransferErc20Message memory message = TransferErc20Message(\n            BaseMessage(MessageType.TRANSFER_ERC20),\n            token,\n            receiver,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC20 with total supply. Returns encoded message.\n     */\n    function encodeTransferErc20AndTotalSupplyMessage(\n        address token,\n        address receiver,\n        uint256 amount,\n        uint256 totalSupply\n    ) internal pure returns (bytes memory) {\n        TransferErc20AndTotalSupplyMessage memory message = TransferErc20AndTotalSupplyMessage(\n            TransferErc20Message(\n                BaseMessage(MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY),\n                token,\n                receiver,\n                amount\n            ),\n            totalSupply\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20. Returns structure `TransferErc20Message`.\n     */\n    function decodeTransferErc20Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc20Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC20, \"Message type is not ERC20 transfer\");\n        return abi.decode(data, (TransferErc20Message));\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20 with total supply. \n     * Returns structure `TransferErc20AndTotalSupplyMessage`.\n     */\n    function decodeTransferErc20AndTotalSupplyMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc20AndTotalSupplyMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY,\n            \"Message type is not ERC20 transfer and total supply\"\n        );\n        return abi.decode(data, (TransferErc20AndTotalSupplyMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC20 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc20AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 amount,\n        uint256 totalSupply,\n        Erc20TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc20AndTokenInfoMessage memory message = TransferErc20AndTokenInfoMessage(\n            TransferErc20Message(\n                BaseMessage(MessageType.TRANSFER_ERC20_AND_TOKEN_INFO),\n                token,\n                receiver,\n                amount\n            ),\n            totalSupply,\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20 with token info. \n     * Returns structure `TransferErc20AndTokenInfoMessage`.\n     */\n    function decodeTransferErc20AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc20AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC20_AND_TOKEN_INFO,\n            \"Message type is not ERC20 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc20AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721Message(\n        address token,\n        address receiver,\n        uint256 tokenId\n    ) internal pure returns (bytes memory) {\n        TransferErc721Message memory message = TransferErc721Message(\n            BaseMessage(MessageType.TRANSFER_ERC721),\n            token,\n            receiver,\n            tokenId\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721. \n     * Returns structure `TransferErc721Message`.\n     */\n    function decodeTransferErc721Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc721Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC721, \"Message type is not ERC721 transfer\");\n        return abi.decode(data, (TransferErc721Message));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        Erc721TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc721AndTokenInfoMessage memory message = TransferErc721AndTokenInfoMessage(\n            TransferErc721Message(\n                BaseMessage(MessageType.TRANSFER_ERC721_AND_TOKEN_INFO),\n                token,\n                receiver,\n                tokenId\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721 with token info. \n     * Returns structure `TransferErc721AndTokenInfoMessage`.\n     */\n    function decodeTransferErc721AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc721AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_AND_TOKEN_INFO,\n            \"Message type is not ERC721 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc721AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721MessageWithMetadata(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        string memory tokenURI\n    ) internal pure returns (bytes memory) {\n        TransferErc721MessageWithMetadata memory message = TransferErc721MessageWithMetadata(\n            TransferErc721Message(\n                BaseMessage(MessageType.TRANSFER_ERC721_WITH_METADATA),\n                token,\n                receiver,\n                tokenId\n            ),\n            tokenURI\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721. \n     * Returns structure `TransferErc721MessageWithMetadata`.\n     */\n    function decodeTransferErc721MessageWithMetadata(\n        bytes calldata data\n    ) internal pure returns (TransferErc721MessageWithMetadata memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_WITH_METADATA,\n            \"Message type is not ERC721 transfer\"\n        );\n        return abi.decode(data, (TransferErc721MessageWithMetadata));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721WithMetadataAndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        string memory tokenURI,\n        Erc721TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc721WithMetadataAndTokenInfoMessage memory message = TransferErc721WithMetadataAndTokenInfoMessage(\n            TransferErc721MessageWithMetadata(\n                TransferErc721Message(\n                    BaseMessage(MessageType.TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO),\n                    token,\n                    receiver,\n                    tokenId\n                ),\n                tokenURI\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721 with token info. \n     * Returns structure `TransferErc721WithMetadataAndTokenInfoMessage`.\n     */\n    function decodeTransferErc721WithMetadataAndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc721WithMetadataAndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO,\n            \"Message type is not ERC721 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc721WithMetadataAndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for activating user on schain. \n     * Returns encoded message.\n     */\n    function encodeActivateUserMessage(address receiver) internal pure returns (bytes memory){\n        return _encodeUserStatusMessage(receiver, true);\n    }\n\n    /**\n     * @dev Encodes message for locking user on schain. \n     * Returns encoded message.\n     */\n    function encodeLockUserMessage(address receiver) internal pure returns (bytes memory){\n        return _encodeUserStatusMessage(receiver, false);\n    }\n\n    /**\n     * @dev Decodes message for user status. \n     * Returns structure UserStatusMessage.\n     */\n    function decodeUserStatusMessage(bytes calldata data) internal pure returns (UserStatusMessage memory) {\n        require(getMessageType(data) == MessageType.USER_STATUS, \"Message type is not User Status\");\n        return abi.decode(data, (UserStatusMessage));\n    }\n\n\n    /**\n     * @dev Encodes message for allowing interchain connection.\n     * Returns encoded message.\n     */\n    function encodeInterchainConnectionMessage(bool isAllowed) internal pure returns (bytes memory) {\n        InterchainConnectionMessage memory message = InterchainConnectionMessage(\n            BaseMessage(MessageType.INTERCHAIN_CONNECTION),\n            isAllowed\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for allowing interchain connection.\n     * Returns structure `InterchainConnectionMessage`.\n     */\n    function decodeInterchainConnectionMessage(bytes calldata data)\n        internal\n        pure\n        returns (InterchainConnectionMessage memory)\n    {\n        require(getMessageType(data) == MessageType.INTERCHAIN_CONNECTION, \"Message type is not Interchain connection\");\n        return abi.decode(data, (InterchainConnectionMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155Message(\n        address token,\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        TransferErc1155Message memory message = TransferErc1155Message(\n            BaseMessage(MessageType.TRANSFER_ERC1155),\n            token,\n            receiver,\n            id,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token.\n     * Returns structure `TransferErc1155Message`.\n     */\n    function decodeTransferErc1155Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC1155, \"Message type is not ERC1155 transfer\");\n        return abi.decode(data, (TransferErc1155Message));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 with token info.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 id,\n        uint256 amount,\n        Erc1155TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc1155AndTokenInfoMessage memory message = TransferErc1155AndTokenInfoMessage(\n            TransferErc1155Message(\n                BaseMessage(MessageType.TRANSFER_ERC1155_AND_TOKEN_INFO),\n                token,\n                receiver,\n                id,\n                amount\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 with token info.\n     * Returns structure `TransferErc1155AndTokenInfoMessage`.\n     */\n    function decodeTransferErc1155AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_AND_TOKEN_INFO,\n            \"Message type is not ERC1155AndTokenInfo transfer\"\n        );\n        return abi.decode(data, (TransferErc1155AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token in batches.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155BatchMessage(\n        address token,\n        address receiver,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal pure returns (bytes memory) {\n        TransferErc1155BatchMessage memory message = TransferErc1155BatchMessage(\n            BaseMessage(MessageType.TRANSFER_ERC1155_BATCH),\n            token,\n            receiver,\n            ids,\n            amounts\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token in batches.\n     * Returns structure `TransferErc1155BatchMessage`.\n     */\n    function decodeTransferErc1155BatchMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155BatchMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_BATCH,\n            \"Message type is not ERC1155Batch transfer\"\n        );\n        return abi.decode(data, (TransferErc1155BatchMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token in batches with token info.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155BatchAndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        Erc1155TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc1155BatchAndTokenInfoMessage memory message = TransferErc1155BatchAndTokenInfoMessage(\n            TransferErc1155BatchMessage(\n                BaseMessage(MessageType.TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO),\n                token,\n                receiver,\n                ids,\n                amounts\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token in batches with token info.\n     * Returns structure `TransferErc1155BatchAndTokenInfoMessage`.\n     */\n    function decodeTransferErc1155BatchAndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155BatchAndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO,\n            \"Message type is not ERC1155BatchAndTokenInfo transfer\"\n        );\n        return abi.decode(data, (TransferErc1155BatchAndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring user status on schain.\n     * Returns encoded message.\n     */\n    function _encodeUserStatusMessage(address receiver, bool isActive) private pure returns (bytes memory) {\n        UserStatusMessage memory message = UserStatusMessage(\n            BaseMessage(MessageType.USER_STATUS),\n            receiver,\n            isActive\n        );\n        return abi.encode(message);\n    }\n\n}"
             },
@@ -403,11 +409,11 @@
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   RevertableERC20.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2022-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\ninterface IRevertableERC20 {\n    function enable() external;\n    function disable() external;\n    function mint(address account, uint amount) external;\n}\n\ncontract RevertableERC20 is IRevertableERC20, ERC20Upgradeable {\n    bool public enabled = true;\n\n    constructor(string memory name, string memory symbol) initializer {\n        super.__ERC20_init(name, symbol);\n    }\n\n    function enable() external override {\n        enabled = true;\n    }\n\n    function disable() external override {\n        enabled = false;\n    }\n\n    function mint(address account, uint amount) external override {\n        _mint(account, amount);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    )\n        internal\n        override\n    {\n        require(enabled, \"Transfers are disabled\");\n        super._transfer(from, to, amount);\n    }\n}"
             },
             "contracts/thirdparty/ERC1155ReceiverUpgradeableWithoutGap.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol\";\n\nabstract contract ERC1155ReceiverUpgradeableWithoutGap is\n    Initializable,\n    ERC165Upgradeable,\n    IERC1155ReceiverUpgradeable\n{\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165Upgradeable)\n        returns (bool)\n    {\n        return interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function __ERC1155Receiver_init() internal initializer {\n        __ERC165_init_unchained();\n        __ERC1155Receiver_init_unchained();\n    }\n\n    // solhint-disable-next-line func-name-mixedcase, no-empty-blocks\n    function __ERC1155Receiver_init_unchained() internal initializer {\n    }\n}"
             }
         }
     },
-    "name": "TokenManager",
+    "name": "MessageProxyForSchain",
     "solcLongVersion": "0.8.16+commit.07a7930e",
     "solcVersion": "0.8.16"
 }
```

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/TokenManagerERC1155.json` & `ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/TokenManagerERC1155.json`

 * *Files identical despite different names*

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/TokenManagerERC1155.meta.json` & `ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/TokenManager.meta.json`

 * *Files 1% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.8745592948717948%*

 * *Differences: {"'input'": "{'sources': {'@skalenetwork/skale-manager-interfaces/IWallets.sol': {'content': '// "*

 * *            'SPDX-License-Identifier: AGPL-3.0-only\\n\\n/*\\n    IWallets - SKALE Manager '*

 * *            'Interfaces\\n    Copyright (C) 2021-Present SKALE Labs\\n    @author Dmytro '*

 * *            'Stebaeiv\\n\\n    SKALE Manager Interfaces is free software: you can redistribute it '*

 * *            'and/or modify\\n    it under the terms of the GNU Affero General Public License as '*

 * *            'published\\n    by […]*

```diff
@@ -218,22 +218,28 @@
             },
             "@skalenetwork/ima-interfaces/schain/tokens/IEthErc20.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   IEthErc20 - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\n\ninterface IEthErc20 {\n    function mint(address account, uint256 amount) external;\n    function forceBurn(address account, uint256 amount) external;\n    function initialize(address tokenManagerEthAddress) external;\n}"
             },
             "@skalenetwork/skale-manager-interfaces/IContractManager.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IContractManager.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IContractManager {\n    /**\n     * @dev Emitted when contract is upgraded.\n     */\n    event ContractUpgraded(string contractsName, address contractsAddress);\n\n    function initialize() external;\n    function setContractsAddress(string calldata contractsName, address newContractsAddress) external;\n    function contracts(bytes32 nameHash) external view returns (address);\n    function getDelegationPeriodManager() external view returns (address);\n    function getBounty() external view returns (address);\n    function getValidatorService() external view returns (address);\n    function getTimeHelpers() external view returns (address);\n    function getConstantsHolder() external view returns (address);\n    function getSkaleToken() external view returns (address);\n    function getTokenState() external view returns (address);\n    function getPunisher() external view returns (address);\n    function getContract(string calldata name) external view returns (address);\n}"
             },
+            "@skalenetwork/skale-manager-interfaces/INodes.sol": {
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    INodes.sol - SKALE Manager\n    Copyright (C) 2018-Present SKALE Labs\n    @author Artem Payvin\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"./utils/IRandom.sol\";\n\ninterface INodes {\n    // All Nodes states\n    enum NodeStatus {Active, Leaving, Left, In_Maintenance}\n\n    struct Node {\n        string name;\n        bytes4 ip;\n        bytes4 publicIP;\n        uint16 port;\n        bytes32[2] publicKey;\n        uint startBlock;\n        uint lastRewardDate;\n        uint finishTime;\n        NodeStatus status;\n        uint validatorId;\n    }\n\n    // struct to note which Nodes and which number of Nodes owned by user\n    struct CreatedNodes {\n        mapping (uint => bool) isNodeExist;\n        uint numberOfNodes;\n    }\n\n    struct SpaceManaging {\n        uint8 freeSpace;\n        uint indexInSpaceMap;\n    }\n\n    struct NodeCreationParams {\n        string name;\n        bytes4 ip;\n        bytes4 publicIp;\n        uint16 port;\n        bytes32[2] publicKey;\n        uint16 nonce;\n        string domainName;\n    }\n    \n    /**\n     * @dev Emitted when a node is created.\n     */\n    event NodeCreated(\n        uint nodeIndex,\n        address owner,\n        string name,\n        bytes4 ip,\n        bytes4 publicIP,\n        uint16 port,\n        uint16 nonce,\n        string domainName\n    );\n\n    /**\n     * @dev Emitted when a node completes a network exit.\n     */\n    event ExitCompleted(\n        uint nodeIndex\n    );\n\n    /**\n     * @dev Emitted when a node begins to exit from the network.\n     */\n    event ExitInitialized(\n        uint nodeIndex,\n        uint startLeavingPeriod\n    );\n\n    /**\n     * @dev Emitted when a node set to in compliant or compliant.\n     */\n    event IncompliantNode(\n        uint indexed nodeIndex,\n        bool status\n    );\n\n    /**\n     * @dev Emitted when a node set to in maintenance or from in maintenance.\n     */\n    event MaintenanceNode(\n        uint indexed nodeIndex,\n        bool status\n    );\n\n    /**\n     * @dev Emitted when a node status changed.\n     */\n    event IPChanged(\n        uint indexed nodeIndex,\n        bytes4 previousIP,\n        bytes4 newIP\n    );\n    \n    function removeSpaceFromNode(uint nodeIndex, uint8 space) external returns (bool);\n    function addSpaceToNode(uint nodeIndex, uint8 space) external;\n    function changeNodeLastRewardDate(uint nodeIndex) external;\n    function changeNodeFinishTime(uint nodeIndex, uint time) external;\n    function createNode(address from, NodeCreationParams calldata params) external;\n    function initExit(uint nodeIndex) external;\n    function completeExit(uint nodeIndex) external returns (bool);\n    function deleteNodeForValidator(uint validatorId, uint nodeIndex) external;\n    function checkPossibilityCreatingNode(address nodeAddress) external;\n    function checkPossibilityToMaintainNode(uint validatorId, uint nodeIndex) external returns (bool);\n    function setNodeInMaintenance(uint nodeIndex) external;\n    function removeNodeFromInMaintenance(uint nodeIndex) external;\n    function setNodeIncompliant(uint nodeIndex) external;\n    function setNodeCompliant(uint nodeIndex) external;\n    function setDomainName(uint nodeIndex, string memory domainName) external;\n    function makeNodeVisible(uint nodeIndex) external;\n    function makeNodeInvisible(uint nodeIndex) external;\n    function changeIP(uint nodeIndex, bytes4 newIP, bytes4 newPublicIP) external;\n    function numberOfActiveNodes() external view returns (uint);\n    function incompliant(uint nodeIndex) external view returns (bool);\n    function getRandomNodeWithFreeSpace(\n        uint8 freeSpace,\n        IRandom.RandomGenerator memory randomGenerator\n    )\n        external\n        view\n        returns (uint);\n    function isTimeForReward(uint nodeIndex) external view returns (bool);\n    function getNodeIP(uint nodeIndex) external view returns (bytes4);\n    function getNodeDomainName(uint nodeIndex) external view returns (string memory);\n    function getNodePort(uint nodeIndex) external view returns (uint16);\n    function getNodePublicKey(uint nodeIndex) external view returns (bytes32[2] memory);\n    function getNodeAddress(uint nodeIndex) external view returns (address);\n    function getNodeFinishTime(uint nodeIndex) external view returns (uint);\n    function isNodeLeft(uint nodeIndex) external view returns (bool);\n    function isNodeInMaintenance(uint nodeIndex) external view returns (bool);\n    function getNodeLastRewardDate(uint nodeIndex) external view returns (uint);\n    function getNodeNextRewardDate(uint nodeIndex) external view returns (uint);\n    function getNumberOfNodes() external view returns (uint);\n    function getNumberOnlineNodes() external view returns (uint);\n    function getActiveNodeIds() external view returns (uint[] memory activeNodeIds);\n    function getNodeStatus(uint nodeIndex) external view returns (NodeStatus);\n    function getValidatorNodeIndexes(uint validatorId) external view returns (uint[] memory);\n    function countNodesWithFreeSpace(uint8 freeSpace) external view returns (uint count);\n    function getValidatorId(uint nodeIndex) external view returns (uint);\n    function isNodeExist(address from, uint nodeIndex) external view returns (bool);\n    function isNodeActive(uint nodeIndex) external view returns (bool);\n    function isNodeLeaving(uint nodeIndex) external view returns (bool);\n}\n"
+            },
             "@skalenetwork/skale-manager-interfaces/ISchains.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchains.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchains {\n\n    struct SchainOption {\n        string name;\n        bytes value;\n    }\n    \n    /**\n     * @dev Emitted when an schain is created.\n     */\n    event SchainCreated(\n        string name,\n        address owner,\n        uint partOfNode,\n        uint lifetime,\n        uint numberOfNodes,\n        uint deposit,\n        uint16 nonce,\n        bytes32 schainHash\n    );\n\n    /**\n     * @dev Emitted when an schain is deleted.\n     */\n    event SchainDeleted(\n        address owner,\n        string name,\n        bytes32 indexed schainHash\n    );\n\n    /**\n     * @dev Emitted when a node in an schain is rotated.\n     */\n    event NodeRotated(\n        bytes32 schainHash,\n        uint oldNode,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a node is added to an schain.\n     */\n    event NodeAdded(\n        bytes32 schainHash,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a group of nodes is created for an schain.\n     */\n    event SchainNodes(\n        string name,\n        bytes32 schainHash,\n        uint[] nodesInGroup\n    );\n\n    function addSchain(address from, uint deposit, bytes calldata data) external;\n    function addSchainByFoundation(\n        uint lifetime,\n        uint8 typeOfSchain,\n        uint16 nonce,\n        string calldata name,\n        address schainOwner,\n        address schainOriginator,\n        SchainOption[] calldata options\n    )\n        external\n        payable;\n    function deleteSchain(address from, string calldata name) external;\n    function deleteSchainByRoot(string calldata name) external;\n    function restartSchainCreation(string calldata name) external;\n    function verifySchainSignature(\n        uint256 signA,\n        uint256 signB,\n        bytes32 hash,\n        uint256 counter,\n        uint256 hashA,\n        uint256 hashB,\n        string calldata schainName\n    )\n        external\n        view\n        returns (bool);\n    function getSchainPrice(uint typeOfSchain, uint lifetime) external view returns (uint);\n    function getOption(bytes32 schainHash, string calldata optionName) external view returns (bytes memory);\n    function getOptions(bytes32 schainHash) external view returns (SchainOption[] memory);\n}"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchains.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchains {\n\n    struct SchainOption {\n        string name;\n        bytes value;\n    }\n    \n    /**\n     * @dev Emitted when an schain is created.\n     */\n    event SchainCreated(\n        string name,\n        address owner,\n        uint partOfNode,\n        uint lifetime,\n        uint numberOfNodes,\n        uint deposit,\n        uint16 nonce,\n        bytes32 schainHash\n    );\n\n    /**\n     * @dev Emitted when an schain is deleted.\n     */\n    event SchainDeleted(\n        address owner,\n        string name,\n        bytes32 indexed schainHash\n    );\n\n    /**\n     * @dev Emitted when a node in an schain is rotated.\n     */\n    event NodeRotated(\n        bytes32 schainHash,\n        uint oldNode,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a node is added to an schain.\n     */\n    event NodeAdded(\n        bytes32 schainHash,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a group of nodes is created for an schain.\n     */\n    event SchainNodes(\n        string name,\n        bytes32 schainHash,\n        uint[] nodesInGroup\n    );\n\n    function addSchain(address from, uint deposit, bytes calldata data) external;\n    function addSchainByFoundation(\n        uint lifetime,\n        uint8 typeOfSchain,\n        uint16 nonce,\n        string calldata name,\n        address schainOwner,\n        address schainOriginator,\n        SchainOption[] calldata options\n    )\n        external\n        payable;\n    function deleteSchain(address from, string calldata name) external;\n    function deleteSchainByRoot(string calldata name) external;\n    function restartSchainCreation(string calldata name) external;\n    function verifySchainSignature(\n        uint256 signA,\n        uint256 signB,\n        bytes32 hash,\n        uint256 counter,\n        uint256 hashA,\n        uint256 hashB,\n        string calldata schainName\n    )\n        external\n        view\n        returns (bool);\n    function getSchainPrice(uint typeOfSchain, uint lifetime) external view returns (uint);\n    function getOption(bytes32 schainHash, string calldata optionName) external view returns (bytes memory);\n    function getOptions(bytes32 schainHash) external view returns (SchainOption[] memory);\n}\n"
             },
             "@skalenetwork/skale-manager-interfaces/ISchainsInternal.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchainsInternal - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchainsInternal {\n    struct Schain {\n        string name;\n        address owner;\n        uint indexInOwnerList;\n        uint8 partOfNode;\n        uint lifetime;\n        uint startDate;\n        uint startBlock;\n        uint deposit;\n        uint64 index;\n        uint generation;\n        address originator;\n    }\n\n    struct SchainType {\n        uint8 partOfNode;\n        uint numberOfNodes;\n    }\n\n    /**\n     * @dev Emitted when schain type added.\n     */\n    event SchainTypeAdded(uint indexed schainType, uint partOfNode, uint numberOfNodes);\n\n    /**\n     * @dev Emitted when schain type removed.\n     */\n    event SchainTypeRemoved(uint indexed schainType);\n\n    function initializeSchain(\n        string calldata name,\n        address from,\n        address originator,\n        uint lifetime,\n        uint deposit) external;\n    function createGroupForSchain(\n        bytes32 schainHash,\n        uint numberOfNodes,\n        uint8 partOfNode\n    )\n        external\n        returns (uint[] memory);\n    function changeLifetime(bytes32 schainHash, uint lifetime, uint deposit) external;\n    function removeSchain(bytes32 schainHash, address from) external;\n    function removeNodeFromSchain(uint nodeIndex, bytes32 schainHash) external;\n    function deleteGroup(bytes32 schainHash) external;\n    function setException(bytes32 schainHash, uint nodeIndex) external;\n    function setNodeInGroup(bytes32 schainHash, uint nodeIndex) external;\n    function removeHolesForSchain(bytes32 schainHash) external;\n    function addSchainType(uint8 partOfNode, uint numberOfNodes) external;\n    function removeSchainType(uint typeOfSchain) external;\n    function setNumberOfSchainTypes(uint newNumberOfSchainTypes) external;\n    function removeNodeFromAllExceptionSchains(uint nodeIndex) external;\n    function removeAllNodesFromSchainExceptions(bytes32 schainHash) external;\n    function makeSchainNodesInvisible(bytes32 schainHash) external;\n    function makeSchainNodesVisible(bytes32 schainHash) external;\n    function newGeneration() external;\n    function addSchainForNode(uint nodeIndex, bytes32 schainHash) external;\n    function removeSchainForNode(uint nodeIndex, uint schainIndex) external;\n    function removeNodeFromExceptions(bytes32 schainHash, uint nodeIndex) external;\n    function isSchainActive(bytes32 schainHash) external view returns (bool);\n    function schainsAtSystem(uint index) external view returns (bytes32);\n    function numberOfSchains() external view returns (uint64);\n    function getSchains() external view returns (bytes32[] memory);\n    function getSchainsPartOfNode(bytes32 schainHash) external view returns (uint8);\n    function getSchainListSize(address from) external view returns (uint);\n    function getSchainHashesByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainIdsByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainHashesForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainIdsForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainOwner(bytes32 schainHash) external view returns (address);\n    function getSchainOriginator(bytes32 schainHash) external view returns (address);\n    function isSchainNameAvailable(string calldata name) external view returns (bool);\n    function isTimeExpired(bytes32 schainHash) external view returns (bool);\n    function isOwnerAddress(address from, bytes32 schainId) external view returns (bool);\n    function getSchainName(bytes32 schainHash) external view returns (string memory);\n    function getActiveSchain(uint nodeIndex) external view returns (bytes32);\n    function getActiveSchains(uint nodeIndex) external view returns (bytes32[] memory activeSchains);\n    function getNumberOfNodesInGroup(bytes32 schainHash) external view returns (uint);\n    function getNodesInGroup(bytes32 schainHash) external view returns (uint[] memory);\n    function isNodeAddressesInGroup(bytes32 schainId, address sender) external view returns (bool);\n    function getNodeIndexInGroup(bytes32 schainHash, uint nodeId) external view returns (uint);\n    function isAnyFreeNode(bytes32 schainHash) external view returns (bool);\n    function checkException(bytes32 schainHash, uint nodeIndex) external view returns (bool);\n    function checkHoleForSchain(bytes32 schainHash, uint indexOfNode) external view returns (bool);\n    function checkSchainOnNode(uint nodeIndex, bytes32 schainHash) external view returns (bool);\n    function getSchainType(uint typeOfSchain) external view returns(uint8, uint);\n    function getGeneration(bytes32 schainHash) external view returns (uint);\n    function isSchainExist(bytes32 schainHash) external view returns (bool);\n}"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchainsInternal - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"./INodes.sol\";\n\ninterface ISchainsInternal {\n    struct Schain {\n        string name;\n        address owner;\n        uint indexInOwnerList;\n        uint8 partOfNode;\n        uint lifetime;\n        uint startDate;\n        uint startBlock;\n        uint deposit;\n        uint64 index;\n        uint generation;\n        address originator;\n    }\n\n    struct SchainType {\n        uint8 partOfNode;\n        uint numberOfNodes;\n    }\n\n    /**\n     * @dev Emitted when schain type added.\n     */\n    event SchainTypeAdded(uint indexed schainType, uint partOfNode, uint numberOfNodes);\n\n    /**\n     * @dev Emitted when schain type removed.\n     */\n    event SchainTypeRemoved(uint indexed schainType);\n\n    function initializeSchain(\n        string calldata name,\n        address from,\n        address originator,\n        uint lifetime,\n        uint deposit) external;\n    function createGroupForSchain(\n        bytes32 schainHash,\n        uint numberOfNodes,\n        uint8 partOfNode\n    )\n        external\n        returns (uint[] memory);\n    function changeLifetime(bytes32 schainHash, uint lifetime, uint deposit) external;\n    function removeSchain(bytes32 schainHash, address from) external;\n    function removeNodeFromSchain(uint nodeIndex, bytes32 schainHash) external;\n    function deleteGroup(bytes32 schainHash) external;\n    function setException(bytes32 schainHash, uint nodeIndex) external;\n    function setNodeInGroup(bytes32 schainHash, uint nodeIndex) external;\n    function removeHolesForSchain(bytes32 schainHash) external;\n    function addSchainType(uint8 partOfNode, uint numberOfNodes) external;\n    function removeSchainType(uint typeOfSchain) external;\n    function setNumberOfSchainTypes(uint newNumberOfSchainTypes) external;\n    function removeNodeFromAllExceptionSchains(uint nodeIndex) external;\n    function removeAllNodesFromSchainExceptions(bytes32 schainHash) external;\n    function makeSchainNodesInvisible(bytes32 schainHash) external;\n    function makeSchainNodesVisible(bytes32 schainHash) external;\n    function newGeneration() external;\n    function addSchainForNode(INodes nodes,uint nodeIndex, bytes32 schainHash) external;\n    function removeSchainForNode(uint nodeIndex, uint schainIndex) external;\n    function removeNodeFromExceptions(bytes32 schainHash, uint nodeIndex) external;\n    function isSchainActive(bytes32 schainHash) external view returns (bool);\n    function schainsAtSystem(uint index) external view returns (bytes32);\n    function numberOfSchains() external view returns (uint64);\n    function getSchains() external view returns (bytes32[] memory);\n    function getSchainsPartOfNode(bytes32 schainHash) external view returns (uint8);\n    function getSchainListSize(address from) external view returns (uint);\n    function getSchainHashesByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainHashesForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainOwner(bytes32 schainHash) external view returns (address);\n    function getSchainOriginator(bytes32 schainHash) external view returns (address);\n    function isSchainNameAvailable(string calldata name) external view returns (bool);\n    function isTimeExpired(bytes32 schainHash) external view returns (bool);\n    function isOwnerAddress(address from, bytes32 schainHash) external view returns (bool);\n    function getSchainName(bytes32 schainHash) external view returns (string memory);\n    function getActiveSchain(uint nodeIndex) external view returns (bytes32);\n    function getActiveSchains(uint nodeIndex) external view returns (bytes32[] memory activeSchains);\n    function getNumberOfNodesInGroup(bytes32 schainHash) external view returns (uint);\n    function getNodesInGroup(bytes32 schainHash) external view returns (uint[] memory);\n    function isNodeAddressesInGroup(bytes32 schainHash, address sender) external view returns (bool);\n    function getNodeIndexInGroup(bytes32 schainHash, uint nodeHash) external view returns (uint);\n    function isAnyFreeNode(bytes32 schainHash) external view returns (bool);\n    function checkException(bytes32 schainHash, uint nodeIndex) external view returns (bool);\n    function checkHoleForSchain(bytes32 schainHash, uint indexOfNode) external view returns (bool);\n    function checkSchainOnNode(uint nodeIndex, bytes32 schainHash) external view returns (bool);\n    function getSchainType(uint typeOfSchain) external view returns(uint8, uint);\n    function getGeneration(bytes32 schainHash) external view returns (uint);\n    function isSchainExist(bytes32 schainHash) external view returns (bool);\n}"
             },
             "@skalenetwork/skale-manager-interfaces/IWallets.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IWallets - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IWallets {\n    /**\n     * @dev Emitted when the validator wallet was funded\n     */\n    event ValidatorWalletRecharged(address sponsor, uint amount, uint validatorId);\n\n    /**\n     * @dev Emitted when the schain wallet was funded\n     */\n    event SchainWalletRecharged(address sponsor, uint amount, bytes32 schainHash);\n\n    /**\n     * @dev Emitted when the node received a refund from validator to its wallet\n     */\n    event NodeRefundedByValidator(address node, uint validatorId, uint amount);\n\n    /**\n     * @dev Emitted when the node received a refund from schain to its wallet\n     */\n    event NodeRefundedBySchain(address node, bytes32 schainHash, uint amount);\n\n    /**\n     * @dev Emitted when the validator withdrawn funds from validator wallet\n     */\n    event WithdrawFromValidatorWallet(uint indexed validatorId, uint amount);\n\n    /**\n     * @dev Emitted when the schain owner withdrawn funds from schain wallet\n     */\n    event WithdrawFromSchainWallet(bytes32 indexed schainHash, uint amount);\n\n    receive() external payable;\n    function refundGasByValidator(uint validatorId, address payable spender, uint spentGas) external;\n    function refundGasByValidatorToSchain(uint validatorId, bytes32 schainHash) external;\n    function refundGasBySchain(bytes32 schainId, address payable spender, uint spentGas, bool isDebt) external;\n    function withdrawFundsFromSchainWallet(address payable schainOwner, bytes32 schainHash) external;\n    function withdrawFundsFromValidatorWallet(uint amount) external;\n    function rechargeValidatorWallet(uint validatorId) external payable;\n    function rechargeSchainWallet(bytes32 schainId) external payable;\n    function getSchainBalance(bytes32 schainHash) external view returns (uint);\n    function getValidatorBalance(uint validatorId) external view returns (uint);\n}\n"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IWallets - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IWallets {\n    receive() external payable;\n    function refundGasByValidator(uint validatorId, address payable spender, uint gasLimit) external;\n    function refundGasByValidatorToSchain(uint validatorId, bytes32 schainHash) external;\n    function refundGasBySchain(bytes32 schainId, address payable spender, uint spentGas, bool isDebt) external;\n    function withdrawFundsFromSchainWallet(address payable schainOwner, bytes32 schainHash) external;\n    function withdrawFundsFromValidatorWallet(uint amount) external;\n    function rechargeValidatorWallet(uint validatorId) external payable;\n    function rechargeSchainWallet(bytes32 schainId) external payable;\n    function getSchainBalance(bytes32 schainHash) external view returns (uint);\n    function getValidatorBalance(uint validatorId) external view returns (uint);\n}\n"
+            },
+            "@skalenetwork/skale-manager-interfaces/utils/IRandom.sol": {
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IRandom.sol - SKALE Manager Interfaces\n    Copyright (C) 2022-Present SKALE Labs\n    @author Dmytro Stebaiev\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\n\ninterface IRandom {\n    struct RandomGenerator {\n        uint seed;\n    }\n}"
             },
             "contracts/MessageProxy.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   MessageProxy.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/IGasReimbursable.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageProxy.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageReceiver.sol\";\n\n\n/**\n * @title MessageProxy\n * @dev Abstract contract for MessageProxyForMainnet and MessageProxyForSchain.\n */\nabstract contract MessageProxy is AccessControlEnumerableUpgradeable, IMessageProxy {\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    /**\n     * @dev Structure that stores counters for outgoing and incoming messages.\n     */\n    struct ConnectedChainInfo {\n        // message counters start with 0\n        uint256 incomingMessageCounter;\n        uint256 outgoingMessageCounter;\n        bool inited;\n        uint256 lastOutgoingMessageBlockId;\n    }\n\n    bytes32 public constant MAINNET_HASH = keccak256(abi.encodePacked(\"Mainnet\"));\n    bytes32 public constant CHAIN_CONNECTOR_ROLE = keccak256(\"CHAIN_CONNECTOR_ROLE\");\n    bytes32 public constant EXTRA_CONTRACT_REGISTRAR_ROLE = keccak256(\"EXTRA_CONTRACT_REGISTRAR_ROLE\");\n    bytes32 public constant CONSTANT_SETTER_ROLE = keccak256(\"CONSTANT_SETTER_ROLE\");\n    uint256 public constant MESSAGES_LENGTH = 10;\n    uint256 public constant REVERT_REASON_LENGTH = 64;\n\n    //   schainHash => ConnectedChainInfo\n    mapping(bytes32 => ConnectedChainInfo) public connectedChains;\n    //   schainHash => contract address => allowed\n    mapping(bytes32 => mapping(address => bool)) private _deprecatedRegistryContracts;\n\n    uint256 public gasLimit;\n\n    /**\n     * @dev Emitted for every outgoing message to schain.\n     */\n    event OutgoingMessage(\n        bytes32 indexed dstChainHash,\n        uint256 indexed msgCounter,\n        address indexed srcContract,\n        address dstContract,\n        bytes data\n    );\n\n    /**\n     * @dev Emitted when function `postMessage` returns revert.\n     *  Used to prevent stuck loop inside function `postIncomingMessages`.\n     */\n    event PostMessageError(\n        uint256 indexed msgCounter,\n        bytes message\n    );\n\n    /**\n     * @dev Emitted when gas limit per one call of `postMessage` was changed.\n     */\n    event GasLimitWasChanged(\n        uint256 oldValue,\n        uint256 newValue\n    );\n\n    /**\n     * @dev Emitted when the version was updated\n     */\n    event VersionUpdated(string oldVersion, string newVersion);\n\n    /**\n     * @dev Emitted when extra contract was added.\n     */\n    event ExtraContractRegistered(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Emitted when extra contract was removed.\n     */\n    event ExtraContractRemoved(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Emitted when referenced to previous outgoing message.\n     */\n    event PreviousMessageReference (\n        uint256 currentMessage,\n        uint256 previousOutgoingMessageBlockId\n    );\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CHAIN_CONNECTOR_ROLE}.\n     */\n    modifier onlyChainConnector() {\n        require(hasRole(CHAIN_CONNECTOR_ROLE, msg.sender), \"CHAIN_CONNECTOR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {EXTRA_CONTRACT_REGISTRAR_ROLE}.\n     */\n    modifier onlyExtraContractRegistrar() {\n        require(hasRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender), \"EXTRA_CONTRACT_REGISTRAR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CONSTANT_SETTER_ROLE}.\n     */\n    modifier onlyConstantSetter() {\n        require(hasRole(CONSTANT_SETTER_ROLE, msg.sender), \"Not enough permissions to set constant\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {DEFAULT_ADMIN_ROLE}.\n     */\n    modifier onlyOwner() {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"DEFAULT_ADMIN_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Sets gasLimit to a new value.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CONSTANT_SETTER_ROLE.\n     */\n    function setNewGasLimit(uint256 newGasLimit) external override onlyConstantSetter {\n        emit GasLimitWasChanged(gasLimit, newGasLimit);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Virtual function for `postIncomingMessages`.\n     */\n    function postIncomingMessages(\n        string calldata fromSchainName,\n        uint256 startingCounter,\n        Message[] calldata messages,\n        Signature calldata sign\n    )\n        external\n        virtual\n        override;\n\n    /**\n     * @dev Allows `msg.sender` to register extra contract for all schains\n     * for being able to transfer messages from custom contracts.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     * - Passed address should be contract.\n     * - Extra contract must not be registered.\n     */\n    function registerExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is already registered\");\n        _getRegistryContracts()[bytes32(0)].add(extraContract);\n        emit ExtraContractRegistered(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Allows `msg.sender` to remove extra contract for all schains.\n     * Extra contract will no longer be able to send messages through MessageProxy.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     */\n    function removeExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[bytes32(0)].remove(extraContract);\n        emit ExtraContractRemoved(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Should return length of contract registered by schainHash.\n     */\n    function getContractRegisteredLength(bytes32 schainHash) external view override returns (uint256) {\n        return _getRegistryContracts()[schainHash].length();\n    }\n\n    /**\n     * @dev Should return a range of contracts registered by schainHash.\n     *\n     * Requirements:\n     * range should be less or equal 10 contracts\n     */\n    function getContractRegisteredRange(\n        bytes32 schainHash,\n        uint256 from,\n        uint256 to\n    )\n        external\n        view\n        override\n        returns (address[] memory contractsInRange)\n    {\n        require(\n            from < to && to - from <= 10 && to <= _getRegistryContracts()[schainHash].length(),\n            \"Range is incorrect\"\n        );\n        contractsInRange = new address[](to - from);\n        for (uint256 i = from; i < to; i++) {\n            contractsInRange[i - from] = _getRegistryContracts()[schainHash].at(i);\n        }\n    }\n\n    /**\n     * @dev Returns number of outgoing messages.\n     *\n     * Requirements:\n     *\n     * - Target schain  must be initialized.\n     */\n    function getOutgoingMessagesCounter(string calldata targetSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 dstChainHash = keccak256(abi.encodePacked(targetSchainName));\n        require(connectedChains[dstChainHash].inited, \"Destination chain is not initialized\");\n        return connectedChains[dstChainHash].outgoingMessageCounter;\n    }\n\n\n    /**\n     * @dev Should return block number of the last message transferred to schain\n     */\n    function getLastOutgoingMessageBlockId(string memory targetSchainName) external view override returns (uint) {\n        bytes32 dstChainHash = keccak256(abi.encodePacked(targetSchainName));\n        require(connectedChains[dstChainHash].inited, \"Destination chain is not initialized\");\n        return connectedChains[dstChainHash].lastOutgoingMessageBlockId;\n    }\n\n    /**\n     * @dev Returns number of incoming messages.\n     *\n     * Requirements:\n     *\n     * - Source schain must be initialized.\n     */\n    function getIncomingMessagesCounter(string calldata fromSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 srcChainHash = keccak256(abi.encodePacked(fromSchainName));\n        require(connectedChains[srcChainHash].inited, \"Source chain is not initialized\");\n        return connectedChains[srcChainHash].incomingMessageCounter;\n    }\n\n    function initializeMessageProxy(uint newGasLimit) public initializer {\n        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(CHAIN_CONNECTOR_ROLE, msg.sender);\n        _setupRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender);\n        _setupRole(CONSTANT_SETTER_ROLE, msg.sender);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Posts message from this contract to `targetChainHash` MessageProxy contract.\n     * This is called by a smart contract to make a cross-chain call.\n     *\n     * Emits an {OutgoingMessage} event.\n     *\n     * Requirements:\n     *\n     * - Target chain must be initialized.\n     * - Target chain must be registered as external contract.\n     */\n    function postOutgoingMessage(\n        bytes32 targetChainHash,\n        address targetContract,\n        bytes memory data\n    )\n        public\n        override\n        virtual\n    {\n        require(connectedChains[targetChainHash].inited, \"Destination chain is not initialized\");\n        _authorizeOutgoingMessageSender(targetChainHash);\n\n        uint outgoingMessageCounter = connectedChains[targetChainHash].outgoingMessageCounter;\n        emit OutgoingMessage(\n            targetChainHash,\n            outgoingMessageCounter,\n            msg.sender,\n            targetContract,\n            data\n        );\n        emit PreviousMessageReference(\n            outgoingMessageCounter,\n            connectedChains[targetChainHash].lastOutgoingMessageBlockId\n        );\n        connectedChains[targetChainHash].outgoingMessageCounter++;\n        connectedChains[targetChainHash].lastOutgoingMessageBlockId = block.number;\n    }\n\n    /**\n     * @dev Allows CHAIN_CONNECTOR_ROLE to remove connected chain from this contract.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CHAIN_CONNECTOR_ROLE.\n     * - `schainName` must be initialized.\n     */\n    function removeConnectedChain(string memory schainName) public virtual override onlyChainConnector {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(connectedChains[schainHash].inited, \"Chain is not initialized\");\n        delete connectedChains[schainHash];\n    }\n\n    /**\n     * @dev Checks whether chain is currently connected.\n     */\n    function isConnectedChain(\n        string memory schainName\n    )\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return connectedChains[keccak256(abi.encodePacked(schainName))].inited;\n    }\n\n    /**\n     * @dev Checks whether contract is currently registered as extra contract.\n     */\n    function isContractRegistered(\n        bytes32 schainHash,\n        address contractAddress\n    )\n        public\n        view\n        override\n        returns (bool)\n    {\n        return _getRegistryContracts()[schainHash].contains(contractAddress);\n    }\n\n    /**\n     * @dev Allows MessageProxy to register extra contract for being able to transfer messages from custom contracts.\n     *\n     * Requirements:\n     *\n     * - Extra contract address must be contract.\n     * - Extra contract must not be registered.\n     * - Extra contract must not be registered for all chains.\n     */\n    function _registerExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {\n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is already registered\");\n        require(\n            !_getRegistryContracts()[bytes32(0)].contains(extraContract),\n            \"Extra contract is already registered for all chains\"\n        );\n\n        _getRegistryContracts()[chainHash].add(extraContract);\n        emit ExtraContractRegistered(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to remove extra contract,\n     * thus `extraContract` will no longer be available to transfer messages from mainnet to schain.\n     *\n     * Requirements:\n     *\n     * - Extra contract must be registered.\n     */\n    function _removeExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {\n        require(_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[chainHash].remove(extraContract);\n        emit ExtraContractRemoved(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to connect schain with MessageProxyOnMainnet for transferring messages.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CHAIN_CONNECTOR_ROLE.\n     * - SKALE chain must not be connected.\n     */\n    function _addConnectedChain(bytes32 schainHash) internal onlyChainConnector {\n        require(!connectedChains[schainHash].inited,\"Chain is already connected\");\n        connectedChains[schainHash] = ConnectedChainInfo({\n            incomingMessageCounter: 0,\n            outgoingMessageCounter: 0,\n            inited: true,\n            lastOutgoingMessageBlockId: 0\n        });\n    }\n\n    /**\n     * @dev Allows MessageProxy to send messages from schain to mainnet.\n     * Destination contract must implement `postMessage` method.\n     */\n    function _callReceiverContract(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n    {\n        if (!message.destinationContract.isContract()) {\n            emit PostMessageError(\n                counter,\n                \"Destination contract is not a contract\"\n            );\n            return;\n        }\n        try IMessageReceiver(message.destinationContract).postMessage{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) {\n            return;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                _getSlice(bytes(reason), REVERT_REASON_LENGTH)\n            );\n        } catch Panic(uint errorCode) {\n               emit PostMessageError(\n                counter,\n                abi.encodePacked(errorCode)\n            );\n        } catch (bytes memory revertData) {\n            emit PostMessageError(\n                counter,\n                _getSlice(revertData, REVERT_REASON_LENGTH)\n            );\n        }\n    }\n\n    /**\n     * @dev Returns receiver of message.\n     */\n    function _getGasPayer(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n        returns (address)\n    {\n        try IGasReimbursable(message.destinationContract).gasPayer{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) returns (address receiver) {\n            return receiver;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                _getSlice(bytes(reason), REVERT_REASON_LENGTH)\n            );\n            return address(0);\n        } catch Panic(uint errorCode) {\n               emit PostMessageError(\n                counter,\n                abi.encodePacked(errorCode)\n            );\n            return address(0);\n        } catch (bytes memory revertData) {\n            emit PostMessageError(\n                counter,\n                _getSlice(revertData, REVERT_REASON_LENGTH)\n            );\n            return address(0);\n        }\n    }\n\n    /**\n     * @dev Checks whether msg.sender is registered as custom extra contract.\n     */\n    function _authorizeOutgoingMessageSender(bytes32 targetChainHash) internal view virtual {\n        require(\n            isContractRegistered(bytes32(0), msg.sender) || isContractRegistered(targetChainHash, msg.sender),\n            \"Sender contract is not registered\"\n        );\n    }\n\n    /**\n     * @dev Returns list of registered custom extra contracts.\n     */\n    function _getRegistryContracts()\n        internal\n        view\n        virtual\n        returns (mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) storage);\n\n    /**\n     * @dev Returns hash of message array.\n     */\n    function _hashedArray(\n        Message[] calldata messages,\n        uint256 startingCounter,\n        string calldata fromChainName\n    )\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32 sourceHash = keccak256(abi.encodePacked(fromChainName));\n        bytes32 hash = keccak256(abi.encodePacked(sourceHash, bytes32(startingCounter)));\n        for (uint256 i = 0; i < messages.length; i++) {\n            hash = keccak256(\n                abi.encodePacked(\n                    abi.encode(\n                        hash,\n                        messages[i].sender,\n                        messages[i].destinationContract\n                    ),\n                    messages[i].data\n                )\n            );\n        }\n        return hash;\n    }\n\n    function _getSlice(bytes memory text, uint end) private pure returns (bytes memory) {\n        uint slicedEnd = end < text.length ? end : text.length;\n        bytes memory sliced = new bytes(slicedEnd);\n        for(uint i = 0; i < slicedEnd; i++){\n            sliced[i] = text[i];\n        }\n        return sliced;\n    }\n}\n"
             },
             "contracts/Messages.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   Messages.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\n\n/**\n * @title Messages\n * @dev Library for encoding and decoding messages\n * for transferring from Mainnet to Schain and vice versa.\n */\nlibrary Messages {\n\n    /**\n     * @dev Enumerator that describes all supported message types.\n     */\n    enum MessageType {\n        EMPTY,\n        TRANSFER_ETH,\n        TRANSFER_ERC20,\n        TRANSFER_ERC20_AND_TOTAL_SUPPLY,\n        TRANSFER_ERC20_AND_TOKEN_INFO,\n        TRANSFER_ERC721,\n        TRANSFER_ERC721_AND_TOKEN_INFO,\n        USER_STATUS,\n        INTERCHAIN_CONNECTION,\n        TRANSFER_ERC1155,\n        TRANSFER_ERC1155_AND_TOKEN_INFO,\n        TRANSFER_ERC1155_BATCH,\n        TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO,\n        TRANSFER_ERC721_WITH_METADATA,\n        TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO\n    }\n\n    /**\n     * @dev Structure for base message.\n     */\n    struct BaseMessage {\n        MessageType messageType;\n    }\n\n    /**\n     * @dev Structure for describing ETH.\n     */\n    struct TransferEthMessage {\n        BaseMessage message;\n        address receiver;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for user status.\n     */\n    struct UserStatusMessage {\n        BaseMessage message;\n        address receiver;\n        bool isActive;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 token.\n     */\n    struct TransferErc20Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC20 token.\n     */\n    struct Erc20TokenInfo {\n        string name;\n        uint8 decimals;\n        string symbol;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token supply.\n     */\n    struct TransferErc20AndTotalSupplyMessage {\n        TransferErc20Message baseErc20transfer;\n        uint256 totalSupply;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token info.\n     */\n    struct TransferErc20AndTokenInfoMessage {\n        TransferErc20Message baseErc20transfer;\n        uint256 totalSupply;\n        Erc20TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing base ERC721.\n     */\n    struct TransferErc721Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 tokenId;\n    }\n\n    /**\n     * @dev Structure for describing base ERC721 with metadata.\n     */\n    struct TransferErc721MessageWithMetadata {\n        TransferErc721Message erc721message;\n        string tokenURI;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token info.\n     */\n    struct Erc721TokenInfo {\n        string name;\n        string symbol;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC721 token.\n     */\n    struct TransferErc721AndTokenInfoMessage {\n        TransferErc721Message baseErc721transfer;\n        Erc721TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC721 token with metadata.\n     */\n    struct TransferErc721WithMetadataAndTokenInfoMessage {\n        TransferErc721MessageWithMetadata baseErc721transferWithMetadata;\n        Erc721TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing whether interchain connection is allowed.\n     */\n    struct InterchainConnectionMessage {\n        BaseMessage message;\n        bool isAllowed;\n    }\n\n    /**\n     * @dev Structure for describing whether interchain connection is allowed.\n     */\n    struct TransferErc1155Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 id;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for describing ERC1155 token in batches.\n     */\n    struct TransferErc1155BatchMessage {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256[] ids;\n        uint256[] amounts;\n    }\n\n    /**\n     * @dev Structure for describing ERC1155 token info.\n     */\n    struct Erc1155TokenInfo {\n        string uri;\n    }\n\n    /**\n     * @dev Structure for describing message for transferring ERC1155 token with info.\n     */\n    struct TransferErc1155AndTokenInfoMessage {\n        TransferErc1155Message baseErc1155transfer;\n        Erc1155TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing message for transferring ERC1155 token in batches with info.\n     */\n    struct TransferErc1155BatchAndTokenInfoMessage {\n        TransferErc1155BatchMessage baseErc1155Batchtransfer;\n        Erc1155TokenInfo tokenInfo;\n    }\n\n\n    /**\n     * @dev Returns type of message for encoded data.\n     */\n    function getMessageType(bytes calldata data) internal pure returns (MessageType) {\n        uint256 firstWord = abi.decode(data, (uint256));\n        if (firstWord % 32 == 0) {\n            return getMessageType(data[firstWord:]);\n        } else {\n            return abi.decode(data, (Messages.MessageType));\n        }\n    }\n\n    /**\n     * @dev Encodes message for transferring ETH. Returns encoded message.\n     */\n    function encodeTransferEthMessage(address receiver, uint256 amount) internal pure returns (bytes memory) {\n        TransferEthMessage memory message = TransferEthMessage(\n            BaseMessage(MessageType.TRANSFER_ETH),\n            receiver,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ETH. Returns structure `TransferEthMessage`.\n     */\n    function decodeTransferEthMessage(\n        bytes calldata data\n    ) internal pure returns (TransferEthMessage memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ETH, \"Message type is not ETH transfer\");\n        return abi.decode(data, (TransferEthMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ETH. Returns encoded message.\n     */\n    function encodeTransferErc20Message(\n        address token,\n        address receiver,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        TransferErc20Message memory message = TransferErc20Message(\n            BaseMessage(MessageType.TRANSFER_ERC20),\n            token,\n            receiver,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC20 with total supply. Returns encoded message.\n     */\n    function encodeTransferErc20AndTotalSupplyMessage(\n        address token,\n        address receiver,\n        uint256 amount,\n        uint256 totalSupply\n    ) internal pure returns (bytes memory) {\n        TransferErc20AndTotalSupplyMessage memory message = TransferErc20AndTotalSupplyMessage(\n            TransferErc20Message(\n                BaseMessage(MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY),\n                token,\n                receiver,\n                amount\n            ),\n            totalSupply\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20. Returns structure `TransferErc20Message`.\n     */\n    function decodeTransferErc20Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc20Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC20, \"Message type is not ERC20 transfer\");\n        return abi.decode(data, (TransferErc20Message));\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20 with total supply. \n     * Returns structure `TransferErc20AndTotalSupplyMessage`.\n     */\n    function decodeTransferErc20AndTotalSupplyMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc20AndTotalSupplyMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY,\n            \"Message type is not ERC20 transfer and total supply\"\n        );\n        return abi.decode(data, (TransferErc20AndTotalSupplyMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC20 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc20AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 amount,\n        uint256 totalSupply,\n        Erc20TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc20AndTokenInfoMessage memory message = TransferErc20AndTokenInfoMessage(\n            TransferErc20Message(\n                BaseMessage(MessageType.TRANSFER_ERC20_AND_TOKEN_INFO),\n                token,\n                receiver,\n                amount\n            ),\n            totalSupply,\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20 with token info. \n     * Returns structure `TransferErc20AndTokenInfoMessage`.\n     */\n    function decodeTransferErc20AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc20AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC20_AND_TOKEN_INFO,\n            \"Message type is not ERC20 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc20AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721Message(\n        address token,\n        address receiver,\n        uint256 tokenId\n    ) internal pure returns (bytes memory) {\n        TransferErc721Message memory message = TransferErc721Message(\n            BaseMessage(MessageType.TRANSFER_ERC721),\n            token,\n            receiver,\n            tokenId\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721. \n     * Returns structure `TransferErc721Message`.\n     */\n    function decodeTransferErc721Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc721Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC721, \"Message type is not ERC721 transfer\");\n        return abi.decode(data, (TransferErc721Message));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        Erc721TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc721AndTokenInfoMessage memory message = TransferErc721AndTokenInfoMessage(\n            TransferErc721Message(\n                BaseMessage(MessageType.TRANSFER_ERC721_AND_TOKEN_INFO),\n                token,\n                receiver,\n                tokenId\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721 with token info. \n     * Returns structure `TransferErc721AndTokenInfoMessage`.\n     */\n    function decodeTransferErc721AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc721AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_AND_TOKEN_INFO,\n            \"Message type is not ERC721 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc721AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721MessageWithMetadata(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        string memory tokenURI\n    ) internal pure returns (bytes memory) {\n        TransferErc721MessageWithMetadata memory message = TransferErc721MessageWithMetadata(\n            TransferErc721Message(\n                BaseMessage(MessageType.TRANSFER_ERC721_WITH_METADATA),\n                token,\n                receiver,\n                tokenId\n            ),\n            tokenURI\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721. \n     * Returns structure `TransferErc721MessageWithMetadata`.\n     */\n    function decodeTransferErc721MessageWithMetadata(\n        bytes calldata data\n    ) internal pure returns (TransferErc721MessageWithMetadata memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_WITH_METADATA,\n            \"Message type is not ERC721 transfer\"\n        );\n        return abi.decode(data, (TransferErc721MessageWithMetadata));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721WithMetadataAndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        string memory tokenURI,\n        Erc721TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc721WithMetadataAndTokenInfoMessage memory message = TransferErc721WithMetadataAndTokenInfoMessage(\n            TransferErc721MessageWithMetadata(\n                TransferErc721Message(\n                    BaseMessage(MessageType.TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO),\n                    token,\n                    receiver,\n                    tokenId\n                ),\n                tokenURI\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721 with token info. \n     * Returns structure `TransferErc721WithMetadataAndTokenInfoMessage`.\n     */\n    function decodeTransferErc721WithMetadataAndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc721WithMetadataAndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO,\n            \"Message type is not ERC721 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc721WithMetadataAndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for activating user on schain. \n     * Returns encoded message.\n     */\n    function encodeActivateUserMessage(address receiver) internal pure returns (bytes memory){\n        return _encodeUserStatusMessage(receiver, true);\n    }\n\n    /**\n     * @dev Encodes message for locking user on schain. \n     * Returns encoded message.\n     */\n    function encodeLockUserMessage(address receiver) internal pure returns (bytes memory){\n        return _encodeUserStatusMessage(receiver, false);\n    }\n\n    /**\n     * @dev Decodes message for user status. \n     * Returns structure UserStatusMessage.\n     */\n    function decodeUserStatusMessage(bytes calldata data) internal pure returns (UserStatusMessage memory) {\n        require(getMessageType(data) == MessageType.USER_STATUS, \"Message type is not User Status\");\n        return abi.decode(data, (UserStatusMessage));\n    }\n\n\n    /**\n     * @dev Encodes message for allowing interchain connection.\n     * Returns encoded message.\n     */\n    function encodeInterchainConnectionMessage(bool isAllowed) internal pure returns (bytes memory) {\n        InterchainConnectionMessage memory message = InterchainConnectionMessage(\n            BaseMessage(MessageType.INTERCHAIN_CONNECTION),\n            isAllowed\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for allowing interchain connection.\n     * Returns structure `InterchainConnectionMessage`.\n     */\n    function decodeInterchainConnectionMessage(bytes calldata data)\n        internal\n        pure\n        returns (InterchainConnectionMessage memory)\n    {\n        require(getMessageType(data) == MessageType.INTERCHAIN_CONNECTION, \"Message type is not Interchain connection\");\n        return abi.decode(data, (InterchainConnectionMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155Message(\n        address token,\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        TransferErc1155Message memory message = TransferErc1155Message(\n            BaseMessage(MessageType.TRANSFER_ERC1155),\n            token,\n            receiver,\n            id,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token.\n     * Returns structure `TransferErc1155Message`.\n     */\n    function decodeTransferErc1155Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC1155, \"Message type is not ERC1155 transfer\");\n        return abi.decode(data, (TransferErc1155Message));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 with token info.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 id,\n        uint256 amount,\n        Erc1155TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc1155AndTokenInfoMessage memory message = TransferErc1155AndTokenInfoMessage(\n            TransferErc1155Message(\n                BaseMessage(MessageType.TRANSFER_ERC1155_AND_TOKEN_INFO),\n                token,\n                receiver,\n                id,\n                amount\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 with token info.\n     * Returns structure `TransferErc1155AndTokenInfoMessage`.\n     */\n    function decodeTransferErc1155AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_AND_TOKEN_INFO,\n            \"Message type is not ERC1155AndTokenInfo transfer\"\n        );\n        return abi.decode(data, (TransferErc1155AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token in batches.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155BatchMessage(\n        address token,\n        address receiver,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal pure returns (bytes memory) {\n        TransferErc1155BatchMessage memory message = TransferErc1155BatchMessage(\n            BaseMessage(MessageType.TRANSFER_ERC1155_BATCH),\n            token,\n            receiver,\n            ids,\n            amounts\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token in batches.\n     * Returns structure `TransferErc1155BatchMessage`.\n     */\n    function decodeTransferErc1155BatchMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155BatchMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_BATCH,\n            \"Message type is not ERC1155Batch transfer\"\n        );\n        return abi.decode(data, (TransferErc1155BatchMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token in batches with token info.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155BatchAndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        Erc1155TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc1155BatchAndTokenInfoMessage memory message = TransferErc1155BatchAndTokenInfoMessage(\n            TransferErc1155BatchMessage(\n                BaseMessage(MessageType.TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO),\n                token,\n                receiver,\n                ids,\n                amounts\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token in batches with token info.\n     * Returns structure `TransferErc1155BatchAndTokenInfoMessage`.\n     */\n    function decodeTransferErc1155BatchAndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155BatchAndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO,\n            \"Message type is not ERC1155BatchAndTokenInfo transfer\"\n        );\n        return abi.decode(data, (TransferErc1155BatchAndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring user status on schain.\n     * Returns encoded message.\n     */\n    function _encodeUserStatusMessage(address receiver, bool isActive) private pure returns (bytes memory) {\n        UserStatusMessage memory message = UserStatusMessage(\n            BaseMessage(MessageType.USER_STATUS),\n            receiver,\n            isActive\n        );\n        return abi.encode(message);\n    }\n\n}"
             },
@@ -403,11 +409,11 @@
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   RevertableERC20.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2022-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\ninterface IRevertableERC20 {\n    function enable() external;\n    function disable() external;\n    function mint(address account, uint amount) external;\n}\n\ncontract RevertableERC20 is IRevertableERC20, ERC20Upgradeable {\n    bool public enabled = true;\n\n    constructor(string memory name, string memory symbol) initializer {\n        super.__ERC20_init(name, symbol);\n    }\n\n    function enable() external override {\n        enabled = true;\n    }\n\n    function disable() external override {\n        enabled = false;\n    }\n\n    function mint(address account, uint amount) external override {\n        _mint(account, amount);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    )\n        internal\n        override\n    {\n        require(enabled, \"Transfers are disabled\");\n        super._transfer(from, to, amount);\n    }\n}"
             },
             "contracts/thirdparty/ERC1155ReceiverUpgradeableWithoutGap.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol\";\n\nabstract contract ERC1155ReceiverUpgradeableWithoutGap is\n    Initializable,\n    ERC165Upgradeable,\n    IERC1155ReceiverUpgradeable\n{\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165Upgradeable)\n        returns (bool)\n    {\n        return interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function __ERC1155Receiver_init() internal initializer {\n        __ERC165_init_unchained();\n        __ERC1155Receiver_init_unchained();\n    }\n\n    // solhint-disable-next-line func-name-mixedcase, no-empty-blocks\n    function __ERC1155Receiver_init_unchained() internal initializer {\n    }\n}"
             }
         }
     },
-    "name": "TokenManagerERC1155",
+    "name": "TokenManager",
     "solcLongVersion": "0.8.16+commit.07a7930e",
     "solcVersion": "0.8.16"
 }
```

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/TokenManagerERC20.json` & `ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/TokenManagerERC20.json`

 * *Files identical despite different names*

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/TokenManagerERC20.meta.json` & `ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/TokenManagerERC1155.meta.json`

 * *Files 1% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.8745592948717948%*

 * *Differences: {"'input'": "{'sources': {'@skalenetwork/skale-manager-interfaces/IWallets.sol': {'content': '// "*

 * *            'SPDX-License-Identifier: AGPL-3.0-only\\n\\n/*\\n    IWallets - SKALE Manager '*

 * *            'Interfaces\\n    Copyright (C) 2021-Present SKALE Labs\\n    @author Dmytro '*

 * *            'Stebaeiv\\n\\n    SKALE Manager Interfaces is free software: you can redistribute it '*

 * *            'and/or modify\\n    it under the terms of the GNU Affero General Public License as '*

 * *            'published\\n    by […]*

```diff
@@ -218,22 +218,28 @@
             },
             "@skalenetwork/ima-interfaces/schain/tokens/IEthErc20.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   IEthErc20 - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\n\ninterface IEthErc20 {\n    function mint(address account, uint256 amount) external;\n    function forceBurn(address account, uint256 amount) external;\n    function initialize(address tokenManagerEthAddress) external;\n}"
             },
             "@skalenetwork/skale-manager-interfaces/IContractManager.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IContractManager.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IContractManager {\n    /**\n     * @dev Emitted when contract is upgraded.\n     */\n    event ContractUpgraded(string contractsName, address contractsAddress);\n\n    function initialize() external;\n    function setContractsAddress(string calldata contractsName, address newContractsAddress) external;\n    function contracts(bytes32 nameHash) external view returns (address);\n    function getDelegationPeriodManager() external view returns (address);\n    function getBounty() external view returns (address);\n    function getValidatorService() external view returns (address);\n    function getTimeHelpers() external view returns (address);\n    function getConstantsHolder() external view returns (address);\n    function getSkaleToken() external view returns (address);\n    function getTokenState() external view returns (address);\n    function getPunisher() external view returns (address);\n    function getContract(string calldata name) external view returns (address);\n}"
             },
+            "@skalenetwork/skale-manager-interfaces/INodes.sol": {
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    INodes.sol - SKALE Manager\n    Copyright (C) 2018-Present SKALE Labs\n    @author Artem Payvin\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"./utils/IRandom.sol\";\n\ninterface INodes {\n    // All Nodes states\n    enum NodeStatus {Active, Leaving, Left, In_Maintenance}\n\n    struct Node {\n        string name;\n        bytes4 ip;\n        bytes4 publicIP;\n        uint16 port;\n        bytes32[2] publicKey;\n        uint startBlock;\n        uint lastRewardDate;\n        uint finishTime;\n        NodeStatus status;\n        uint validatorId;\n    }\n\n    // struct to note which Nodes and which number of Nodes owned by user\n    struct CreatedNodes {\n        mapping (uint => bool) isNodeExist;\n        uint numberOfNodes;\n    }\n\n    struct SpaceManaging {\n        uint8 freeSpace;\n        uint indexInSpaceMap;\n    }\n\n    struct NodeCreationParams {\n        string name;\n        bytes4 ip;\n        bytes4 publicIp;\n        uint16 port;\n        bytes32[2] publicKey;\n        uint16 nonce;\n        string domainName;\n    }\n    \n    /**\n     * @dev Emitted when a node is created.\n     */\n    event NodeCreated(\n        uint nodeIndex,\n        address owner,\n        string name,\n        bytes4 ip,\n        bytes4 publicIP,\n        uint16 port,\n        uint16 nonce,\n        string domainName\n    );\n\n    /**\n     * @dev Emitted when a node completes a network exit.\n     */\n    event ExitCompleted(\n        uint nodeIndex\n    );\n\n    /**\n     * @dev Emitted when a node begins to exit from the network.\n     */\n    event ExitInitialized(\n        uint nodeIndex,\n        uint startLeavingPeriod\n    );\n\n    /**\n     * @dev Emitted when a node set to in compliant or compliant.\n     */\n    event IncompliantNode(\n        uint indexed nodeIndex,\n        bool status\n    );\n\n    /**\n     * @dev Emitted when a node set to in maintenance or from in maintenance.\n     */\n    event MaintenanceNode(\n        uint indexed nodeIndex,\n        bool status\n    );\n\n    /**\n     * @dev Emitted when a node status changed.\n     */\n    event IPChanged(\n        uint indexed nodeIndex,\n        bytes4 previousIP,\n        bytes4 newIP\n    );\n    \n    function removeSpaceFromNode(uint nodeIndex, uint8 space) external returns (bool);\n    function addSpaceToNode(uint nodeIndex, uint8 space) external;\n    function changeNodeLastRewardDate(uint nodeIndex) external;\n    function changeNodeFinishTime(uint nodeIndex, uint time) external;\n    function createNode(address from, NodeCreationParams calldata params) external;\n    function initExit(uint nodeIndex) external;\n    function completeExit(uint nodeIndex) external returns (bool);\n    function deleteNodeForValidator(uint validatorId, uint nodeIndex) external;\n    function checkPossibilityCreatingNode(address nodeAddress) external;\n    function checkPossibilityToMaintainNode(uint validatorId, uint nodeIndex) external returns (bool);\n    function setNodeInMaintenance(uint nodeIndex) external;\n    function removeNodeFromInMaintenance(uint nodeIndex) external;\n    function setNodeIncompliant(uint nodeIndex) external;\n    function setNodeCompliant(uint nodeIndex) external;\n    function setDomainName(uint nodeIndex, string memory domainName) external;\n    function makeNodeVisible(uint nodeIndex) external;\n    function makeNodeInvisible(uint nodeIndex) external;\n    function changeIP(uint nodeIndex, bytes4 newIP, bytes4 newPublicIP) external;\n    function numberOfActiveNodes() external view returns (uint);\n    function incompliant(uint nodeIndex) external view returns (bool);\n    function getRandomNodeWithFreeSpace(\n        uint8 freeSpace,\n        IRandom.RandomGenerator memory randomGenerator\n    )\n        external\n        view\n        returns (uint);\n    function isTimeForReward(uint nodeIndex) external view returns (bool);\n    function getNodeIP(uint nodeIndex) external view returns (bytes4);\n    function getNodeDomainName(uint nodeIndex) external view returns (string memory);\n    function getNodePort(uint nodeIndex) external view returns (uint16);\n    function getNodePublicKey(uint nodeIndex) external view returns (bytes32[2] memory);\n    function getNodeAddress(uint nodeIndex) external view returns (address);\n    function getNodeFinishTime(uint nodeIndex) external view returns (uint);\n    function isNodeLeft(uint nodeIndex) external view returns (bool);\n    function isNodeInMaintenance(uint nodeIndex) external view returns (bool);\n    function getNodeLastRewardDate(uint nodeIndex) external view returns (uint);\n    function getNodeNextRewardDate(uint nodeIndex) external view returns (uint);\n    function getNumberOfNodes() external view returns (uint);\n    function getNumberOnlineNodes() external view returns (uint);\n    function getActiveNodeIds() external view returns (uint[] memory activeNodeIds);\n    function getNodeStatus(uint nodeIndex) external view returns (NodeStatus);\n    function getValidatorNodeIndexes(uint validatorId) external view returns (uint[] memory);\n    function countNodesWithFreeSpace(uint8 freeSpace) external view returns (uint count);\n    function getValidatorId(uint nodeIndex) external view returns (uint);\n    function isNodeExist(address from, uint nodeIndex) external view returns (bool);\n    function isNodeActive(uint nodeIndex) external view returns (bool);\n    function isNodeLeaving(uint nodeIndex) external view returns (bool);\n}\n"
+            },
             "@skalenetwork/skale-manager-interfaces/ISchains.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchains.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchains {\n\n    struct SchainOption {\n        string name;\n        bytes value;\n    }\n    \n    /**\n     * @dev Emitted when an schain is created.\n     */\n    event SchainCreated(\n        string name,\n        address owner,\n        uint partOfNode,\n        uint lifetime,\n        uint numberOfNodes,\n        uint deposit,\n        uint16 nonce,\n        bytes32 schainHash\n    );\n\n    /**\n     * @dev Emitted when an schain is deleted.\n     */\n    event SchainDeleted(\n        address owner,\n        string name,\n        bytes32 indexed schainHash\n    );\n\n    /**\n     * @dev Emitted when a node in an schain is rotated.\n     */\n    event NodeRotated(\n        bytes32 schainHash,\n        uint oldNode,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a node is added to an schain.\n     */\n    event NodeAdded(\n        bytes32 schainHash,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a group of nodes is created for an schain.\n     */\n    event SchainNodes(\n        string name,\n        bytes32 schainHash,\n        uint[] nodesInGroup\n    );\n\n    function addSchain(address from, uint deposit, bytes calldata data) external;\n    function addSchainByFoundation(\n        uint lifetime,\n        uint8 typeOfSchain,\n        uint16 nonce,\n        string calldata name,\n        address schainOwner,\n        address schainOriginator,\n        SchainOption[] calldata options\n    )\n        external\n        payable;\n    function deleteSchain(address from, string calldata name) external;\n    function deleteSchainByRoot(string calldata name) external;\n    function restartSchainCreation(string calldata name) external;\n    function verifySchainSignature(\n        uint256 signA,\n        uint256 signB,\n        bytes32 hash,\n        uint256 counter,\n        uint256 hashA,\n        uint256 hashB,\n        string calldata schainName\n    )\n        external\n        view\n        returns (bool);\n    function getSchainPrice(uint typeOfSchain, uint lifetime) external view returns (uint);\n    function getOption(bytes32 schainHash, string calldata optionName) external view returns (bytes memory);\n    function getOptions(bytes32 schainHash) external view returns (SchainOption[] memory);\n}"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchains.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchains {\n\n    struct SchainOption {\n        string name;\n        bytes value;\n    }\n    \n    /**\n     * @dev Emitted when an schain is created.\n     */\n    event SchainCreated(\n        string name,\n        address owner,\n        uint partOfNode,\n        uint lifetime,\n        uint numberOfNodes,\n        uint deposit,\n        uint16 nonce,\n        bytes32 schainHash\n    );\n\n    /**\n     * @dev Emitted when an schain is deleted.\n     */\n    event SchainDeleted(\n        address owner,\n        string name,\n        bytes32 indexed schainHash\n    );\n\n    /**\n     * @dev Emitted when a node in an schain is rotated.\n     */\n    event NodeRotated(\n        bytes32 schainHash,\n        uint oldNode,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a node is added to an schain.\n     */\n    event NodeAdded(\n        bytes32 schainHash,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a group of nodes is created for an schain.\n     */\n    event SchainNodes(\n        string name,\n        bytes32 schainHash,\n        uint[] nodesInGroup\n    );\n\n    function addSchain(address from, uint deposit, bytes calldata data) external;\n    function addSchainByFoundation(\n        uint lifetime,\n        uint8 typeOfSchain,\n        uint16 nonce,\n        string calldata name,\n        address schainOwner,\n        address schainOriginator,\n        SchainOption[] calldata options\n    )\n        external\n        payable;\n    function deleteSchain(address from, string calldata name) external;\n    function deleteSchainByRoot(string calldata name) external;\n    function restartSchainCreation(string calldata name) external;\n    function verifySchainSignature(\n        uint256 signA,\n        uint256 signB,\n        bytes32 hash,\n        uint256 counter,\n        uint256 hashA,\n        uint256 hashB,\n        string calldata schainName\n    )\n        external\n        view\n        returns (bool);\n    function getSchainPrice(uint typeOfSchain, uint lifetime) external view returns (uint);\n    function getOption(bytes32 schainHash, string calldata optionName) external view returns (bytes memory);\n    function getOptions(bytes32 schainHash) external view returns (SchainOption[] memory);\n}\n"
             },
             "@skalenetwork/skale-manager-interfaces/ISchainsInternal.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchainsInternal - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchainsInternal {\n    struct Schain {\n        string name;\n        address owner;\n        uint indexInOwnerList;\n        uint8 partOfNode;\n        uint lifetime;\n        uint startDate;\n        uint startBlock;\n        uint deposit;\n        uint64 index;\n        uint generation;\n        address originator;\n    }\n\n    struct SchainType {\n        uint8 partOfNode;\n        uint numberOfNodes;\n    }\n\n    /**\n     * @dev Emitted when schain type added.\n     */\n    event SchainTypeAdded(uint indexed schainType, uint partOfNode, uint numberOfNodes);\n\n    /**\n     * @dev Emitted when schain type removed.\n     */\n    event SchainTypeRemoved(uint indexed schainType);\n\n    function initializeSchain(\n        string calldata name,\n        address from,\n        address originator,\n        uint lifetime,\n        uint deposit) external;\n    function createGroupForSchain(\n        bytes32 schainHash,\n        uint numberOfNodes,\n        uint8 partOfNode\n    )\n        external\n        returns (uint[] memory);\n    function changeLifetime(bytes32 schainHash, uint lifetime, uint deposit) external;\n    function removeSchain(bytes32 schainHash, address from) external;\n    function removeNodeFromSchain(uint nodeIndex, bytes32 schainHash) external;\n    function deleteGroup(bytes32 schainHash) external;\n    function setException(bytes32 schainHash, uint nodeIndex) external;\n    function setNodeInGroup(bytes32 schainHash, uint nodeIndex) external;\n    function removeHolesForSchain(bytes32 schainHash) external;\n    function addSchainType(uint8 partOfNode, uint numberOfNodes) external;\n    function removeSchainType(uint typeOfSchain) external;\n    function setNumberOfSchainTypes(uint newNumberOfSchainTypes) external;\n    function removeNodeFromAllExceptionSchains(uint nodeIndex) external;\n    function removeAllNodesFromSchainExceptions(bytes32 schainHash) external;\n    function makeSchainNodesInvisible(bytes32 schainHash) external;\n    function makeSchainNodesVisible(bytes32 schainHash) external;\n    function newGeneration() external;\n    function addSchainForNode(uint nodeIndex, bytes32 schainHash) external;\n    function removeSchainForNode(uint nodeIndex, uint schainIndex) external;\n    function removeNodeFromExceptions(bytes32 schainHash, uint nodeIndex) external;\n    function isSchainActive(bytes32 schainHash) external view returns (bool);\n    function schainsAtSystem(uint index) external view returns (bytes32);\n    function numberOfSchains() external view returns (uint64);\n    function getSchains() external view returns (bytes32[] memory);\n    function getSchainsPartOfNode(bytes32 schainHash) external view returns (uint8);\n    function getSchainListSize(address from) external view returns (uint);\n    function getSchainHashesByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainIdsByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainHashesForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainIdsForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainOwner(bytes32 schainHash) external view returns (address);\n    function getSchainOriginator(bytes32 schainHash) external view returns (address);\n    function isSchainNameAvailable(string calldata name) external view returns (bool);\n    function isTimeExpired(bytes32 schainHash) external view returns (bool);\n    function isOwnerAddress(address from, bytes32 schainId) external view returns (bool);\n    function getSchainName(bytes32 schainHash) external view returns (string memory);\n    function getActiveSchain(uint nodeIndex) external view returns (bytes32);\n    function getActiveSchains(uint nodeIndex) external view returns (bytes32[] memory activeSchains);\n    function getNumberOfNodesInGroup(bytes32 schainHash) external view returns (uint);\n    function getNodesInGroup(bytes32 schainHash) external view returns (uint[] memory);\n    function isNodeAddressesInGroup(bytes32 schainId, address sender) external view returns (bool);\n    function getNodeIndexInGroup(bytes32 schainHash, uint nodeId) external view returns (uint);\n    function isAnyFreeNode(bytes32 schainHash) external view returns (bool);\n    function checkException(bytes32 schainHash, uint nodeIndex) external view returns (bool);\n    function checkHoleForSchain(bytes32 schainHash, uint indexOfNode) external view returns (bool);\n    function checkSchainOnNode(uint nodeIndex, bytes32 schainHash) external view returns (bool);\n    function getSchainType(uint typeOfSchain) external view returns(uint8, uint);\n    function getGeneration(bytes32 schainHash) external view returns (uint);\n    function isSchainExist(bytes32 schainHash) external view returns (bool);\n}"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchainsInternal - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"./INodes.sol\";\n\ninterface ISchainsInternal {\n    struct Schain {\n        string name;\n        address owner;\n        uint indexInOwnerList;\n        uint8 partOfNode;\n        uint lifetime;\n        uint startDate;\n        uint startBlock;\n        uint deposit;\n        uint64 index;\n        uint generation;\n        address originator;\n    }\n\n    struct SchainType {\n        uint8 partOfNode;\n        uint numberOfNodes;\n    }\n\n    /**\n     * @dev Emitted when schain type added.\n     */\n    event SchainTypeAdded(uint indexed schainType, uint partOfNode, uint numberOfNodes);\n\n    /**\n     * @dev Emitted when schain type removed.\n     */\n    event SchainTypeRemoved(uint indexed schainType);\n\n    function initializeSchain(\n        string calldata name,\n        address from,\n        address originator,\n        uint lifetime,\n        uint deposit) external;\n    function createGroupForSchain(\n        bytes32 schainHash,\n        uint numberOfNodes,\n        uint8 partOfNode\n    )\n        external\n        returns (uint[] memory);\n    function changeLifetime(bytes32 schainHash, uint lifetime, uint deposit) external;\n    function removeSchain(bytes32 schainHash, address from) external;\n    function removeNodeFromSchain(uint nodeIndex, bytes32 schainHash) external;\n    function deleteGroup(bytes32 schainHash) external;\n    function setException(bytes32 schainHash, uint nodeIndex) external;\n    function setNodeInGroup(bytes32 schainHash, uint nodeIndex) external;\n    function removeHolesForSchain(bytes32 schainHash) external;\n    function addSchainType(uint8 partOfNode, uint numberOfNodes) external;\n    function removeSchainType(uint typeOfSchain) external;\n    function setNumberOfSchainTypes(uint newNumberOfSchainTypes) external;\n    function removeNodeFromAllExceptionSchains(uint nodeIndex) external;\n    function removeAllNodesFromSchainExceptions(bytes32 schainHash) external;\n    function makeSchainNodesInvisible(bytes32 schainHash) external;\n    function makeSchainNodesVisible(bytes32 schainHash) external;\n    function newGeneration() external;\n    function addSchainForNode(INodes nodes,uint nodeIndex, bytes32 schainHash) external;\n    function removeSchainForNode(uint nodeIndex, uint schainIndex) external;\n    function removeNodeFromExceptions(bytes32 schainHash, uint nodeIndex) external;\n    function isSchainActive(bytes32 schainHash) external view returns (bool);\n    function schainsAtSystem(uint index) external view returns (bytes32);\n    function numberOfSchains() external view returns (uint64);\n    function getSchains() external view returns (bytes32[] memory);\n    function getSchainsPartOfNode(bytes32 schainHash) external view returns (uint8);\n    function getSchainListSize(address from) external view returns (uint);\n    function getSchainHashesByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainHashesForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainOwner(bytes32 schainHash) external view returns (address);\n    function getSchainOriginator(bytes32 schainHash) external view returns (address);\n    function isSchainNameAvailable(string calldata name) external view returns (bool);\n    function isTimeExpired(bytes32 schainHash) external view returns (bool);\n    function isOwnerAddress(address from, bytes32 schainHash) external view returns (bool);\n    function getSchainName(bytes32 schainHash) external view returns (string memory);\n    function getActiveSchain(uint nodeIndex) external view returns (bytes32);\n    function getActiveSchains(uint nodeIndex) external view returns (bytes32[] memory activeSchains);\n    function getNumberOfNodesInGroup(bytes32 schainHash) external view returns (uint);\n    function getNodesInGroup(bytes32 schainHash) external view returns (uint[] memory);\n    function isNodeAddressesInGroup(bytes32 schainHash, address sender) external view returns (bool);\n    function getNodeIndexInGroup(bytes32 schainHash, uint nodeHash) external view returns (uint);\n    function isAnyFreeNode(bytes32 schainHash) external view returns (bool);\n    function checkException(bytes32 schainHash, uint nodeIndex) external view returns (bool);\n    function checkHoleForSchain(bytes32 schainHash, uint indexOfNode) external view returns (bool);\n    function checkSchainOnNode(uint nodeIndex, bytes32 schainHash) external view returns (bool);\n    function getSchainType(uint typeOfSchain) external view returns(uint8, uint);\n    function getGeneration(bytes32 schainHash) external view returns (uint);\n    function isSchainExist(bytes32 schainHash) external view returns (bool);\n}"
             },
             "@skalenetwork/skale-manager-interfaces/IWallets.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IWallets - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IWallets {\n    /**\n     * @dev Emitted when the validator wallet was funded\n     */\n    event ValidatorWalletRecharged(address sponsor, uint amount, uint validatorId);\n\n    /**\n     * @dev Emitted when the schain wallet was funded\n     */\n    event SchainWalletRecharged(address sponsor, uint amount, bytes32 schainHash);\n\n    /**\n     * @dev Emitted when the node received a refund from validator to its wallet\n     */\n    event NodeRefundedByValidator(address node, uint validatorId, uint amount);\n\n    /**\n     * @dev Emitted when the node received a refund from schain to its wallet\n     */\n    event NodeRefundedBySchain(address node, bytes32 schainHash, uint amount);\n\n    /**\n     * @dev Emitted when the validator withdrawn funds from validator wallet\n     */\n    event WithdrawFromValidatorWallet(uint indexed validatorId, uint amount);\n\n    /**\n     * @dev Emitted when the schain owner withdrawn funds from schain wallet\n     */\n    event WithdrawFromSchainWallet(bytes32 indexed schainHash, uint amount);\n\n    receive() external payable;\n    function refundGasByValidator(uint validatorId, address payable spender, uint spentGas) external;\n    function refundGasByValidatorToSchain(uint validatorId, bytes32 schainHash) external;\n    function refundGasBySchain(bytes32 schainId, address payable spender, uint spentGas, bool isDebt) external;\n    function withdrawFundsFromSchainWallet(address payable schainOwner, bytes32 schainHash) external;\n    function withdrawFundsFromValidatorWallet(uint amount) external;\n    function rechargeValidatorWallet(uint validatorId) external payable;\n    function rechargeSchainWallet(bytes32 schainId) external payable;\n    function getSchainBalance(bytes32 schainHash) external view returns (uint);\n    function getValidatorBalance(uint validatorId) external view returns (uint);\n}\n"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IWallets - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IWallets {\n    receive() external payable;\n    function refundGasByValidator(uint validatorId, address payable spender, uint gasLimit) external;\n    function refundGasByValidatorToSchain(uint validatorId, bytes32 schainHash) external;\n    function refundGasBySchain(bytes32 schainId, address payable spender, uint spentGas, bool isDebt) external;\n    function withdrawFundsFromSchainWallet(address payable schainOwner, bytes32 schainHash) external;\n    function withdrawFundsFromValidatorWallet(uint amount) external;\n    function rechargeValidatorWallet(uint validatorId) external payable;\n    function rechargeSchainWallet(bytes32 schainId) external payable;\n    function getSchainBalance(bytes32 schainHash) external view returns (uint);\n    function getValidatorBalance(uint validatorId) external view returns (uint);\n}\n"
+            },
+            "@skalenetwork/skale-manager-interfaces/utils/IRandom.sol": {
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IRandom.sol - SKALE Manager Interfaces\n    Copyright (C) 2022-Present SKALE Labs\n    @author Dmytro Stebaiev\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\n\ninterface IRandom {\n    struct RandomGenerator {\n        uint seed;\n    }\n}"
             },
             "contracts/MessageProxy.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   MessageProxy.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/IGasReimbursable.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageProxy.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageReceiver.sol\";\n\n\n/**\n * @title MessageProxy\n * @dev Abstract contract for MessageProxyForMainnet and MessageProxyForSchain.\n */\nabstract contract MessageProxy is AccessControlEnumerableUpgradeable, IMessageProxy {\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    /**\n     * @dev Structure that stores counters for outgoing and incoming messages.\n     */\n    struct ConnectedChainInfo {\n        // message counters start with 0\n        uint256 incomingMessageCounter;\n        uint256 outgoingMessageCounter;\n        bool inited;\n        uint256 lastOutgoingMessageBlockId;\n    }\n\n    bytes32 public constant MAINNET_HASH = keccak256(abi.encodePacked(\"Mainnet\"));\n    bytes32 public constant CHAIN_CONNECTOR_ROLE = keccak256(\"CHAIN_CONNECTOR_ROLE\");\n    bytes32 public constant EXTRA_CONTRACT_REGISTRAR_ROLE = keccak256(\"EXTRA_CONTRACT_REGISTRAR_ROLE\");\n    bytes32 public constant CONSTANT_SETTER_ROLE = keccak256(\"CONSTANT_SETTER_ROLE\");\n    uint256 public constant MESSAGES_LENGTH = 10;\n    uint256 public constant REVERT_REASON_LENGTH = 64;\n\n    //   schainHash => ConnectedChainInfo\n    mapping(bytes32 => ConnectedChainInfo) public connectedChains;\n    //   schainHash => contract address => allowed\n    mapping(bytes32 => mapping(address => bool)) private _deprecatedRegistryContracts;\n\n    uint256 public gasLimit;\n\n    /**\n     * @dev Emitted for every outgoing message to schain.\n     */\n    event OutgoingMessage(\n        bytes32 indexed dstChainHash,\n        uint256 indexed msgCounter,\n        address indexed srcContract,\n        address dstContract,\n        bytes data\n    );\n\n    /**\n     * @dev Emitted when function `postMessage` returns revert.\n     *  Used to prevent stuck loop inside function `postIncomingMessages`.\n     */\n    event PostMessageError(\n        uint256 indexed msgCounter,\n        bytes message\n    );\n\n    /**\n     * @dev Emitted when gas limit per one call of `postMessage` was changed.\n     */\n    event GasLimitWasChanged(\n        uint256 oldValue,\n        uint256 newValue\n    );\n\n    /**\n     * @dev Emitted when the version was updated\n     */\n    event VersionUpdated(string oldVersion, string newVersion);\n\n    /**\n     * @dev Emitted when extra contract was added.\n     */\n    event ExtraContractRegistered(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Emitted when extra contract was removed.\n     */\n    event ExtraContractRemoved(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Emitted when referenced to previous outgoing message.\n     */\n    event PreviousMessageReference (\n        uint256 currentMessage,\n        uint256 previousOutgoingMessageBlockId\n    );\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CHAIN_CONNECTOR_ROLE}.\n     */\n    modifier onlyChainConnector() {\n        require(hasRole(CHAIN_CONNECTOR_ROLE, msg.sender), \"CHAIN_CONNECTOR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {EXTRA_CONTRACT_REGISTRAR_ROLE}.\n     */\n    modifier onlyExtraContractRegistrar() {\n        require(hasRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender), \"EXTRA_CONTRACT_REGISTRAR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CONSTANT_SETTER_ROLE}.\n     */\n    modifier onlyConstantSetter() {\n        require(hasRole(CONSTANT_SETTER_ROLE, msg.sender), \"Not enough permissions to set constant\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {DEFAULT_ADMIN_ROLE}.\n     */\n    modifier onlyOwner() {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"DEFAULT_ADMIN_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Sets gasLimit to a new value.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CONSTANT_SETTER_ROLE.\n     */\n    function setNewGasLimit(uint256 newGasLimit) external override onlyConstantSetter {\n        emit GasLimitWasChanged(gasLimit, newGasLimit);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Virtual function for `postIncomingMessages`.\n     */\n    function postIncomingMessages(\n        string calldata fromSchainName,\n        uint256 startingCounter,\n        Message[] calldata messages,\n        Signature calldata sign\n    )\n        external\n        virtual\n        override;\n\n    /**\n     * @dev Allows `msg.sender` to register extra contract for all schains\n     * for being able to transfer messages from custom contracts.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     * - Passed address should be contract.\n     * - Extra contract must not be registered.\n     */\n    function registerExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is already registered\");\n        _getRegistryContracts()[bytes32(0)].add(extraContract);\n        emit ExtraContractRegistered(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Allows `msg.sender` to remove extra contract for all schains.\n     * Extra contract will no longer be able to send messages through MessageProxy.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     */\n    function removeExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[bytes32(0)].remove(extraContract);\n        emit ExtraContractRemoved(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Should return length of contract registered by schainHash.\n     */\n    function getContractRegisteredLength(bytes32 schainHash) external view override returns (uint256) {\n        return _getRegistryContracts()[schainHash].length();\n    }\n\n    /**\n     * @dev Should return a range of contracts registered by schainHash.\n     *\n     * Requirements:\n     * range should be less or equal 10 contracts\n     */\n    function getContractRegisteredRange(\n        bytes32 schainHash,\n        uint256 from,\n        uint256 to\n    )\n        external\n        view\n        override\n        returns (address[] memory contractsInRange)\n    {\n        require(\n            from < to && to - from <= 10 && to <= _getRegistryContracts()[schainHash].length(),\n            \"Range is incorrect\"\n        );\n        contractsInRange = new address[](to - from);\n        for (uint256 i = from; i < to; i++) {\n            contractsInRange[i - from] = _getRegistryContracts()[schainHash].at(i);\n        }\n    }\n\n    /**\n     * @dev Returns number of outgoing messages.\n     *\n     * Requirements:\n     *\n     * - Target schain  must be initialized.\n     */\n    function getOutgoingMessagesCounter(string calldata targetSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 dstChainHash = keccak256(abi.encodePacked(targetSchainName));\n        require(connectedChains[dstChainHash].inited, \"Destination chain is not initialized\");\n        return connectedChains[dstChainHash].outgoingMessageCounter;\n    }\n\n\n    /**\n     * @dev Should return block number of the last message transferred to schain\n     */\n    function getLastOutgoingMessageBlockId(string memory targetSchainName) external view override returns (uint) {\n        bytes32 dstChainHash = keccak256(abi.encodePacked(targetSchainName));\n        require(connectedChains[dstChainHash].inited, \"Destination chain is not initialized\");\n        return connectedChains[dstChainHash].lastOutgoingMessageBlockId;\n    }\n\n    /**\n     * @dev Returns number of incoming messages.\n     *\n     * Requirements:\n     *\n     * - Source schain must be initialized.\n     */\n    function getIncomingMessagesCounter(string calldata fromSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 srcChainHash = keccak256(abi.encodePacked(fromSchainName));\n        require(connectedChains[srcChainHash].inited, \"Source chain is not initialized\");\n        return connectedChains[srcChainHash].incomingMessageCounter;\n    }\n\n    function initializeMessageProxy(uint newGasLimit) public initializer {\n        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(CHAIN_CONNECTOR_ROLE, msg.sender);\n        _setupRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender);\n        _setupRole(CONSTANT_SETTER_ROLE, msg.sender);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Posts message from this contract to `targetChainHash` MessageProxy contract.\n     * This is called by a smart contract to make a cross-chain call.\n     *\n     * Emits an {OutgoingMessage} event.\n     *\n     * Requirements:\n     *\n     * - Target chain must be initialized.\n     * - Target chain must be registered as external contract.\n     */\n    function postOutgoingMessage(\n        bytes32 targetChainHash,\n        address targetContract,\n        bytes memory data\n    )\n        public\n        override\n        virtual\n    {\n        require(connectedChains[targetChainHash].inited, \"Destination chain is not initialized\");\n        _authorizeOutgoingMessageSender(targetChainHash);\n\n        uint outgoingMessageCounter = connectedChains[targetChainHash].outgoingMessageCounter;\n        emit OutgoingMessage(\n            targetChainHash,\n            outgoingMessageCounter,\n            msg.sender,\n            targetContract,\n            data\n        );\n        emit PreviousMessageReference(\n            outgoingMessageCounter,\n            connectedChains[targetChainHash].lastOutgoingMessageBlockId\n        );\n        connectedChains[targetChainHash].outgoingMessageCounter++;\n        connectedChains[targetChainHash].lastOutgoingMessageBlockId = block.number;\n    }\n\n    /**\n     * @dev Allows CHAIN_CONNECTOR_ROLE to remove connected chain from this contract.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CHAIN_CONNECTOR_ROLE.\n     * - `schainName` must be initialized.\n     */\n    function removeConnectedChain(string memory schainName) public virtual override onlyChainConnector {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(connectedChains[schainHash].inited, \"Chain is not initialized\");\n        delete connectedChains[schainHash];\n    }\n\n    /**\n     * @dev Checks whether chain is currently connected.\n     */\n    function isConnectedChain(\n        string memory schainName\n    )\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return connectedChains[keccak256(abi.encodePacked(schainName))].inited;\n    }\n\n    /**\n     * @dev Checks whether contract is currently registered as extra contract.\n     */\n    function isContractRegistered(\n        bytes32 schainHash,\n        address contractAddress\n    )\n        public\n        view\n        override\n        returns (bool)\n    {\n        return _getRegistryContracts()[schainHash].contains(contractAddress);\n    }\n\n    /**\n     * @dev Allows MessageProxy to register extra contract for being able to transfer messages from custom contracts.\n     *\n     * Requirements:\n     *\n     * - Extra contract address must be contract.\n     * - Extra contract must not be registered.\n     * - Extra contract must not be registered for all chains.\n     */\n    function _registerExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {\n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is already registered\");\n        require(\n            !_getRegistryContracts()[bytes32(0)].contains(extraContract),\n            \"Extra contract is already registered for all chains\"\n        );\n\n        _getRegistryContracts()[chainHash].add(extraContract);\n        emit ExtraContractRegistered(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to remove extra contract,\n     * thus `extraContract` will no longer be available to transfer messages from mainnet to schain.\n     *\n     * Requirements:\n     *\n     * - Extra contract must be registered.\n     */\n    function _removeExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {\n        require(_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[chainHash].remove(extraContract);\n        emit ExtraContractRemoved(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to connect schain with MessageProxyOnMainnet for transferring messages.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CHAIN_CONNECTOR_ROLE.\n     * - SKALE chain must not be connected.\n     */\n    function _addConnectedChain(bytes32 schainHash) internal onlyChainConnector {\n        require(!connectedChains[schainHash].inited,\"Chain is already connected\");\n        connectedChains[schainHash] = ConnectedChainInfo({\n            incomingMessageCounter: 0,\n            outgoingMessageCounter: 0,\n            inited: true,\n            lastOutgoingMessageBlockId: 0\n        });\n    }\n\n    /**\n     * @dev Allows MessageProxy to send messages from schain to mainnet.\n     * Destination contract must implement `postMessage` method.\n     */\n    function _callReceiverContract(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n    {\n        if (!message.destinationContract.isContract()) {\n            emit PostMessageError(\n                counter,\n                \"Destination contract is not a contract\"\n            );\n            return;\n        }\n        try IMessageReceiver(message.destinationContract).postMessage{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) {\n            return;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                _getSlice(bytes(reason), REVERT_REASON_LENGTH)\n            );\n        } catch Panic(uint errorCode) {\n               emit PostMessageError(\n                counter,\n                abi.encodePacked(errorCode)\n            );\n        } catch (bytes memory revertData) {\n            emit PostMessageError(\n                counter,\n                _getSlice(revertData, REVERT_REASON_LENGTH)\n            );\n        }\n    }\n\n    /**\n     * @dev Returns receiver of message.\n     */\n    function _getGasPayer(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n        returns (address)\n    {\n        try IGasReimbursable(message.destinationContract).gasPayer{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) returns (address receiver) {\n            return receiver;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                _getSlice(bytes(reason), REVERT_REASON_LENGTH)\n            );\n            return address(0);\n        } catch Panic(uint errorCode) {\n               emit PostMessageError(\n                counter,\n                abi.encodePacked(errorCode)\n            );\n            return address(0);\n        } catch (bytes memory revertData) {\n            emit PostMessageError(\n                counter,\n                _getSlice(revertData, REVERT_REASON_LENGTH)\n            );\n            return address(0);\n        }\n    }\n\n    /**\n     * @dev Checks whether msg.sender is registered as custom extra contract.\n     */\n    function _authorizeOutgoingMessageSender(bytes32 targetChainHash) internal view virtual {\n        require(\n            isContractRegistered(bytes32(0), msg.sender) || isContractRegistered(targetChainHash, msg.sender),\n            \"Sender contract is not registered\"\n        );\n    }\n\n    /**\n     * @dev Returns list of registered custom extra contracts.\n     */\n    function _getRegistryContracts()\n        internal\n        view\n        virtual\n        returns (mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) storage);\n\n    /**\n     * @dev Returns hash of message array.\n     */\n    function _hashedArray(\n        Message[] calldata messages,\n        uint256 startingCounter,\n        string calldata fromChainName\n    )\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32 sourceHash = keccak256(abi.encodePacked(fromChainName));\n        bytes32 hash = keccak256(abi.encodePacked(sourceHash, bytes32(startingCounter)));\n        for (uint256 i = 0; i < messages.length; i++) {\n            hash = keccak256(\n                abi.encodePacked(\n                    abi.encode(\n                        hash,\n                        messages[i].sender,\n                        messages[i].destinationContract\n                    ),\n                    messages[i].data\n                )\n            );\n        }\n        return hash;\n    }\n\n    function _getSlice(bytes memory text, uint end) private pure returns (bytes memory) {\n        uint slicedEnd = end < text.length ? end : text.length;\n        bytes memory sliced = new bytes(slicedEnd);\n        for(uint i = 0; i < slicedEnd; i++){\n            sliced[i] = text[i];\n        }\n        return sliced;\n    }\n}\n"
             },
             "contracts/Messages.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   Messages.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\n\n/**\n * @title Messages\n * @dev Library for encoding and decoding messages\n * for transferring from Mainnet to Schain and vice versa.\n */\nlibrary Messages {\n\n    /**\n     * @dev Enumerator that describes all supported message types.\n     */\n    enum MessageType {\n        EMPTY,\n        TRANSFER_ETH,\n        TRANSFER_ERC20,\n        TRANSFER_ERC20_AND_TOTAL_SUPPLY,\n        TRANSFER_ERC20_AND_TOKEN_INFO,\n        TRANSFER_ERC721,\n        TRANSFER_ERC721_AND_TOKEN_INFO,\n        USER_STATUS,\n        INTERCHAIN_CONNECTION,\n        TRANSFER_ERC1155,\n        TRANSFER_ERC1155_AND_TOKEN_INFO,\n        TRANSFER_ERC1155_BATCH,\n        TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO,\n        TRANSFER_ERC721_WITH_METADATA,\n        TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO\n    }\n\n    /**\n     * @dev Structure for base message.\n     */\n    struct BaseMessage {\n        MessageType messageType;\n    }\n\n    /**\n     * @dev Structure for describing ETH.\n     */\n    struct TransferEthMessage {\n        BaseMessage message;\n        address receiver;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for user status.\n     */\n    struct UserStatusMessage {\n        BaseMessage message;\n        address receiver;\n        bool isActive;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 token.\n     */\n    struct TransferErc20Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC20 token.\n     */\n    struct Erc20TokenInfo {\n        string name;\n        uint8 decimals;\n        string symbol;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token supply.\n     */\n    struct TransferErc20AndTotalSupplyMessage {\n        TransferErc20Message baseErc20transfer;\n        uint256 totalSupply;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token info.\n     */\n    struct TransferErc20AndTokenInfoMessage {\n        TransferErc20Message baseErc20transfer;\n        uint256 totalSupply;\n        Erc20TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing base ERC721.\n     */\n    struct TransferErc721Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 tokenId;\n    }\n\n    /**\n     * @dev Structure for describing base ERC721 with metadata.\n     */\n    struct TransferErc721MessageWithMetadata {\n        TransferErc721Message erc721message;\n        string tokenURI;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token info.\n     */\n    struct Erc721TokenInfo {\n        string name;\n        string symbol;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC721 token.\n     */\n    struct TransferErc721AndTokenInfoMessage {\n        TransferErc721Message baseErc721transfer;\n        Erc721TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC721 token with metadata.\n     */\n    struct TransferErc721WithMetadataAndTokenInfoMessage {\n        TransferErc721MessageWithMetadata baseErc721transferWithMetadata;\n        Erc721TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing whether interchain connection is allowed.\n     */\n    struct InterchainConnectionMessage {\n        BaseMessage message;\n        bool isAllowed;\n    }\n\n    /**\n     * @dev Structure for describing whether interchain connection is allowed.\n     */\n    struct TransferErc1155Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 id;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for describing ERC1155 token in batches.\n     */\n    struct TransferErc1155BatchMessage {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256[] ids;\n        uint256[] amounts;\n    }\n\n    /**\n     * @dev Structure for describing ERC1155 token info.\n     */\n    struct Erc1155TokenInfo {\n        string uri;\n    }\n\n    /**\n     * @dev Structure for describing message for transferring ERC1155 token with info.\n     */\n    struct TransferErc1155AndTokenInfoMessage {\n        TransferErc1155Message baseErc1155transfer;\n        Erc1155TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing message for transferring ERC1155 token in batches with info.\n     */\n    struct TransferErc1155BatchAndTokenInfoMessage {\n        TransferErc1155BatchMessage baseErc1155Batchtransfer;\n        Erc1155TokenInfo tokenInfo;\n    }\n\n\n    /**\n     * @dev Returns type of message for encoded data.\n     */\n    function getMessageType(bytes calldata data) internal pure returns (MessageType) {\n        uint256 firstWord = abi.decode(data, (uint256));\n        if (firstWord % 32 == 0) {\n            return getMessageType(data[firstWord:]);\n        } else {\n            return abi.decode(data, (Messages.MessageType));\n        }\n    }\n\n    /**\n     * @dev Encodes message for transferring ETH. Returns encoded message.\n     */\n    function encodeTransferEthMessage(address receiver, uint256 amount) internal pure returns (bytes memory) {\n        TransferEthMessage memory message = TransferEthMessage(\n            BaseMessage(MessageType.TRANSFER_ETH),\n            receiver,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ETH. Returns structure `TransferEthMessage`.\n     */\n    function decodeTransferEthMessage(\n        bytes calldata data\n    ) internal pure returns (TransferEthMessage memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ETH, \"Message type is not ETH transfer\");\n        return abi.decode(data, (TransferEthMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ETH. Returns encoded message.\n     */\n    function encodeTransferErc20Message(\n        address token,\n        address receiver,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        TransferErc20Message memory message = TransferErc20Message(\n            BaseMessage(MessageType.TRANSFER_ERC20),\n            token,\n            receiver,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC20 with total supply. Returns encoded message.\n     */\n    function encodeTransferErc20AndTotalSupplyMessage(\n        address token,\n        address receiver,\n        uint256 amount,\n        uint256 totalSupply\n    ) internal pure returns (bytes memory) {\n        TransferErc20AndTotalSupplyMessage memory message = TransferErc20AndTotalSupplyMessage(\n            TransferErc20Message(\n                BaseMessage(MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY),\n                token,\n                receiver,\n                amount\n            ),\n            totalSupply\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20. Returns structure `TransferErc20Message`.\n     */\n    function decodeTransferErc20Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc20Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC20, \"Message type is not ERC20 transfer\");\n        return abi.decode(data, (TransferErc20Message));\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20 with total supply. \n     * Returns structure `TransferErc20AndTotalSupplyMessage`.\n     */\n    function decodeTransferErc20AndTotalSupplyMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc20AndTotalSupplyMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY,\n            \"Message type is not ERC20 transfer and total supply\"\n        );\n        return abi.decode(data, (TransferErc20AndTotalSupplyMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC20 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc20AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 amount,\n        uint256 totalSupply,\n        Erc20TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc20AndTokenInfoMessage memory message = TransferErc20AndTokenInfoMessage(\n            TransferErc20Message(\n                BaseMessage(MessageType.TRANSFER_ERC20_AND_TOKEN_INFO),\n                token,\n                receiver,\n                amount\n            ),\n            totalSupply,\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20 with token info. \n     * Returns structure `TransferErc20AndTokenInfoMessage`.\n     */\n    function decodeTransferErc20AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc20AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC20_AND_TOKEN_INFO,\n            \"Message type is not ERC20 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc20AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721Message(\n        address token,\n        address receiver,\n        uint256 tokenId\n    ) internal pure returns (bytes memory) {\n        TransferErc721Message memory message = TransferErc721Message(\n            BaseMessage(MessageType.TRANSFER_ERC721),\n            token,\n            receiver,\n            tokenId\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721. \n     * Returns structure `TransferErc721Message`.\n     */\n    function decodeTransferErc721Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc721Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC721, \"Message type is not ERC721 transfer\");\n        return abi.decode(data, (TransferErc721Message));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        Erc721TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc721AndTokenInfoMessage memory message = TransferErc721AndTokenInfoMessage(\n            TransferErc721Message(\n                BaseMessage(MessageType.TRANSFER_ERC721_AND_TOKEN_INFO),\n                token,\n                receiver,\n                tokenId\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721 with token info. \n     * Returns structure `TransferErc721AndTokenInfoMessage`.\n     */\n    function decodeTransferErc721AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc721AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_AND_TOKEN_INFO,\n            \"Message type is not ERC721 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc721AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721MessageWithMetadata(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        string memory tokenURI\n    ) internal pure returns (bytes memory) {\n        TransferErc721MessageWithMetadata memory message = TransferErc721MessageWithMetadata(\n            TransferErc721Message(\n                BaseMessage(MessageType.TRANSFER_ERC721_WITH_METADATA),\n                token,\n                receiver,\n                tokenId\n            ),\n            tokenURI\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721. \n     * Returns structure `TransferErc721MessageWithMetadata`.\n     */\n    function decodeTransferErc721MessageWithMetadata(\n        bytes calldata data\n    ) internal pure returns (TransferErc721MessageWithMetadata memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_WITH_METADATA,\n            \"Message type is not ERC721 transfer\"\n        );\n        return abi.decode(data, (TransferErc721MessageWithMetadata));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721WithMetadataAndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        string memory tokenURI,\n        Erc721TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc721WithMetadataAndTokenInfoMessage memory message = TransferErc721WithMetadataAndTokenInfoMessage(\n            TransferErc721MessageWithMetadata(\n                TransferErc721Message(\n                    BaseMessage(MessageType.TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO),\n                    token,\n                    receiver,\n                    tokenId\n                ),\n                tokenURI\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721 with token info. \n     * Returns structure `TransferErc721WithMetadataAndTokenInfoMessage`.\n     */\n    function decodeTransferErc721WithMetadataAndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc721WithMetadataAndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO,\n            \"Message type is not ERC721 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc721WithMetadataAndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for activating user on schain. \n     * Returns encoded message.\n     */\n    function encodeActivateUserMessage(address receiver) internal pure returns (bytes memory){\n        return _encodeUserStatusMessage(receiver, true);\n    }\n\n    /**\n     * @dev Encodes message for locking user on schain. \n     * Returns encoded message.\n     */\n    function encodeLockUserMessage(address receiver) internal pure returns (bytes memory){\n        return _encodeUserStatusMessage(receiver, false);\n    }\n\n    /**\n     * @dev Decodes message for user status. \n     * Returns structure UserStatusMessage.\n     */\n    function decodeUserStatusMessage(bytes calldata data) internal pure returns (UserStatusMessage memory) {\n        require(getMessageType(data) == MessageType.USER_STATUS, \"Message type is not User Status\");\n        return abi.decode(data, (UserStatusMessage));\n    }\n\n\n    /**\n     * @dev Encodes message for allowing interchain connection.\n     * Returns encoded message.\n     */\n    function encodeInterchainConnectionMessage(bool isAllowed) internal pure returns (bytes memory) {\n        InterchainConnectionMessage memory message = InterchainConnectionMessage(\n            BaseMessage(MessageType.INTERCHAIN_CONNECTION),\n            isAllowed\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for allowing interchain connection.\n     * Returns structure `InterchainConnectionMessage`.\n     */\n    function decodeInterchainConnectionMessage(bytes calldata data)\n        internal\n        pure\n        returns (InterchainConnectionMessage memory)\n    {\n        require(getMessageType(data) == MessageType.INTERCHAIN_CONNECTION, \"Message type is not Interchain connection\");\n        return abi.decode(data, (InterchainConnectionMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155Message(\n        address token,\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        TransferErc1155Message memory message = TransferErc1155Message(\n            BaseMessage(MessageType.TRANSFER_ERC1155),\n            token,\n            receiver,\n            id,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token.\n     * Returns structure `TransferErc1155Message`.\n     */\n    function decodeTransferErc1155Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC1155, \"Message type is not ERC1155 transfer\");\n        return abi.decode(data, (TransferErc1155Message));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 with token info.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 id,\n        uint256 amount,\n        Erc1155TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc1155AndTokenInfoMessage memory message = TransferErc1155AndTokenInfoMessage(\n            TransferErc1155Message(\n                BaseMessage(MessageType.TRANSFER_ERC1155_AND_TOKEN_INFO),\n                token,\n                receiver,\n                id,\n                amount\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 with token info.\n     * Returns structure `TransferErc1155AndTokenInfoMessage`.\n     */\n    function decodeTransferErc1155AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_AND_TOKEN_INFO,\n            \"Message type is not ERC1155AndTokenInfo transfer\"\n        );\n        return abi.decode(data, (TransferErc1155AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token in batches.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155BatchMessage(\n        address token,\n        address receiver,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal pure returns (bytes memory) {\n        TransferErc1155BatchMessage memory message = TransferErc1155BatchMessage(\n            BaseMessage(MessageType.TRANSFER_ERC1155_BATCH),\n            token,\n            receiver,\n            ids,\n            amounts\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token in batches.\n     * Returns structure `TransferErc1155BatchMessage`.\n     */\n    function decodeTransferErc1155BatchMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155BatchMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_BATCH,\n            \"Message type is not ERC1155Batch transfer\"\n        );\n        return abi.decode(data, (TransferErc1155BatchMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token in batches with token info.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155BatchAndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        Erc1155TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc1155BatchAndTokenInfoMessage memory message = TransferErc1155BatchAndTokenInfoMessage(\n            TransferErc1155BatchMessage(\n                BaseMessage(MessageType.TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO),\n                token,\n                receiver,\n                ids,\n                amounts\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token in batches with token info.\n     * Returns structure `TransferErc1155BatchAndTokenInfoMessage`.\n     */\n    function decodeTransferErc1155BatchAndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155BatchAndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO,\n            \"Message type is not ERC1155BatchAndTokenInfo transfer\"\n        );\n        return abi.decode(data, (TransferErc1155BatchAndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring user status on schain.\n     * Returns encoded message.\n     */\n    function _encodeUserStatusMessage(address receiver, bool isActive) private pure returns (bytes memory) {\n        UserStatusMessage memory message = UserStatusMessage(\n            BaseMessage(MessageType.USER_STATUS),\n            receiver,\n            isActive\n        );\n        return abi.encode(message);\n    }\n\n}"
             },
@@ -403,11 +409,11 @@
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   RevertableERC20.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2022-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\ninterface IRevertableERC20 {\n    function enable() external;\n    function disable() external;\n    function mint(address account, uint amount) external;\n}\n\ncontract RevertableERC20 is IRevertableERC20, ERC20Upgradeable {\n    bool public enabled = true;\n\n    constructor(string memory name, string memory symbol) initializer {\n        super.__ERC20_init(name, symbol);\n    }\n\n    function enable() external override {\n        enabled = true;\n    }\n\n    function disable() external override {\n        enabled = false;\n    }\n\n    function mint(address account, uint amount) external override {\n        _mint(account, amount);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    )\n        internal\n        override\n    {\n        require(enabled, \"Transfers are disabled\");\n        super._transfer(from, to, amount);\n    }\n}"
             },
             "contracts/thirdparty/ERC1155ReceiverUpgradeableWithoutGap.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol\";\n\nabstract contract ERC1155ReceiverUpgradeableWithoutGap is\n    Initializable,\n    ERC165Upgradeable,\n    IERC1155ReceiverUpgradeable\n{\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165Upgradeable, IERC165Upgradeable)\n        returns (bool)\n    {\n        return interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function __ERC1155Receiver_init() internal initializer {\n        __ERC165_init_unchained();\n        __ERC1155Receiver_init_unchained();\n    }\n\n    // solhint-disable-next-line func-name-mixedcase, no-empty-blocks\n    function __ERC1155Receiver_init_unchained() internal initializer {\n    }\n}"
             }
         }
     },
-    "name": "TokenManagerERC20",
+    "name": "TokenManagerERC1155",
     "solcLongVersion": "0.8.16+commit.07a7930e",
     "solcVersion": "0.8.16"
 }
```

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/TokenManagerERC721.json` & `ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/TokenManagerERC721.json`

 * *Files identical despite different names*

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/TokenManagerERC721.meta.json` & `ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/TokenManagerERC721.meta.json`

 * *Files 1% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9995592948717948%*

 * *Differences: {"'input'": "{'sources': {'@skalenetwork/skale-manager-interfaces/IWallets.sol': {'content': '// "*

 * *            'SPDX-License-Identifier: AGPL-3.0-only\\n\\n/*\\n    IWallets - SKALE Manager '*

 * *            'Interfaces\\n    Copyright (C) 2021-Present SKALE Labs\\n    @author Dmytro '*

 * *            'Stebaeiv\\n\\n    SKALE Manager Interfaces is free software: you can redistribute it '*

 * *            'and/or modify\\n    it under the terms of the GNU Affero General Public License as '*

 * *            'published\\n    by […]*

```diff
@@ -218,22 +218,28 @@
             },
             "@skalenetwork/ima-interfaces/schain/tokens/IEthErc20.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   IEthErc20 - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\n\ninterface IEthErc20 {\n    function mint(address account, uint256 amount) external;\n    function forceBurn(address account, uint256 amount) external;\n    function initialize(address tokenManagerEthAddress) external;\n}"
             },
             "@skalenetwork/skale-manager-interfaces/IContractManager.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IContractManager.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IContractManager {\n    /**\n     * @dev Emitted when contract is upgraded.\n     */\n    event ContractUpgraded(string contractsName, address contractsAddress);\n\n    function initialize() external;\n    function setContractsAddress(string calldata contractsName, address newContractsAddress) external;\n    function contracts(bytes32 nameHash) external view returns (address);\n    function getDelegationPeriodManager() external view returns (address);\n    function getBounty() external view returns (address);\n    function getValidatorService() external view returns (address);\n    function getTimeHelpers() external view returns (address);\n    function getConstantsHolder() external view returns (address);\n    function getSkaleToken() external view returns (address);\n    function getTokenState() external view returns (address);\n    function getPunisher() external view returns (address);\n    function getContract(string calldata name) external view returns (address);\n}"
             },
+            "@skalenetwork/skale-manager-interfaces/INodes.sol": {
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    INodes.sol - SKALE Manager\n    Copyright (C) 2018-Present SKALE Labs\n    @author Artem Payvin\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"./utils/IRandom.sol\";\n\ninterface INodes {\n    // All Nodes states\n    enum NodeStatus {Active, Leaving, Left, In_Maintenance}\n\n    struct Node {\n        string name;\n        bytes4 ip;\n        bytes4 publicIP;\n        uint16 port;\n        bytes32[2] publicKey;\n        uint startBlock;\n        uint lastRewardDate;\n        uint finishTime;\n        NodeStatus status;\n        uint validatorId;\n    }\n\n    // struct to note which Nodes and which number of Nodes owned by user\n    struct CreatedNodes {\n        mapping (uint => bool) isNodeExist;\n        uint numberOfNodes;\n    }\n\n    struct SpaceManaging {\n        uint8 freeSpace;\n        uint indexInSpaceMap;\n    }\n\n    struct NodeCreationParams {\n        string name;\n        bytes4 ip;\n        bytes4 publicIp;\n        uint16 port;\n        bytes32[2] publicKey;\n        uint16 nonce;\n        string domainName;\n    }\n    \n    /**\n     * @dev Emitted when a node is created.\n     */\n    event NodeCreated(\n        uint nodeIndex,\n        address owner,\n        string name,\n        bytes4 ip,\n        bytes4 publicIP,\n        uint16 port,\n        uint16 nonce,\n        string domainName\n    );\n\n    /**\n     * @dev Emitted when a node completes a network exit.\n     */\n    event ExitCompleted(\n        uint nodeIndex\n    );\n\n    /**\n     * @dev Emitted when a node begins to exit from the network.\n     */\n    event ExitInitialized(\n        uint nodeIndex,\n        uint startLeavingPeriod\n    );\n\n    /**\n     * @dev Emitted when a node set to in compliant or compliant.\n     */\n    event IncompliantNode(\n        uint indexed nodeIndex,\n        bool status\n    );\n\n    /**\n     * @dev Emitted when a node set to in maintenance or from in maintenance.\n     */\n    event MaintenanceNode(\n        uint indexed nodeIndex,\n        bool status\n    );\n\n    /**\n     * @dev Emitted when a node status changed.\n     */\n    event IPChanged(\n        uint indexed nodeIndex,\n        bytes4 previousIP,\n        bytes4 newIP\n    );\n    \n    function removeSpaceFromNode(uint nodeIndex, uint8 space) external returns (bool);\n    function addSpaceToNode(uint nodeIndex, uint8 space) external;\n    function changeNodeLastRewardDate(uint nodeIndex) external;\n    function changeNodeFinishTime(uint nodeIndex, uint time) external;\n    function createNode(address from, NodeCreationParams calldata params) external;\n    function initExit(uint nodeIndex) external;\n    function completeExit(uint nodeIndex) external returns (bool);\n    function deleteNodeForValidator(uint validatorId, uint nodeIndex) external;\n    function checkPossibilityCreatingNode(address nodeAddress) external;\n    function checkPossibilityToMaintainNode(uint validatorId, uint nodeIndex) external returns (bool);\n    function setNodeInMaintenance(uint nodeIndex) external;\n    function removeNodeFromInMaintenance(uint nodeIndex) external;\n    function setNodeIncompliant(uint nodeIndex) external;\n    function setNodeCompliant(uint nodeIndex) external;\n    function setDomainName(uint nodeIndex, string memory domainName) external;\n    function makeNodeVisible(uint nodeIndex) external;\n    function makeNodeInvisible(uint nodeIndex) external;\n    function changeIP(uint nodeIndex, bytes4 newIP, bytes4 newPublicIP) external;\n    function numberOfActiveNodes() external view returns (uint);\n    function incompliant(uint nodeIndex) external view returns (bool);\n    function getRandomNodeWithFreeSpace(\n        uint8 freeSpace,\n        IRandom.RandomGenerator memory randomGenerator\n    )\n        external\n        view\n        returns (uint);\n    function isTimeForReward(uint nodeIndex) external view returns (bool);\n    function getNodeIP(uint nodeIndex) external view returns (bytes4);\n    function getNodeDomainName(uint nodeIndex) external view returns (string memory);\n    function getNodePort(uint nodeIndex) external view returns (uint16);\n    function getNodePublicKey(uint nodeIndex) external view returns (bytes32[2] memory);\n    function getNodeAddress(uint nodeIndex) external view returns (address);\n    function getNodeFinishTime(uint nodeIndex) external view returns (uint);\n    function isNodeLeft(uint nodeIndex) external view returns (bool);\n    function isNodeInMaintenance(uint nodeIndex) external view returns (bool);\n    function getNodeLastRewardDate(uint nodeIndex) external view returns (uint);\n    function getNodeNextRewardDate(uint nodeIndex) external view returns (uint);\n    function getNumberOfNodes() external view returns (uint);\n    function getNumberOnlineNodes() external view returns (uint);\n    function getActiveNodeIds() external view returns (uint[] memory activeNodeIds);\n    function getNodeStatus(uint nodeIndex) external view returns (NodeStatus);\n    function getValidatorNodeIndexes(uint validatorId) external view returns (uint[] memory);\n    function countNodesWithFreeSpace(uint8 freeSpace) external view returns (uint count);\n    function getValidatorId(uint nodeIndex) external view returns (uint);\n    function isNodeExist(address from, uint nodeIndex) external view returns (bool);\n    function isNodeActive(uint nodeIndex) external view returns (bool);\n    function isNodeLeaving(uint nodeIndex) external view returns (bool);\n}\n"
+            },
             "@skalenetwork/skale-manager-interfaces/ISchains.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchains.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchains {\n\n    struct SchainOption {\n        string name;\n        bytes value;\n    }\n    \n    /**\n     * @dev Emitted when an schain is created.\n     */\n    event SchainCreated(\n        string name,\n        address owner,\n        uint partOfNode,\n        uint lifetime,\n        uint numberOfNodes,\n        uint deposit,\n        uint16 nonce,\n        bytes32 schainHash\n    );\n\n    /**\n     * @dev Emitted when an schain is deleted.\n     */\n    event SchainDeleted(\n        address owner,\n        string name,\n        bytes32 indexed schainHash\n    );\n\n    /**\n     * @dev Emitted when a node in an schain is rotated.\n     */\n    event NodeRotated(\n        bytes32 schainHash,\n        uint oldNode,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a node is added to an schain.\n     */\n    event NodeAdded(\n        bytes32 schainHash,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a group of nodes is created for an schain.\n     */\n    event SchainNodes(\n        string name,\n        bytes32 schainHash,\n        uint[] nodesInGroup\n    );\n\n    function addSchain(address from, uint deposit, bytes calldata data) external;\n    function addSchainByFoundation(\n        uint lifetime,\n        uint8 typeOfSchain,\n        uint16 nonce,\n        string calldata name,\n        address schainOwner,\n        address schainOriginator,\n        SchainOption[] calldata options\n    )\n        external\n        payable;\n    function deleteSchain(address from, string calldata name) external;\n    function deleteSchainByRoot(string calldata name) external;\n    function restartSchainCreation(string calldata name) external;\n    function verifySchainSignature(\n        uint256 signA,\n        uint256 signB,\n        bytes32 hash,\n        uint256 counter,\n        uint256 hashA,\n        uint256 hashB,\n        string calldata schainName\n    )\n        external\n        view\n        returns (bool);\n    function getSchainPrice(uint typeOfSchain, uint lifetime) external view returns (uint);\n    function getOption(bytes32 schainHash, string calldata optionName) external view returns (bytes memory);\n    function getOptions(bytes32 schainHash) external view returns (SchainOption[] memory);\n}"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchains.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchains {\n\n    struct SchainOption {\n        string name;\n        bytes value;\n    }\n    \n    /**\n     * @dev Emitted when an schain is created.\n     */\n    event SchainCreated(\n        string name,\n        address owner,\n        uint partOfNode,\n        uint lifetime,\n        uint numberOfNodes,\n        uint deposit,\n        uint16 nonce,\n        bytes32 schainHash\n    );\n\n    /**\n     * @dev Emitted when an schain is deleted.\n     */\n    event SchainDeleted(\n        address owner,\n        string name,\n        bytes32 indexed schainHash\n    );\n\n    /**\n     * @dev Emitted when a node in an schain is rotated.\n     */\n    event NodeRotated(\n        bytes32 schainHash,\n        uint oldNode,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a node is added to an schain.\n     */\n    event NodeAdded(\n        bytes32 schainHash,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a group of nodes is created for an schain.\n     */\n    event SchainNodes(\n        string name,\n        bytes32 schainHash,\n        uint[] nodesInGroup\n    );\n\n    function addSchain(address from, uint deposit, bytes calldata data) external;\n    function addSchainByFoundation(\n        uint lifetime,\n        uint8 typeOfSchain,\n        uint16 nonce,\n        string calldata name,\n        address schainOwner,\n        address schainOriginator,\n        SchainOption[] calldata options\n    )\n        external\n        payable;\n    function deleteSchain(address from, string calldata name) external;\n    function deleteSchainByRoot(string calldata name) external;\n    function restartSchainCreation(string calldata name) external;\n    function verifySchainSignature(\n        uint256 signA,\n        uint256 signB,\n        bytes32 hash,\n        uint256 counter,\n        uint256 hashA,\n        uint256 hashB,\n        string calldata schainName\n    )\n        external\n        view\n        returns (bool);\n    function getSchainPrice(uint typeOfSchain, uint lifetime) external view returns (uint);\n    function getOption(bytes32 schainHash, string calldata optionName) external view returns (bytes memory);\n    function getOptions(bytes32 schainHash) external view returns (SchainOption[] memory);\n}\n"
             },
             "@skalenetwork/skale-manager-interfaces/ISchainsInternal.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchainsInternal - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchainsInternal {\n    struct Schain {\n        string name;\n        address owner;\n        uint indexInOwnerList;\n        uint8 partOfNode;\n        uint lifetime;\n        uint startDate;\n        uint startBlock;\n        uint deposit;\n        uint64 index;\n        uint generation;\n        address originator;\n    }\n\n    struct SchainType {\n        uint8 partOfNode;\n        uint numberOfNodes;\n    }\n\n    /**\n     * @dev Emitted when schain type added.\n     */\n    event SchainTypeAdded(uint indexed schainType, uint partOfNode, uint numberOfNodes);\n\n    /**\n     * @dev Emitted when schain type removed.\n     */\n    event SchainTypeRemoved(uint indexed schainType);\n\n    function initializeSchain(\n        string calldata name,\n        address from,\n        address originator,\n        uint lifetime,\n        uint deposit) external;\n    function createGroupForSchain(\n        bytes32 schainHash,\n        uint numberOfNodes,\n        uint8 partOfNode\n    )\n        external\n        returns (uint[] memory);\n    function changeLifetime(bytes32 schainHash, uint lifetime, uint deposit) external;\n    function removeSchain(bytes32 schainHash, address from) external;\n    function removeNodeFromSchain(uint nodeIndex, bytes32 schainHash) external;\n    function deleteGroup(bytes32 schainHash) external;\n    function setException(bytes32 schainHash, uint nodeIndex) external;\n    function setNodeInGroup(bytes32 schainHash, uint nodeIndex) external;\n    function removeHolesForSchain(bytes32 schainHash) external;\n    function addSchainType(uint8 partOfNode, uint numberOfNodes) external;\n    function removeSchainType(uint typeOfSchain) external;\n    function setNumberOfSchainTypes(uint newNumberOfSchainTypes) external;\n    function removeNodeFromAllExceptionSchains(uint nodeIndex) external;\n    function removeAllNodesFromSchainExceptions(bytes32 schainHash) external;\n    function makeSchainNodesInvisible(bytes32 schainHash) external;\n    function makeSchainNodesVisible(bytes32 schainHash) external;\n    function newGeneration() external;\n    function addSchainForNode(uint nodeIndex, bytes32 schainHash) external;\n    function removeSchainForNode(uint nodeIndex, uint schainIndex) external;\n    function removeNodeFromExceptions(bytes32 schainHash, uint nodeIndex) external;\n    function isSchainActive(bytes32 schainHash) external view returns (bool);\n    function schainsAtSystem(uint index) external view returns (bytes32);\n    function numberOfSchains() external view returns (uint64);\n    function getSchains() external view returns (bytes32[] memory);\n    function getSchainsPartOfNode(bytes32 schainHash) external view returns (uint8);\n    function getSchainListSize(address from) external view returns (uint);\n    function getSchainHashesByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainIdsByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainHashesForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainIdsForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainOwner(bytes32 schainHash) external view returns (address);\n    function getSchainOriginator(bytes32 schainHash) external view returns (address);\n    function isSchainNameAvailable(string calldata name) external view returns (bool);\n    function isTimeExpired(bytes32 schainHash) external view returns (bool);\n    function isOwnerAddress(address from, bytes32 schainId) external view returns (bool);\n    function getSchainName(bytes32 schainHash) external view returns (string memory);\n    function getActiveSchain(uint nodeIndex) external view returns (bytes32);\n    function getActiveSchains(uint nodeIndex) external view returns (bytes32[] memory activeSchains);\n    function getNumberOfNodesInGroup(bytes32 schainHash) external view returns (uint);\n    function getNodesInGroup(bytes32 schainHash) external view returns (uint[] memory);\n    function isNodeAddressesInGroup(bytes32 schainId, address sender) external view returns (bool);\n    function getNodeIndexInGroup(bytes32 schainHash, uint nodeId) external view returns (uint);\n    function isAnyFreeNode(bytes32 schainHash) external view returns (bool);\n    function checkException(bytes32 schainHash, uint nodeIndex) external view returns (bool);\n    function checkHoleForSchain(bytes32 schainHash, uint indexOfNode) external view returns (bool);\n    function checkSchainOnNode(uint nodeIndex, bytes32 schainHash) external view returns (bool);\n    function getSchainType(uint typeOfSchain) external view returns(uint8, uint);\n    function getGeneration(bytes32 schainHash) external view returns (uint);\n    function isSchainExist(bytes32 schainHash) external view returns (bool);\n}"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchainsInternal - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"./INodes.sol\";\n\ninterface ISchainsInternal {\n    struct Schain {\n        string name;\n        address owner;\n        uint indexInOwnerList;\n        uint8 partOfNode;\n        uint lifetime;\n        uint startDate;\n        uint startBlock;\n        uint deposit;\n        uint64 index;\n        uint generation;\n        address originator;\n    }\n\n    struct SchainType {\n        uint8 partOfNode;\n        uint numberOfNodes;\n    }\n\n    /**\n     * @dev Emitted when schain type added.\n     */\n    event SchainTypeAdded(uint indexed schainType, uint partOfNode, uint numberOfNodes);\n\n    /**\n     * @dev Emitted when schain type removed.\n     */\n    event SchainTypeRemoved(uint indexed schainType);\n\n    function initializeSchain(\n        string calldata name,\n        address from,\n        address originator,\n        uint lifetime,\n        uint deposit) external;\n    function createGroupForSchain(\n        bytes32 schainHash,\n        uint numberOfNodes,\n        uint8 partOfNode\n    )\n        external\n        returns (uint[] memory);\n    function changeLifetime(bytes32 schainHash, uint lifetime, uint deposit) external;\n    function removeSchain(bytes32 schainHash, address from) external;\n    function removeNodeFromSchain(uint nodeIndex, bytes32 schainHash) external;\n    function deleteGroup(bytes32 schainHash) external;\n    function setException(bytes32 schainHash, uint nodeIndex) external;\n    function setNodeInGroup(bytes32 schainHash, uint nodeIndex) external;\n    function removeHolesForSchain(bytes32 schainHash) external;\n    function addSchainType(uint8 partOfNode, uint numberOfNodes) external;\n    function removeSchainType(uint typeOfSchain) external;\n    function setNumberOfSchainTypes(uint newNumberOfSchainTypes) external;\n    function removeNodeFromAllExceptionSchains(uint nodeIndex) external;\n    function removeAllNodesFromSchainExceptions(bytes32 schainHash) external;\n    function makeSchainNodesInvisible(bytes32 schainHash) external;\n    function makeSchainNodesVisible(bytes32 schainHash) external;\n    function newGeneration() external;\n    function addSchainForNode(INodes nodes,uint nodeIndex, bytes32 schainHash) external;\n    function removeSchainForNode(uint nodeIndex, uint schainIndex) external;\n    function removeNodeFromExceptions(bytes32 schainHash, uint nodeIndex) external;\n    function isSchainActive(bytes32 schainHash) external view returns (bool);\n    function schainsAtSystem(uint index) external view returns (bytes32);\n    function numberOfSchains() external view returns (uint64);\n    function getSchains() external view returns (bytes32[] memory);\n    function getSchainsPartOfNode(bytes32 schainHash) external view returns (uint8);\n    function getSchainListSize(address from) external view returns (uint);\n    function getSchainHashesByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainHashesForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainOwner(bytes32 schainHash) external view returns (address);\n    function getSchainOriginator(bytes32 schainHash) external view returns (address);\n    function isSchainNameAvailable(string calldata name) external view returns (bool);\n    function isTimeExpired(bytes32 schainHash) external view returns (bool);\n    function isOwnerAddress(address from, bytes32 schainHash) external view returns (bool);\n    function getSchainName(bytes32 schainHash) external view returns (string memory);\n    function getActiveSchain(uint nodeIndex) external view returns (bytes32);\n    function getActiveSchains(uint nodeIndex) external view returns (bytes32[] memory activeSchains);\n    function getNumberOfNodesInGroup(bytes32 schainHash) external view returns (uint);\n    function getNodesInGroup(bytes32 schainHash) external view returns (uint[] memory);\n    function isNodeAddressesInGroup(bytes32 schainHash, address sender) external view returns (bool);\n    function getNodeIndexInGroup(bytes32 schainHash, uint nodeHash) external view returns (uint);\n    function isAnyFreeNode(bytes32 schainHash) external view returns (bool);\n    function checkException(bytes32 schainHash, uint nodeIndex) external view returns (bool);\n    function checkHoleForSchain(bytes32 schainHash, uint indexOfNode) external view returns (bool);\n    function checkSchainOnNode(uint nodeIndex, bytes32 schainHash) external view returns (bool);\n    function getSchainType(uint typeOfSchain) external view returns(uint8, uint);\n    function getGeneration(bytes32 schainHash) external view returns (uint);\n    function isSchainExist(bytes32 schainHash) external view returns (bool);\n}"
             },
             "@skalenetwork/skale-manager-interfaces/IWallets.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IWallets - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IWallets {\n    /**\n     * @dev Emitted when the validator wallet was funded\n     */\n    event ValidatorWalletRecharged(address sponsor, uint amount, uint validatorId);\n\n    /**\n     * @dev Emitted when the schain wallet was funded\n     */\n    event SchainWalletRecharged(address sponsor, uint amount, bytes32 schainHash);\n\n    /**\n     * @dev Emitted when the node received a refund from validator to its wallet\n     */\n    event NodeRefundedByValidator(address node, uint validatorId, uint amount);\n\n    /**\n     * @dev Emitted when the node received a refund from schain to its wallet\n     */\n    event NodeRefundedBySchain(address node, bytes32 schainHash, uint amount);\n\n    /**\n     * @dev Emitted when the validator withdrawn funds from validator wallet\n     */\n    event WithdrawFromValidatorWallet(uint indexed validatorId, uint amount);\n\n    /**\n     * @dev Emitted when the schain owner withdrawn funds from schain wallet\n     */\n    event WithdrawFromSchainWallet(bytes32 indexed schainHash, uint amount);\n\n    receive() external payable;\n    function refundGasByValidator(uint validatorId, address payable spender, uint spentGas) external;\n    function refundGasByValidatorToSchain(uint validatorId, bytes32 schainHash) external;\n    function refundGasBySchain(bytes32 schainId, address payable spender, uint spentGas, bool isDebt) external;\n    function withdrawFundsFromSchainWallet(address payable schainOwner, bytes32 schainHash) external;\n    function withdrawFundsFromValidatorWallet(uint amount) external;\n    function rechargeValidatorWallet(uint validatorId) external payable;\n    function rechargeSchainWallet(bytes32 schainId) external payable;\n    function getSchainBalance(bytes32 schainHash) external view returns (uint);\n    function getValidatorBalance(uint validatorId) external view returns (uint);\n}\n"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IWallets - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IWallets {\n    receive() external payable;\n    function refundGasByValidator(uint validatorId, address payable spender, uint gasLimit) external;\n    function refundGasByValidatorToSchain(uint validatorId, bytes32 schainHash) external;\n    function refundGasBySchain(bytes32 schainId, address payable spender, uint spentGas, bool isDebt) external;\n    function withdrawFundsFromSchainWallet(address payable schainOwner, bytes32 schainHash) external;\n    function withdrawFundsFromValidatorWallet(uint amount) external;\n    function rechargeValidatorWallet(uint validatorId) external payable;\n    function rechargeSchainWallet(bytes32 schainId) external payable;\n    function getSchainBalance(bytes32 schainHash) external view returns (uint);\n    function getValidatorBalance(uint validatorId) external view returns (uint);\n}\n"
+            },
+            "@skalenetwork/skale-manager-interfaces/utils/IRandom.sol": {
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IRandom.sol - SKALE Manager Interfaces\n    Copyright (C) 2022-Present SKALE Labs\n    @author Dmytro Stebaiev\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\n\ninterface IRandom {\n    struct RandomGenerator {\n        uint seed;\n    }\n}"
             },
             "contracts/MessageProxy.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   MessageProxy.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/IGasReimbursable.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageProxy.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageReceiver.sol\";\n\n\n/**\n * @title MessageProxy\n * @dev Abstract contract for MessageProxyForMainnet and MessageProxyForSchain.\n */\nabstract contract MessageProxy is AccessControlEnumerableUpgradeable, IMessageProxy {\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    /**\n     * @dev Structure that stores counters for outgoing and incoming messages.\n     */\n    struct ConnectedChainInfo {\n        // message counters start with 0\n        uint256 incomingMessageCounter;\n        uint256 outgoingMessageCounter;\n        bool inited;\n        uint256 lastOutgoingMessageBlockId;\n    }\n\n    bytes32 public constant MAINNET_HASH = keccak256(abi.encodePacked(\"Mainnet\"));\n    bytes32 public constant CHAIN_CONNECTOR_ROLE = keccak256(\"CHAIN_CONNECTOR_ROLE\");\n    bytes32 public constant EXTRA_CONTRACT_REGISTRAR_ROLE = keccak256(\"EXTRA_CONTRACT_REGISTRAR_ROLE\");\n    bytes32 public constant CONSTANT_SETTER_ROLE = keccak256(\"CONSTANT_SETTER_ROLE\");\n    uint256 public constant MESSAGES_LENGTH = 10;\n    uint256 public constant REVERT_REASON_LENGTH = 64;\n\n    //   schainHash => ConnectedChainInfo\n    mapping(bytes32 => ConnectedChainInfo) public connectedChains;\n    //   schainHash => contract address => allowed\n    mapping(bytes32 => mapping(address => bool)) private _deprecatedRegistryContracts;\n\n    uint256 public gasLimit;\n\n    /**\n     * @dev Emitted for every outgoing message to schain.\n     */\n    event OutgoingMessage(\n        bytes32 indexed dstChainHash,\n        uint256 indexed msgCounter,\n        address indexed srcContract,\n        address dstContract,\n        bytes data\n    );\n\n    /**\n     * @dev Emitted when function `postMessage` returns revert.\n     *  Used to prevent stuck loop inside function `postIncomingMessages`.\n     */\n    event PostMessageError(\n        uint256 indexed msgCounter,\n        bytes message\n    );\n\n    /**\n     * @dev Emitted when gas limit per one call of `postMessage` was changed.\n     */\n    event GasLimitWasChanged(\n        uint256 oldValue,\n        uint256 newValue\n    );\n\n    /**\n     * @dev Emitted when the version was updated\n     */\n    event VersionUpdated(string oldVersion, string newVersion);\n\n    /**\n     * @dev Emitted when extra contract was added.\n     */\n    event ExtraContractRegistered(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Emitted when extra contract was removed.\n     */\n    event ExtraContractRemoved(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Emitted when referenced to previous outgoing message.\n     */\n    event PreviousMessageReference (\n        uint256 currentMessage,\n        uint256 previousOutgoingMessageBlockId\n    );\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CHAIN_CONNECTOR_ROLE}.\n     */\n    modifier onlyChainConnector() {\n        require(hasRole(CHAIN_CONNECTOR_ROLE, msg.sender), \"CHAIN_CONNECTOR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {EXTRA_CONTRACT_REGISTRAR_ROLE}.\n     */\n    modifier onlyExtraContractRegistrar() {\n        require(hasRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender), \"EXTRA_CONTRACT_REGISTRAR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CONSTANT_SETTER_ROLE}.\n     */\n    modifier onlyConstantSetter() {\n        require(hasRole(CONSTANT_SETTER_ROLE, msg.sender), \"Not enough permissions to set constant\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {DEFAULT_ADMIN_ROLE}.\n     */\n    modifier onlyOwner() {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"DEFAULT_ADMIN_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Sets gasLimit to a new value.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CONSTANT_SETTER_ROLE.\n     */\n    function setNewGasLimit(uint256 newGasLimit) external override onlyConstantSetter {\n        emit GasLimitWasChanged(gasLimit, newGasLimit);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Virtual function for `postIncomingMessages`.\n     */\n    function postIncomingMessages(\n        string calldata fromSchainName,\n        uint256 startingCounter,\n        Message[] calldata messages,\n        Signature calldata sign\n    )\n        external\n        virtual\n        override;\n\n    /**\n     * @dev Allows `msg.sender` to register extra contract for all schains\n     * for being able to transfer messages from custom contracts.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     * - Passed address should be contract.\n     * - Extra contract must not be registered.\n     */\n    function registerExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is already registered\");\n        _getRegistryContracts()[bytes32(0)].add(extraContract);\n        emit ExtraContractRegistered(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Allows `msg.sender` to remove extra contract for all schains.\n     * Extra contract will no longer be able to send messages through MessageProxy.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     */\n    function removeExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[bytes32(0)].remove(extraContract);\n        emit ExtraContractRemoved(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Should return length of contract registered by schainHash.\n     */\n    function getContractRegisteredLength(bytes32 schainHash) external view override returns (uint256) {\n        return _getRegistryContracts()[schainHash].length();\n    }\n\n    /**\n     * @dev Should return a range of contracts registered by schainHash.\n     *\n     * Requirements:\n     * range should be less or equal 10 contracts\n     */\n    function getContractRegisteredRange(\n        bytes32 schainHash,\n        uint256 from,\n        uint256 to\n    )\n        external\n        view\n        override\n        returns (address[] memory contractsInRange)\n    {\n        require(\n            from < to && to - from <= 10 && to <= _getRegistryContracts()[schainHash].length(),\n            \"Range is incorrect\"\n        );\n        contractsInRange = new address[](to - from);\n        for (uint256 i = from; i < to; i++) {\n            contractsInRange[i - from] = _getRegistryContracts()[schainHash].at(i);\n        }\n    }\n\n    /**\n     * @dev Returns number of outgoing messages.\n     *\n     * Requirements:\n     *\n     * - Target schain  must be initialized.\n     */\n    function getOutgoingMessagesCounter(string calldata targetSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 dstChainHash = keccak256(abi.encodePacked(targetSchainName));\n        require(connectedChains[dstChainHash].inited, \"Destination chain is not initialized\");\n        return connectedChains[dstChainHash].outgoingMessageCounter;\n    }\n\n\n    /**\n     * @dev Should return block number of the last message transferred to schain\n     */\n    function getLastOutgoingMessageBlockId(string memory targetSchainName) external view override returns (uint) {\n        bytes32 dstChainHash = keccak256(abi.encodePacked(targetSchainName));\n        require(connectedChains[dstChainHash].inited, \"Destination chain is not initialized\");\n        return connectedChains[dstChainHash].lastOutgoingMessageBlockId;\n    }\n\n    /**\n     * @dev Returns number of incoming messages.\n     *\n     * Requirements:\n     *\n     * - Source schain must be initialized.\n     */\n    function getIncomingMessagesCounter(string calldata fromSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 srcChainHash = keccak256(abi.encodePacked(fromSchainName));\n        require(connectedChains[srcChainHash].inited, \"Source chain is not initialized\");\n        return connectedChains[srcChainHash].incomingMessageCounter;\n    }\n\n    function initializeMessageProxy(uint newGasLimit) public initializer {\n        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(CHAIN_CONNECTOR_ROLE, msg.sender);\n        _setupRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender);\n        _setupRole(CONSTANT_SETTER_ROLE, msg.sender);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Posts message from this contract to `targetChainHash` MessageProxy contract.\n     * This is called by a smart contract to make a cross-chain call.\n     *\n     * Emits an {OutgoingMessage} event.\n     *\n     * Requirements:\n     *\n     * - Target chain must be initialized.\n     * - Target chain must be registered as external contract.\n     */\n    function postOutgoingMessage(\n        bytes32 targetChainHash,\n        address targetContract,\n        bytes memory data\n    )\n        public\n        override\n        virtual\n    {\n        require(connectedChains[targetChainHash].inited, \"Destination chain is not initialized\");\n        _authorizeOutgoingMessageSender(targetChainHash);\n\n        uint outgoingMessageCounter = connectedChains[targetChainHash].outgoingMessageCounter;\n        emit OutgoingMessage(\n            targetChainHash,\n            outgoingMessageCounter,\n            msg.sender,\n            targetContract,\n            data\n        );\n        emit PreviousMessageReference(\n            outgoingMessageCounter,\n            connectedChains[targetChainHash].lastOutgoingMessageBlockId\n        );\n        connectedChains[targetChainHash].outgoingMessageCounter++;\n        connectedChains[targetChainHash].lastOutgoingMessageBlockId = block.number;\n    }\n\n    /**\n     * @dev Allows CHAIN_CONNECTOR_ROLE to remove connected chain from this contract.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CHAIN_CONNECTOR_ROLE.\n     * - `schainName` must be initialized.\n     */\n    function removeConnectedChain(string memory schainName) public virtual override onlyChainConnector {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(connectedChains[schainHash].inited, \"Chain is not initialized\");\n        delete connectedChains[schainHash];\n    }\n\n    /**\n     * @dev Checks whether chain is currently connected.\n     */\n    function isConnectedChain(\n        string memory schainName\n    )\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return connectedChains[keccak256(abi.encodePacked(schainName))].inited;\n    }\n\n    /**\n     * @dev Checks whether contract is currently registered as extra contract.\n     */\n    function isContractRegistered(\n        bytes32 schainHash,\n        address contractAddress\n    )\n        public\n        view\n        override\n        returns (bool)\n    {\n        return _getRegistryContracts()[schainHash].contains(contractAddress);\n    }\n\n    /**\n     * @dev Allows MessageProxy to register extra contract for being able to transfer messages from custom contracts.\n     *\n     * Requirements:\n     *\n     * - Extra contract address must be contract.\n     * - Extra contract must not be registered.\n     * - Extra contract must not be registered for all chains.\n     */\n    function _registerExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {\n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is already registered\");\n        require(\n            !_getRegistryContracts()[bytes32(0)].contains(extraContract),\n            \"Extra contract is already registered for all chains\"\n        );\n\n        _getRegistryContracts()[chainHash].add(extraContract);\n        emit ExtraContractRegistered(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to remove extra contract,\n     * thus `extraContract` will no longer be available to transfer messages from mainnet to schain.\n     *\n     * Requirements:\n     *\n     * - Extra contract must be registered.\n     */\n    function _removeExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {\n        require(_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[chainHash].remove(extraContract);\n        emit ExtraContractRemoved(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to connect schain with MessageProxyOnMainnet for transferring messages.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CHAIN_CONNECTOR_ROLE.\n     * - SKALE chain must not be connected.\n     */\n    function _addConnectedChain(bytes32 schainHash) internal onlyChainConnector {\n        require(!connectedChains[schainHash].inited,\"Chain is already connected\");\n        connectedChains[schainHash] = ConnectedChainInfo({\n            incomingMessageCounter: 0,\n            outgoingMessageCounter: 0,\n            inited: true,\n            lastOutgoingMessageBlockId: 0\n        });\n    }\n\n    /**\n     * @dev Allows MessageProxy to send messages from schain to mainnet.\n     * Destination contract must implement `postMessage` method.\n     */\n    function _callReceiverContract(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n    {\n        if (!message.destinationContract.isContract()) {\n            emit PostMessageError(\n                counter,\n                \"Destination contract is not a contract\"\n            );\n            return;\n        }\n        try IMessageReceiver(message.destinationContract).postMessage{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) {\n            return;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                _getSlice(bytes(reason), REVERT_REASON_LENGTH)\n            );\n        } catch Panic(uint errorCode) {\n               emit PostMessageError(\n                counter,\n                abi.encodePacked(errorCode)\n            );\n        } catch (bytes memory revertData) {\n            emit PostMessageError(\n                counter,\n                _getSlice(revertData, REVERT_REASON_LENGTH)\n            );\n        }\n    }\n\n    /**\n     * @dev Returns receiver of message.\n     */\n    function _getGasPayer(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n        returns (address)\n    {\n        try IGasReimbursable(message.destinationContract).gasPayer{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) returns (address receiver) {\n            return receiver;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                _getSlice(bytes(reason), REVERT_REASON_LENGTH)\n            );\n            return address(0);\n        } catch Panic(uint errorCode) {\n               emit PostMessageError(\n                counter,\n                abi.encodePacked(errorCode)\n            );\n            return address(0);\n        } catch (bytes memory revertData) {\n            emit PostMessageError(\n                counter,\n                _getSlice(revertData, REVERT_REASON_LENGTH)\n            );\n            return address(0);\n        }\n    }\n\n    /**\n     * @dev Checks whether msg.sender is registered as custom extra contract.\n     */\n    function _authorizeOutgoingMessageSender(bytes32 targetChainHash) internal view virtual {\n        require(\n            isContractRegistered(bytes32(0), msg.sender) || isContractRegistered(targetChainHash, msg.sender),\n            \"Sender contract is not registered\"\n        );\n    }\n\n    /**\n     * @dev Returns list of registered custom extra contracts.\n     */\n    function _getRegistryContracts()\n        internal\n        view\n        virtual\n        returns (mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) storage);\n\n    /**\n     * @dev Returns hash of message array.\n     */\n    function _hashedArray(\n        Message[] calldata messages,\n        uint256 startingCounter,\n        string calldata fromChainName\n    )\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32 sourceHash = keccak256(abi.encodePacked(fromChainName));\n        bytes32 hash = keccak256(abi.encodePacked(sourceHash, bytes32(startingCounter)));\n        for (uint256 i = 0; i < messages.length; i++) {\n            hash = keccak256(\n                abi.encodePacked(\n                    abi.encode(\n                        hash,\n                        messages[i].sender,\n                        messages[i].destinationContract\n                    ),\n                    messages[i].data\n                )\n            );\n        }\n        return hash;\n    }\n\n    function _getSlice(bytes memory text, uint end) private pure returns (bytes memory) {\n        uint slicedEnd = end < text.length ? end : text.length;\n        bytes memory sliced = new bytes(slicedEnd);\n        for(uint i = 0; i < slicedEnd; i++){\n            sliced[i] = text[i];\n        }\n        return sliced;\n    }\n}\n"
             },
             "contracts/Messages.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   Messages.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\n\n/**\n * @title Messages\n * @dev Library for encoding and decoding messages\n * for transferring from Mainnet to Schain and vice versa.\n */\nlibrary Messages {\n\n    /**\n     * @dev Enumerator that describes all supported message types.\n     */\n    enum MessageType {\n        EMPTY,\n        TRANSFER_ETH,\n        TRANSFER_ERC20,\n        TRANSFER_ERC20_AND_TOTAL_SUPPLY,\n        TRANSFER_ERC20_AND_TOKEN_INFO,\n        TRANSFER_ERC721,\n        TRANSFER_ERC721_AND_TOKEN_INFO,\n        USER_STATUS,\n        INTERCHAIN_CONNECTION,\n        TRANSFER_ERC1155,\n        TRANSFER_ERC1155_AND_TOKEN_INFO,\n        TRANSFER_ERC1155_BATCH,\n        TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO,\n        TRANSFER_ERC721_WITH_METADATA,\n        TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO\n    }\n\n    /**\n     * @dev Structure for base message.\n     */\n    struct BaseMessage {\n        MessageType messageType;\n    }\n\n    /**\n     * @dev Structure for describing ETH.\n     */\n    struct TransferEthMessage {\n        BaseMessage message;\n        address receiver;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for user status.\n     */\n    struct UserStatusMessage {\n        BaseMessage message;\n        address receiver;\n        bool isActive;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 token.\n     */\n    struct TransferErc20Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC20 token.\n     */\n    struct Erc20TokenInfo {\n        string name;\n        uint8 decimals;\n        string symbol;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token supply.\n     */\n    struct TransferErc20AndTotalSupplyMessage {\n        TransferErc20Message baseErc20transfer;\n        uint256 totalSupply;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token info.\n     */\n    struct TransferErc20AndTokenInfoMessage {\n        TransferErc20Message baseErc20transfer;\n        uint256 totalSupply;\n        Erc20TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing base ERC721.\n     */\n    struct TransferErc721Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 tokenId;\n    }\n\n    /**\n     * @dev Structure for describing base ERC721 with metadata.\n     */\n    struct TransferErc721MessageWithMetadata {\n        TransferErc721Message erc721message;\n        string tokenURI;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token info.\n     */\n    struct Erc721TokenInfo {\n        string name;\n        string symbol;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC721 token.\n     */\n    struct TransferErc721AndTokenInfoMessage {\n        TransferErc721Message baseErc721transfer;\n        Erc721TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC721 token with metadata.\n     */\n    struct TransferErc721WithMetadataAndTokenInfoMessage {\n        TransferErc721MessageWithMetadata baseErc721transferWithMetadata;\n        Erc721TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing whether interchain connection is allowed.\n     */\n    struct InterchainConnectionMessage {\n        BaseMessage message;\n        bool isAllowed;\n    }\n\n    /**\n     * @dev Structure for describing whether interchain connection is allowed.\n     */\n    struct TransferErc1155Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 id;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for describing ERC1155 token in batches.\n     */\n    struct TransferErc1155BatchMessage {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256[] ids;\n        uint256[] amounts;\n    }\n\n    /**\n     * @dev Structure for describing ERC1155 token info.\n     */\n    struct Erc1155TokenInfo {\n        string uri;\n    }\n\n    /**\n     * @dev Structure for describing message for transferring ERC1155 token with info.\n     */\n    struct TransferErc1155AndTokenInfoMessage {\n        TransferErc1155Message baseErc1155transfer;\n        Erc1155TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing message for transferring ERC1155 token in batches with info.\n     */\n    struct TransferErc1155BatchAndTokenInfoMessage {\n        TransferErc1155BatchMessage baseErc1155Batchtransfer;\n        Erc1155TokenInfo tokenInfo;\n    }\n\n\n    /**\n     * @dev Returns type of message for encoded data.\n     */\n    function getMessageType(bytes calldata data) internal pure returns (MessageType) {\n        uint256 firstWord = abi.decode(data, (uint256));\n        if (firstWord % 32 == 0) {\n            return getMessageType(data[firstWord:]);\n        } else {\n            return abi.decode(data, (Messages.MessageType));\n        }\n    }\n\n    /**\n     * @dev Encodes message for transferring ETH. Returns encoded message.\n     */\n    function encodeTransferEthMessage(address receiver, uint256 amount) internal pure returns (bytes memory) {\n        TransferEthMessage memory message = TransferEthMessage(\n            BaseMessage(MessageType.TRANSFER_ETH),\n            receiver,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ETH. Returns structure `TransferEthMessage`.\n     */\n    function decodeTransferEthMessage(\n        bytes calldata data\n    ) internal pure returns (TransferEthMessage memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ETH, \"Message type is not ETH transfer\");\n        return abi.decode(data, (TransferEthMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ETH. Returns encoded message.\n     */\n    function encodeTransferErc20Message(\n        address token,\n        address receiver,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        TransferErc20Message memory message = TransferErc20Message(\n            BaseMessage(MessageType.TRANSFER_ERC20),\n            token,\n            receiver,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC20 with total supply. Returns encoded message.\n     */\n    function encodeTransferErc20AndTotalSupplyMessage(\n        address token,\n        address receiver,\n        uint256 amount,\n        uint256 totalSupply\n    ) internal pure returns (bytes memory) {\n        TransferErc20AndTotalSupplyMessage memory message = TransferErc20AndTotalSupplyMessage(\n            TransferErc20Message(\n                BaseMessage(MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY),\n                token,\n                receiver,\n                amount\n            ),\n            totalSupply\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20. Returns structure `TransferErc20Message`.\n     */\n    function decodeTransferErc20Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc20Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC20, \"Message type is not ERC20 transfer\");\n        return abi.decode(data, (TransferErc20Message));\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20 with total supply. \n     * Returns structure `TransferErc20AndTotalSupplyMessage`.\n     */\n    function decodeTransferErc20AndTotalSupplyMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc20AndTotalSupplyMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY,\n            \"Message type is not ERC20 transfer and total supply\"\n        );\n        return abi.decode(data, (TransferErc20AndTotalSupplyMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC20 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc20AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 amount,\n        uint256 totalSupply,\n        Erc20TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc20AndTokenInfoMessage memory message = TransferErc20AndTokenInfoMessage(\n            TransferErc20Message(\n                BaseMessage(MessageType.TRANSFER_ERC20_AND_TOKEN_INFO),\n                token,\n                receiver,\n                amount\n            ),\n            totalSupply,\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20 with token info. \n     * Returns structure `TransferErc20AndTokenInfoMessage`.\n     */\n    function decodeTransferErc20AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc20AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC20_AND_TOKEN_INFO,\n            \"Message type is not ERC20 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc20AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721Message(\n        address token,\n        address receiver,\n        uint256 tokenId\n    ) internal pure returns (bytes memory) {\n        TransferErc721Message memory message = TransferErc721Message(\n            BaseMessage(MessageType.TRANSFER_ERC721),\n            token,\n            receiver,\n            tokenId\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721. \n     * Returns structure `TransferErc721Message`.\n     */\n    function decodeTransferErc721Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc721Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC721, \"Message type is not ERC721 transfer\");\n        return abi.decode(data, (TransferErc721Message));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        Erc721TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc721AndTokenInfoMessage memory message = TransferErc721AndTokenInfoMessage(\n            TransferErc721Message(\n                BaseMessage(MessageType.TRANSFER_ERC721_AND_TOKEN_INFO),\n                token,\n                receiver,\n                tokenId\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721 with token info. \n     * Returns structure `TransferErc721AndTokenInfoMessage`.\n     */\n    function decodeTransferErc721AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc721AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_AND_TOKEN_INFO,\n            \"Message type is not ERC721 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc721AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721MessageWithMetadata(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        string memory tokenURI\n    ) internal pure returns (bytes memory) {\n        TransferErc721MessageWithMetadata memory message = TransferErc721MessageWithMetadata(\n            TransferErc721Message(\n                BaseMessage(MessageType.TRANSFER_ERC721_WITH_METADATA),\n                token,\n                receiver,\n                tokenId\n            ),\n            tokenURI\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721. \n     * Returns structure `TransferErc721MessageWithMetadata`.\n     */\n    function decodeTransferErc721MessageWithMetadata(\n        bytes calldata data\n    ) internal pure returns (TransferErc721MessageWithMetadata memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_WITH_METADATA,\n            \"Message type is not ERC721 transfer\"\n        );\n        return abi.decode(data, (TransferErc721MessageWithMetadata));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721WithMetadataAndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        string memory tokenURI,\n        Erc721TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc721WithMetadataAndTokenInfoMessage memory message = TransferErc721WithMetadataAndTokenInfoMessage(\n            TransferErc721MessageWithMetadata(\n                TransferErc721Message(\n                    BaseMessage(MessageType.TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO),\n                    token,\n                    receiver,\n                    tokenId\n                ),\n                tokenURI\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721 with token info. \n     * Returns structure `TransferErc721WithMetadataAndTokenInfoMessage`.\n     */\n    function decodeTransferErc721WithMetadataAndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc721WithMetadataAndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO,\n            \"Message type is not ERC721 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc721WithMetadataAndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for activating user on schain. \n     * Returns encoded message.\n     */\n    function encodeActivateUserMessage(address receiver) internal pure returns (bytes memory){\n        return _encodeUserStatusMessage(receiver, true);\n    }\n\n    /**\n     * @dev Encodes message for locking user on schain. \n     * Returns encoded message.\n     */\n    function encodeLockUserMessage(address receiver) internal pure returns (bytes memory){\n        return _encodeUserStatusMessage(receiver, false);\n    }\n\n    /**\n     * @dev Decodes message for user status. \n     * Returns structure UserStatusMessage.\n     */\n    function decodeUserStatusMessage(bytes calldata data) internal pure returns (UserStatusMessage memory) {\n        require(getMessageType(data) == MessageType.USER_STATUS, \"Message type is not User Status\");\n        return abi.decode(data, (UserStatusMessage));\n    }\n\n\n    /**\n     * @dev Encodes message for allowing interchain connection.\n     * Returns encoded message.\n     */\n    function encodeInterchainConnectionMessage(bool isAllowed) internal pure returns (bytes memory) {\n        InterchainConnectionMessage memory message = InterchainConnectionMessage(\n            BaseMessage(MessageType.INTERCHAIN_CONNECTION),\n            isAllowed\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for allowing interchain connection.\n     * Returns structure `InterchainConnectionMessage`.\n     */\n    function decodeInterchainConnectionMessage(bytes calldata data)\n        internal\n        pure\n        returns (InterchainConnectionMessage memory)\n    {\n        require(getMessageType(data) == MessageType.INTERCHAIN_CONNECTION, \"Message type is not Interchain connection\");\n        return abi.decode(data, (InterchainConnectionMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155Message(\n        address token,\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        TransferErc1155Message memory message = TransferErc1155Message(\n            BaseMessage(MessageType.TRANSFER_ERC1155),\n            token,\n            receiver,\n            id,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token.\n     * Returns structure `TransferErc1155Message`.\n     */\n    function decodeTransferErc1155Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC1155, \"Message type is not ERC1155 transfer\");\n        return abi.decode(data, (TransferErc1155Message));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 with token info.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 id,\n        uint256 amount,\n        Erc1155TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc1155AndTokenInfoMessage memory message = TransferErc1155AndTokenInfoMessage(\n            TransferErc1155Message(\n                BaseMessage(MessageType.TRANSFER_ERC1155_AND_TOKEN_INFO),\n                token,\n                receiver,\n                id,\n                amount\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 with token info.\n     * Returns structure `TransferErc1155AndTokenInfoMessage`.\n     */\n    function decodeTransferErc1155AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_AND_TOKEN_INFO,\n            \"Message type is not ERC1155AndTokenInfo transfer\"\n        );\n        return abi.decode(data, (TransferErc1155AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token in batches.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155BatchMessage(\n        address token,\n        address receiver,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal pure returns (bytes memory) {\n        TransferErc1155BatchMessage memory message = TransferErc1155BatchMessage(\n            BaseMessage(MessageType.TRANSFER_ERC1155_BATCH),\n            token,\n            receiver,\n            ids,\n            amounts\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token in batches.\n     * Returns structure `TransferErc1155BatchMessage`.\n     */\n    function decodeTransferErc1155BatchMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155BatchMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_BATCH,\n            \"Message type is not ERC1155Batch transfer\"\n        );\n        return abi.decode(data, (TransferErc1155BatchMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token in batches with token info.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155BatchAndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        Erc1155TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc1155BatchAndTokenInfoMessage memory message = TransferErc1155BatchAndTokenInfoMessage(\n            TransferErc1155BatchMessage(\n                BaseMessage(MessageType.TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO),\n                token,\n                receiver,\n                ids,\n                amounts\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token in batches with token info.\n     * Returns structure `TransferErc1155BatchAndTokenInfoMessage`.\n     */\n    function decodeTransferErc1155BatchAndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155BatchAndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO,\n            \"Message type is not ERC1155BatchAndTokenInfo transfer\"\n        );\n        return abi.decode(data, (TransferErc1155BatchAndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring user status on schain.\n     * Returns encoded message.\n     */\n    function _encodeUserStatusMessage(address receiver, bool isActive) private pure returns (bytes memory) {\n        UserStatusMessage memory message = UserStatusMessage(\n            BaseMessage(MessageType.USER_STATUS),\n            receiver,\n            isActive\n        );\n        return abi.encode(message);\n    }\n\n}"
             },
```

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/TokenManagerERC721WithMetadata.json` & `ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/TokenManagerERC721WithMetadata.json`

 * *Files identical despite different names*

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/TokenManagerERC721WithMetadata.meta.json` & `ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/TokenManagerERC721WithMetadata.meta.json`

 * *Files 1% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9995592948717948%*

 * *Differences: {"'input'": "{'sources': {'@skalenetwork/skale-manager-interfaces/IWallets.sol': {'content': '// "*

 * *            'SPDX-License-Identifier: AGPL-3.0-only\\n\\n/*\\n    IWallets - SKALE Manager '*

 * *            'Interfaces\\n    Copyright (C) 2021-Present SKALE Labs\\n    @author Dmytro '*

 * *            'Stebaeiv\\n\\n    SKALE Manager Interfaces is free software: you can redistribute it '*

 * *            'and/or modify\\n    it under the terms of the GNU Affero General Public License as '*

 * *            'published\\n    by […]*

```diff
@@ -218,22 +218,28 @@
             },
             "@skalenetwork/ima-interfaces/schain/tokens/IEthErc20.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   IEthErc20 - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\n\ninterface IEthErc20 {\n    function mint(address account, uint256 amount) external;\n    function forceBurn(address account, uint256 amount) external;\n    function initialize(address tokenManagerEthAddress) external;\n}"
             },
             "@skalenetwork/skale-manager-interfaces/IContractManager.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IContractManager.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IContractManager {\n    /**\n     * @dev Emitted when contract is upgraded.\n     */\n    event ContractUpgraded(string contractsName, address contractsAddress);\n\n    function initialize() external;\n    function setContractsAddress(string calldata contractsName, address newContractsAddress) external;\n    function contracts(bytes32 nameHash) external view returns (address);\n    function getDelegationPeriodManager() external view returns (address);\n    function getBounty() external view returns (address);\n    function getValidatorService() external view returns (address);\n    function getTimeHelpers() external view returns (address);\n    function getConstantsHolder() external view returns (address);\n    function getSkaleToken() external view returns (address);\n    function getTokenState() external view returns (address);\n    function getPunisher() external view returns (address);\n    function getContract(string calldata name) external view returns (address);\n}"
             },
+            "@skalenetwork/skale-manager-interfaces/INodes.sol": {
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    INodes.sol - SKALE Manager\n    Copyright (C) 2018-Present SKALE Labs\n    @author Artem Payvin\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"./utils/IRandom.sol\";\n\ninterface INodes {\n    // All Nodes states\n    enum NodeStatus {Active, Leaving, Left, In_Maintenance}\n\n    struct Node {\n        string name;\n        bytes4 ip;\n        bytes4 publicIP;\n        uint16 port;\n        bytes32[2] publicKey;\n        uint startBlock;\n        uint lastRewardDate;\n        uint finishTime;\n        NodeStatus status;\n        uint validatorId;\n    }\n\n    // struct to note which Nodes and which number of Nodes owned by user\n    struct CreatedNodes {\n        mapping (uint => bool) isNodeExist;\n        uint numberOfNodes;\n    }\n\n    struct SpaceManaging {\n        uint8 freeSpace;\n        uint indexInSpaceMap;\n    }\n\n    struct NodeCreationParams {\n        string name;\n        bytes4 ip;\n        bytes4 publicIp;\n        uint16 port;\n        bytes32[2] publicKey;\n        uint16 nonce;\n        string domainName;\n    }\n    \n    /**\n     * @dev Emitted when a node is created.\n     */\n    event NodeCreated(\n        uint nodeIndex,\n        address owner,\n        string name,\n        bytes4 ip,\n        bytes4 publicIP,\n        uint16 port,\n        uint16 nonce,\n        string domainName\n    );\n\n    /**\n     * @dev Emitted when a node completes a network exit.\n     */\n    event ExitCompleted(\n        uint nodeIndex\n    );\n\n    /**\n     * @dev Emitted when a node begins to exit from the network.\n     */\n    event ExitInitialized(\n        uint nodeIndex,\n        uint startLeavingPeriod\n    );\n\n    /**\n     * @dev Emitted when a node set to in compliant or compliant.\n     */\n    event IncompliantNode(\n        uint indexed nodeIndex,\n        bool status\n    );\n\n    /**\n     * @dev Emitted when a node set to in maintenance or from in maintenance.\n     */\n    event MaintenanceNode(\n        uint indexed nodeIndex,\n        bool status\n    );\n\n    /**\n     * @dev Emitted when a node status changed.\n     */\n    event IPChanged(\n        uint indexed nodeIndex,\n        bytes4 previousIP,\n        bytes4 newIP\n    );\n    \n    function removeSpaceFromNode(uint nodeIndex, uint8 space) external returns (bool);\n    function addSpaceToNode(uint nodeIndex, uint8 space) external;\n    function changeNodeLastRewardDate(uint nodeIndex) external;\n    function changeNodeFinishTime(uint nodeIndex, uint time) external;\n    function createNode(address from, NodeCreationParams calldata params) external;\n    function initExit(uint nodeIndex) external;\n    function completeExit(uint nodeIndex) external returns (bool);\n    function deleteNodeForValidator(uint validatorId, uint nodeIndex) external;\n    function checkPossibilityCreatingNode(address nodeAddress) external;\n    function checkPossibilityToMaintainNode(uint validatorId, uint nodeIndex) external returns (bool);\n    function setNodeInMaintenance(uint nodeIndex) external;\n    function removeNodeFromInMaintenance(uint nodeIndex) external;\n    function setNodeIncompliant(uint nodeIndex) external;\n    function setNodeCompliant(uint nodeIndex) external;\n    function setDomainName(uint nodeIndex, string memory domainName) external;\n    function makeNodeVisible(uint nodeIndex) external;\n    function makeNodeInvisible(uint nodeIndex) external;\n    function changeIP(uint nodeIndex, bytes4 newIP, bytes4 newPublicIP) external;\n    function numberOfActiveNodes() external view returns (uint);\n    function incompliant(uint nodeIndex) external view returns (bool);\n    function getRandomNodeWithFreeSpace(\n        uint8 freeSpace,\n        IRandom.RandomGenerator memory randomGenerator\n    )\n        external\n        view\n        returns (uint);\n    function isTimeForReward(uint nodeIndex) external view returns (bool);\n    function getNodeIP(uint nodeIndex) external view returns (bytes4);\n    function getNodeDomainName(uint nodeIndex) external view returns (string memory);\n    function getNodePort(uint nodeIndex) external view returns (uint16);\n    function getNodePublicKey(uint nodeIndex) external view returns (bytes32[2] memory);\n    function getNodeAddress(uint nodeIndex) external view returns (address);\n    function getNodeFinishTime(uint nodeIndex) external view returns (uint);\n    function isNodeLeft(uint nodeIndex) external view returns (bool);\n    function isNodeInMaintenance(uint nodeIndex) external view returns (bool);\n    function getNodeLastRewardDate(uint nodeIndex) external view returns (uint);\n    function getNodeNextRewardDate(uint nodeIndex) external view returns (uint);\n    function getNumberOfNodes() external view returns (uint);\n    function getNumberOnlineNodes() external view returns (uint);\n    function getActiveNodeIds() external view returns (uint[] memory activeNodeIds);\n    function getNodeStatus(uint nodeIndex) external view returns (NodeStatus);\n    function getValidatorNodeIndexes(uint validatorId) external view returns (uint[] memory);\n    function countNodesWithFreeSpace(uint8 freeSpace) external view returns (uint count);\n    function getValidatorId(uint nodeIndex) external view returns (uint);\n    function isNodeExist(address from, uint nodeIndex) external view returns (bool);\n    function isNodeActive(uint nodeIndex) external view returns (bool);\n    function isNodeLeaving(uint nodeIndex) external view returns (bool);\n}\n"
+            },
             "@skalenetwork/skale-manager-interfaces/ISchains.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchains.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchains {\n\n    struct SchainOption {\n        string name;\n        bytes value;\n    }\n    \n    /**\n     * @dev Emitted when an schain is created.\n     */\n    event SchainCreated(\n        string name,\n        address owner,\n        uint partOfNode,\n        uint lifetime,\n        uint numberOfNodes,\n        uint deposit,\n        uint16 nonce,\n        bytes32 schainHash\n    );\n\n    /**\n     * @dev Emitted when an schain is deleted.\n     */\n    event SchainDeleted(\n        address owner,\n        string name,\n        bytes32 indexed schainHash\n    );\n\n    /**\n     * @dev Emitted when a node in an schain is rotated.\n     */\n    event NodeRotated(\n        bytes32 schainHash,\n        uint oldNode,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a node is added to an schain.\n     */\n    event NodeAdded(\n        bytes32 schainHash,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a group of nodes is created for an schain.\n     */\n    event SchainNodes(\n        string name,\n        bytes32 schainHash,\n        uint[] nodesInGroup\n    );\n\n    function addSchain(address from, uint deposit, bytes calldata data) external;\n    function addSchainByFoundation(\n        uint lifetime,\n        uint8 typeOfSchain,\n        uint16 nonce,\n        string calldata name,\n        address schainOwner,\n        address schainOriginator,\n        SchainOption[] calldata options\n    )\n        external\n        payable;\n    function deleteSchain(address from, string calldata name) external;\n    function deleteSchainByRoot(string calldata name) external;\n    function restartSchainCreation(string calldata name) external;\n    function verifySchainSignature(\n        uint256 signA,\n        uint256 signB,\n        bytes32 hash,\n        uint256 counter,\n        uint256 hashA,\n        uint256 hashB,\n        string calldata schainName\n    )\n        external\n        view\n        returns (bool);\n    function getSchainPrice(uint typeOfSchain, uint lifetime) external view returns (uint);\n    function getOption(bytes32 schainHash, string calldata optionName) external view returns (bytes memory);\n    function getOptions(bytes32 schainHash) external view returns (SchainOption[] memory);\n}"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchains.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchains {\n\n    struct SchainOption {\n        string name;\n        bytes value;\n    }\n    \n    /**\n     * @dev Emitted when an schain is created.\n     */\n    event SchainCreated(\n        string name,\n        address owner,\n        uint partOfNode,\n        uint lifetime,\n        uint numberOfNodes,\n        uint deposit,\n        uint16 nonce,\n        bytes32 schainHash\n    );\n\n    /**\n     * @dev Emitted when an schain is deleted.\n     */\n    event SchainDeleted(\n        address owner,\n        string name,\n        bytes32 indexed schainHash\n    );\n\n    /**\n     * @dev Emitted when a node in an schain is rotated.\n     */\n    event NodeRotated(\n        bytes32 schainHash,\n        uint oldNode,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a node is added to an schain.\n     */\n    event NodeAdded(\n        bytes32 schainHash,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a group of nodes is created for an schain.\n     */\n    event SchainNodes(\n        string name,\n        bytes32 schainHash,\n        uint[] nodesInGroup\n    );\n\n    function addSchain(address from, uint deposit, bytes calldata data) external;\n    function addSchainByFoundation(\n        uint lifetime,\n        uint8 typeOfSchain,\n        uint16 nonce,\n        string calldata name,\n        address schainOwner,\n        address schainOriginator,\n        SchainOption[] calldata options\n    )\n        external\n        payable;\n    function deleteSchain(address from, string calldata name) external;\n    function deleteSchainByRoot(string calldata name) external;\n    function restartSchainCreation(string calldata name) external;\n    function verifySchainSignature(\n        uint256 signA,\n        uint256 signB,\n        bytes32 hash,\n        uint256 counter,\n        uint256 hashA,\n        uint256 hashB,\n        string calldata schainName\n    )\n        external\n        view\n        returns (bool);\n    function getSchainPrice(uint typeOfSchain, uint lifetime) external view returns (uint);\n    function getOption(bytes32 schainHash, string calldata optionName) external view returns (bytes memory);\n    function getOptions(bytes32 schainHash) external view returns (SchainOption[] memory);\n}\n"
             },
             "@skalenetwork/skale-manager-interfaces/ISchainsInternal.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchainsInternal - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchainsInternal {\n    struct Schain {\n        string name;\n        address owner;\n        uint indexInOwnerList;\n        uint8 partOfNode;\n        uint lifetime;\n        uint startDate;\n        uint startBlock;\n        uint deposit;\n        uint64 index;\n        uint generation;\n        address originator;\n    }\n\n    struct SchainType {\n        uint8 partOfNode;\n        uint numberOfNodes;\n    }\n\n    /**\n     * @dev Emitted when schain type added.\n     */\n    event SchainTypeAdded(uint indexed schainType, uint partOfNode, uint numberOfNodes);\n\n    /**\n     * @dev Emitted when schain type removed.\n     */\n    event SchainTypeRemoved(uint indexed schainType);\n\n    function initializeSchain(\n        string calldata name,\n        address from,\n        address originator,\n        uint lifetime,\n        uint deposit) external;\n    function createGroupForSchain(\n        bytes32 schainHash,\n        uint numberOfNodes,\n        uint8 partOfNode\n    )\n        external\n        returns (uint[] memory);\n    function changeLifetime(bytes32 schainHash, uint lifetime, uint deposit) external;\n    function removeSchain(bytes32 schainHash, address from) external;\n    function removeNodeFromSchain(uint nodeIndex, bytes32 schainHash) external;\n    function deleteGroup(bytes32 schainHash) external;\n    function setException(bytes32 schainHash, uint nodeIndex) external;\n    function setNodeInGroup(bytes32 schainHash, uint nodeIndex) external;\n    function removeHolesForSchain(bytes32 schainHash) external;\n    function addSchainType(uint8 partOfNode, uint numberOfNodes) external;\n    function removeSchainType(uint typeOfSchain) external;\n    function setNumberOfSchainTypes(uint newNumberOfSchainTypes) external;\n    function removeNodeFromAllExceptionSchains(uint nodeIndex) external;\n    function removeAllNodesFromSchainExceptions(bytes32 schainHash) external;\n    function makeSchainNodesInvisible(bytes32 schainHash) external;\n    function makeSchainNodesVisible(bytes32 schainHash) external;\n    function newGeneration() external;\n    function addSchainForNode(uint nodeIndex, bytes32 schainHash) external;\n    function removeSchainForNode(uint nodeIndex, uint schainIndex) external;\n    function removeNodeFromExceptions(bytes32 schainHash, uint nodeIndex) external;\n    function isSchainActive(bytes32 schainHash) external view returns (bool);\n    function schainsAtSystem(uint index) external view returns (bytes32);\n    function numberOfSchains() external view returns (uint64);\n    function getSchains() external view returns (bytes32[] memory);\n    function getSchainsPartOfNode(bytes32 schainHash) external view returns (uint8);\n    function getSchainListSize(address from) external view returns (uint);\n    function getSchainHashesByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainIdsByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainHashesForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainIdsForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainOwner(bytes32 schainHash) external view returns (address);\n    function getSchainOriginator(bytes32 schainHash) external view returns (address);\n    function isSchainNameAvailable(string calldata name) external view returns (bool);\n    function isTimeExpired(bytes32 schainHash) external view returns (bool);\n    function isOwnerAddress(address from, bytes32 schainId) external view returns (bool);\n    function getSchainName(bytes32 schainHash) external view returns (string memory);\n    function getActiveSchain(uint nodeIndex) external view returns (bytes32);\n    function getActiveSchains(uint nodeIndex) external view returns (bytes32[] memory activeSchains);\n    function getNumberOfNodesInGroup(bytes32 schainHash) external view returns (uint);\n    function getNodesInGroup(bytes32 schainHash) external view returns (uint[] memory);\n    function isNodeAddressesInGroup(bytes32 schainId, address sender) external view returns (bool);\n    function getNodeIndexInGroup(bytes32 schainHash, uint nodeId) external view returns (uint);\n    function isAnyFreeNode(bytes32 schainHash) external view returns (bool);\n    function checkException(bytes32 schainHash, uint nodeIndex) external view returns (bool);\n    function checkHoleForSchain(bytes32 schainHash, uint indexOfNode) external view returns (bool);\n    function checkSchainOnNode(uint nodeIndex, bytes32 schainHash) external view returns (bool);\n    function getSchainType(uint typeOfSchain) external view returns(uint8, uint);\n    function getGeneration(bytes32 schainHash) external view returns (uint);\n    function isSchainExist(bytes32 schainHash) external view returns (bool);\n}"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchainsInternal - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"./INodes.sol\";\n\ninterface ISchainsInternal {\n    struct Schain {\n        string name;\n        address owner;\n        uint indexInOwnerList;\n        uint8 partOfNode;\n        uint lifetime;\n        uint startDate;\n        uint startBlock;\n        uint deposit;\n        uint64 index;\n        uint generation;\n        address originator;\n    }\n\n    struct SchainType {\n        uint8 partOfNode;\n        uint numberOfNodes;\n    }\n\n    /**\n     * @dev Emitted when schain type added.\n     */\n    event SchainTypeAdded(uint indexed schainType, uint partOfNode, uint numberOfNodes);\n\n    /**\n     * @dev Emitted when schain type removed.\n     */\n    event SchainTypeRemoved(uint indexed schainType);\n\n    function initializeSchain(\n        string calldata name,\n        address from,\n        address originator,\n        uint lifetime,\n        uint deposit) external;\n    function createGroupForSchain(\n        bytes32 schainHash,\n        uint numberOfNodes,\n        uint8 partOfNode\n    )\n        external\n        returns (uint[] memory);\n    function changeLifetime(bytes32 schainHash, uint lifetime, uint deposit) external;\n    function removeSchain(bytes32 schainHash, address from) external;\n    function removeNodeFromSchain(uint nodeIndex, bytes32 schainHash) external;\n    function deleteGroup(bytes32 schainHash) external;\n    function setException(bytes32 schainHash, uint nodeIndex) external;\n    function setNodeInGroup(bytes32 schainHash, uint nodeIndex) external;\n    function removeHolesForSchain(bytes32 schainHash) external;\n    function addSchainType(uint8 partOfNode, uint numberOfNodes) external;\n    function removeSchainType(uint typeOfSchain) external;\n    function setNumberOfSchainTypes(uint newNumberOfSchainTypes) external;\n    function removeNodeFromAllExceptionSchains(uint nodeIndex) external;\n    function removeAllNodesFromSchainExceptions(bytes32 schainHash) external;\n    function makeSchainNodesInvisible(bytes32 schainHash) external;\n    function makeSchainNodesVisible(bytes32 schainHash) external;\n    function newGeneration() external;\n    function addSchainForNode(INodes nodes,uint nodeIndex, bytes32 schainHash) external;\n    function removeSchainForNode(uint nodeIndex, uint schainIndex) external;\n    function removeNodeFromExceptions(bytes32 schainHash, uint nodeIndex) external;\n    function isSchainActive(bytes32 schainHash) external view returns (bool);\n    function schainsAtSystem(uint index) external view returns (bytes32);\n    function numberOfSchains() external view returns (uint64);\n    function getSchains() external view returns (bytes32[] memory);\n    function getSchainsPartOfNode(bytes32 schainHash) external view returns (uint8);\n    function getSchainListSize(address from) external view returns (uint);\n    function getSchainHashesByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainHashesForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainOwner(bytes32 schainHash) external view returns (address);\n    function getSchainOriginator(bytes32 schainHash) external view returns (address);\n    function isSchainNameAvailable(string calldata name) external view returns (bool);\n    function isTimeExpired(bytes32 schainHash) external view returns (bool);\n    function isOwnerAddress(address from, bytes32 schainHash) external view returns (bool);\n    function getSchainName(bytes32 schainHash) external view returns (string memory);\n    function getActiveSchain(uint nodeIndex) external view returns (bytes32);\n    function getActiveSchains(uint nodeIndex) external view returns (bytes32[] memory activeSchains);\n    function getNumberOfNodesInGroup(bytes32 schainHash) external view returns (uint);\n    function getNodesInGroup(bytes32 schainHash) external view returns (uint[] memory);\n    function isNodeAddressesInGroup(bytes32 schainHash, address sender) external view returns (bool);\n    function getNodeIndexInGroup(bytes32 schainHash, uint nodeHash) external view returns (uint);\n    function isAnyFreeNode(bytes32 schainHash) external view returns (bool);\n    function checkException(bytes32 schainHash, uint nodeIndex) external view returns (bool);\n    function checkHoleForSchain(bytes32 schainHash, uint indexOfNode) external view returns (bool);\n    function checkSchainOnNode(uint nodeIndex, bytes32 schainHash) external view returns (bool);\n    function getSchainType(uint typeOfSchain) external view returns(uint8, uint);\n    function getGeneration(bytes32 schainHash) external view returns (uint);\n    function isSchainExist(bytes32 schainHash) external view returns (bool);\n}"
             },
             "@skalenetwork/skale-manager-interfaces/IWallets.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IWallets - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IWallets {\n    /**\n     * @dev Emitted when the validator wallet was funded\n     */\n    event ValidatorWalletRecharged(address sponsor, uint amount, uint validatorId);\n\n    /**\n     * @dev Emitted when the schain wallet was funded\n     */\n    event SchainWalletRecharged(address sponsor, uint amount, bytes32 schainHash);\n\n    /**\n     * @dev Emitted when the node received a refund from validator to its wallet\n     */\n    event NodeRefundedByValidator(address node, uint validatorId, uint amount);\n\n    /**\n     * @dev Emitted when the node received a refund from schain to its wallet\n     */\n    event NodeRefundedBySchain(address node, bytes32 schainHash, uint amount);\n\n    /**\n     * @dev Emitted when the validator withdrawn funds from validator wallet\n     */\n    event WithdrawFromValidatorWallet(uint indexed validatorId, uint amount);\n\n    /**\n     * @dev Emitted when the schain owner withdrawn funds from schain wallet\n     */\n    event WithdrawFromSchainWallet(bytes32 indexed schainHash, uint amount);\n\n    receive() external payable;\n    function refundGasByValidator(uint validatorId, address payable spender, uint spentGas) external;\n    function refundGasByValidatorToSchain(uint validatorId, bytes32 schainHash) external;\n    function refundGasBySchain(bytes32 schainId, address payable spender, uint spentGas, bool isDebt) external;\n    function withdrawFundsFromSchainWallet(address payable schainOwner, bytes32 schainHash) external;\n    function withdrawFundsFromValidatorWallet(uint amount) external;\n    function rechargeValidatorWallet(uint validatorId) external payable;\n    function rechargeSchainWallet(bytes32 schainId) external payable;\n    function getSchainBalance(bytes32 schainHash) external view returns (uint);\n    function getValidatorBalance(uint validatorId) external view returns (uint);\n}\n"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IWallets - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IWallets {\n    receive() external payable;\n    function refundGasByValidator(uint validatorId, address payable spender, uint gasLimit) external;\n    function refundGasByValidatorToSchain(uint validatorId, bytes32 schainHash) external;\n    function refundGasBySchain(bytes32 schainId, address payable spender, uint spentGas, bool isDebt) external;\n    function withdrawFundsFromSchainWallet(address payable schainOwner, bytes32 schainHash) external;\n    function withdrawFundsFromValidatorWallet(uint amount) external;\n    function rechargeValidatorWallet(uint validatorId) external payable;\n    function rechargeSchainWallet(bytes32 schainId) external payable;\n    function getSchainBalance(bytes32 schainHash) external view returns (uint);\n    function getValidatorBalance(uint validatorId) external view returns (uint);\n}\n"
+            },
+            "@skalenetwork/skale-manager-interfaces/utils/IRandom.sol": {
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IRandom.sol - SKALE Manager Interfaces\n    Copyright (C) 2022-Present SKALE Labs\n    @author Dmytro Stebaiev\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\n\ninterface IRandom {\n    struct RandomGenerator {\n        uint seed;\n    }\n}"
             },
             "contracts/MessageProxy.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   MessageProxy.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/IGasReimbursable.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageProxy.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageReceiver.sol\";\n\n\n/**\n * @title MessageProxy\n * @dev Abstract contract for MessageProxyForMainnet and MessageProxyForSchain.\n */\nabstract contract MessageProxy is AccessControlEnumerableUpgradeable, IMessageProxy {\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    /**\n     * @dev Structure that stores counters for outgoing and incoming messages.\n     */\n    struct ConnectedChainInfo {\n        // message counters start with 0\n        uint256 incomingMessageCounter;\n        uint256 outgoingMessageCounter;\n        bool inited;\n        uint256 lastOutgoingMessageBlockId;\n    }\n\n    bytes32 public constant MAINNET_HASH = keccak256(abi.encodePacked(\"Mainnet\"));\n    bytes32 public constant CHAIN_CONNECTOR_ROLE = keccak256(\"CHAIN_CONNECTOR_ROLE\");\n    bytes32 public constant EXTRA_CONTRACT_REGISTRAR_ROLE = keccak256(\"EXTRA_CONTRACT_REGISTRAR_ROLE\");\n    bytes32 public constant CONSTANT_SETTER_ROLE = keccak256(\"CONSTANT_SETTER_ROLE\");\n    uint256 public constant MESSAGES_LENGTH = 10;\n    uint256 public constant REVERT_REASON_LENGTH = 64;\n\n    //   schainHash => ConnectedChainInfo\n    mapping(bytes32 => ConnectedChainInfo) public connectedChains;\n    //   schainHash => contract address => allowed\n    mapping(bytes32 => mapping(address => bool)) private _deprecatedRegistryContracts;\n\n    uint256 public gasLimit;\n\n    /**\n     * @dev Emitted for every outgoing message to schain.\n     */\n    event OutgoingMessage(\n        bytes32 indexed dstChainHash,\n        uint256 indexed msgCounter,\n        address indexed srcContract,\n        address dstContract,\n        bytes data\n    );\n\n    /**\n     * @dev Emitted when function `postMessage` returns revert.\n     *  Used to prevent stuck loop inside function `postIncomingMessages`.\n     */\n    event PostMessageError(\n        uint256 indexed msgCounter,\n        bytes message\n    );\n\n    /**\n     * @dev Emitted when gas limit per one call of `postMessage` was changed.\n     */\n    event GasLimitWasChanged(\n        uint256 oldValue,\n        uint256 newValue\n    );\n\n    /**\n     * @dev Emitted when the version was updated\n     */\n    event VersionUpdated(string oldVersion, string newVersion);\n\n    /**\n     * @dev Emitted when extra contract was added.\n     */\n    event ExtraContractRegistered(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Emitted when extra contract was removed.\n     */\n    event ExtraContractRemoved(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Emitted when referenced to previous outgoing message.\n     */\n    event PreviousMessageReference (\n        uint256 currentMessage,\n        uint256 previousOutgoingMessageBlockId\n    );\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CHAIN_CONNECTOR_ROLE}.\n     */\n    modifier onlyChainConnector() {\n        require(hasRole(CHAIN_CONNECTOR_ROLE, msg.sender), \"CHAIN_CONNECTOR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {EXTRA_CONTRACT_REGISTRAR_ROLE}.\n     */\n    modifier onlyExtraContractRegistrar() {\n        require(hasRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender), \"EXTRA_CONTRACT_REGISTRAR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CONSTANT_SETTER_ROLE}.\n     */\n    modifier onlyConstantSetter() {\n        require(hasRole(CONSTANT_SETTER_ROLE, msg.sender), \"Not enough permissions to set constant\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {DEFAULT_ADMIN_ROLE}.\n     */\n    modifier onlyOwner() {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"DEFAULT_ADMIN_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Sets gasLimit to a new value.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CONSTANT_SETTER_ROLE.\n     */\n    function setNewGasLimit(uint256 newGasLimit) external override onlyConstantSetter {\n        emit GasLimitWasChanged(gasLimit, newGasLimit);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Virtual function for `postIncomingMessages`.\n     */\n    function postIncomingMessages(\n        string calldata fromSchainName,\n        uint256 startingCounter,\n        Message[] calldata messages,\n        Signature calldata sign\n    )\n        external\n        virtual\n        override;\n\n    /**\n     * @dev Allows `msg.sender` to register extra contract for all schains\n     * for being able to transfer messages from custom contracts.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     * - Passed address should be contract.\n     * - Extra contract must not be registered.\n     */\n    function registerExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is already registered\");\n        _getRegistryContracts()[bytes32(0)].add(extraContract);\n        emit ExtraContractRegistered(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Allows `msg.sender` to remove extra contract for all schains.\n     * Extra contract will no longer be able to send messages through MessageProxy.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     */\n    function removeExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[bytes32(0)].remove(extraContract);\n        emit ExtraContractRemoved(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Should return length of contract registered by schainHash.\n     */\n    function getContractRegisteredLength(bytes32 schainHash) external view override returns (uint256) {\n        return _getRegistryContracts()[schainHash].length();\n    }\n\n    /**\n     * @dev Should return a range of contracts registered by schainHash.\n     *\n     * Requirements:\n     * range should be less or equal 10 contracts\n     */\n    function getContractRegisteredRange(\n        bytes32 schainHash,\n        uint256 from,\n        uint256 to\n    )\n        external\n        view\n        override\n        returns (address[] memory contractsInRange)\n    {\n        require(\n            from < to && to - from <= 10 && to <= _getRegistryContracts()[schainHash].length(),\n            \"Range is incorrect\"\n        );\n        contractsInRange = new address[](to - from);\n        for (uint256 i = from; i < to; i++) {\n            contractsInRange[i - from] = _getRegistryContracts()[schainHash].at(i);\n        }\n    }\n\n    /**\n     * @dev Returns number of outgoing messages.\n     *\n     * Requirements:\n     *\n     * - Target schain  must be initialized.\n     */\n    function getOutgoingMessagesCounter(string calldata targetSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 dstChainHash = keccak256(abi.encodePacked(targetSchainName));\n        require(connectedChains[dstChainHash].inited, \"Destination chain is not initialized\");\n        return connectedChains[dstChainHash].outgoingMessageCounter;\n    }\n\n\n    /**\n     * @dev Should return block number of the last message transferred to schain\n     */\n    function getLastOutgoingMessageBlockId(string memory targetSchainName) external view override returns (uint) {\n        bytes32 dstChainHash = keccak256(abi.encodePacked(targetSchainName));\n        require(connectedChains[dstChainHash].inited, \"Destination chain is not initialized\");\n        return connectedChains[dstChainHash].lastOutgoingMessageBlockId;\n    }\n\n    /**\n     * @dev Returns number of incoming messages.\n     *\n     * Requirements:\n     *\n     * - Source schain must be initialized.\n     */\n    function getIncomingMessagesCounter(string calldata fromSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 srcChainHash = keccak256(abi.encodePacked(fromSchainName));\n        require(connectedChains[srcChainHash].inited, \"Source chain is not initialized\");\n        return connectedChains[srcChainHash].incomingMessageCounter;\n    }\n\n    function initializeMessageProxy(uint newGasLimit) public initializer {\n        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(CHAIN_CONNECTOR_ROLE, msg.sender);\n        _setupRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender);\n        _setupRole(CONSTANT_SETTER_ROLE, msg.sender);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Posts message from this contract to `targetChainHash` MessageProxy contract.\n     * This is called by a smart contract to make a cross-chain call.\n     *\n     * Emits an {OutgoingMessage} event.\n     *\n     * Requirements:\n     *\n     * - Target chain must be initialized.\n     * - Target chain must be registered as external contract.\n     */\n    function postOutgoingMessage(\n        bytes32 targetChainHash,\n        address targetContract,\n        bytes memory data\n    )\n        public\n        override\n        virtual\n    {\n        require(connectedChains[targetChainHash].inited, \"Destination chain is not initialized\");\n        _authorizeOutgoingMessageSender(targetChainHash);\n\n        uint outgoingMessageCounter = connectedChains[targetChainHash].outgoingMessageCounter;\n        emit OutgoingMessage(\n            targetChainHash,\n            outgoingMessageCounter,\n            msg.sender,\n            targetContract,\n            data\n        );\n        emit PreviousMessageReference(\n            outgoingMessageCounter,\n            connectedChains[targetChainHash].lastOutgoingMessageBlockId\n        );\n        connectedChains[targetChainHash].outgoingMessageCounter++;\n        connectedChains[targetChainHash].lastOutgoingMessageBlockId = block.number;\n    }\n\n    /**\n     * @dev Allows CHAIN_CONNECTOR_ROLE to remove connected chain from this contract.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CHAIN_CONNECTOR_ROLE.\n     * - `schainName` must be initialized.\n     */\n    function removeConnectedChain(string memory schainName) public virtual override onlyChainConnector {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(connectedChains[schainHash].inited, \"Chain is not initialized\");\n        delete connectedChains[schainHash];\n    }\n\n    /**\n     * @dev Checks whether chain is currently connected.\n     */\n    function isConnectedChain(\n        string memory schainName\n    )\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return connectedChains[keccak256(abi.encodePacked(schainName))].inited;\n    }\n\n    /**\n     * @dev Checks whether contract is currently registered as extra contract.\n     */\n    function isContractRegistered(\n        bytes32 schainHash,\n        address contractAddress\n    )\n        public\n        view\n        override\n        returns (bool)\n    {\n        return _getRegistryContracts()[schainHash].contains(contractAddress);\n    }\n\n    /**\n     * @dev Allows MessageProxy to register extra contract for being able to transfer messages from custom contracts.\n     *\n     * Requirements:\n     *\n     * - Extra contract address must be contract.\n     * - Extra contract must not be registered.\n     * - Extra contract must not be registered for all chains.\n     */\n    function _registerExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {\n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is already registered\");\n        require(\n            !_getRegistryContracts()[bytes32(0)].contains(extraContract),\n            \"Extra contract is already registered for all chains\"\n        );\n\n        _getRegistryContracts()[chainHash].add(extraContract);\n        emit ExtraContractRegistered(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to remove extra contract,\n     * thus `extraContract` will no longer be available to transfer messages from mainnet to schain.\n     *\n     * Requirements:\n     *\n     * - Extra contract must be registered.\n     */\n    function _removeExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {\n        require(_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[chainHash].remove(extraContract);\n        emit ExtraContractRemoved(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to connect schain with MessageProxyOnMainnet for transferring messages.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CHAIN_CONNECTOR_ROLE.\n     * - SKALE chain must not be connected.\n     */\n    function _addConnectedChain(bytes32 schainHash) internal onlyChainConnector {\n        require(!connectedChains[schainHash].inited,\"Chain is already connected\");\n        connectedChains[schainHash] = ConnectedChainInfo({\n            incomingMessageCounter: 0,\n            outgoingMessageCounter: 0,\n            inited: true,\n            lastOutgoingMessageBlockId: 0\n        });\n    }\n\n    /**\n     * @dev Allows MessageProxy to send messages from schain to mainnet.\n     * Destination contract must implement `postMessage` method.\n     */\n    function _callReceiverContract(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n    {\n        if (!message.destinationContract.isContract()) {\n            emit PostMessageError(\n                counter,\n                \"Destination contract is not a contract\"\n            );\n            return;\n        }\n        try IMessageReceiver(message.destinationContract).postMessage{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) {\n            return;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                _getSlice(bytes(reason), REVERT_REASON_LENGTH)\n            );\n        } catch Panic(uint errorCode) {\n               emit PostMessageError(\n                counter,\n                abi.encodePacked(errorCode)\n            );\n        } catch (bytes memory revertData) {\n            emit PostMessageError(\n                counter,\n                _getSlice(revertData, REVERT_REASON_LENGTH)\n            );\n        }\n    }\n\n    /**\n     * @dev Returns receiver of message.\n     */\n    function _getGasPayer(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n        returns (address)\n    {\n        try IGasReimbursable(message.destinationContract).gasPayer{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) returns (address receiver) {\n            return receiver;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                _getSlice(bytes(reason), REVERT_REASON_LENGTH)\n            );\n            return address(0);\n        } catch Panic(uint errorCode) {\n               emit PostMessageError(\n                counter,\n                abi.encodePacked(errorCode)\n            );\n            return address(0);\n        } catch (bytes memory revertData) {\n            emit PostMessageError(\n                counter,\n                _getSlice(revertData, REVERT_REASON_LENGTH)\n            );\n            return address(0);\n        }\n    }\n\n    /**\n     * @dev Checks whether msg.sender is registered as custom extra contract.\n     */\n    function _authorizeOutgoingMessageSender(bytes32 targetChainHash) internal view virtual {\n        require(\n            isContractRegistered(bytes32(0), msg.sender) || isContractRegistered(targetChainHash, msg.sender),\n            \"Sender contract is not registered\"\n        );\n    }\n\n    /**\n     * @dev Returns list of registered custom extra contracts.\n     */\n    function _getRegistryContracts()\n        internal\n        view\n        virtual\n        returns (mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) storage);\n\n    /**\n     * @dev Returns hash of message array.\n     */\n    function _hashedArray(\n        Message[] calldata messages,\n        uint256 startingCounter,\n        string calldata fromChainName\n    )\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32 sourceHash = keccak256(abi.encodePacked(fromChainName));\n        bytes32 hash = keccak256(abi.encodePacked(sourceHash, bytes32(startingCounter)));\n        for (uint256 i = 0; i < messages.length; i++) {\n            hash = keccak256(\n                abi.encodePacked(\n                    abi.encode(\n                        hash,\n                        messages[i].sender,\n                        messages[i].destinationContract\n                    ),\n                    messages[i].data\n                )\n            );\n        }\n        return hash;\n    }\n\n    function _getSlice(bytes memory text, uint end) private pure returns (bytes memory) {\n        uint slicedEnd = end < text.length ? end : text.length;\n        bytes memory sliced = new bytes(slicedEnd);\n        for(uint i = 0; i < slicedEnd; i++){\n            sliced[i] = text[i];\n        }\n        return sliced;\n    }\n}\n"
             },
             "contracts/Messages.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   Messages.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\n\n/**\n * @title Messages\n * @dev Library for encoding and decoding messages\n * for transferring from Mainnet to Schain and vice versa.\n */\nlibrary Messages {\n\n    /**\n     * @dev Enumerator that describes all supported message types.\n     */\n    enum MessageType {\n        EMPTY,\n        TRANSFER_ETH,\n        TRANSFER_ERC20,\n        TRANSFER_ERC20_AND_TOTAL_SUPPLY,\n        TRANSFER_ERC20_AND_TOKEN_INFO,\n        TRANSFER_ERC721,\n        TRANSFER_ERC721_AND_TOKEN_INFO,\n        USER_STATUS,\n        INTERCHAIN_CONNECTION,\n        TRANSFER_ERC1155,\n        TRANSFER_ERC1155_AND_TOKEN_INFO,\n        TRANSFER_ERC1155_BATCH,\n        TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO,\n        TRANSFER_ERC721_WITH_METADATA,\n        TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO\n    }\n\n    /**\n     * @dev Structure for base message.\n     */\n    struct BaseMessage {\n        MessageType messageType;\n    }\n\n    /**\n     * @dev Structure for describing ETH.\n     */\n    struct TransferEthMessage {\n        BaseMessage message;\n        address receiver;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for user status.\n     */\n    struct UserStatusMessage {\n        BaseMessage message;\n        address receiver;\n        bool isActive;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 token.\n     */\n    struct TransferErc20Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC20 token.\n     */\n    struct Erc20TokenInfo {\n        string name;\n        uint8 decimals;\n        string symbol;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token supply.\n     */\n    struct TransferErc20AndTotalSupplyMessage {\n        TransferErc20Message baseErc20transfer;\n        uint256 totalSupply;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token info.\n     */\n    struct TransferErc20AndTokenInfoMessage {\n        TransferErc20Message baseErc20transfer;\n        uint256 totalSupply;\n        Erc20TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing base ERC721.\n     */\n    struct TransferErc721Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 tokenId;\n    }\n\n    /**\n     * @dev Structure for describing base ERC721 with metadata.\n     */\n    struct TransferErc721MessageWithMetadata {\n        TransferErc721Message erc721message;\n        string tokenURI;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token info.\n     */\n    struct Erc721TokenInfo {\n        string name;\n        string symbol;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC721 token.\n     */\n    struct TransferErc721AndTokenInfoMessage {\n        TransferErc721Message baseErc721transfer;\n        Erc721TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC721 token with metadata.\n     */\n    struct TransferErc721WithMetadataAndTokenInfoMessage {\n        TransferErc721MessageWithMetadata baseErc721transferWithMetadata;\n        Erc721TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing whether interchain connection is allowed.\n     */\n    struct InterchainConnectionMessage {\n        BaseMessage message;\n        bool isAllowed;\n    }\n\n    /**\n     * @dev Structure for describing whether interchain connection is allowed.\n     */\n    struct TransferErc1155Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 id;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for describing ERC1155 token in batches.\n     */\n    struct TransferErc1155BatchMessage {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256[] ids;\n        uint256[] amounts;\n    }\n\n    /**\n     * @dev Structure for describing ERC1155 token info.\n     */\n    struct Erc1155TokenInfo {\n        string uri;\n    }\n\n    /**\n     * @dev Structure for describing message for transferring ERC1155 token with info.\n     */\n    struct TransferErc1155AndTokenInfoMessage {\n        TransferErc1155Message baseErc1155transfer;\n        Erc1155TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing message for transferring ERC1155 token in batches with info.\n     */\n    struct TransferErc1155BatchAndTokenInfoMessage {\n        TransferErc1155BatchMessage baseErc1155Batchtransfer;\n        Erc1155TokenInfo tokenInfo;\n    }\n\n\n    /**\n     * @dev Returns type of message for encoded data.\n     */\n    function getMessageType(bytes calldata data) internal pure returns (MessageType) {\n        uint256 firstWord = abi.decode(data, (uint256));\n        if (firstWord % 32 == 0) {\n            return getMessageType(data[firstWord:]);\n        } else {\n            return abi.decode(data, (Messages.MessageType));\n        }\n    }\n\n    /**\n     * @dev Encodes message for transferring ETH. Returns encoded message.\n     */\n    function encodeTransferEthMessage(address receiver, uint256 amount) internal pure returns (bytes memory) {\n        TransferEthMessage memory message = TransferEthMessage(\n            BaseMessage(MessageType.TRANSFER_ETH),\n            receiver,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ETH. Returns structure `TransferEthMessage`.\n     */\n    function decodeTransferEthMessage(\n        bytes calldata data\n    ) internal pure returns (TransferEthMessage memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ETH, \"Message type is not ETH transfer\");\n        return abi.decode(data, (TransferEthMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ETH. Returns encoded message.\n     */\n    function encodeTransferErc20Message(\n        address token,\n        address receiver,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        TransferErc20Message memory message = TransferErc20Message(\n            BaseMessage(MessageType.TRANSFER_ERC20),\n            token,\n            receiver,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC20 with total supply. Returns encoded message.\n     */\n    function encodeTransferErc20AndTotalSupplyMessage(\n        address token,\n        address receiver,\n        uint256 amount,\n        uint256 totalSupply\n    ) internal pure returns (bytes memory) {\n        TransferErc20AndTotalSupplyMessage memory message = TransferErc20AndTotalSupplyMessage(\n            TransferErc20Message(\n                BaseMessage(MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY),\n                token,\n                receiver,\n                amount\n            ),\n            totalSupply\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20. Returns structure `TransferErc20Message`.\n     */\n    function decodeTransferErc20Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc20Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC20, \"Message type is not ERC20 transfer\");\n        return abi.decode(data, (TransferErc20Message));\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20 with total supply. \n     * Returns structure `TransferErc20AndTotalSupplyMessage`.\n     */\n    function decodeTransferErc20AndTotalSupplyMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc20AndTotalSupplyMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY,\n            \"Message type is not ERC20 transfer and total supply\"\n        );\n        return abi.decode(data, (TransferErc20AndTotalSupplyMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC20 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc20AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 amount,\n        uint256 totalSupply,\n        Erc20TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc20AndTokenInfoMessage memory message = TransferErc20AndTokenInfoMessage(\n            TransferErc20Message(\n                BaseMessage(MessageType.TRANSFER_ERC20_AND_TOKEN_INFO),\n                token,\n                receiver,\n                amount\n            ),\n            totalSupply,\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20 with token info. \n     * Returns structure `TransferErc20AndTokenInfoMessage`.\n     */\n    function decodeTransferErc20AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc20AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC20_AND_TOKEN_INFO,\n            \"Message type is not ERC20 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc20AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721Message(\n        address token,\n        address receiver,\n        uint256 tokenId\n    ) internal pure returns (bytes memory) {\n        TransferErc721Message memory message = TransferErc721Message(\n            BaseMessage(MessageType.TRANSFER_ERC721),\n            token,\n            receiver,\n            tokenId\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721. \n     * Returns structure `TransferErc721Message`.\n     */\n    function decodeTransferErc721Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc721Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC721, \"Message type is not ERC721 transfer\");\n        return abi.decode(data, (TransferErc721Message));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        Erc721TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc721AndTokenInfoMessage memory message = TransferErc721AndTokenInfoMessage(\n            TransferErc721Message(\n                BaseMessage(MessageType.TRANSFER_ERC721_AND_TOKEN_INFO),\n                token,\n                receiver,\n                tokenId\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721 with token info. \n     * Returns structure `TransferErc721AndTokenInfoMessage`.\n     */\n    function decodeTransferErc721AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc721AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_AND_TOKEN_INFO,\n            \"Message type is not ERC721 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc721AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721MessageWithMetadata(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        string memory tokenURI\n    ) internal pure returns (bytes memory) {\n        TransferErc721MessageWithMetadata memory message = TransferErc721MessageWithMetadata(\n            TransferErc721Message(\n                BaseMessage(MessageType.TRANSFER_ERC721_WITH_METADATA),\n                token,\n                receiver,\n                tokenId\n            ),\n            tokenURI\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721. \n     * Returns structure `TransferErc721MessageWithMetadata`.\n     */\n    function decodeTransferErc721MessageWithMetadata(\n        bytes calldata data\n    ) internal pure returns (TransferErc721MessageWithMetadata memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_WITH_METADATA,\n            \"Message type is not ERC721 transfer\"\n        );\n        return abi.decode(data, (TransferErc721MessageWithMetadata));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721WithMetadataAndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        string memory tokenURI,\n        Erc721TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc721WithMetadataAndTokenInfoMessage memory message = TransferErc721WithMetadataAndTokenInfoMessage(\n            TransferErc721MessageWithMetadata(\n                TransferErc721Message(\n                    BaseMessage(MessageType.TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO),\n                    token,\n                    receiver,\n                    tokenId\n                ),\n                tokenURI\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721 with token info. \n     * Returns structure `TransferErc721WithMetadataAndTokenInfoMessage`.\n     */\n    function decodeTransferErc721WithMetadataAndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc721WithMetadataAndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO,\n            \"Message type is not ERC721 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc721WithMetadataAndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for activating user on schain. \n     * Returns encoded message.\n     */\n    function encodeActivateUserMessage(address receiver) internal pure returns (bytes memory){\n        return _encodeUserStatusMessage(receiver, true);\n    }\n\n    /**\n     * @dev Encodes message for locking user on schain. \n     * Returns encoded message.\n     */\n    function encodeLockUserMessage(address receiver) internal pure returns (bytes memory){\n        return _encodeUserStatusMessage(receiver, false);\n    }\n\n    /**\n     * @dev Decodes message for user status. \n     * Returns structure UserStatusMessage.\n     */\n    function decodeUserStatusMessage(bytes calldata data) internal pure returns (UserStatusMessage memory) {\n        require(getMessageType(data) == MessageType.USER_STATUS, \"Message type is not User Status\");\n        return abi.decode(data, (UserStatusMessage));\n    }\n\n\n    /**\n     * @dev Encodes message for allowing interchain connection.\n     * Returns encoded message.\n     */\n    function encodeInterchainConnectionMessage(bool isAllowed) internal pure returns (bytes memory) {\n        InterchainConnectionMessage memory message = InterchainConnectionMessage(\n            BaseMessage(MessageType.INTERCHAIN_CONNECTION),\n            isAllowed\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for allowing interchain connection.\n     * Returns structure `InterchainConnectionMessage`.\n     */\n    function decodeInterchainConnectionMessage(bytes calldata data)\n        internal\n        pure\n        returns (InterchainConnectionMessage memory)\n    {\n        require(getMessageType(data) == MessageType.INTERCHAIN_CONNECTION, \"Message type is not Interchain connection\");\n        return abi.decode(data, (InterchainConnectionMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155Message(\n        address token,\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        TransferErc1155Message memory message = TransferErc1155Message(\n            BaseMessage(MessageType.TRANSFER_ERC1155),\n            token,\n            receiver,\n            id,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token.\n     * Returns structure `TransferErc1155Message`.\n     */\n    function decodeTransferErc1155Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC1155, \"Message type is not ERC1155 transfer\");\n        return abi.decode(data, (TransferErc1155Message));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 with token info.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 id,\n        uint256 amount,\n        Erc1155TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc1155AndTokenInfoMessage memory message = TransferErc1155AndTokenInfoMessage(\n            TransferErc1155Message(\n                BaseMessage(MessageType.TRANSFER_ERC1155_AND_TOKEN_INFO),\n                token,\n                receiver,\n                id,\n                amount\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 with token info.\n     * Returns structure `TransferErc1155AndTokenInfoMessage`.\n     */\n    function decodeTransferErc1155AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_AND_TOKEN_INFO,\n            \"Message type is not ERC1155AndTokenInfo transfer\"\n        );\n        return abi.decode(data, (TransferErc1155AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token in batches.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155BatchMessage(\n        address token,\n        address receiver,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal pure returns (bytes memory) {\n        TransferErc1155BatchMessage memory message = TransferErc1155BatchMessage(\n            BaseMessage(MessageType.TRANSFER_ERC1155_BATCH),\n            token,\n            receiver,\n            ids,\n            amounts\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token in batches.\n     * Returns structure `TransferErc1155BatchMessage`.\n     */\n    function decodeTransferErc1155BatchMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155BatchMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_BATCH,\n            \"Message type is not ERC1155Batch transfer\"\n        );\n        return abi.decode(data, (TransferErc1155BatchMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token in batches with token info.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155BatchAndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        Erc1155TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc1155BatchAndTokenInfoMessage memory message = TransferErc1155BatchAndTokenInfoMessage(\n            TransferErc1155BatchMessage(\n                BaseMessage(MessageType.TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO),\n                token,\n                receiver,\n                ids,\n                amounts\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token in batches with token info.\n     * Returns structure `TransferErc1155BatchAndTokenInfoMessage`.\n     */\n    function decodeTransferErc1155BatchAndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155BatchAndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO,\n            \"Message type is not ERC1155BatchAndTokenInfo transfer\"\n        );\n        return abi.decode(data, (TransferErc1155BatchAndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring user status on schain.\n     * Returns encoded message.\n     */\n    function _encodeUserStatusMessage(address receiver, bool isActive) private pure returns (bytes memory) {\n        UserStatusMessage memory message = UserStatusMessage(\n            BaseMessage(MessageType.USER_STATUS),\n            receiver,\n            isActive\n        );\n        return abi.encode(message);\n    }\n\n}"
             },
```

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/TokenManagerEth.json` & `ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/TokenManagerEth.json`

 * *Files identical despite different names*

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/TokenManagerEth.meta.json` & `ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/TokenManagerEth.meta.json`

 * *Files 1% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9995592948717948%*

 * *Differences: {"'input'": "{'sources': {'@skalenetwork/skale-manager-interfaces/IWallets.sol': {'content': '// "*

 * *            'SPDX-License-Identifier: AGPL-3.0-only\\n\\n/*\\n    IWallets - SKALE Manager '*

 * *            'Interfaces\\n    Copyright (C) 2021-Present SKALE Labs\\n    @author Dmytro '*

 * *            'Stebaeiv\\n\\n    SKALE Manager Interfaces is free software: you can redistribute it '*

 * *            'and/or modify\\n    it under the terms of the GNU Affero General Public License as '*

 * *            'published\\n    by […]*

```diff
@@ -218,22 +218,28 @@
             },
             "@skalenetwork/ima-interfaces/schain/tokens/IEthErc20.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   IEthErc20 - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\n\ninterface IEthErc20 {\n    function mint(address account, uint256 amount) external;\n    function forceBurn(address account, uint256 amount) external;\n    function initialize(address tokenManagerEthAddress) external;\n}"
             },
             "@skalenetwork/skale-manager-interfaces/IContractManager.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IContractManager.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IContractManager {\n    /**\n     * @dev Emitted when contract is upgraded.\n     */\n    event ContractUpgraded(string contractsName, address contractsAddress);\n\n    function initialize() external;\n    function setContractsAddress(string calldata contractsName, address newContractsAddress) external;\n    function contracts(bytes32 nameHash) external view returns (address);\n    function getDelegationPeriodManager() external view returns (address);\n    function getBounty() external view returns (address);\n    function getValidatorService() external view returns (address);\n    function getTimeHelpers() external view returns (address);\n    function getConstantsHolder() external view returns (address);\n    function getSkaleToken() external view returns (address);\n    function getTokenState() external view returns (address);\n    function getPunisher() external view returns (address);\n    function getContract(string calldata name) external view returns (address);\n}"
             },
+            "@skalenetwork/skale-manager-interfaces/INodes.sol": {
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    INodes.sol - SKALE Manager\n    Copyright (C) 2018-Present SKALE Labs\n    @author Artem Payvin\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"./utils/IRandom.sol\";\n\ninterface INodes {\n    // All Nodes states\n    enum NodeStatus {Active, Leaving, Left, In_Maintenance}\n\n    struct Node {\n        string name;\n        bytes4 ip;\n        bytes4 publicIP;\n        uint16 port;\n        bytes32[2] publicKey;\n        uint startBlock;\n        uint lastRewardDate;\n        uint finishTime;\n        NodeStatus status;\n        uint validatorId;\n    }\n\n    // struct to note which Nodes and which number of Nodes owned by user\n    struct CreatedNodes {\n        mapping (uint => bool) isNodeExist;\n        uint numberOfNodes;\n    }\n\n    struct SpaceManaging {\n        uint8 freeSpace;\n        uint indexInSpaceMap;\n    }\n\n    struct NodeCreationParams {\n        string name;\n        bytes4 ip;\n        bytes4 publicIp;\n        uint16 port;\n        bytes32[2] publicKey;\n        uint16 nonce;\n        string domainName;\n    }\n    \n    /**\n     * @dev Emitted when a node is created.\n     */\n    event NodeCreated(\n        uint nodeIndex,\n        address owner,\n        string name,\n        bytes4 ip,\n        bytes4 publicIP,\n        uint16 port,\n        uint16 nonce,\n        string domainName\n    );\n\n    /**\n     * @dev Emitted when a node completes a network exit.\n     */\n    event ExitCompleted(\n        uint nodeIndex\n    );\n\n    /**\n     * @dev Emitted when a node begins to exit from the network.\n     */\n    event ExitInitialized(\n        uint nodeIndex,\n        uint startLeavingPeriod\n    );\n\n    /**\n     * @dev Emitted when a node set to in compliant or compliant.\n     */\n    event IncompliantNode(\n        uint indexed nodeIndex,\n        bool status\n    );\n\n    /**\n     * @dev Emitted when a node set to in maintenance or from in maintenance.\n     */\n    event MaintenanceNode(\n        uint indexed nodeIndex,\n        bool status\n    );\n\n    /**\n     * @dev Emitted when a node status changed.\n     */\n    event IPChanged(\n        uint indexed nodeIndex,\n        bytes4 previousIP,\n        bytes4 newIP\n    );\n    \n    function removeSpaceFromNode(uint nodeIndex, uint8 space) external returns (bool);\n    function addSpaceToNode(uint nodeIndex, uint8 space) external;\n    function changeNodeLastRewardDate(uint nodeIndex) external;\n    function changeNodeFinishTime(uint nodeIndex, uint time) external;\n    function createNode(address from, NodeCreationParams calldata params) external;\n    function initExit(uint nodeIndex) external;\n    function completeExit(uint nodeIndex) external returns (bool);\n    function deleteNodeForValidator(uint validatorId, uint nodeIndex) external;\n    function checkPossibilityCreatingNode(address nodeAddress) external;\n    function checkPossibilityToMaintainNode(uint validatorId, uint nodeIndex) external returns (bool);\n    function setNodeInMaintenance(uint nodeIndex) external;\n    function removeNodeFromInMaintenance(uint nodeIndex) external;\n    function setNodeIncompliant(uint nodeIndex) external;\n    function setNodeCompliant(uint nodeIndex) external;\n    function setDomainName(uint nodeIndex, string memory domainName) external;\n    function makeNodeVisible(uint nodeIndex) external;\n    function makeNodeInvisible(uint nodeIndex) external;\n    function changeIP(uint nodeIndex, bytes4 newIP, bytes4 newPublicIP) external;\n    function numberOfActiveNodes() external view returns (uint);\n    function incompliant(uint nodeIndex) external view returns (bool);\n    function getRandomNodeWithFreeSpace(\n        uint8 freeSpace,\n        IRandom.RandomGenerator memory randomGenerator\n    )\n        external\n        view\n        returns (uint);\n    function isTimeForReward(uint nodeIndex) external view returns (bool);\n    function getNodeIP(uint nodeIndex) external view returns (bytes4);\n    function getNodeDomainName(uint nodeIndex) external view returns (string memory);\n    function getNodePort(uint nodeIndex) external view returns (uint16);\n    function getNodePublicKey(uint nodeIndex) external view returns (bytes32[2] memory);\n    function getNodeAddress(uint nodeIndex) external view returns (address);\n    function getNodeFinishTime(uint nodeIndex) external view returns (uint);\n    function isNodeLeft(uint nodeIndex) external view returns (bool);\n    function isNodeInMaintenance(uint nodeIndex) external view returns (bool);\n    function getNodeLastRewardDate(uint nodeIndex) external view returns (uint);\n    function getNodeNextRewardDate(uint nodeIndex) external view returns (uint);\n    function getNumberOfNodes() external view returns (uint);\n    function getNumberOnlineNodes() external view returns (uint);\n    function getActiveNodeIds() external view returns (uint[] memory activeNodeIds);\n    function getNodeStatus(uint nodeIndex) external view returns (NodeStatus);\n    function getValidatorNodeIndexes(uint validatorId) external view returns (uint[] memory);\n    function countNodesWithFreeSpace(uint8 freeSpace) external view returns (uint count);\n    function getValidatorId(uint nodeIndex) external view returns (uint);\n    function isNodeExist(address from, uint nodeIndex) external view returns (bool);\n    function isNodeActive(uint nodeIndex) external view returns (bool);\n    function isNodeLeaving(uint nodeIndex) external view returns (bool);\n}\n"
+            },
             "@skalenetwork/skale-manager-interfaces/ISchains.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchains.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchains {\n\n    struct SchainOption {\n        string name;\n        bytes value;\n    }\n    \n    /**\n     * @dev Emitted when an schain is created.\n     */\n    event SchainCreated(\n        string name,\n        address owner,\n        uint partOfNode,\n        uint lifetime,\n        uint numberOfNodes,\n        uint deposit,\n        uint16 nonce,\n        bytes32 schainHash\n    );\n\n    /**\n     * @dev Emitted when an schain is deleted.\n     */\n    event SchainDeleted(\n        address owner,\n        string name,\n        bytes32 indexed schainHash\n    );\n\n    /**\n     * @dev Emitted when a node in an schain is rotated.\n     */\n    event NodeRotated(\n        bytes32 schainHash,\n        uint oldNode,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a node is added to an schain.\n     */\n    event NodeAdded(\n        bytes32 schainHash,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a group of nodes is created for an schain.\n     */\n    event SchainNodes(\n        string name,\n        bytes32 schainHash,\n        uint[] nodesInGroup\n    );\n\n    function addSchain(address from, uint deposit, bytes calldata data) external;\n    function addSchainByFoundation(\n        uint lifetime,\n        uint8 typeOfSchain,\n        uint16 nonce,\n        string calldata name,\n        address schainOwner,\n        address schainOriginator,\n        SchainOption[] calldata options\n    )\n        external\n        payable;\n    function deleteSchain(address from, string calldata name) external;\n    function deleteSchainByRoot(string calldata name) external;\n    function restartSchainCreation(string calldata name) external;\n    function verifySchainSignature(\n        uint256 signA,\n        uint256 signB,\n        bytes32 hash,\n        uint256 counter,\n        uint256 hashA,\n        uint256 hashB,\n        string calldata schainName\n    )\n        external\n        view\n        returns (bool);\n    function getSchainPrice(uint typeOfSchain, uint lifetime) external view returns (uint);\n    function getOption(bytes32 schainHash, string calldata optionName) external view returns (bytes memory);\n    function getOptions(bytes32 schainHash) external view returns (SchainOption[] memory);\n}"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchains.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchains {\n\n    struct SchainOption {\n        string name;\n        bytes value;\n    }\n    \n    /**\n     * @dev Emitted when an schain is created.\n     */\n    event SchainCreated(\n        string name,\n        address owner,\n        uint partOfNode,\n        uint lifetime,\n        uint numberOfNodes,\n        uint deposit,\n        uint16 nonce,\n        bytes32 schainHash\n    );\n\n    /**\n     * @dev Emitted when an schain is deleted.\n     */\n    event SchainDeleted(\n        address owner,\n        string name,\n        bytes32 indexed schainHash\n    );\n\n    /**\n     * @dev Emitted when a node in an schain is rotated.\n     */\n    event NodeRotated(\n        bytes32 schainHash,\n        uint oldNode,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a node is added to an schain.\n     */\n    event NodeAdded(\n        bytes32 schainHash,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a group of nodes is created for an schain.\n     */\n    event SchainNodes(\n        string name,\n        bytes32 schainHash,\n        uint[] nodesInGroup\n    );\n\n    function addSchain(address from, uint deposit, bytes calldata data) external;\n    function addSchainByFoundation(\n        uint lifetime,\n        uint8 typeOfSchain,\n        uint16 nonce,\n        string calldata name,\n        address schainOwner,\n        address schainOriginator,\n        SchainOption[] calldata options\n    )\n        external\n        payable;\n    function deleteSchain(address from, string calldata name) external;\n    function deleteSchainByRoot(string calldata name) external;\n    function restartSchainCreation(string calldata name) external;\n    function verifySchainSignature(\n        uint256 signA,\n        uint256 signB,\n        bytes32 hash,\n        uint256 counter,\n        uint256 hashA,\n        uint256 hashB,\n        string calldata schainName\n    )\n        external\n        view\n        returns (bool);\n    function getSchainPrice(uint typeOfSchain, uint lifetime) external view returns (uint);\n    function getOption(bytes32 schainHash, string calldata optionName) external view returns (bytes memory);\n    function getOptions(bytes32 schainHash) external view returns (SchainOption[] memory);\n}\n"
             },
             "@skalenetwork/skale-manager-interfaces/ISchainsInternal.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchainsInternal - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchainsInternal {\n    struct Schain {\n        string name;\n        address owner;\n        uint indexInOwnerList;\n        uint8 partOfNode;\n        uint lifetime;\n        uint startDate;\n        uint startBlock;\n        uint deposit;\n        uint64 index;\n        uint generation;\n        address originator;\n    }\n\n    struct SchainType {\n        uint8 partOfNode;\n        uint numberOfNodes;\n    }\n\n    /**\n     * @dev Emitted when schain type added.\n     */\n    event SchainTypeAdded(uint indexed schainType, uint partOfNode, uint numberOfNodes);\n\n    /**\n     * @dev Emitted when schain type removed.\n     */\n    event SchainTypeRemoved(uint indexed schainType);\n\n    function initializeSchain(\n        string calldata name,\n        address from,\n        address originator,\n        uint lifetime,\n        uint deposit) external;\n    function createGroupForSchain(\n        bytes32 schainHash,\n        uint numberOfNodes,\n        uint8 partOfNode\n    )\n        external\n        returns (uint[] memory);\n    function changeLifetime(bytes32 schainHash, uint lifetime, uint deposit) external;\n    function removeSchain(bytes32 schainHash, address from) external;\n    function removeNodeFromSchain(uint nodeIndex, bytes32 schainHash) external;\n    function deleteGroup(bytes32 schainHash) external;\n    function setException(bytes32 schainHash, uint nodeIndex) external;\n    function setNodeInGroup(bytes32 schainHash, uint nodeIndex) external;\n    function removeHolesForSchain(bytes32 schainHash) external;\n    function addSchainType(uint8 partOfNode, uint numberOfNodes) external;\n    function removeSchainType(uint typeOfSchain) external;\n    function setNumberOfSchainTypes(uint newNumberOfSchainTypes) external;\n    function removeNodeFromAllExceptionSchains(uint nodeIndex) external;\n    function removeAllNodesFromSchainExceptions(bytes32 schainHash) external;\n    function makeSchainNodesInvisible(bytes32 schainHash) external;\n    function makeSchainNodesVisible(bytes32 schainHash) external;\n    function newGeneration() external;\n    function addSchainForNode(uint nodeIndex, bytes32 schainHash) external;\n    function removeSchainForNode(uint nodeIndex, uint schainIndex) external;\n    function removeNodeFromExceptions(bytes32 schainHash, uint nodeIndex) external;\n    function isSchainActive(bytes32 schainHash) external view returns (bool);\n    function schainsAtSystem(uint index) external view returns (bytes32);\n    function numberOfSchains() external view returns (uint64);\n    function getSchains() external view returns (bytes32[] memory);\n    function getSchainsPartOfNode(bytes32 schainHash) external view returns (uint8);\n    function getSchainListSize(address from) external view returns (uint);\n    function getSchainHashesByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainIdsByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainHashesForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainIdsForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainOwner(bytes32 schainHash) external view returns (address);\n    function getSchainOriginator(bytes32 schainHash) external view returns (address);\n    function isSchainNameAvailable(string calldata name) external view returns (bool);\n    function isTimeExpired(bytes32 schainHash) external view returns (bool);\n    function isOwnerAddress(address from, bytes32 schainId) external view returns (bool);\n    function getSchainName(bytes32 schainHash) external view returns (string memory);\n    function getActiveSchain(uint nodeIndex) external view returns (bytes32);\n    function getActiveSchains(uint nodeIndex) external view returns (bytes32[] memory activeSchains);\n    function getNumberOfNodesInGroup(bytes32 schainHash) external view returns (uint);\n    function getNodesInGroup(bytes32 schainHash) external view returns (uint[] memory);\n    function isNodeAddressesInGroup(bytes32 schainId, address sender) external view returns (bool);\n    function getNodeIndexInGroup(bytes32 schainHash, uint nodeId) external view returns (uint);\n    function isAnyFreeNode(bytes32 schainHash) external view returns (bool);\n    function checkException(bytes32 schainHash, uint nodeIndex) external view returns (bool);\n    function checkHoleForSchain(bytes32 schainHash, uint indexOfNode) external view returns (bool);\n    function checkSchainOnNode(uint nodeIndex, bytes32 schainHash) external view returns (bool);\n    function getSchainType(uint typeOfSchain) external view returns(uint8, uint);\n    function getGeneration(bytes32 schainHash) external view returns (uint);\n    function isSchainExist(bytes32 schainHash) external view returns (bool);\n}"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchainsInternal - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"./INodes.sol\";\n\ninterface ISchainsInternal {\n    struct Schain {\n        string name;\n        address owner;\n        uint indexInOwnerList;\n        uint8 partOfNode;\n        uint lifetime;\n        uint startDate;\n        uint startBlock;\n        uint deposit;\n        uint64 index;\n        uint generation;\n        address originator;\n    }\n\n    struct SchainType {\n        uint8 partOfNode;\n        uint numberOfNodes;\n    }\n\n    /**\n     * @dev Emitted when schain type added.\n     */\n    event SchainTypeAdded(uint indexed schainType, uint partOfNode, uint numberOfNodes);\n\n    /**\n     * @dev Emitted when schain type removed.\n     */\n    event SchainTypeRemoved(uint indexed schainType);\n\n    function initializeSchain(\n        string calldata name,\n        address from,\n        address originator,\n        uint lifetime,\n        uint deposit) external;\n    function createGroupForSchain(\n        bytes32 schainHash,\n        uint numberOfNodes,\n        uint8 partOfNode\n    )\n        external\n        returns (uint[] memory);\n    function changeLifetime(bytes32 schainHash, uint lifetime, uint deposit) external;\n    function removeSchain(bytes32 schainHash, address from) external;\n    function removeNodeFromSchain(uint nodeIndex, bytes32 schainHash) external;\n    function deleteGroup(bytes32 schainHash) external;\n    function setException(bytes32 schainHash, uint nodeIndex) external;\n    function setNodeInGroup(bytes32 schainHash, uint nodeIndex) external;\n    function removeHolesForSchain(bytes32 schainHash) external;\n    function addSchainType(uint8 partOfNode, uint numberOfNodes) external;\n    function removeSchainType(uint typeOfSchain) external;\n    function setNumberOfSchainTypes(uint newNumberOfSchainTypes) external;\n    function removeNodeFromAllExceptionSchains(uint nodeIndex) external;\n    function removeAllNodesFromSchainExceptions(bytes32 schainHash) external;\n    function makeSchainNodesInvisible(bytes32 schainHash) external;\n    function makeSchainNodesVisible(bytes32 schainHash) external;\n    function newGeneration() external;\n    function addSchainForNode(INodes nodes,uint nodeIndex, bytes32 schainHash) external;\n    function removeSchainForNode(uint nodeIndex, uint schainIndex) external;\n    function removeNodeFromExceptions(bytes32 schainHash, uint nodeIndex) external;\n    function isSchainActive(bytes32 schainHash) external view returns (bool);\n    function schainsAtSystem(uint index) external view returns (bytes32);\n    function numberOfSchains() external view returns (uint64);\n    function getSchains() external view returns (bytes32[] memory);\n    function getSchainsPartOfNode(bytes32 schainHash) external view returns (uint8);\n    function getSchainListSize(address from) external view returns (uint);\n    function getSchainHashesByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainHashesForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainOwner(bytes32 schainHash) external view returns (address);\n    function getSchainOriginator(bytes32 schainHash) external view returns (address);\n    function isSchainNameAvailable(string calldata name) external view returns (bool);\n    function isTimeExpired(bytes32 schainHash) external view returns (bool);\n    function isOwnerAddress(address from, bytes32 schainHash) external view returns (bool);\n    function getSchainName(bytes32 schainHash) external view returns (string memory);\n    function getActiveSchain(uint nodeIndex) external view returns (bytes32);\n    function getActiveSchains(uint nodeIndex) external view returns (bytes32[] memory activeSchains);\n    function getNumberOfNodesInGroup(bytes32 schainHash) external view returns (uint);\n    function getNodesInGroup(bytes32 schainHash) external view returns (uint[] memory);\n    function isNodeAddressesInGroup(bytes32 schainHash, address sender) external view returns (bool);\n    function getNodeIndexInGroup(bytes32 schainHash, uint nodeHash) external view returns (uint);\n    function isAnyFreeNode(bytes32 schainHash) external view returns (bool);\n    function checkException(bytes32 schainHash, uint nodeIndex) external view returns (bool);\n    function checkHoleForSchain(bytes32 schainHash, uint indexOfNode) external view returns (bool);\n    function checkSchainOnNode(uint nodeIndex, bytes32 schainHash) external view returns (bool);\n    function getSchainType(uint typeOfSchain) external view returns(uint8, uint);\n    function getGeneration(bytes32 schainHash) external view returns (uint);\n    function isSchainExist(bytes32 schainHash) external view returns (bool);\n}"
             },
             "@skalenetwork/skale-manager-interfaces/IWallets.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IWallets - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IWallets {\n    /**\n     * @dev Emitted when the validator wallet was funded\n     */\n    event ValidatorWalletRecharged(address sponsor, uint amount, uint validatorId);\n\n    /**\n     * @dev Emitted when the schain wallet was funded\n     */\n    event SchainWalletRecharged(address sponsor, uint amount, bytes32 schainHash);\n\n    /**\n     * @dev Emitted when the node received a refund from validator to its wallet\n     */\n    event NodeRefundedByValidator(address node, uint validatorId, uint amount);\n\n    /**\n     * @dev Emitted when the node received a refund from schain to its wallet\n     */\n    event NodeRefundedBySchain(address node, bytes32 schainHash, uint amount);\n\n    /**\n     * @dev Emitted when the validator withdrawn funds from validator wallet\n     */\n    event WithdrawFromValidatorWallet(uint indexed validatorId, uint amount);\n\n    /**\n     * @dev Emitted when the schain owner withdrawn funds from schain wallet\n     */\n    event WithdrawFromSchainWallet(bytes32 indexed schainHash, uint amount);\n\n    receive() external payable;\n    function refundGasByValidator(uint validatorId, address payable spender, uint spentGas) external;\n    function refundGasByValidatorToSchain(uint validatorId, bytes32 schainHash) external;\n    function refundGasBySchain(bytes32 schainId, address payable spender, uint spentGas, bool isDebt) external;\n    function withdrawFundsFromSchainWallet(address payable schainOwner, bytes32 schainHash) external;\n    function withdrawFundsFromValidatorWallet(uint amount) external;\n    function rechargeValidatorWallet(uint validatorId) external payable;\n    function rechargeSchainWallet(bytes32 schainId) external payable;\n    function getSchainBalance(bytes32 schainHash) external view returns (uint);\n    function getValidatorBalance(uint validatorId) external view returns (uint);\n}\n"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IWallets - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IWallets {\n    receive() external payable;\n    function refundGasByValidator(uint validatorId, address payable spender, uint gasLimit) external;\n    function refundGasByValidatorToSchain(uint validatorId, bytes32 schainHash) external;\n    function refundGasBySchain(bytes32 schainId, address payable spender, uint spentGas, bool isDebt) external;\n    function withdrawFundsFromSchainWallet(address payable schainOwner, bytes32 schainHash) external;\n    function withdrawFundsFromValidatorWallet(uint amount) external;\n    function rechargeValidatorWallet(uint validatorId) external payable;\n    function rechargeSchainWallet(bytes32 schainId) external payable;\n    function getSchainBalance(bytes32 schainHash) external view returns (uint);\n    function getValidatorBalance(uint validatorId) external view returns (uint);\n}\n"
+            },
+            "@skalenetwork/skale-manager-interfaces/utils/IRandom.sol": {
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IRandom.sol - SKALE Manager Interfaces\n    Copyright (C) 2022-Present SKALE Labs\n    @author Dmytro Stebaiev\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\n\ninterface IRandom {\n    struct RandomGenerator {\n        uint seed;\n    }\n}"
             },
             "contracts/MessageProxy.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   MessageProxy.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/IGasReimbursable.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageProxy.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageReceiver.sol\";\n\n\n/**\n * @title MessageProxy\n * @dev Abstract contract for MessageProxyForMainnet and MessageProxyForSchain.\n */\nabstract contract MessageProxy is AccessControlEnumerableUpgradeable, IMessageProxy {\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    /**\n     * @dev Structure that stores counters for outgoing and incoming messages.\n     */\n    struct ConnectedChainInfo {\n        // message counters start with 0\n        uint256 incomingMessageCounter;\n        uint256 outgoingMessageCounter;\n        bool inited;\n        uint256 lastOutgoingMessageBlockId;\n    }\n\n    bytes32 public constant MAINNET_HASH = keccak256(abi.encodePacked(\"Mainnet\"));\n    bytes32 public constant CHAIN_CONNECTOR_ROLE = keccak256(\"CHAIN_CONNECTOR_ROLE\");\n    bytes32 public constant EXTRA_CONTRACT_REGISTRAR_ROLE = keccak256(\"EXTRA_CONTRACT_REGISTRAR_ROLE\");\n    bytes32 public constant CONSTANT_SETTER_ROLE = keccak256(\"CONSTANT_SETTER_ROLE\");\n    uint256 public constant MESSAGES_LENGTH = 10;\n    uint256 public constant REVERT_REASON_LENGTH = 64;\n\n    //   schainHash => ConnectedChainInfo\n    mapping(bytes32 => ConnectedChainInfo) public connectedChains;\n    //   schainHash => contract address => allowed\n    mapping(bytes32 => mapping(address => bool)) private _deprecatedRegistryContracts;\n\n    uint256 public gasLimit;\n\n    /**\n     * @dev Emitted for every outgoing message to schain.\n     */\n    event OutgoingMessage(\n        bytes32 indexed dstChainHash,\n        uint256 indexed msgCounter,\n        address indexed srcContract,\n        address dstContract,\n        bytes data\n    );\n\n    /**\n     * @dev Emitted when function `postMessage` returns revert.\n     *  Used to prevent stuck loop inside function `postIncomingMessages`.\n     */\n    event PostMessageError(\n        uint256 indexed msgCounter,\n        bytes message\n    );\n\n    /**\n     * @dev Emitted when gas limit per one call of `postMessage` was changed.\n     */\n    event GasLimitWasChanged(\n        uint256 oldValue,\n        uint256 newValue\n    );\n\n    /**\n     * @dev Emitted when the version was updated\n     */\n    event VersionUpdated(string oldVersion, string newVersion);\n\n    /**\n     * @dev Emitted when extra contract was added.\n     */\n    event ExtraContractRegistered(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Emitted when extra contract was removed.\n     */\n    event ExtraContractRemoved(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Emitted when referenced to previous outgoing message.\n     */\n    event PreviousMessageReference (\n        uint256 currentMessage,\n        uint256 previousOutgoingMessageBlockId\n    );\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CHAIN_CONNECTOR_ROLE}.\n     */\n    modifier onlyChainConnector() {\n        require(hasRole(CHAIN_CONNECTOR_ROLE, msg.sender), \"CHAIN_CONNECTOR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {EXTRA_CONTRACT_REGISTRAR_ROLE}.\n     */\n    modifier onlyExtraContractRegistrar() {\n        require(hasRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender), \"EXTRA_CONTRACT_REGISTRAR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CONSTANT_SETTER_ROLE}.\n     */\n    modifier onlyConstantSetter() {\n        require(hasRole(CONSTANT_SETTER_ROLE, msg.sender), \"Not enough permissions to set constant\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {DEFAULT_ADMIN_ROLE}.\n     */\n    modifier onlyOwner() {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"DEFAULT_ADMIN_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Sets gasLimit to a new value.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CONSTANT_SETTER_ROLE.\n     */\n    function setNewGasLimit(uint256 newGasLimit) external override onlyConstantSetter {\n        emit GasLimitWasChanged(gasLimit, newGasLimit);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Virtual function for `postIncomingMessages`.\n     */\n    function postIncomingMessages(\n        string calldata fromSchainName,\n        uint256 startingCounter,\n        Message[] calldata messages,\n        Signature calldata sign\n    )\n        external\n        virtual\n        override;\n\n    /**\n     * @dev Allows `msg.sender` to register extra contract for all schains\n     * for being able to transfer messages from custom contracts.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     * - Passed address should be contract.\n     * - Extra contract must not be registered.\n     */\n    function registerExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is already registered\");\n        _getRegistryContracts()[bytes32(0)].add(extraContract);\n        emit ExtraContractRegistered(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Allows `msg.sender` to remove extra contract for all schains.\n     * Extra contract will no longer be able to send messages through MessageProxy.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     */\n    function removeExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[bytes32(0)].remove(extraContract);\n        emit ExtraContractRemoved(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Should return length of contract registered by schainHash.\n     */\n    function getContractRegisteredLength(bytes32 schainHash) external view override returns (uint256) {\n        return _getRegistryContracts()[schainHash].length();\n    }\n\n    /**\n     * @dev Should return a range of contracts registered by schainHash.\n     *\n     * Requirements:\n     * range should be less or equal 10 contracts\n     */\n    function getContractRegisteredRange(\n        bytes32 schainHash,\n        uint256 from,\n        uint256 to\n    )\n        external\n        view\n        override\n        returns (address[] memory contractsInRange)\n    {\n        require(\n            from < to && to - from <= 10 && to <= _getRegistryContracts()[schainHash].length(),\n            \"Range is incorrect\"\n        );\n        contractsInRange = new address[](to - from);\n        for (uint256 i = from; i < to; i++) {\n            contractsInRange[i - from] = _getRegistryContracts()[schainHash].at(i);\n        }\n    }\n\n    /**\n     * @dev Returns number of outgoing messages.\n     *\n     * Requirements:\n     *\n     * - Target schain  must be initialized.\n     */\n    function getOutgoingMessagesCounter(string calldata targetSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 dstChainHash = keccak256(abi.encodePacked(targetSchainName));\n        require(connectedChains[dstChainHash].inited, \"Destination chain is not initialized\");\n        return connectedChains[dstChainHash].outgoingMessageCounter;\n    }\n\n\n    /**\n     * @dev Should return block number of the last message transferred to schain\n     */\n    function getLastOutgoingMessageBlockId(string memory targetSchainName) external view override returns (uint) {\n        bytes32 dstChainHash = keccak256(abi.encodePacked(targetSchainName));\n        require(connectedChains[dstChainHash].inited, \"Destination chain is not initialized\");\n        return connectedChains[dstChainHash].lastOutgoingMessageBlockId;\n    }\n\n    /**\n     * @dev Returns number of incoming messages.\n     *\n     * Requirements:\n     *\n     * - Source schain must be initialized.\n     */\n    function getIncomingMessagesCounter(string calldata fromSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 srcChainHash = keccak256(abi.encodePacked(fromSchainName));\n        require(connectedChains[srcChainHash].inited, \"Source chain is not initialized\");\n        return connectedChains[srcChainHash].incomingMessageCounter;\n    }\n\n    function initializeMessageProxy(uint newGasLimit) public initializer {\n        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(CHAIN_CONNECTOR_ROLE, msg.sender);\n        _setupRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender);\n        _setupRole(CONSTANT_SETTER_ROLE, msg.sender);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Posts message from this contract to `targetChainHash` MessageProxy contract.\n     * This is called by a smart contract to make a cross-chain call.\n     *\n     * Emits an {OutgoingMessage} event.\n     *\n     * Requirements:\n     *\n     * - Target chain must be initialized.\n     * - Target chain must be registered as external contract.\n     */\n    function postOutgoingMessage(\n        bytes32 targetChainHash,\n        address targetContract,\n        bytes memory data\n    )\n        public\n        override\n        virtual\n    {\n        require(connectedChains[targetChainHash].inited, \"Destination chain is not initialized\");\n        _authorizeOutgoingMessageSender(targetChainHash);\n\n        uint outgoingMessageCounter = connectedChains[targetChainHash].outgoingMessageCounter;\n        emit OutgoingMessage(\n            targetChainHash,\n            outgoingMessageCounter,\n            msg.sender,\n            targetContract,\n            data\n        );\n        emit PreviousMessageReference(\n            outgoingMessageCounter,\n            connectedChains[targetChainHash].lastOutgoingMessageBlockId\n        );\n        connectedChains[targetChainHash].outgoingMessageCounter++;\n        connectedChains[targetChainHash].lastOutgoingMessageBlockId = block.number;\n    }\n\n    /**\n     * @dev Allows CHAIN_CONNECTOR_ROLE to remove connected chain from this contract.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CHAIN_CONNECTOR_ROLE.\n     * - `schainName` must be initialized.\n     */\n    function removeConnectedChain(string memory schainName) public virtual override onlyChainConnector {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(connectedChains[schainHash].inited, \"Chain is not initialized\");\n        delete connectedChains[schainHash];\n    }\n\n    /**\n     * @dev Checks whether chain is currently connected.\n     */\n    function isConnectedChain(\n        string memory schainName\n    )\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return connectedChains[keccak256(abi.encodePacked(schainName))].inited;\n    }\n\n    /**\n     * @dev Checks whether contract is currently registered as extra contract.\n     */\n    function isContractRegistered(\n        bytes32 schainHash,\n        address contractAddress\n    )\n        public\n        view\n        override\n        returns (bool)\n    {\n        return _getRegistryContracts()[schainHash].contains(contractAddress);\n    }\n\n    /**\n     * @dev Allows MessageProxy to register extra contract for being able to transfer messages from custom contracts.\n     *\n     * Requirements:\n     *\n     * - Extra contract address must be contract.\n     * - Extra contract must not be registered.\n     * - Extra contract must not be registered for all chains.\n     */\n    function _registerExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {\n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is already registered\");\n        require(\n            !_getRegistryContracts()[bytes32(0)].contains(extraContract),\n            \"Extra contract is already registered for all chains\"\n        );\n\n        _getRegistryContracts()[chainHash].add(extraContract);\n        emit ExtraContractRegistered(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to remove extra contract,\n     * thus `extraContract` will no longer be available to transfer messages from mainnet to schain.\n     *\n     * Requirements:\n     *\n     * - Extra contract must be registered.\n     */\n    function _removeExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {\n        require(_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[chainHash].remove(extraContract);\n        emit ExtraContractRemoved(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to connect schain with MessageProxyOnMainnet for transferring messages.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CHAIN_CONNECTOR_ROLE.\n     * - SKALE chain must not be connected.\n     */\n    function _addConnectedChain(bytes32 schainHash) internal onlyChainConnector {\n        require(!connectedChains[schainHash].inited,\"Chain is already connected\");\n        connectedChains[schainHash] = ConnectedChainInfo({\n            incomingMessageCounter: 0,\n            outgoingMessageCounter: 0,\n            inited: true,\n            lastOutgoingMessageBlockId: 0\n        });\n    }\n\n    /**\n     * @dev Allows MessageProxy to send messages from schain to mainnet.\n     * Destination contract must implement `postMessage` method.\n     */\n    function _callReceiverContract(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n    {\n        if (!message.destinationContract.isContract()) {\n            emit PostMessageError(\n                counter,\n                \"Destination contract is not a contract\"\n            );\n            return;\n        }\n        try IMessageReceiver(message.destinationContract).postMessage{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) {\n            return;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                _getSlice(bytes(reason), REVERT_REASON_LENGTH)\n            );\n        } catch Panic(uint errorCode) {\n               emit PostMessageError(\n                counter,\n                abi.encodePacked(errorCode)\n            );\n        } catch (bytes memory revertData) {\n            emit PostMessageError(\n                counter,\n                _getSlice(revertData, REVERT_REASON_LENGTH)\n            );\n        }\n    }\n\n    /**\n     * @dev Returns receiver of message.\n     */\n    function _getGasPayer(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n        returns (address)\n    {\n        try IGasReimbursable(message.destinationContract).gasPayer{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) returns (address receiver) {\n            return receiver;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                _getSlice(bytes(reason), REVERT_REASON_LENGTH)\n            );\n            return address(0);\n        } catch Panic(uint errorCode) {\n               emit PostMessageError(\n                counter,\n                abi.encodePacked(errorCode)\n            );\n            return address(0);\n        } catch (bytes memory revertData) {\n            emit PostMessageError(\n                counter,\n                _getSlice(revertData, REVERT_REASON_LENGTH)\n            );\n            return address(0);\n        }\n    }\n\n    /**\n     * @dev Checks whether msg.sender is registered as custom extra contract.\n     */\n    function _authorizeOutgoingMessageSender(bytes32 targetChainHash) internal view virtual {\n        require(\n            isContractRegistered(bytes32(0), msg.sender) || isContractRegistered(targetChainHash, msg.sender),\n            \"Sender contract is not registered\"\n        );\n    }\n\n    /**\n     * @dev Returns list of registered custom extra contracts.\n     */\n    function _getRegistryContracts()\n        internal\n        view\n        virtual\n        returns (mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) storage);\n\n    /**\n     * @dev Returns hash of message array.\n     */\n    function _hashedArray(\n        Message[] calldata messages,\n        uint256 startingCounter,\n        string calldata fromChainName\n    )\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32 sourceHash = keccak256(abi.encodePacked(fromChainName));\n        bytes32 hash = keccak256(abi.encodePacked(sourceHash, bytes32(startingCounter)));\n        for (uint256 i = 0; i < messages.length; i++) {\n            hash = keccak256(\n                abi.encodePacked(\n                    abi.encode(\n                        hash,\n                        messages[i].sender,\n                        messages[i].destinationContract\n                    ),\n                    messages[i].data\n                )\n            );\n        }\n        return hash;\n    }\n\n    function _getSlice(bytes memory text, uint end) private pure returns (bytes memory) {\n        uint slicedEnd = end < text.length ? end : text.length;\n        bytes memory sliced = new bytes(slicedEnd);\n        for(uint i = 0; i < slicedEnd; i++){\n            sliced[i] = text[i];\n        }\n        return sliced;\n    }\n}\n"
             },
             "contracts/Messages.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   Messages.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\n\n/**\n * @title Messages\n * @dev Library for encoding and decoding messages\n * for transferring from Mainnet to Schain and vice versa.\n */\nlibrary Messages {\n\n    /**\n     * @dev Enumerator that describes all supported message types.\n     */\n    enum MessageType {\n        EMPTY,\n        TRANSFER_ETH,\n        TRANSFER_ERC20,\n        TRANSFER_ERC20_AND_TOTAL_SUPPLY,\n        TRANSFER_ERC20_AND_TOKEN_INFO,\n        TRANSFER_ERC721,\n        TRANSFER_ERC721_AND_TOKEN_INFO,\n        USER_STATUS,\n        INTERCHAIN_CONNECTION,\n        TRANSFER_ERC1155,\n        TRANSFER_ERC1155_AND_TOKEN_INFO,\n        TRANSFER_ERC1155_BATCH,\n        TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO,\n        TRANSFER_ERC721_WITH_METADATA,\n        TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO\n    }\n\n    /**\n     * @dev Structure for base message.\n     */\n    struct BaseMessage {\n        MessageType messageType;\n    }\n\n    /**\n     * @dev Structure for describing ETH.\n     */\n    struct TransferEthMessage {\n        BaseMessage message;\n        address receiver;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for user status.\n     */\n    struct UserStatusMessage {\n        BaseMessage message;\n        address receiver;\n        bool isActive;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 token.\n     */\n    struct TransferErc20Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC20 token.\n     */\n    struct Erc20TokenInfo {\n        string name;\n        uint8 decimals;\n        string symbol;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token supply.\n     */\n    struct TransferErc20AndTotalSupplyMessage {\n        TransferErc20Message baseErc20transfer;\n        uint256 totalSupply;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token info.\n     */\n    struct TransferErc20AndTokenInfoMessage {\n        TransferErc20Message baseErc20transfer;\n        uint256 totalSupply;\n        Erc20TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing base ERC721.\n     */\n    struct TransferErc721Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 tokenId;\n    }\n\n    /**\n     * @dev Structure for describing base ERC721 with metadata.\n     */\n    struct TransferErc721MessageWithMetadata {\n        TransferErc721Message erc721message;\n        string tokenURI;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token info.\n     */\n    struct Erc721TokenInfo {\n        string name;\n        string symbol;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC721 token.\n     */\n    struct TransferErc721AndTokenInfoMessage {\n        TransferErc721Message baseErc721transfer;\n        Erc721TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC721 token with metadata.\n     */\n    struct TransferErc721WithMetadataAndTokenInfoMessage {\n        TransferErc721MessageWithMetadata baseErc721transferWithMetadata;\n        Erc721TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing whether interchain connection is allowed.\n     */\n    struct InterchainConnectionMessage {\n        BaseMessage message;\n        bool isAllowed;\n    }\n\n    /**\n     * @dev Structure for describing whether interchain connection is allowed.\n     */\n    struct TransferErc1155Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 id;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for describing ERC1155 token in batches.\n     */\n    struct TransferErc1155BatchMessage {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256[] ids;\n        uint256[] amounts;\n    }\n\n    /**\n     * @dev Structure for describing ERC1155 token info.\n     */\n    struct Erc1155TokenInfo {\n        string uri;\n    }\n\n    /**\n     * @dev Structure for describing message for transferring ERC1155 token with info.\n     */\n    struct TransferErc1155AndTokenInfoMessage {\n        TransferErc1155Message baseErc1155transfer;\n        Erc1155TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing message for transferring ERC1155 token in batches with info.\n     */\n    struct TransferErc1155BatchAndTokenInfoMessage {\n        TransferErc1155BatchMessage baseErc1155Batchtransfer;\n        Erc1155TokenInfo tokenInfo;\n    }\n\n\n    /**\n     * @dev Returns type of message for encoded data.\n     */\n    function getMessageType(bytes calldata data) internal pure returns (MessageType) {\n        uint256 firstWord = abi.decode(data, (uint256));\n        if (firstWord % 32 == 0) {\n            return getMessageType(data[firstWord:]);\n        } else {\n            return abi.decode(data, (Messages.MessageType));\n        }\n    }\n\n    /**\n     * @dev Encodes message for transferring ETH. Returns encoded message.\n     */\n    function encodeTransferEthMessage(address receiver, uint256 amount) internal pure returns (bytes memory) {\n        TransferEthMessage memory message = TransferEthMessage(\n            BaseMessage(MessageType.TRANSFER_ETH),\n            receiver,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ETH. Returns structure `TransferEthMessage`.\n     */\n    function decodeTransferEthMessage(\n        bytes calldata data\n    ) internal pure returns (TransferEthMessage memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ETH, \"Message type is not ETH transfer\");\n        return abi.decode(data, (TransferEthMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ETH. Returns encoded message.\n     */\n    function encodeTransferErc20Message(\n        address token,\n        address receiver,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        TransferErc20Message memory message = TransferErc20Message(\n            BaseMessage(MessageType.TRANSFER_ERC20),\n            token,\n            receiver,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC20 with total supply. Returns encoded message.\n     */\n    function encodeTransferErc20AndTotalSupplyMessage(\n        address token,\n        address receiver,\n        uint256 amount,\n        uint256 totalSupply\n    ) internal pure returns (bytes memory) {\n        TransferErc20AndTotalSupplyMessage memory message = TransferErc20AndTotalSupplyMessage(\n            TransferErc20Message(\n                BaseMessage(MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY),\n                token,\n                receiver,\n                amount\n            ),\n            totalSupply\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20. Returns structure `TransferErc20Message`.\n     */\n    function decodeTransferErc20Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc20Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC20, \"Message type is not ERC20 transfer\");\n        return abi.decode(data, (TransferErc20Message));\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20 with total supply. \n     * Returns structure `TransferErc20AndTotalSupplyMessage`.\n     */\n    function decodeTransferErc20AndTotalSupplyMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc20AndTotalSupplyMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY,\n            \"Message type is not ERC20 transfer and total supply\"\n        );\n        return abi.decode(data, (TransferErc20AndTotalSupplyMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC20 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc20AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 amount,\n        uint256 totalSupply,\n        Erc20TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc20AndTokenInfoMessage memory message = TransferErc20AndTokenInfoMessage(\n            TransferErc20Message(\n                BaseMessage(MessageType.TRANSFER_ERC20_AND_TOKEN_INFO),\n                token,\n                receiver,\n                amount\n            ),\n            totalSupply,\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20 with token info. \n     * Returns structure `TransferErc20AndTokenInfoMessage`.\n     */\n    function decodeTransferErc20AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc20AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC20_AND_TOKEN_INFO,\n            \"Message type is not ERC20 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc20AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721Message(\n        address token,\n        address receiver,\n        uint256 tokenId\n    ) internal pure returns (bytes memory) {\n        TransferErc721Message memory message = TransferErc721Message(\n            BaseMessage(MessageType.TRANSFER_ERC721),\n            token,\n            receiver,\n            tokenId\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721. \n     * Returns structure `TransferErc721Message`.\n     */\n    function decodeTransferErc721Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc721Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC721, \"Message type is not ERC721 transfer\");\n        return abi.decode(data, (TransferErc721Message));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        Erc721TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc721AndTokenInfoMessage memory message = TransferErc721AndTokenInfoMessage(\n            TransferErc721Message(\n                BaseMessage(MessageType.TRANSFER_ERC721_AND_TOKEN_INFO),\n                token,\n                receiver,\n                tokenId\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721 with token info. \n     * Returns structure `TransferErc721AndTokenInfoMessage`.\n     */\n    function decodeTransferErc721AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc721AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_AND_TOKEN_INFO,\n            \"Message type is not ERC721 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc721AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721MessageWithMetadata(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        string memory tokenURI\n    ) internal pure returns (bytes memory) {\n        TransferErc721MessageWithMetadata memory message = TransferErc721MessageWithMetadata(\n            TransferErc721Message(\n                BaseMessage(MessageType.TRANSFER_ERC721_WITH_METADATA),\n                token,\n                receiver,\n                tokenId\n            ),\n            tokenURI\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721. \n     * Returns structure `TransferErc721MessageWithMetadata`.\n     */\n    function decodeTransferErc721MessageWithMetadata(\n        bytes calldata data\n    ) internal pure returns (TransferErc721MessageWithMetadata memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_WITH_METADATA,\n            \"Message type is not ERC721 transfer\"\n        );\n        return abi.decode(data, (TransferErc721MessageWithMetadata));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721WithMetadataAndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        string memory tokenURI,\n        Erc721TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc721WithMetadataAndTokenInfoMessage memory message = TransferErc721WithMetadataAndTokenInfoMessage(\n            TransferErc721MessageWithMetadata(\n                TransferErc721Message(\n                    BaseMessage(MessageType.TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO),\n                    token,\n                    receiver,\n                    tokenId\n                ),\n                tokenURI\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721 with token info. \n     * Returns structure `TransferErc721WithMetadataAndTokenInfoMessage`.\n     */\n    function decodeTransferErc721WithMetadataAndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc721WithMetadataAndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO,\n            \"Message type is not ERC721 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc721WithMetadataAndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for activating user on schain. \n     * Returns encoded message.\n     */\n    function encodeActivateUserMessage(address receiver) internal pure returns (bytes memory){\n        return _encodeUserStatusMessage(receiver, true);\n    }\n\n    /**\n     * @dev Encodes message for locking user on schain. \n     * Returns encoded message.\n     */\n    function encodeLockUserMessage(address receiver) internal pure returns (bytes memory){\n        return _encodeUserStatusMessage(receiver, false);\n    }\n\n    /**\n     * @dev Decodes message for user status. \n     * Returns structure UserStatusMessage.\n     */\n    function decodeUserStatusMessage(bytes calldata data) internal pure returns (UserStatusMessage memory) {\n        require(getMessageType(data) == MessageType.USER_STATUS, \"Message type is not User Status\");\n        return abi.decode(data, (UserStatusMessage));\n    }\n\n\n    /**\n     * @dev Encodes message for allowing interchain connection.\n     * Returns encoded message.\n     */\n    function encodeInterchainConnectionMessage(bool isAllowed) internal pure returns (bytes memory) {\n        InterchainConnectionMessage memory message = InterchainConnectionMessage(\n            BaseMessage(MessageType.INTERCHAIN_CONNECTION),\n            isAllowed\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for allowing interchain connection.\n     * Returns structure `InterchainConnectionMessage`.\n     */\n    function decodeInterchainConnectionMessage(bytes calldata data)\n        internal\n        pure\n        returns (InterchainConnectionMessage memory)\n    {\n        require(getMessageType(data) == MessageType.INTERCHAIN_CONNECTION, \"Message type is not Interchain connection\");\n        return abi.decode(data, (InterchainConnectionMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155Message(\n        address token,\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        TransferErc1155Message memory message = TransferErc1155Message(\n            BaseMessage(MessageType.TRANSFER_ERC1155),\n            token,\n            receiver,\n            id,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token.\n     * Returns structure `TransferErc1155Message`.\n     */\n    function decodeTransferErc1155Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC1155, \"Message type is not ERC1155 transfer\");\n        return abi.decode(data, (TransferErc1155Message));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 with token info.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 id,\n        uint256 amount,\n        Erc1155TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc1155AndTokenInfoMessage memory message = TransferErc1155AndTokenInfoMessage(\n            TransferErc1155Message(\n                BaseMessage(MessageType.TRANSFER_ERC1155_AND_TOKEN_INFO),\n                token,\n                receiver,\n                id,\n                amount\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 with token info.\n     * Returns structure `TransferErc1155AndTokenInfoMessage`.\n     */\n    function decodeTransferErc1155AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_AND_TOKEN_INFO,\n            \"Message type is not ERC1155AndTokenInfo transfer\"\n        );\n        return abi.decode(data, (TransferErc1155AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token in batches.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155BatchMessage(\n        address token,\n        address receiver,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal pure returns (bytes memory) {\n        TransferErc1155BatchMessage memory message = TransferErc1155BatchMessage(\n            BaseMessage(MessageType.TRANSFER_ERC1155_BATCH),\n            token,\n            receiver,\n            ids,\n            amounts\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token in batches.\n     * Returns structure `TransferErc1155BatchMessage`.\n     */\n    function decodeTransferErc1155BatchMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155BatchMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_BATCH,\n            \"Message type is not ERC1155Batch transfer\"\n        );\n        return abi.decode(data, (TransferErc1155BatchMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token in batches with token info.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155BatchAndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        Erc1155TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc1155BatchAndTokenInfoMessage memory message = TransferErc1155BatchAndTokenInfoMessage(\n            TransferErc1155BatchMessage(\n                BaseMessage(MessageType.TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO),\n                token,\n                receiver,\n                ids,\n                amounts\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token in batches with token info.\n     * Returns structure `TransferErc1155BatchAndTokenInfoMessage`.\n     */\n    function decodeTransferErc1155BatchAndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155BatchAndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO,\n            \"Message type is not ERC1155BatchAndTokenInfo transfer\"\n        );\n        return abi.decode(data, (TransferErc1155BatchAndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring user status on schain.\n     * Returns encoded message.\n     */\n    function _encodeUserStatusMessage(address receiver, bool isActive) private pure returns (bytes memory) {\n        UserStatusMessage memory message = UserStatusMessage(\n            BaseMessage(MessageType.USER_STATUS),\n            receiver,\n            isActive\n        );\n        return abi.encode(message);\n    }\n\n}"
             },
```

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/TokenManagerLinker.json` & `ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/TokenManagerLinker.json`

 * *Files identical despite different names*

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/artifacts/TokenManagerLinker.meta.json` & `ima-predeployed-2.0.0b1/src/ima_predeployed/artifacts/TokenManagerLinker.meta.json`

 * *Files 1% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9995592948717948%*

 * *Differences: {"'input'": "{'sources': {'@skalenetwork/skale-manager-interfaces/IWallets.sol': {'content': '// "*

 * *            'SPDX-License-Identifier: AGPL-3.0-only\\n\\n/*\\n    IWallets - SKALE Manager '*

 * *            'Interfaces\\n    Copyright (C) 2021-Present SKALE Labs\\n    @author Dmytro '*

 * *            'Stebaeiv\\n\\n    SKALE Manager Interfaces is free software: you can redistribute it '*

 * *            'and/or modify\\n    it under the terms of the GNU Affero General Public License as '*

 * *            'published\\n    by […]*

```diff
@@ -218,22 +218,28 @@
             },
             "@skalenetwork/ima-interfaces/schain/tokens/IEthErc20.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   IEthErc20 - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity >=0.6.10 <0.9.0;\n\n\ninterface IEthErc20 {\n    function mint(address account, uint256 amount) external;\n    function forceBurn(address account, uint256 amount) external;\n    function initialize(address tokenManagerEthAddress) external;\n}"
             },
             "@skalenetwork/skale-manager-interfaces/IContractManager.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IContractManager.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IContractManager {\n    /**\n     * @dev Emitted when contract is upgraded.\n     */\n    event ContractUpgraded(string contractsName, address contractsAddress);\n\n    function initialize() external;\n    function setContractsAddress(string calldata contractsName, address newContractsAddress) external;\n    function contracts(bytes32 nameHash) external view returns (address);\n    function getDelegationPeriodManager() external view returns (address);\n    function getBounty() external view returns (address);\n    function getValidatorService() external view returns (address);\n    function getTimeHelpers() external view returns (address);\n    function getConstantsHolder() external view returns (address);\n    function getSkaleToken() external view returns (address);\n    function getTokenState() external view returns (address);\n    function getPunisher() external view returns (address);\n    function getContract(string calldata name) external view returns (address);\n}"
             },
+            "@skalenetwork/skale-manager-interfaces/INodes.sol": {
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    INodes.sol - SKALE Manager\n    Copyright (C) 2018-Present SKALE Labs\n    @author Artem Payvin\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"./utils/IRandom.sol\";\n\ninterface INodes {\n    // All Nodes states\n    enum NodeStatus {Active, Leaving, Left, In_Maintenance}\n\n    struct Node {\n        string name;\n        bytes4 ip;\n        bytes4 publicIP;\n        uint16 port;\n        bytes32[2] publicKey;\n        uint startBlock;\n        uint lastRewardDate;\n        uint finishTime;\n        NodeStatus status;\n        uint validatorId;\n    }\n\n    // struct to note which Nodes and which number of Nodes owned by user\n    struct CreatedNodes {\n        mapping (uint => bool) isNodeExist;\n        uint numberOfNodes;\n    }\n\n    struct SpaceManaging {\n        uint8 freeSpace;\n        uint indexInSpaceMap;\n    }\n\n    struct NodeCreationParams {\n        string name;\n        bytes4 ip;\n        bytes4 publicIp;\n        uint16 port;\n        bytes32[2] publicKey;\n        uint16 nonce;\n        string domainName;\n    }\n    \n    /**\n     * @dev Emitted when a node is created.\n     */\n    event NodeCreated(\n        uint nodeIndex,\n        address owner,\n        string name,\n        bytes4 ip,\n        bytes4 publicIP,\n        uint16 port,\n        uint16 nonce,\n        string domainName\n    );\n\n    /**\n     * @dev Emitted when a node completes a network exit.\n     */\n    event ExitCompleted(\n        uint nodeIndex\n    );\n\n    /**\n     * @dev Emitted when a node begins to exit from the network.\n     */\n    event ExitInitialized(\n        uint nodeIndex,\n        uint startLeavingPeriod\n    );\n\n    /**\n     * @dev Emitted when a node set to in compliant or compliant.\n     */\n    event IncompliantNode(\n        uint indexed nodeIndex,\n        bool status\n    );\n\n    /**\n     * @dev Emitted when a node set to in maintenance or from in maintenance.\n     */\n    event MaintenanceNode(\n        uint indexed nodeIndex,\n        bool status\n    );\n\n    /**\n     * @dev Emitted when a node status changed.\n     */\n    event IPChanged(\n        uint indexed nodeIndex,\n        bytes4 previousIP,\n        bytes4 newIP\n    );\n    \n    function removeSpaceFromNode(uint nodeIndex, uint8 space) external returns (bool);\n    function addSpaceToNode(uint nodeIndex, uint8 space) external;\n    function changeNodeLastRewardDate(uint nodeIndex) external;\n    function changeNodeFinishTime(uint nodeIndex, uint time) external;\n    function createNode(address from, NodeCreationParams calldata params) external;\n    function initExit(uint nodeIndex) external;\n    function completeExit(uint nodeIndex) external returns (bool);\n    function deleteNodeForValidator(uint validatorId, uint nodeIndex) external;\n    function checkPossibilityCreatingNode(address nodeAddress) external;\n    function checkPossibilityToMaintainNode(uint validatorId, uint nodeIndex) external returns (bool);\n    function setNodeInMaintenance(uint nodeIndex) external;\n    function removeNodeFromInMaintenance(uint nodeIndex) external;\n    function setNodeIncompliant(uint nodeIndex) external;\n    function setNodeCompliant(uint nodeIndex) external;\n    function setDomainName(uint nodeIndex, string memory domainName) external;\n    function makeNodeVisible(uint nodeIndex) external;\n    function makeNodeInvisible(uint nodeIndex) external;\n    function changeIP(uint nodeIndex, bytes4 newIP, bytes4 newPublicIP) external;\n    function numberOfActiveNodes() external view returns (uint);\n    function incompliant(uint nodeIndex) external view returns (bool);\n    function getRandomNodeWithFreeSpace(\n        uint8 freeSpace,\n        IRandom.RandomGenerator memory randomGenerator\n    )\n        external\n        view\n        returns (uint);\n    function isTimeForReward(uint nodeIndex) external view returns (bool);\n    function getNodeIP(uint nodeIndex) external view returns (bytes4);\n    function getNodeDomainName(uint nodeIndex) external view returns (string memory);\n    function getNodePort(uint nodeIndex) external view returns (uint16);\n    function getNodePublicKey(uint nodeIndex) external view returns (bytes32[2] memory);\n    function getNodeAddress(uint nodeIndex) external view returns (address);\n    function getNodeFinishTime(uint nodeIndex) external view returns (uint);\n    function isNodeLeft(uint nodeIndex) external view returns (bool);\n    function isNodeInMaintenance(uint nodeIndex) external view returns (bool);\n    function getNodeLastRewardDate(uint nodeIndex) external view returns (uint);\n    function getNodeNextRewardDate(uint nodeIndex) external view returns (uint);\n    function getNumberOfNodes() external view returns (uint);\n    function getNumberOnlineNodes() external view returns (uint);\n    function getActiveNodeIds() external view returns (uint[] memory activeNodeIds);\n    function getNodeStatus(uint nodeIndex) external view returns (NodeStatus);\n    function getValidatorNodeIndexes(uint validatorId) external view returns (uint[] memory);\n    function countNodesWithFreeSpace(uint8 freeSpace) external view returns (uint count);\n    function getValidatorId(uint nodeIndex) external view returns (uint);\n    function isNodeExist(address from, uint nodeIndex) external view returns (bool);\n    function isNodeActive(uint nodeIndex) external view returns (bool);\n    function isNodeLeaving(uint nodeIndex) external view returns (bool);\n}\n"
+            },
             "@skalenetwork/skale-manager-interfaces/ISchains.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchains.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchains {\n\n    struct SchainOption {\n        string name;\n        bytes value;\n    }\n    \n    /**\n     * @dev Emitted when an schain is created.\n     */\n    event SchainCreated(\n        string name,\n        address owner,\n        uint partOfNode,\n        uint lifetime,\n        uint numberOfNodes,\n        uint deposit,\n        uint16 nonce,\n        bytes32 schainHash\n    );\n\n    /**\n     * @dev Emitted when an schain is deleted.\n     */\n    event SchainDeleted(\n        address owner,\n        string name,\n        bytes32 indexed schainHash\n    );\n\n    /**\n     * @dev Emitted when a node in an schain is rotated.\n     */\n    event NodeRotated(\n        bytes32 schainHash,\n        uint oldNode,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a node is added to an schain.\n     */\n    event NodeAdded(\n        bytes32 schainHash,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a group of nodes is created for an schain.\n     */\n    event SchainNodes(\n        string name,\n        bytes32 schainHash,\n        uint[] nodesInGroup\n    );\n\n    function addSchain(address from, uint deposit, bytes calldata data) external;\n    function addSchainByFoundation(\n        uint lifetime,\n        uint8 typeOfSchain,\n        uint16 nonce,\n        string calldata name,\n        address schainOwner,\n        address schainOriginator,\n        SchainOption[] calldata options\n    )\n        external\n        payable;\n    function deleteSchain(address from, string calldata name) external;\n    function deleteSchainByRoot(string calldata name) external;\n    function restartSchainCreation(string calldata name) external;\n    function verifySchainSignature(\n        uint256 signA,\n        uint256 signB,\n        bytes32 hash,\n        uint256 counter,\n        uint256 hashA,\n        uint256 hashB,\n        string calldata schainName\n    )\n        external\n        view\n        returns (bool);\n    function getSchainPrice(uint typeOfSchain, uint lifetime) external view returns (uint);\n    function getOption(bytes32 schainHash, string calldata optionName) external view returns (bytes memory);\n    function getOptions(bytes32 schainHash) external view returns (SchainOption[] memory);\n}"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchains.sol - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchains {\n\n    struct SchainOption {\n        string name;\n        bytes value;\n    }\n    \n    /**\n     * @dev Emitted when an schain is created.\n     */\n    event SchainCreated(\n        string name,\n        address owner,\n        uint partOfNode,\n        uint lifetime,\n        uint numberOfNodes,\n        uint deposit,\n        uint16 nonce,\n        bytes32 schainHash\n    );\n\n    /**\n     * @dev Emitted when an schain is deleted.\n     */\n    event SchainDeleted(\n        address owner,\n        string name,\n        bytes32 indexed schainHash\n    );\n\n    /**\n     * @dev Emitted when a node in an schain is rotated.\n     */\n    event NodeRotated(\n        bytes32 schainHash,\n        uint oldNode,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a node is added to an schain.\n     */\n    event NodeAdded(\n        bytes32 schainHash,\n        uint newNode\n    );\n\n    /**\n     * @dev Emitted when a group of nodes is created for an schain.\n     */\n    event SchainNodes(\n        string name,\n        bytes32 schainHash,\n        uint[] nodesInGroup\n    );\n\n    function addSchain(address from, uint deposit, bytes calldata data) external;\n    function addSchainByFoundation(\n        uint lifetime,\n        uint8 typeOfSchain,\n        uint16 nonce,\n        string calldata name,\n        address schainOwner,\n        address schainOriginator,\n        SchainOption[] calldata options\n    )\n        external\n        payable;\n    function deleteSchain(address from, string calldata name) external;\n    function deleteSchainByRoot(string calldata name) external;\n    function restartSchainCreation(string calldata name) external;\n    function verifySchainSignature(\n        uint256 signA,\n        uint256 signB,\n        bytes32 hash,\n        uint256 counter,\n        uint256 hashA,\n        uint256 hashB,\n        string calldata schainName\n    )\n        external\n        view\n        returns (bool);\n    function getSchainPrice(uint typeOfSchain, uint lifetime) external view returns (uint);\n    function getOption(bytes32 schainHash, string calldata optionName) external view returns (bytes memory);\n    function getOptions(bytes32 schainHash) external view returns (SchainOption[] memory);\n}\n"
             },
             "@skalenetwork/skale-manager-interfaces/ISchainsInternal.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchainsInternal - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface ISchainsInternal {\n    struct Schain {\n        string name;\n        address owner;\n        uint indexInOwnerList;\n        uint8 partOfNode;\n        uint lifetime;\n        uint startDate;\n        uint startBlock;\n        uint deposit;\n        uint64 index;\n        uint generation;\n        address originator;\n    }\n\n    struct SchainType {\n        uint8 partOfNode;\n        uint numberOfNodes;\n    }\n\n    /**\n     * @dev Emitted when schain type added.\n     */\n    event SchainTypeAdded(uint indexed schainType, uint partOfNode, uint numberOfNodes);\n\n    /**\n     * @dev Emitted when schain type removed.\n     */\n    event SchainTypeRemoved(uint indexed schainType);\n\n    function initializeSchain(\n        string calldata name,\n        address from,\n        address originator,\n        uint lifetime,\n        uint deposit) external;\n    function createGroupForSchain(\n        bytes32 schainHash,\n        uint numberOfNodes,\n        uint8 partOfNode\n    )\n        external\n        returns (uint[] memory);\n    function changeLifetime(bytes32 schainHash, uint lifetime, uint deposit) external;\n    function removeSchain(bytes32 schainHash, address from) external;\n    function removeNodeFromSchain(uint nodeIndex, bytes32 schainHash) external;\n    function deleteGroup(bytes32 schainHash) external;\n    function setException(bytes32 schainHash, uint nodeIndex) external;\n    function setNodeInGroup(bytes32 schainHash, uint nodeIndex) external;\n    function removeHolesForSchain(bytes32 schainHash) external;\n    function addSchainType(uint8 partOfNode, uint numberOfNodes) external;\n    function removeSchainType(uint typeOfSchain) external;\n    function setNumberOfSchainTypes(uint newNumberOfSchainTypes) external;\n    function removeNodeFromAllExceptionSchains(uint nodeIndex) external;\n    function removeAllNodesFromSchainExceptions(bytes32 schainHash) external;\n    function makeSchainNodesInvisible(bytes32 schainHash) external;\n    function makeSchainNodesVisible(bytes32 schainHash) external;\n    function newGeneration() external;\n    function addSchainForNode(uint nodeIndex, bytes32 schainHash) external;\n    function removeSchainForNode(uint nodeIndex, uint schainIndex) external;\n    function removeNodeFromExceptions(bytes32 schainHash, uint nodeIndex) external;\n    function isSchainActive(bytes32 schainHash) external view returns (bool);\n    function schainsAtSystem(uint index) external view returns (bytes32);\n    function numberOfSchains() external view returns (uint64);\n    function getSchains() external view returns (bytes32[] memory);\n    function getSchainsPartOfNode(bytes32 schainHash) external view returns (uint8);\n    function getSchainListSize(address from) external view returns (uint);\n    function getSchainHashesByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainIdsByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainHashesForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainIdsForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainOwner(bytes32 schainHash) external view returns (address);\n    function getSchainOriginator(bytes32 schainHash) external view returns (address);\n    function isSchainNameAvailable(string calldata name) external view returns (bool);\n    function isTimeExpired(bytes32 schainHash) external view returns (bool);\n    function isOwnerAddress(address from, bytes32 schainId) external view returns (bool);\n    function getSchainName(bytes32 schainHash) external view returns (string memory);\n    function getActiveSchain(uint nodeIndex) external view returns (bytes32);\n    function getActiveSchains(uint nodeIndex) external view returns (bytes32[] memory activeSchains);\n    function getNumberOfNodesInGroup(bytes32 schainHash) external view returns (uint);\n    function getNodesInGroup(bytes32 schainHash) external view returns (uint[] memory);\n    function isNodeAddressesInGroup(bytes32 schainId, address sender) external view returns (bool);\n    function getNodeIndexInGroup(bytes32 schainHash, uint nodeId) external view returns (uint);\n    function isAnyFreeNode(bytes32 schainHash) external view returns (bool);\n    function checkException(bytes32 schainHash, uint nodeIndex) external view returns (bool);\n    function checkHoleForSchain(bytes32 schainHash, uint indexOfNode) external view returns (bool);\n    function checkSchainOnNode(uint nodeIndex, bytes32 schainHash) external view returns (bool);\n    function getSchainType(uint typeOfSchain) external view returns(uint8, uint);\n    function getGeneration(bytes32 schainHash) external view returns (uint);\n    function isSchainExist(bytes32 schainHash) external view returns (bool);\n}"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ISchainsInternal - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\nimport \"./INodes.sol\";\n\ninterface ISchainsInternal {\n    struct Schain {\n        string name;\n        address owner;\n        uint indexInOwnerList;\n        uint8 partOfNode;\n        uint lifetime;\n        uint startDate;\n        uint startBlock;\n        uint deposit;\n        uint64 index;\n        uint generation;\n        address originator;\n    }\n\n    struct SchainType {\n        uint8 partOfNode;\n        uint numberOfNodes;\n    }\n\n    /**\n     * @dev Emitted when schain type added.\n     */\n    event SchainTypeAdded(uint indexed schainType, uint partOfNode, uint numberOfNodes);\n\n    /**\n     * @dev Emitted when schain type removed.\n     */\n    event SchainTypeRemoved(uint indexed schainType);\n\n    function initializeSchain(\n        string calldata name,\n        address from,\n        address originator,\n        uint lifetime,\n        uint deposit) external;\n    function createGroupForSchain(\n        bytes32 schainHash,\n        uint numberOfNodes,\n        uint8 partOfNode\n    )\n        external\n        returns (uint[] memory);\n    function changeLifetime(bytes32 schainHash, uint lifetime, uint deposit) external;\n    function removeSchain(bytes32 schainHash, address from) external;\n    function removeNodeFromSchain(uint nodeIndex, bytes32 schainHash) external;\n    function deleteGroup(bytes32 schainHash) external;\n    function setException(bytes32 schainHash, uint nodeIndex) external;\n    function setNodeInGroup(bytes32 schainHash, uint nodeIndex) external;\n    function removeHolesForSchain(bytes32 schainHash) external;\n    function addSchainType(uint8 partOfNode, uint numberOfNodes) external;\n    function removeSchainType(uint typeOfSchain) external;\n    function setNumberOfSchainTypes(uint newNumberOfSchainTypes) external;\n    function removeNodeFromAllExceptionSchains(uint nodeIndex) external;\n    function removeAllNodesFromSchainExceptions(bytes32 schainHash) external;\n    function makeSchainNodesInvisible(bytes32 schainHash) external;\n    function makeSchainNodesVisible(bytes32 schainHash) external;\n    function newGeneration() external;\n    function addSchainForNode(INodes nodes,uint nodeIndex, bytes32 schainHash) external;\n    function removeSchainForNode(uint nodeIndex, uint schainIndex) external;\n    function removeNodeFromExceptions(bytes32 schainHash, uint nodeIndex) external;\n    function isSchainActive(bytes32 schainHash) external view returns (bool);\n    function schainsAtSystem(uint index) external view returns (bytes32);\n    function numberOfSchains() external view returns (uint64);\n    function getSchains() external view returns (bytes32[] memory);\n    function getSchainsPartOfNode(bytes32 schainHash) external view returns (uint8);\n    function getSchainListSize(address from) external view returns (uint);\n    function getSchainHashesByAddress(address from) external view returns (bytes32[] memory);\n    function getSchainHashesForNode(uint nodeIndex) external view returns (bytes32[] memory);\n    function getSchainOwner(bytes32 schainHash) external view returns (address);\n    function getSchainOriginator(bytes32 schainHash) external view returns (address);\n    function isSchainNameAvailable(string calldata name) external view returns (bool);\n    function isTimeExpired(bytes32 schainHash) external view returns (bool);\n    function isOwnerAddress(address from, bytes32 schainHash) external view returns (bool);\n    function getSchainName(bytes32 schainHash) external view returns (string memory);\n    function getActiveSchain(uint nodeIndex) external view returns (bytes32);\n    function getActiveSchains(uint nodeIndex) external view returns (bytes32[] memory activeSchains);\n    function getNumberOfNodesInGroup(bytes32 schainHash) external view returns (uint);\n    function getNodesInGroup(bytes32 schainHash) external view returns (uint[] memory);\n    function isNodeAddressesInGroup(bytes32 schainHash, address sender) external view returns (bool);\n    function getNodeIndexInGroup(bytes32 schainHash, uint nodeHash) external view returns (uint);\n    function isAnyFreeNode(bytes32 schainHash) external view returns (bool);\n    function checkException(bytes32 schainHash, uint nodeIndex) external view returns (bool);\n    function checkHoleForSchain(bytes32 schainHash, uint indexOfNode) external view returns (bool);\n    function checkSchainOnNode(uint nodeIndex, bytes32 schainHash) external view returns (bool);\n    function getSchainType(uint typeOfSchain) external view returns(uint8, uint);\n    function getGeneration(bytes32 schainHash) external view returns (uint);\n    function isSchainExist(bytes32 schainHash) external view returns (bool);\n}"
             },
             "@skalenetwork/skale-manager-interfaces/IWallets.sol": {
-                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IWallets - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IWallets {\n    /**\n     * @dev Emitted when the validator wallet was funded\n     */\n    event ValidatorWalletRecharged(address sponsor, uint amount, uint validatorId);\n\n    /**\n     * @dev Emitted when the schain wallet was funded\n     */\n    event SchainWalletRecharged(address sponsor, uint amount, bytes32 schainHash);\n\n    /**\n     * @dev Emitted when the node received a refund from validator to its wallet\n     */\n    event NodeRefundedByValidator(address node, uint validatorId, uint amount);\n\n    /**\n     * @dev Emitted when the node received a refund from schain to its wallet\n     */\n    event NodeRefundedBySchain(address node, bytes32 schainHash, uint amount);\n\n    /**\n     * @dev Emitted when the validator withdrawn funds from validator wallet\n     */\n    event WithdrawFromValidatorWallet(uint indexed validatorId, uint amount);\n\n    /**\n     * @dev Emitted when the schain owner withdrawn funds from schain wallet\n     */\n    event WithdrawFromSchainWallet(bytes32 indexed schainHash, uint amount);\n\n    receive() external payable;\n    function refundGasByValidator(uint validatorId, address payable spender, uint spentGas) external;\n    function refundGasByValidatorToSchain(uint validatorId, bytes32 schainHash) external;\n    function refundGasBySchain(bytes32 schainId, address payable spender, uint spentGas, bool isDebt) external;\n    function withdrawFundsFromSchainWallet(address payable schainOwner, bytes32 schainHash) external;\n    function withdrawFundsFromValidatorWallet(uint amount) external;\n    function rechargeValidatorWallet(uint validatorId) external payable;\n    function rechargeSchainWallet(bytes32 schainId) external payable;\n    function getSchainBalance(bytes32 schainHash) external view returns (uint);\n    function getValidatorBalance(uint validatorId) external view returns (uint);\n}\n"
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IWallets - SKALE Manager Interfaces\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaeiv\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\ninterface IWallets {\n    receive() external payable;\n    function refundGasByValidator(uint validatorId, address payable spender, uint gasLimit) external;\n    function refundGasByValidatorToSchain(uint validatorId, bytes32 schainHash) external;\n    function refundGasBySchain(bytes32 schainId, address payable spender, uint spentGas, bool isDebt) external;\n    function withdrawFundsFromSchainWallet(address payable schainOwner, bytes32 schainHash) external;\n    function withdrawFundsFromValidatorWallet(uint amount) external;\n    function rechargeValidatorWallet(uint validatorId) external payable;\n    function rechargeSchainWallet(bytes32 schainId) external payable;\n    function getSchainBalance(bytes32 schainHash) external view returns (uint);\n    function getValidatorBalance(uint validatorId) external view returns (uint);\n}\n"
+            },
+            "@skalenetwork/skale-manager-interfaces/utils/IRandom.sol": {
+                "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    IRandom.sol - SKALE Manager Interfaces\n    Copyright (C) 2022-Present SKALE Labs\n    @author Dmytro Stebaiev\n\n    SKALE Manager Interfaces is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager Interfaces is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager Interfaces.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.6.10 <0.9.0;\n\n\ninterface IRandom {\n    struct RandomGenerator {\n        uint seed;\n    }\n}"
             },
             "contracts/MessageProxy.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   MessageProxy.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/IGasReimbursable.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageProxy.sol\";\nimport \"@skalenetwork/ima-interfaces/IMessageReceiver.sol\";\n\n\n/**\n * @title MessageProxy\n * @dev Abstract contract for MessageProxyForMainnet and MessageProxyForSchain.\n */\nabstract contract MessageProxy is AccessControlEnumerableUpgradeable, IMessageProxy {\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    /**\n     * @dev Structure that stores counters for outgoing and incoming messages.\n     */\n    struct ConnectedChainInfo {\n        // message counters start with 0\n        uint256 incomingMessageCounter;\n        uint256 outgoingMessageCounter;\n        bool inited;\n        uint256 lastOutgoingMessageBlockId;\n    }\n\n    bytes32 public constant MAINNET_HASH = keccak256(abi.encodePacked(\"Mainnet\"));\n    bytes32 public constant CHAIN_CONNECTOR_ROLE = keccak256(\"CHAIN_CONNECTOR_ROLE\");\n    bytes32 public constant EXTRA_CONTRACT_REGISTRAR_ROLE = keccak256(\"EXTRA_CONTRACT_REGISTRAR_ROLE\");\n    bytes32 public constant CONSTANT_SETTER_ROLE = keccak256(\"CONSTANT_SETTER_ROLE\");\n    uint256 public constant MESSAGES_LENGTH = 10;\n    uint256 public constant REVERT_REASON_LENGTH = 64;\n\n    //   schainHash => ConnectedChainInfo\n    mapping(bytes32 => ConnectedChainInfo) public connectedChains;\n    //   schainHash => contract address => allowed\n    mapping(bytes32 => mapping(address => bool)) private _deprecatedRegistryContracts;\n\n    uint256 public gasLimit;\n\n    /**\n     * @dev Emitted for every outgoing message to schain.\n     */\n    event OutgoingMessage(\n        bytes32 indexed dstChainHash,\n        uint256 indexed msgCounter,\n        address indexed srcContract,\n        address dstContract,\n        bytes data\n    );\n\n    /**\n     * @dev Emitted when function `postMessage` returns revert.\n     *  Used to prevent stuck loop inside function `postIncomingMessages`.\n     */\n    event PostMessageError(\n        uint256 indexed msgCounter,\n        bytes message\n    );\n\n    /**\n     * @dev Emitted when gas limit per one call of `postMessage` was changed.\n     */\n    event GasLimitWasChanged(\n        uint256 oldValue,\n        uint256 newValue\n    );\n\n    /**\n     * @dev Emitted when the version was updated\n     */\n    event VersionUpdated(string oldVersion, string newVersion);\n\n    /**\n     * @dev Emitted when extra contract was added.\n     */\n    event ExtraContractRegistered(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Emitted when extra contract was removed.\n     */\n    event ExtraContractRemoved(\n        bytes32 indexed chainHash,\n        address contractAddress\n    );\n\n    /**\n     * @dev Emitted when referenced to previous outgoing message.\n     */\n    event PreviousMessageReference (\n        uint256 currentMessage,\n        uint256 previousOutgoingMessageBlockId\n    );\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CHAIN_CONNECTOR_ROLE}.\n     */\n    modifier onlyChainConnector() {\n        require(hasRole(CHAIN_CONNECTOR_ROLE, msg.sender), \"CHAIN_CONNECTOR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {EXTRA_CONTRACT_REGISTRAR_ROLE}.\n     */\n    modifier onlyExtraContractRegistrar() {\n        require(hasRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender), \"EXTRA_CONTRACT_REGISTRAR_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {CONSTANT_SETTER_ROLE}.\n     */\n    modifier onlyConstantSetter() {\n        require(hasRole(CONSTANT_SETTER_ROLE, msg.sender), \"Not enough permissions to set constant\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only if caller is granted with {DEFAULT_ADMIN_ROLE}.\n     */\n    modifier onlyOwner() {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"DEFAULT_ADMIN_ROLE is required\");\n        _;\n    }\n\n    /**\n     * @dev Sets gasLimit to a new value.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CONSTANT_SETTER_ROLE.\n     */\n    function setNewGasLimit(uint256 newGasLimit) external override onlyConstantSetter {\n        emit GasLimitWasChanged(gasLimit, newGasLimit);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Virtual function for `postIncomingMessages`.\n     */\n    function postIncomingMessages(\n        string calldata fromSchainName,\n        uint256 startingCounter,\n        Message[] calldata messages,\n        Signature calldata sign\n    )\n        external\n        virtual\n        override;\n\n    /**\n     * @dev Allows `msg.sender` to register extra contract for all schains\n     * for being able to transfer messages from custom contracts.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     * - Passed address should be contract.\n     * - Extra contract must not be registered.\n     */\n    function registerExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is already registered\");\n        _getRegistryContracts()[bytes32(0)].add(extraContract);\n        emit ExtraContractRegistered(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Allows `msg.sender` to remove extra contract for all schains.\n     * Extra contract will no longer be able to send messages through MessageProxy.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted as EXTRA_CONTRACT_REGISTRAR_ROLE.\n     */\n    function removeExtraContractForAll(address extraContract) external override onlyExtraContractRegistrar {\n        require(_getRegistryContracts()[bytes32(0)].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[bytes32(0)].remove(extraContract);\n        emit ExtraContractRemoved(bytes32(0), extraContract);\n    }\n\n    /**\n     * @dev Should return length of contract registered by schainHash.\n     */\n    function getContractRegisteredLength(bytes32 schainHash) external view override returns (uint256) {\n        return _getRegistryContracts()[schainHash].length();\n    }\n\n    /**\n     * @dev Should return a range of contracts registered by schainHash.\n     *\n     * Requirements:\n     * range should be less or equal 10 contracts\n     */\n    function getContractRegisteredRange(\n        bytes32 schainHash,\n        uint256 from,\n        uint256 to\n    )\n        external\n        view\n        override\n        returns (address[] memory contractsInRange)\n    {\n        require(\n            from < to && to - from <= 10 && to <= _getRegistryContracts()[schainHash].length(),\n            \"Range is incorrect\"\n        );\n        contractsInRange = new address[](to - from);\n        for (uint256 i = from; i < to; i++) {\n            contractsInRange[i - from] = _getRegistryContracts()[schainHash].at(i);\n        }\n    }\n\n    /**\n     * @dev Returns number of outgoing messages.\n     *\n     * Requirements:\n     *\n     * - Target schain  must be initialized.\n     */\n    function getOutgoingMessagesCounter(string calldata targetSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 dstChainHash = keccak256(abi.encodePacked(targetSchainName));\n        require(connectedChains[dstChainHash].inited, \"Destination chain is not initialized\");\n        return connectedChains[dstChainHash].outgoingMessageCounter;\n    }\n\n\n    /**\n     * @dev Should return block number of the last message transferred to schain\n     */\n    function getLastOutgoingMessageBlockId(string memory targetSchainName) external view override returns (uint) {\n        bytes32 dstChainHash = keccak256(abi.encodePacked(targetSchainName));\n        require(connectedChains[dstChainHash].inited, \"Destination chain is not initialized\");\n        return connectedChains[dstChainHash].lastOutgoingMessageBlockId;\n    }\n\n    /**\n     * @dev Returns number of incoming messages.\n     *\n     * Requirements:\n     *\n     * - Source schain must be initialized.\n     */\n    function getIncomingMessagesCounter(string calldata fromSchainName)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        bytes32 srcChainHash = keccak256(abi.encodePacked(fromSchainName));\n        require(connectedChains[srcChainHash].inited, \"Source chain is not initialized\");\n        return connectedChains[srcChainHash].incomingMessageCounter;\n    }\n\n    function initializeMessageProxy(uint newGasLimit) public initializer {\n        AccessControlEnumerableUpgradeable.__AccessControlEnumerable_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(CHAIN_CONNECTOR_ROLE, msg.sender);\n        _setupRole(EXTRA_CONTRACT_REGISTRAR_ROLE, msg.sender);\n        _setupRole(CONSTANT_SETTER_ROLE, msg.sender);\n        gasLimit = newGasLimit;\n    }\n\n    /**\n     * @dev Posts message from this contract to `targetChainHash` MessageProxy contract.\n     * This is called by a smart contract to make a cross-chain call.\n     *\n     * Emits an {OutgoingMessage} event.\n     *\n     * Requirements:\n     *\n     * - Target chain must be initialized.\n     * - Target chain must be registered as external contract.\n     */\n    function postOutgoingMessage(\n        bytes32 targetChainHash,\n        address targetContract,\n        bytes memory data\n    )\n        public\n        override\n        virtual\n    {\n        require(connectedChains[targetChainHash].inited, \"Destination chain is not initialized\");\n        _authorizeOutgoingMessageSender(targetChainHash);\n\n        uint outgoingMessageCounter = connectedChains[targetChainHash].outgoingMessageCounter;\n        emit OutgoingMessage(\n            targetChainHash,\n            outgoingMessageCounter,\n            msg.sender,\n            targetContract,\n            data\n        );\n        emit PreviousMessageReference(\n            outgoingMessageCounter,\n            connectedChains[targetChainHash].lastOutgoingMessageBlockId\n        );\n        connectedChains[targetChainHash].outgoingMessageCounter++;\n        connectedChains[targetChainHash].lastOutgoingMessageBlockId = block.number;\n    }\n\n    /**\n     * @dev Allows CHAIN_CONNECTOR_ROLE to remove connected chain from this contract.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CHAIN_CONNECTOR_ROLE.\n     * - `schainName` must be initialized.\n     */\n    function removeConnectedChain(string memory schainName) public virtual override onlyChainConnector {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(connectedChains[schainHash].inited, \"Chain is not initialized\");\n        delete connectedChains[schainHash];\n    }\n\n    /**\n     * @dev Checks whether chain is currently connected.\n     */\n    function isConnectedChain(\n        string memory schainName\n    )\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return connectedChains[keccak256(abi.encodePacked(schainName))].inited;\n    }\n\n    /**\n     * @dev Checks whether contract is currently registered as extra contract.\n     */\n    function isContractRegistered(\n        bytes32 schainHash,\n        address contractAddress\n    )\n        public\n        view\n        override\n        returns (bool)\n    {\n        return _getRegistryContracts()[schainHash].contains(contractAddress);\n    }\n\n    /**\n     * @dev Allows MessageProxy to register extra contract for being able to transfer messages from custom contracts.\n     *\n     * Requirements:\n     *\n     * - Extra contract address must be contract.\n     * - Extra contract must not be registered.\n     * - Extra contract must not be registered for all chains.\n     */\n    function _registerExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {\n        require(extraContract.isContract(), \"Given address is not a contract\");\n        require(!_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is already registered\");\n        require(\n            !_getRegistryContracts()[bytes32(0)].contains(extraContract),\n            \"Extra contract is already registered for all chains\"\n        );\n\n        _getRegistryContracts()[chainHash].add(extraContract);\n        emit ExtraContractRegistered(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to remove extra contract,\n     * thus `extraContract` will no longer be available to transfer messages from mainnet to schain.\n     *\n     * Requirements:\n     *\n     * - Extra contract must be registered.\n     */\n    function _removeExtraContract(\n        bytes32 chainHash,\n        address extraContract\n    )\n        internal\n    {\n        require(_getRegistryContracts()[chainHash].contains(extraContract), \"Extra contract is not registered\");\n        _getRegistryContracts()[chainHash].remove(extraContract);\n        emit ExtraContractRemoved(chainHash, extraContract);\n    }\n\n    /**\n     * @dev Allows MessageProxy to connect schain with MessageProxyOnMainnet for transferring messages.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be granted CHAIN_CONNECTOR_ROLE.\n     * - SKALE chain must not be connected.\n     */\n    function _addConnectedChain(bytes32 schainHash) internal onlyChainConnector {\n        require(!connectedChains[schainHash].inited,\"Chain is already connected\");\n        connectedChains[schainHash] = ConnectedChainInfo({\n            incomingMessageCounter: 0,\n            outgoingMessageCounter: 0,\n            inited: true,\n            lastOutgoingMessageBlockId: 0\n        });\n    }\n\n    /**\n     * @dev Allows MessageProxy to send messages from schain to mainnet.\n     * Destination contract must implement `postMessage` method.\n     */\n    function _callReceiverContract(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n    {\n        if (!message.destinationContract.isContract()) {\n            emit PostMessageError(\n                counter,\n                \"Destination contract is not a contract\"\n            );\n            return;\n        }\n        try IMessageReceiver(message.destinationContract).postMessage{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) {\n            return;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                _getSlice(bytes(reason), REVERT_REASON_LENGTH)\n            );\n        } catch Panic(uint errorCode) {\n               emit PostMessageError(\n                counter,\n                abi.encodePacked(errorCode)\n            );\n        } catch (bytes memory revertData) {\n            emit PostMessageError(\n                counter,\n                _getSlice(revertData, REVERT_REASON_LENGTH)\n            );\n        }\n    }\n\n    /**\n     * @dev Returns receiver of message.\n     */\n    function _getGasPayer(\n        bytes32 schainHash,\n        Message calldata message,\n        uint counter\n    )\n        internal\n        returns (address)\n    {\n        try IGasReimbursable(message.destinationContract).gasPayer{gas: gasLimit}(\n            schainHash,\n            message.sender,\n            message.data\n        ) returns (address receiver) {\n            return receiver;\n        } catch Error(string memory reason) {\n            emit PostMessageError(\n                counter,\n                _getSlice(bytes(reason), REVERT_REASON_LENGTH)\n            );\n            return address(0);\n        } catch Panic(uint errorCode) {\n               emit PostMessageError(\n                counter,\n                abi.encodePacked(errorCode)\n            );\n            return address(0);\n        } catch (bytes memory revertData) {\n            emit PostMessageError(\n                counter,\n                _getSlice(revertData, REVERT_REASON_LENGTH)\n            );\n            return address(0);\n        }\n    }\n\n    /**\n     * @dev Checks whether msg.sender is registered as custom extra contract.\n     */\n    function _authorizeOutgoingMessageSender(bytes32 targetChainHash) internal view virtual {\n        require(\n            isContractRegistered(bytes32(0), msg.sender) || isContractRegistered(targetChainHash, msg.sender),\n            \"Sender contract is not registered\"\n        );\n    }\n\n    /**\n     * @dev Returns list of registered custom extra contracts.\n     */\n    function _getRegistryContracts()\n        internal\n        view\n        virtual\n        returns (mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) storage);\n\n    /**\n     * @dev Returns hash of message array.\n     */\n    function _hashedArray(\n        Message[] calldata messages,\n        uint256 startingCounter,\n        string calldata fromChainName\n    )\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32 sourceHash = keccak256(abi.encodePacked(fromChainName));\n        bytes32 hash = keccak256(abi.encodePacked(sourceHash, bytes32(startingCounter)));\n        for (uint256 i = 0; i < messages.length; i++) {\n            hash = keccak256(\n                abi.encodePacked(\n                    abi.encode(\n                        hash,\n                        messages[i].sender,\n                        messages[i].destinationContract\n                    ),\n                    messages[i].data\n                )\n            );\n        }\n        return hash;\n    }\n\n    function _getSlice(bytes memory text, uint end) private pure returns (bytes memory) {\n        uint slicedEnd = end < text.length ? end : text.length;\n        bytes memory sliced = new bytes(slicedEnd);\n        for(uint i = 0; i < slicedEnd; i++){\n            sliced[i] = text[i];\n        }\n        return sliced;\n    }\n}\n"
             },
             "contracts/Messages.sol": {
                 "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   Messages.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2021-Present SKALE Labs\n *   @author Dmytro Stebaiev\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.16;\n\n\n/**\n * @title Messages\n * @dev Library for encoding and decoding messages\n * for transferring from Mainnet to Schain and vice versa.\n */\nlibrary Messages {\n\n    /**\n     * @dev Enumerator that describes all supported message types.\n     */\n    enum MessageType {\n        EMPTY,\n        TRANSFER_ETH,\n        TRANSFER_ERC20,\n        TRANSFER_ERC20_AND_TOTAL_SUPPLY,\n        TRANSFER_ERC20_AND_TOKEN_INFO,\n        TRANSFER_ERC721,\n        TRANSFER_ERC721_AND_TOKEN_INFO,\n        USER_STATUS,\n        INTERCHAIN_CONNECTION,\n        TRANSFER_ERC1155,\n        TRANSFER_ERC1155_AND_TOKEN_INFO,\n        TRANSFER_ERC1155_BATCH,\n        TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO,\n        TRANSFER_ERC721_WITH_METADATA,\n        TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO\n    }\n\n    /**\n     * @dev Structure for base message.\n     */\n    struct BaseMessage {\n        MessageType messageType;\n    }\n\n    /**\n     * @dev Structure for describing ETH.\n     */\n    struct TransferEthMessage {\n        BaseMessage message;\n        address receiver;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for user status.\n     */\n    struct UserStatusMessage {\n        BaseMessage message;\n        address receiver;\n        bool isActive;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 token.\n     */\n    struct TransferErc20Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC20 token.\n     */\n    struct Erc20TokenInfo {\n        string name;\n        uint8 decimals;\n        string symbol;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token supply.\n     */\n    struct TransferErc20AndTotalSupplyMessage {\n        TransferErc20Message baseErc20transfer;\n        uint256 totalSupply;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token info.\n     */\n    struct TransferErc20AndTokenInfoMessage {\n        TransferErc20Message baseErc20transfer;\n        uint256 totalSupply;\n        Erc20TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing base ERC721.\n     */\n    struct TransferErc721Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 tokenId;\n    }\n\n    /**\n     * @dev Structure for describing base ERC721 with metadata.\n     */\n    struct TransferErc721MessageWithMetadata {\n        TransferErc721Message erc721message;\n        string tokenURI;\n    }\n\n    /**\n     * @dev Structure for describing ERC20 with token info.\n     */\n    struct Erc721TokenInfo {\n        string name;\n        string symbol;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC721 token.\n     */\n    struct TransferErc721AndTokenInfoMessage {\n        TransferErc721Message baseErc721transfer;\n        Erc721TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing additional data for ERC721 token with metadata.\n     */\n    struct TransferErc721WithMetadataAndTokenInfoMessage {\n        TransferErc721MessageWithMetadata baseErc721transferWithMetadata;\n        Erc721TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing whether interchain connection is allowed.\n     */\n    struct InterchainConnectionMessage {\n        BaseMessage message;\n        bool isAllowed;\n    }\n\n    /**\n     * @dev Structure for describing whether interchain connection is allowed.\n     */\n    struct TransferErc1155Message {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256 id;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Structure for describing ERC1155 token in batches.\n     */\n    struct TransferErc1155BatchMessage {\n        BaseMessage message;\n        address token;\n        address receiver;\n        uint256[] ids;\n        uint256[] amounts;\n    }\n\n    /**\n     * @dev Structure for describing ERC1155 token info.\n     */\n    struct Erc1155TokenInfo {\n        string uri;\n    }\n\n    /**\n     * @dev Structure for describing message for transferring ERC1155 token with info.\n     */\n    struct TransferErc1155AndTokenInfoMessage {\n        TransferErc1155Message baseErc1155transfer;\n        Erc1155TokenInfo tokenInfo;\n    }\n\n    /**\n     * @dev Structure for describing message for transferring ERC1155 token in batches with info.\n     */\n    struct TransferErc1155BatchAndTokenInfoMessage {\n        TransferErc1155BatchMessage baseErc1155Batchtransfer;\n        Erc1155TokenInfo tokenInfo;\n    }\n\n\n    /**\n     * @dev Returns type of message for encoded data.\n     */\n    function getMessageType(bytes calldata data) internal pure returns (MessageType) {\n        uint256 firstWord = abi.decode(data, (uint256));\n        if (firstWord % 32 == 0) {\n            return getMessageType(data[firstWord:]);\n        } else {\n            return abi.decode(data, (Messages.MessageType));\n        }\n    }\n\n    /**\n     * @dev Encodes message for transferring ETH. Returns encoded message.\n     */\n    function encodeTransferEthMessage(address receiver, uint256 amount) internal pure returns (bytes memory) {\n        TransferEthMessage memory message = TransferEthMessage(\n            BaseMessage(MessageType.TRANSFER_ETH),\n            receiver,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ETH. Returns structure `TransferEthMessage`.\n     */\n    function decodeTransferEthMessage(\n        bytes calldata data\n    ) internal pure returns (TransferEthMessage memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ETH, \"Message type is not ETH transfer\");\n        return abi.decode(data, (TransferEthMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ETH. Returns encoded message.\n     */\n    function encodeTransferErc20Message(\n        address token,\n        address receiver,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        TransferErc20Message memory message = TransferErc20Message(\n            BaseMessage(MessageType.TRANSFER_ERC20),\n            token,\n            receiver,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC20 with total supply. Returns encoded message.\n     */\n    function encodeTransferErc20AndTotalSupplyMessage(\n        address token,\n        address receiver,\n        uint256 amount,\n        uint256 totalSupply\n    ) internal pure returns (bytes memory) {\n        TransferErc20AndTotalSupplyMessage memory message = TransferErc20AndTotalSupplyMessage(\n            TransferErc20Message(\n                BaseMessage(MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY),\n                token,\n                receiver,\n                amount\n            ),\n            totalSupply\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20. Returns structure `TransferErc20Message`.\n     */\n    function decodeTransferErc20Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc20Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC20, \"Message type is not ERC20 transfer\");\n        return abi.decode(data, (TransferErc20Message));\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20 with total supply. \n     * Returns structure `TransferErc20AndTotalSupplyMessage`.\n     */\n    function decodeTransferErc20AndTotalSupplyMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc20AndTotalSupplyMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY,\n            \"Message type is not ERC20 transfer and total supply\"\n        );\n        return abi.decode(data, (TransferErc20AndTotalSupplyMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC20 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc20AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 amount,\n        uint256 totalSupply,\n        Erc20TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc20AndTokenInfoMessage memory message = TransferErc20AndTokenInfoMessage(\n            TransferErc20Message(\n                BaseMessage(MessageType.TRANSFER_ERC20_AND_TOKEN_INFO),\n                token,\n                receiver,\n                amount\n            ),\n            totalSupply,\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC20 with token info. \n     * Returns structure `TransferErc20AndTokenInfoMessage`.\n     */\n    function decodeTransferErc20AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc20AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC20_AND_TOKEN_INFO,\n            \"Message type is not ERC20 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc20AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721Message(\n        address token,\n        address receiver,\n        uint256 tokenId\n    ) internal pure returns (bytes memory) {\n        TransferErc721Message memory message = TransferErc721Message(\n            BaseMessage(MessageType.TRANSFER_ERC721),\n            token,\n            receiver,\n            tokenId\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721. \n     * Returns structure `TransferErc721Message`.\n     */\n    function decodeTransferErc721Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc721Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC721, \"Message type is not ERC721 transfer\");\n        return abi.decode(data, (TransferErc721Message));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        Erc721TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc721AndTokenInfoMessage memory message = TransferErc721AndTokenInfoMessage(\n            TransferErc721Message(\n                BaseMessage(MessageType.TRANSFER_ERC721_AND_TOKEN_INFO),\n                token,\n                receiver,\n                tokenId\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721 with token info. \n     * Returns structure `TransferErc721AndTokenInfoMessage`.\n     */\n    function decodeTransferErc721AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc721AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_AND_TOKEN_INFO,\n            \"Message type is not ERC721 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc721AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721MessageWithMetadata(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        string memory tokenURI\n    ) internal pure returns (bytes memory) {\n        TransferErc721MessageWithMetadata memory message = TransferErc721MessageWithMetadata(\n            TransferErc721Message(\n                BaseMessage(MessageType.TRANSFER_ERC721_WITH_METADATA),\n                token,\n                receiver,\n                tokenId\n            ),\n            tokenURI\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721. \n     * Returns structure `TransferErc721MessageWithMetadata`.\n     */\n    function decodeTransferErc721MessageWithMetadata(\n        bytes calldata data\n    ) internal pure returns (TransferErc721MessageWithMetadata memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_WITH_METADATA,\n            \"Message type is not ERC721 transfer\"\n        );\n        return abi.decode(data, (TransferErc721MessageWithMetadata));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC721 with token info. \n     * Returns encoded message.\n     */\n    function encodeTransferErc721WithMetadataAndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 tokenId,\n        string memory tokenURI,\n        Erc721TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc721WithMetadataAndTokenInfoMessage memory message = TransferErc721WithMetadataAndTokenInfoMessage(\n            TransferErc721MessageWithMetadata(\n                TransferErc721Message(\n                    BaseMessage(MessageType.TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO),\n                    token,\n                    receiver,\n                    tokenId\n                ),\n                tokenURI\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC721 with token info. \n     * Returns structure `TransferErc721WithMetadataAndTokenInfoMessage`.\n     */\n    function decodeTransferErc721WithMetadataAndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc721WithMetadataAndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC721_WITH_METADATA_AND_TOKEN_INFO,\n            \"Message type is not ERC721 transfer with token info\"\n        );\n        return abi.decode(data, (TransferErc721WithMetadataAndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for activating user on schain. \n     * Returns encoded message.\n     */\n    function encodeActivateUserMessage(address receiver) internal pure returns (bytes memory){\n        return _encodeUserStatusMessage(receiver, true);\n    }\n\n    /**\n     * @dev Encodes message for locking user on schain. \n     * Returns encoded message.\n     */\n    function encodeLockUserMessage(address receiver) internal pure returns (bytes memory){\n        return _encodeUserStatusMessage(receiver, false);\n    }\n\n    /**\n     * @dev Decodes message for user status. \n     * Returns structure UserStatusMessage.\n     */\n    function decodeUserStatusMessage(bytes calldata data) internal pure returns (UserStatusMessage memory) {\n        require(getMessageType(data) == MessageType.USER_STATUS, \"Message type is not User Status\");\n        return abi.decode(data, (UserStatusMessage));\n    }\n\n\n    /**\n     * @dev Encodes message for allowing interchain connection.\n     * Returns encoded message.\n     */\n    function encodeInterchainConnectionMessage(bool isAllowed) internal pure returns (bytes memory) {\n        InterchainConnectionMessage memory message = InterchainConnectionMessage(\n            BaseMessage(MessageType.INTERCHAIN_CONNECTION),\n            isAllowed\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for allowing interchain connection.\n     * Returns structure `InterchainConnectionMessage`.\n     */\n    function decodeInterchainConnectionMessage(bytes calldata data)\n        internal\n        pure\n        returns (InterchainConnectionMessage memory)\n    {\n        require(getMessageType(data) == MessageType.INTERCHAIN_CONNECTION, \"Message type is not Interchain connection\");\n        return abi.decode(data, (InterchainConnectionMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155Message(\n        address token,\n        address receiver,\n        uint256 id,\n        uint256 amount\n    ) internal pure returns (bytes memory) {\n        TransferErc1155Message memory message = TransferErc1155Message(\n            BaseMessage(MessageType.TRANSFER_ERC1155),\n            token,\n            receiver,\n            id,\n            amount\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token.\n     * Returns structure `TransferErc1155Message`.\n     */\n    function decodeTransferErc1155Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC1155, \"Message type is not ERC1155 transfer\");\n        return abi.decode(data, (TransferErc1155Message));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 with token info.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155AndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256 id,\n        uint256 amount,\n        Erc1155TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc1155AndTokenInfoMessage memory message = TransferErc1155AndTokenInfoMessage(\n            TransferErc1155Message(\n                BaseMessage(MessageType.TRANSFER_ERC1155_AND_TOKEN_INFO),\n                token,\n                receiver,\n                id,\n                amount\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 with token info.\n     * Returns structure `TransferErc1155AndTokenInfoMessage`.\n     */\n    function decodeTransferErc1155AndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155AndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_AND_TOKEN_INFO,\n            \"Message type is not ERC1155AndTokenInfo transfer\"\n        );\n        return abi.decode(data, (TransferErc1155AndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token in batches.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155BatchMessage(\n        address token,\n        address receiver,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal pure returns (bytes memory) {\n        TransferErc1155BatchMessage memory message = TransferErc1155BatchMessage(\n            BaseMessage(MessageType.TRANSFER_ERC1155_BATCH),\n            token,\n            receiver,\n            ids,\n            amounts\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token in batches.\n     * Returns structure `TransferErc1155BatchMessage`.\n     */\n    function decodeTransferErc1155BatchMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155BatchMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_BATCH,\n            \"Message type is not ERC1155Batch transfer\"\n        );\n        return abi.decode(data, (TransferErc1155BatchMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring ERC1155 token in batches with token info.\n     * Returns encoded message.\n     */\n    function encodeTransferErc1155BatchAndTokenInfoMessage(\n        address token,\n        address receiver,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        Erc1155TokenInfo memory tokenInfo\n    ) internal pure returns (bytes memory) {\n        TransferErc1155BatchAndTokenInfoMessage memory message = TransferErc1155BatchAndTokenInfoMessage(\n            TransferErc1155BatchMessage(\n                BaseMessage(MessageType.TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO),\n                token,\n                receiver,\n                ids,\n                amounts\n            ),\n            tokenInfo\n        );\n        return abi.encode(message);\n    }\n\n    /**\n     * @dev Decodes message for transferring ERC1155 token in batches with token info.\n     * Returns structure `TransferErc1155BatchAndTokenInfoMessage`.\n     */\n    function decodeTransferErc1155BatchAndTokenInfoMessage(\n        bytes calldata data\n    ) internal pure returns (TransferErc1155BatchAndTokenInfoMessage memory) {\n        require(\n            getMessageType(data) == MessageType.TRANSFER_ERC1155_BATCH_AND_TOKEN_INFO,\n            \"Message type is not ERC1155BatchAndTokenInfo transfer\"\n        );\n        return abi.decode(data, (TransferErc1155BatchAndTokenInfoMessage));\n    }\n\n    /**\n     * @dev Encodes message for transferring user status on schain.\n     * Returns encoded message.\n     */\n    function _encodeUserStatusMessage(address receiver, bool isActive) private pure returns (bytes memory) {\n        UserStatusMessage memory message = UserStatusMessage(\n            BaseMessage(MessageType.USER_STATUS),\n            receiver,\n            isActive\n        );\n        return abi.encode(message);\n    }\n\n}"
             },
```

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/contract_generator.py` & `ima-predeployed-2.0.0b1/src/ima_predeployed/contract_generator.py`

 * *Files identical despite different names*

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/contracts/admin_upgradeability_proxy.py` & `ima-predeployed-2.0.0b1/src/ima_predeployed/contracts/admin_upgradeability_proxy.py`

 * *Files identical despite different names*

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/contracts/community_locker.py` & `ima-predeployed-2.0.0b1/src/ima_predeployed/contracts/community_locker.py`

 * *Files identical despite different names*

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/contracts/erc1155_on_chain.py` & `ima-predeployed-2.0.0b1/src/ima_predeployed/contracts/erc1155_on_chain.py`

 * *Files identical despite different names*

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/contracts/erc20_on_chain.py` & `ima-predeployed-2.0.0b1/src/ima_predeployed/contracts/erc20_on_chain.py`

 * *Files identical despite different names*

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/contracts/erc721_on_chain.py` & `ima-predeployed-2.0.0b1/src/ima_predeployed/contracts/erc721_on_chain.py`

 * *Files identical despite different names*

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/contracts/eth_erc20.py` & `ima-predeployed-2.0.0b1/src/ima_predeployed/contracts/eth_erc20.py`

 * *Files identical despite different names*

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/contracts/key_storage.py` & `ima-predeployed-2.0.0b1/src/ima_predeployed/contracts/key_storage.py`

 * *Files identical despite different names*

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/contracts/message_proxy_for_schain.py` & `ima-predeployed-2.0.0b1/src/ima_predeployed/contracts/message_proxy_for_schain.py`

 * *Files identical despite different names*

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/contracts/token_manager.py` & `ima-predeployed-2.0.0b1/src/ima_predeployed/contracts/token_manager.py`

 * *Files identical despite different names*

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/contracts/token_manager_erc1155.py` & `ima-predeployed-2.0.0b1/src/ima_predeployed/contracts/token_manager_erc1155.py`

 * *Files identical despite different names*

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/contracts/token_manager_erc20.py` & `ima-predeployed-2.0.0b1/src/ima_predeployed/contracts/token_manager_erc20.py`

 * *Files identical despite different names*

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/contracts/token_manager_erc721.py` & `ima-predeployed-2.0.0b1/src/ima_predeployed/contracts/token_manager_erc721.py`

 * *Files identical despite different names*

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/contracts/token_manager_erc721_with_metadata.py` & `ima-predeployed-2.0.0b1/src/ima_predeployed/contracts/token_manager_erc721_with_metadata.py`

 * *Files identical despite different names*

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/contracts/token_manager_eth.py` & `ima-predeployed-2.0.0b1/src/ima_predeployed/contracts/token_manager_eth.py`

 * *Files identical despite different names*

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/contracts/token_manager_linker.py` & `ima-predeployed-2.0.0b1/src/ima_predeployed/contracts/token_manager_linker.py`

 * *Files identical despite different names*

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/generator.py` & `ima-predeployed-2.0.0b1/src/ima_predeployed/generator.py`

 * *Files identical despite different names*

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed/upgradeable_contract_generator.py` & `ima-predeployed-2.0.0b1/src/ima_predeployed/upgradeable_contract_generator.py`

 * *Files identical despite different names*

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed.egg-info/PKG-INFO` & `ima-predeployed-2.0.0b1/src/ima_predeployed.egg-info/PKG-INFO`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: ima-predeployed
-Version: 2.0.0b0
+Version: 2.0.0b1
 Summary: A tool to generate config for predeployed IMA
 Home-page: https://github.com/skalenetwork/IMA
 Author: Dmytro Stebaiev
 Author-email: dmytro@skalelabs.com
 Classifier: Programming Language :: Python :: 3
 Classifier: License :: OSI Approved :: GNU Affero General Public License v3
 Classifier: Operating System :: OS Independent
```

### Comparing `ima-predeployed-2.0.0b0/src/ima_predeployed.egg-info/SOURCES.txt` & `ima-predeployed-2.0.0b1/src/ima_predeployed.egg-info/SOURCES.txt`

 * *Files identical despite different names*

### Comparing `ima-predeployed-2.0.0b0/test/test.py` & `ima-predeployed-2.0.0b1/test/test.py`

 * *Files identical despite different names*

### Comparing `ima-predeployed-2.0.0b0/test/test_generator.py` & `ima-predeployed-2.0.0b1/test/test_generator.py`

 * *Files identical despite different names*


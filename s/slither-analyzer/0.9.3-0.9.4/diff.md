# Comparing `tmp/slither-analyzer-0.9.3.tar.gz` & `tmp/slither-analyzer-0.9.4.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "slither-analyzer-0.9.3.tar", last modified: Fri Mar 17 18:25:11 2023, max compression
+gzip compressed data, was "slither-analyzer-0.9.4.tar", last modified: Mon Jun 26 18:41:10 2023, max compression
```

## Comparing `slither-analyzer-0.9.3.tar` & `slither-analyzer-0.9.4.tar`

### file list

```diff
@@ -1,588 +1,623 @@
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.872770 slither-analyzer-0.9.3/
--rw-r--r--   0 monty      (501) staff       (20)    34523 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/LICENSE
--rw-r--r--   0 monty      (501) staff       (20)    27339 2023-03-17 18:25:11.872582 slither-analyzer-0.9.3/PKG-INFO
--rw-r--r--   0 monty      (501) staff       (20)    27010 2023-03-17 18:21:51.000000 slither-analyzer-0.9.3/README.md
--rw-r--r--   0 monty      (501) staff       (20)      424 2022-11-03 19:46:23.000000 slither-analyzer-0.9.3/pyproject.toml
--rw-r--r--   0 monty      (501) staff       (20)       38 2023-03-17 18:25:11.872824 slither-analyzer-0.9.3/setup.cfg
--rw-r--r--   0 monty      (501) staff       (20)     2096 2023-03-17 18:24:13.000000 slither-analyzer-0.9.3/setup.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.794237 slither-analyzer-0.9.3/slither/
--rw-r--r--   0 monty      (501) staff       (20)       29 2022-08-02 11:30:48.000000 slither-analyzer-0.9.3/slither/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)    33010 2023-03-17 18:21:51.000000 slither-analyzer-0.9.3/slither/__main__.py
--rw-r--r--   0 monty      (501) staff       (20)      310 2022-08-02 11:30:48.000000 slither-analyzer-0.9.3/slither/all_exceptions.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.794371 slither-analyzer-0.9.3/slither/analyses/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/analyses/__init__.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.794607 slither-analyzer-0.9.3/slither/analyses/data_dependency/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/analyses/data_dependency/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)    15186 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/analyses/data_dependency/data_dependency.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.795023 slither-analyzer-0.9.3/slither/analyses/evm/
--rw-r--r--   0 monty      (501) staff       (20)      106 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/analyses/evm/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     7797 2022-10-03 10:02:06.000000 slither-analyzer-0.9.3/slither/analyses/evm/convert.py
--rw-r--r--   0 monty      (501) staff       (20)      689 2022-08-02 11:30:48.000000 slither-analyzer-0.9.3/slither/analyses/evm/evm_cfg_builder.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.795282 slither-analyzer-0.9.3/slither/analyses/write/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/analyses/write/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     3910 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/analyses/write/are_variables_written.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.795808 slither-analyzer-0.9.3/slither/core/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/core/__init__.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.796278 slither-analyzer-0.9.3/slither/core/cfg/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/core/cfg/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)    37830 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/cfg/node.py
--rw-r--r--   0 monty      (501) staff       (20)      455 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/core/cfg/scope.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.797744 slither-analyzer-0.9.3/slither/core/children/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/core/children/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)      476 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/children/child_contract.py
--rw-r--r--   0 monty      (501) staff       (20)      350 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/children/child_event.py
--rw-r--r--   0 monty      (501) staff       (20)      523 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/children/child_expression.py
--rw-r--r--   0 monty      (501) staff       (20)      391 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/children/child_function.py
--rw-r--r--   0 monty      (501) staff       (20)      439 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/children/child_inheritance.py
--rw-r--r--   0 monty      (501) staff       (20)      773 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/children/child_node.py
--rw-r--r--   0 monty      (501) staff       (20)      402 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/children/child_structure.py
--rw-r--r--   0 monty      (501) staff       (20)    11503 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/compilation_unit.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.798030 slither-analyzer-0.9.3/slither/core/context/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/core/context/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)      368 2023-01-25 15:25:39.000000 slither-analyzer-0.9.3/slither/core/context/context.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.801663 slither-analyzer-0.9.3/slither/core/declarations/
--rw-r--r--   0 monty      (501) staff       (20)      692 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/core/declarations/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)    59046 2023-03-17 18:21:51.000000 slither-analyzer-0.9.3/slither/core/declarations/contract.py
--rw-r--r--   0 monty      (501) staff       (20)     3424 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/declarations/custom_error.py
--rw-r--r--   0 monty      (501) staff       (20)      387 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/declarations/custom_error_contract.py
--rw-r--r--   0 monty      (501) staff       (20)      521 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/declarations/custom_error_top_level.py
--rw-r--r--   0 monty      (501) staff       (20)      883 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/core/declarations/enum.py
--rw-r--r--   0 monty      (501) staff       (20)      477 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/declarations/enum_contract.py
--rw-r--r--   0 monty      (501) staff       (20)      465 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/core/declarations/enum_top_level.py
--rw-r--r--   0 monty      (501) staff       (20)     1747 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/declarations/event.py
--rw-r--r--   0 monty      (501) staff       (20)    69290 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/declarations/function.py
--rw-r--r--   0 monty      (501) staff       (20)     4687 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/declarations/function_contract.py
--rw-r--r--   0 monty      (501) staff       (20)     3851 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/core/declarations/function_top_level.py
--rw-r--r--   0 monty      (501) staff       (20)     1112 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/core/declarations/import_directive.py
--rw-r--r--   0 monty      (501) staff       (20)      121 2023-02-20 10:34:00.000000 slither-analyzer-0.9.3/slither/core/declarations/modifier.py
--rw-r--r--   0 monty      (501) staff       (20)     1141 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/core/declarations/pragma_directive.py
--rw-r--r--   0 monty      (501) staff       (20)     1522 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/core/declarations/solidity_import_placeholder.py
--rw-r--r--   0 monty      (501) staff       (20)     6928 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/declarations/solidity_variables.py
--rw-r--r--   0 monty      (501) staff       (20)     2074 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/core/declarations/structure.py
--rw-r--r--   0 monty      (501) staff       (20)      368 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/declarations/structure_contract.py
--rw-r--r--   0 monty      (501) staff       (20)      510 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/core/declarations/structure_top_level.py
--rw-r--r--   0 monty      (501) staff       (20)      111 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/declarations/top_level.py
--rw-r--r--   0 monty      (501) staff       (20)      564 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/declarations/using_for_top_level.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.802299 slither-analyzer-0.9.3/slither/core/dominators/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/core/dominators/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)      581 2022-08-02 11:30:48.000000 slither-analyzer-0.9.3/slither/core/dominators/node_dominator_tree.py
--rw-r--r--   0 monty      (501) staff       (20)     3165 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/dominators/utils.py
--rw-r--r--   0 monty      (501) staff       (20)      101 2022-08-02 11:30:48.000000 slither-analyzer-0.9.3/slither/core/exceptions.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.806578 slither-analyzer-0.9.3/slither/core/expressions/
--rw-r--r--   0 monty      (501) staff       (20)      840 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/core/expressions/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     4263 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/expressions/assignment_operation.py
--rw-r--r--   0 monty      (501) staff       (20)     6134 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/expressions/binary_operation.py
--rw-r--r--   0 monty      (501) staff       (20)     2127 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/expressions/call_expression.py
--rw-r--r--   0 monty      (501) staff       (20)     1890 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/expressions/conditional_expression.py
--rw-r--r--   0 monty      (501) staff       (20)      707 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/core/expressions/elementary_type_name_expression.py
--rw-r--r--   0 monty      (501) staff       (20)      340 2023-01-25 14:20:59.000000 slither-analyzer-0.9.3/slither/core/expressions/expression.py
--rw-r--r--   0 monty      (501) staff       (20)      525 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/expressions/expression_typed.py
--rw-r--r--   0 monty      (501) staff       (20)      463 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/expressions/identifier.py
--rw-r--r--   0 monty      (501) staff       (20)     1307 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/expressions/index_access.py
--rw-r--r--   0 monty      (501) staff       (20)     1739 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/expressions/literal.py
--rw-r--r--   0 monty      (501) staff       (20)      947 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/expressions/member_access.py
--rw-r--r--   0 monty      (501) staff       (20)      915 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/core/expressions/new_array.py
--rw-r--r--   0 monty      (501) staff       (20)      755 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/core/expressions/new_contract.py
--rw-r--r--   0 monty      (501) staff       (20)      455 2022-08-02 11:30:48.000000 slither-analyzer-0.9.3/slither/core/expressions/new_elementary_type.py
--rw-r--r--   0 monty      (501) staff       (20)      122 2022-08-02 11:30:48.000000 slither-analyzer-0.9.3/slither/core/expressions/super_call_expression.py
--rw-r--r--   0 monty      (501) staff       (20)      162 2022-08-02 11:30:48.000000 slither-analyzer-0.9.3/slither/core/expressions/super_identifier.py
--rw-r--r--   0 monty      (501) staff       (20)      563 2023-01-25 14:15:08.000000 slither-analyzer-0.9.3/slither/core/expressions/tuple_expression.py
--rw-r--r--   0 monty      (501) staff       (20)     1431 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/expressions/type_conversion.py
--rw-r--r--   0 monty      (501) staff       (20)     4515 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/expressions/unary_operation.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.806872 slither-analyzer-0.9.3/slither/core/scope/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-08-03 15:19:25.000000 slither-analyzer-0.9.3/slither/core/scope/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     8701 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/core/scope/scope.py
--rw-r--r--   0 monty      (501) staff       (20)    22003 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/slither_core.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.808206 slither-analyzer-0.9.3/slither/core/solidity_types/
--rw-r--r--   0 monty      (501) staff       (20)      344 2023-02-20 10:34:00.000000 slither-analyzer-0.9.3/slither/core/solidity_types/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     2634 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/solidity_types/array_type.py
--rw-r--r--   0 monty      (501) staff       (20)     4843 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/solidity_types/elementary_type.py
--rw-r--r--   0 monty      (501) staff       (20)     2462 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/core/solidity_types/function_type.py
--rw-r--r--   0 monty      (501) staff       (20)     1266 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/solidity_types/mapping_type.py
--rw-r--r--   0 monty      (501) staff       (20)      636 2022-10-03 10:02:06.000000 slither-analyzer-0.9.3/slither/core/solidity_types/type.py
--rw-r--r--   0 monty      (501) staff       (20)     1648 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/solidity_types/type_alias.py
--rw-r--r--   0 monty      (501) staff       (20)     1621 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/solidity_types/type_information.py
--rw-r--r--   0 monty      (501) staff       (20)     3065 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/core/solidity_types/user_defined_type.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.808554 slither-analyzer-0.9.3/slither/core/source_mapping/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/core/source_mapping/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     7134 2023-03-17 18:21:51.000000 slither-analyzer-0.9.3/slither/core/source_mapping/source_mapping.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.810024 slither-analyzer-0.9.3/slither/core/variables/
--rw-r--r--   0 monty      (501) staff       (20)       73 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/core/variables/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)      608 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/variables/event_variable.py
--rw-r--r--   0 monty      (501) staff       (20)      185 2022-08-02 11:30:48.000000 slither-analyzer-0.9.3/slither/core/variables/function_type_variable.py
--rw-r--r--   0 monty      (501) staff       (20)     1893 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/variables/local_variable.py
--rw-r--r--   0 monty      (501) staff       (20)      693 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/core/variables/local_variable_init_from_tuple.py
--rw-r--r--   0 monty      (501) staff       (20)     2439 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/variables/state_variable.py
--rw-r--r--   0 monty      (501) staff       (20)      180 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/variables/structure_variable.py
--rw-r--r--   0 monty      (501) staff       (20)     1426 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/core/variables/top_level_variable.py
--rw-r--r--   0 monty      (501) staff       (20)     5550 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/core/variables/variable.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.810500 slither-analyzer-0.9.3/slither/detectors/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/detectors/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)    10500 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/abstract_detector.py
--rw-r--r--   0 monty      (501) staff       (20)     5552 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/detectors/all_detectors.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.810857 slither-analyzer-0.9.3/slither/detectors/assembly/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-08-03 15:19:25.000000 slither-analyzer-0.9.3/slither/detectors/assembly/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     2231 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/assembly/shift_parameter_mixup.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.811930 slither-analyzer-0.9.3/slither/detectors/attributes/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/detectors/attributes/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     2991 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/attributes/const_functions_asm.py
--rw-r--r--   0 monty      (501) staff       (20)     3267 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/attributes/const_functions_state.py
--rw-r--r--   0 monty      (501) staff       (20)     1587 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/attributes/constant_pragma.py
--rw-r--r--   0 monty      (501) staff       (20)     5953 2023-03-17 18:21:51.000000 slither-analyzer-0.9.3/slither/detectors/attributes/incorrect_solc.py
--rw-r--r--   0 monty      (501) staff       (20)     3628 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/attributes/locked_ether.py
--rw-r--r--   0 monty      (501) staff       (20)     5694 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/attributes/unimplemented_interface.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.813458 slither-analyzer-0.9.3/slither/detectors/compiler_bugs/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-08-03 15:19:25.000000 slither-analyzer-0.9.3/slither/detectors/compiler_bugs/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     7409 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/compiler_bugs/array_by_reference.py
--rw-r--r--   0 monty      (501) staff       (20)     2743 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/compiler_bugs/enum_conversion.py
--rw-r--r--   0 monty      (501) staff       (20)     2454 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/compiler_bugs/multiple_constructor_schemes.py
--rw-r--r--   0 monty      (501) staff       (20)     3741 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/detectors/compiler_bugs/public_mapping_nested.py
--rw-r--r--   0 monty      (501) staff       (20)     6162 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/compiler_bugs/reused_base_constructor.py
--rw-r--r--   0 monty      (501) staff       (20)     5421 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/compiler_bugs/storage_ABIEncoderV2_array.py
--rw-r--r--   0 monty      (501) staff       (20)     5241 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/compiler_bugs/storage_signed_integer_array.py
--rw-r--r--   0 monty      (501) staff       (20)     5037 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/compiler_bugs/uninitialized_function_ptr_in_constructor.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.813964 slither-analyzer-0.9.3/slither/detectors/erc/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/detectors/erc/__init__.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.814847 slither-analyzer-0.9.3/slither/detectors/erc/erc20/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-08-08 12:48:30.000000 slither-analyzer-0.9.3/slither/detectors/erc/erc20/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     4055 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/erc/erc20/arbitrary_send_erc20.py
--rw-r--r--   0 monty      (501) staff       (20)     1666 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/erc/erc20/arbitrary_send_erc20_no_permit.py
--rw-r--r--   0 monty      (501) staff       (20)     2012 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/erc/erc20/arbitrary_send_erc20_permit.py
--rw-r--r--   0 monty      (501) staff       (20)     4280 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/erc/erc20/incorrect_erc20_interface.py
--rw-r--r--   0 monty      (501) staff       (20)     4690 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/erc/incorrect_erc721_interface.py
--rw-r--r--   0 monty      (501) staff       (20)     4012 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/detectors/erc/unindexed_event_parameters.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.815115 slither-analyzer-0.9.3/slither/detectors/examples/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/detectors/examples/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     1240 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/examples/backdoor.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.817261 slither-analyzer-0.9.3/slither/detectors/functions/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/detectors/functions/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     4798 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/functions/arbitrary_send_eth.py
--rw-r--r--   0 monty      (501) staff       (20)     4337 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/detectors/functions/codex.py
--rw-r--r--   0 monty      (501) staff       (20)     1809 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/functions/cyclomatic_complexity.py
--rw-r--r--   0 monty      (501) staff       (20)     2867 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/functions/dead_code.py
--rw-r--r--   0 monty      (501) staff       (20)    12558 2023-02-20 10:34:00.000000 slither-analyzer-0.9.3/slither/detectors/functions/external_function.py
--rw-r--r--   0 monty      (501) staff       (20)     3172 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/functions/modifier.py
--rw-r--r--   0 monty      (501) staff       (20)     3436 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/functions/permit_domain_signature_collision.py
--rw-r--r--   0 monty      (501) staff       (20)     2917 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/functions/protected_variable.py
--rw-r--r--   0 monty      (501) staff       (20)     2518 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/functions/suicidal.py
--rw-r--r--   0 monty      (501) staff       (20)     4296 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/functions/unimplemented.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.817623 slither-analyzer-0.9.3/slither/detectors/naming_convention/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/detectors/naming_convention/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     8246 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/naming_convention/naming_convention.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.819740 slither-analyzer-0.9.3/slither/detectors/operations/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/detectors/operations/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     4565 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/operations/bad_prng.py
--rw-r--r--   0 monty      (501) staff       (20)     3247 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/operations/block_timestamp.py
--rw-r--r--   0 monty      (501) staff       (20)     2506 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/operations/low_level_calls.py
--rw-r--r--   0 monty      (501) staff       (20)     4446 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/operations/missing_events_access_control.py
--rw-r--r--   0 monty      (501) staff       (20)     5132 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/operations/missing_events_arithmetic.py
--rw-r--r--   0 monty      (501) staff       (20)     6586 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/operations/missing_zero_address_validation.py
--rw-r--r--   0 monty      (501) staff       (20)     1545 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/detectors/operations/unchecked_low_level_return_values.py
--rw-r--r--   0 monty      (501) staff       (20)     1442 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/detectors/operations/unchecked_send_return_value.py
--rw-r--r--   0 monty      (501) staff       (20)     2099 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/detectors/operations/unchecked_transfer.py
--rw-r--r--   0 monty      (501) staff       (20)     3567 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/operations/unused_return_values.py
--rw-r--r--   0 monty      (501) staff       (20)     1624 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/operations/void_constructor.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.820911 slither-analyzer-0.9.3/slither/detectors/reentrancy/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/detectors/reentrancy/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)    10740 2023-01-25 13:27:50.000000 slither-analyzer-0.9.3/slither/detectors/reentrancy/reentrancy.py
--rw-r--r--   0 monty      (501) staff       (20)     7600 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/detectors/reentrancy/reentrancy_benign.py
--rw-r--r--   0 monty      (501) staff       (20)     8599 2023-03-17 18:21:51.000000 slither-analyzer-0.9.3/slither/detectors/reentrancy/reentrancy_eth.py
--rw-r--r--   0 monty      (501) staff       (20)     6568 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/detectors/reentrancy/reentrancy_events.py
--rw-r--r--   0 monty      (501) staff       (20)     9222 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/detectors/reentrancy/reentrancy_no_gas.py
--rw-r--r--   0 monty      (501) staff       (20)     7125 2023-01-25 13:24:09.000000 slither-analyzer-0.9.3/slither/detectors/reentrancy/reentrancy_read_before_write.py
--rw-r--r--   0 monty      (501) staff       (20)     3645 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/reentrancy/token.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.821749 slither-analyzer-0.9.3/slither/detectors/shadowing/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/detectors/shadowing/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     2795 2023-01-25 13:23:26.000000 slither-analyzer-0.9.3/slither/detectors/shadowing/abstract.py
--rw-r--r--   0 monty      (501) staff       (20)     6768 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/shadowing/builtin_symbols.py
--rw-r--r--   0 monty      (501) staff       (20)     1164 2023-01-25 13:21:56.000000 slither-analyzer-0.9.3/slither/detectors/shadowing/common.py
--rw-r--r--   0 monty      (501) staff       (20)     6534 2023-03-17 18:21:51.000000 slither-analyzer-0.9.3/slither/detectors/shadowing/local.py
--rw-r--r--   0 monty      (501) staff       (20)     2823 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/shadowing/state.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.822043 slither-analyzer-0.9.3/slither/detectors/slither/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/detectors/slither/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     4563 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/slither/name_reused.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.822315 slither-analyzer-0.9.3/slither/detectors/source/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/detectors/source/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     3432 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/source/rtlo.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.825627 slither-analyzer-0.9.3/slither/detectors/statements/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/detectors/statements/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     5450 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/statements/array_length_assignment.py
--rw-r--r--   0 monty      (501) staff       (20)     2166 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/statements/assembly.py
--rw-r--r--   0 monty      (501) staff       (20)     3299 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/statements/assert_state_change.py
--rw-r--r--   0 monty      (501) staff       (20)     3112 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/statements/boolean_constant_equality.py
--rw-r--r--   0 monty      (501) staff       (20)     4440 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/statements/boolean_constant_misuse.py
--rw-r--r--   0 monty      (501) staff       (20)     3041 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/statements/calls_in_loop.py
--rw-r--r--   0 monty      (501) staff       (20)     2642 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/statements/controlled_delegatecall.py
--rw-r--r--   0 monty      (501) staff       (20)     3559 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/statements/costly_operations_in_loop.py
--rw-r--r--   0 monty      (501) staff       (20)     3301 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/statements/delegatecall_in_loop.py
--rw-r--r--   0 monty      (501) staff       (20)     7716 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/statements/deprecated_calls.py
--rw-r--r--   0 monty      (501) staff       (20)     7285 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/statements/divide_before_multiply.py
--rw-r--r--   0 monty      (501) staff       (20)     7000 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/detectors/statements/incorrect_strict_equality.py
--rw-r--r--   0 monty      (501) staff       (20)     3442 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/statements/mapping_deletion.py
--rw-r--r--   0 monty      (501) staff       (20)     2814 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/statements/msg_value_in_loop.py
--rw-r--r--   0 monty      (501) staff       (20)     3303 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/statements/redundant_statements.py
--rw-r--r--   0 monty      (501) staff       (20)     3450 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/statements/too_many_digits.py
--rw-r--r--   0 monty      (501) staff       (20)     3009 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/statements/tx_origin.py
--rw-r--r--   0 monty      (501) staff       (20)     5926 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/statements/type_based_tautology.py
--rw-r--r--   0 monty      (501) staff       (20)     3257 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/statements/unary.py
--rw-r--r--   0 monty      (501) staff       (20)     5253 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/statements/unprotected_upgradeable.py
--rw-r--r--   0 monty      (501) staff       (20)     4586 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/statements/write_after_write.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.827524 slither-analyzer-0.9.3/slither/detectors/variables/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/detectors/variables/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     2060 2023-02-14 09:06:15.000000 slither-analyzer-0.9.3/slither/detectors/variables/could_be_constant.py
--rw-r--r--   0 monty      (501) staff       (20)     2037 2023-02-14 09:06:15.000000 slither-analyzer-0.9.3/slither/detectors/variables/could_be_immutable.py
--rw-r--r--   0 monty      (501) staff       (20)     4928 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/variables/function_init_state_variables.py
--rw-r--r--   0 monty      (501) staff       (20)     6877 2023-03-17 18:21:51.000000 slither-analyzer-0.9.3/slither/detectors/variables/predeclaration_usage_local.py
--rw-r--r--   0 monty      (501) staff       (20)     3163 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/variables/similar_variables.py
--rw-r--r--   0 monty      (501) staff       (20)     4730 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/detectors/variables/unchanged_state_variables.py
--rw-r--r--   0 monty      (501) staff       (20)     4382 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/detectors/variables/uninitialized_local_variables.py
--rw-r--r--   0 monty      (501) staff       (20)     5900 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/variables/uninitialized_state_variables.py
--rw-r--r--   0 monty      (501) staff       (20)     4218 2023-03-10 15:15:31.000000 slither-analyzer-0.9.3/slither/detectors/variables/uninitialized_storage_variables.py
--rw-r--r--   0 monty      (501) staff       (20)     3002 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/variables/unused_state_variables.py
--rw-r--r--   0 monty      (501) staff       (20)     2305 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/detectors/variables/var_read_using_this.py
--rw-r--r--   0 monty      (501) staff       (20)       93 2022-08-02 11:30:48.000000 slither-analyzer-0.9.3/slither/exceptions.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.827802 slither-analyzer-0.9.3/slither/formatters/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/formatters/__init__.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.828438 slither-analyzer-0.9.3/slither/formatters/attributes/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/formatters/attributes/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     2116 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/formatters/attributes/const_functions.py
--rw-r--r--   0 monty      (501) staff       (20)     2805 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/formatters/attributes/constant_pragma.py
--rw-r--r--   0 monty      (501) staff       (20)     2369 2022-10-03 10:02:06.000000 slither-analyzer-0.9.3/slither/formatters/attributes/incorrect_solc.py
--rw-r--r--   0 monty      (501) staff       (20)      149 2022-08-02 11:30:48.000000 slither-analyzer-0.9.3/slither/formatters/exceptions.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.828750 slither-analyzer-0.9.3/slither/formatters/functions/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/formatters/functions/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     2497 2022-10-03 10:02:06.000000 slither-analyzer-0.9.3/slither/formatters/functions/external_function.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.829031 slither-analyzer-0.9.3/slither/formatters/naming_convention/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/formatters/naming_convention/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)    25464 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/formatters/naming_convention/naming_convention.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.829452 slither-analyzer-0.9.3/slither/formatters/utils/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/formatters/utils/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     1859 2022-08-22 18:55:46.000000 slither-analyzer-0.9.3/slither/formatters/utils/patches.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.829874 slither-analyzer-0.9.3/slither/formatters/variables/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/formatters/variables/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     2027 2023-02-14 09:06:15.000000 slither-analyzer-0.9.3/slither/formatters/variables/unchanged_state_variables.py
--rw-r--r--   0 monty      (501) staff       (20)     1153 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/formatters/variables/unused_state_variables.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.830346 slither-analyzer-0.9.3/slither/printers/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/printers/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     1746 2023-01-25 12:54:46.000000 slither-analyzer-0.9.3/slither/printers/abstract_printer.py
--rw-r--r--   0 monty      (501) staff       (20)     1099 2022-12-06 11:59:34.000000 slither-analyzer-0.9.3/slither/printers/all_printers.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.830601 slither-analyzer-0.9.3/slither/printers/call/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/printers/call/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     7767 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/printers/call/call_graph.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.831233 slither-analyzer-0.9.3/slither/printers/functions/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/printers/functions/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     2412 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/printers/functions/authorization.py
--rw-r--r--   0 monty      (501) staff       (20)     1271 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/printers/functions/cfg.py
--rw-r--r--   0 monty      (501) staff       (20)     1153 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/printers/functions/dominator.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.831478 slither-analyzer-0.9.3/slither/printers/guidance/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/printers/guidance/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)    17654 2023-03-17 18:21:51.000000 slither-analyzer-0.9.3/slither/printers/guidance/echidna.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.831922 slither-analyzer-0.9.3/slither/printers/inheritance/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/printers/inheritance/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     3117 2022-08-03 15:19:25.000000 slither-analyzer-0.9.3/slither/printers/inheritance/inheritance.py
--rw-r--r--   0 monty      (501) staff       (20)     8331 2022-08-31 09:50:35.000000 slither-analyzer-0.9.3/slither/printers/inheritance/inheritance_graph.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.834373 slither-analyzer-0.9.3/slither/printers/summary/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/printers/summary/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     2129 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/printers/summary/constructor_calls.py
--rw-r--r--   0 monty      (501) staff       (20)     3327 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/printers/summary/contract.py
--rw-r--r--   0 monty      (501) staff       (20)     1983 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/printers/summary/data_depenency.py
--rw-r--r--   0 monty      (501) staff       (20)     2649 2023-03-17 18:21:51.000000 slither-analyzer-0.9.3/slither/printers/summary/declaration.py
--rw-r--r--   0 monty      (501) staff       (20)     5244 2023-03-17 18:21:51.000000 slither-analyzer-0.9.3/slither/printers/summary/evm.py
--rw-r--r--   0 monty      (501) staff       (20)     4001 2023-03-10 11:07:55.000000 slither-analyzer-0.9.3/slither/printers/summary/function.py
--rw-r--r--   0 monty      (501) staff       (20)     1698 2023-01-05 14:29:03.000000 slither-analyzer-0.9.3/slither/printers/summary/function_ids.py
--rw-r--r--   0 monty      (501) staff       (20)    15234 2022-10-03 10:02:06.000000 slither-analyzer-0.9.3/slither/printers/summary/human_summary.py
--rw-r--r--   0 monty      (501) staff       (20)     1578 2023-01-05 18:03:34.000000 slither-analyzer-0.9.3/slither/printers/summary/modifier_calls.py
--rw-r--r--   0 monty      (501) staff       (20)     1939 2023-01-05 18:03:34.000000 slither-analyzer-0.9.3/slither/printers/summary/require_calls.py
--rw-r--r--   0 monty      (501) staff       (20)     1947 2023-03-17 18:21:51.000000 slither-analyzer-0.9.3/slither/printers/summary/slithir.py
--rw-r--r--   0 monty      (501) staff       (20)     1711 2022-08-03 15:19:25.000000 slither-analyzer-0.9.3/slither/printers/summary/slithir_ssa.py
--rw-r--r--   0 monty      (501) staff       (20)     1334 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/printers/summary/variable_order.py
--rw-r--r--   0 monty      (501) staff       (20)     1918 2022-08-08 12:48:30.000000 slither-analyzer-0.9.3/slither/printers/summary/when_not_paused.py
--rw-r--r--   0 monty      (501) staff       (20)     9344 2023-03-17 18:21:51.000000 slither-analyzer-0.9.3/slither/slither.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.834865 slither-analyzer-0.9.3/slither/slithir/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/slithir/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)    74642 2023-03-17 18:21:51.000000 slither-analyzer-0.9.3/slither/slithir/convert.py
--rw-r--r--   0 monty      (501) staff       (20)       97 2022-08-02 11:30:48.000000 slither-analyzer-0.9.3/slither/slithir/exceptions.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.840528 slither-analyzer-0.9.3/slither/slithir/operations/
--rw-r--r--   0 monty      (501) staff       (20)     1073 2023-01-05 18:03:34.000000 slither-analyzer-0.9.3/slither/slithir/operations/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     1772 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/slithir/operations/assignment.py
--rw-r--r--   0 monty      (501) staff       (20)     5092 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/slithir/operations/binary.py
--rw-r--r--   0 monty      (501) staff       (20)      763 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/slithir/operations/call.py
--rw-r--r--   0 monty      (501) staff       (20)     1186 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/slithir/operations/codesize.py
--rw-r--r--   0 monty      (501) staff       (20)     1241 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/slithir/operations/condition.py
--rw-r--r--   0 monty      (501) staff       (20)     1333 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/slithir/operations/delete.py
--rw-r--r--   0 monty      (501) staff       (20)      622 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/slithir/operations/event_call.py
--rw-r--r--   0 monty      (501) staff       (20)     6518 2023-03-17 18:21:51.000000 slither-analyzer-0.9.3/slither/slithir/operations/high_level_call.py
--rw-r--r--   0 monty      (501) staff       (20)     1798 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/slithir/operations/index.py
--rw-r--r--   0 monty      (501) staff       (20)     1518 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/slithir/operations/init_array.py
--rw-r--r--   0 monty      (501) staff       (20)     3208 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/slithir/operations/internal_call.py
--rw-r--r--   0 monty      (501) staff       (20)     2834 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/slithir/operations/internal_dynamic_call.py
--rw-r--r--   0 monty      (501) staff       (20)     1401 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/slithir/operations/length.py
--rw-r--r--   0 monty      (501) staff       (20)     1805 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/slithir/operations/library_call.py
--rw-r--r--   0 monty      (501) staff       (20)     4046 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/slithir/operations/low_level_call.py
--rw-r--r--   0 monty      (501) staff       (20)      495 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/slithir/operations/lvalue.py
--rw-r--r--   0 monty      (501) staff       (20)     2597 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/slithir/operations/member.py
--rw-r--r--   0 monty      (501) staff       (20)     1329 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/slithir/operations/new_array.py
--rw-r--r--   0 monty      (501) staff       (20)     3652 2023-03-17 18:21:51.000000 slither-analyzer-0.9.3/slither/slithir/operations/new_contract.py
--rw-r--r--   0 monty      (501) staff       (20)      790 2022-08-03 15:19:25.000000 slither-analyzer-0.9.3/slither/slithir/operations/new_elementary_type.py
--rw-r--r--   0 monty      (501) staff       (20)     1420 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/slithir/operations/new_structure.py
--rw-r--r--   0 monty      (501) staff       (20)      320 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/slithir/operations/nop.py
--rw-r--r--   0 monty      (501) staff       (20)     1037 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/slithir/operations/operation.py
--rw-r--r--   0 monty      (501) staff       (20)     1686 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/slithir/operations/phi.py
--rw-r--r--   0 monty      (501) staff       (20)     1575 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/slithir/operations/phi_callback.py
--rw-r--r--   0 monty      (501) staff       (20)     1705 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/slithir/operations/return_operation.py
--rw-r--r--   0 monty      (501) staff       (20)     1683 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/slithir/operations/send.py
--rw-r--r--   0 monty      (501) staff       (20)     2031 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/slithir/operations/solidity_call.py
--rw-r--r--   0 monty      (501) staff       (20)     1218 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/slithir/operations/transfer.py
--rw-r--r--   0 monty      (501) staff       (20)     1854 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/slithir/operations/type_conversion.py
--rw-r--r--   0 monty      (501) staff       (20)     2015 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/slithir/operations/unary.py
--rw-r--r--   0 monty      (501) staff       (20)     1310 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/slithir/operations/unpack.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.841576 slither-analyzer-0.9.3/slither/slithir/tmp_operations/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/slithir/tmp_operations/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     1009 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/slithir/tmp_operations/argument.py
--rw-r--r--   0 monty      (501) staff       (20)     2895 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/slithir/tmp_operations/tmp_call.py
--rw-r--r--   0 monty      (501) staff       (20)      823 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/slithir/tmp_operations/tmp_new_array.py
--rw-r--r--   0 monty      (501) staff       (20)      947 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/slithir/tmp_operations/tmp_new_contract.py
--rw-r--r--   0 monty      (501) staff       (20)      648 2022-12-06 11:59:34.000000 slither-analyzer-0.9.3/slither/slithir/tmp_operations/tmp_new_elementary_type.py
--rw-r--r--   0 monty      (501) staff       (20)      478 2022-08-03 15:19:25.000000 slither-analyzer-0.9.3/slither/slithir/tmp_operations/tmp_new_structure.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.841988 slither-analyzer-0.9.3/slither/slithir/utils/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/slithir/utils/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)    34642 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/slithir/utils/ssa.py
--rw-r--r--   0 monty      (501) staff       (20)     1136 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/slithir/utils/utils.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.843593 slither-analyzer-0.9.3/slither/slithir/variables/
--rw-r--r--   0 monty      (501) staff       (20)      370 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/slithir/variables/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     2505 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/slithir/variables/constant.py
--rw-r--r--   0 monty      (501) staff       (20)     2414 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/slithir/variables/local_variable.py
--rw-r--r--   0 monty      (501) staff       (20)     2059 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/slithir/variables/reference.py
--rw-r--r--   0 monty      (501) staff       (20)      704 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/slithir/variables/reference_ssa.py
--rw-r--r--   0 monty      (501) staff       (20)     1367 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/slithir/variables/state_variable.py
--rw-r--r--   0 monty      (501) staff       (20)      868 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/slithir/variables/temporary.py
--rw-r--r--   0 monty      (501) staff       (20)      789 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/slithir/variables/temporary_ssa.py
--rw-r--r--   0 monty      (501) staff       (20)      876 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/slithir/variables/tuple.py
--rw-r--r--   0 monty      (501) staff       (20)      522 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/slithir/variables/tuple_ssa.py
--rw-r--r--   0 monty      (501) staff       (20)      288 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/slithir/variables/variable.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.843987 slither-analyzer-0.9.3/slither/solc_parsing/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/solc_parsing/__init__.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.844264 slither-analyzer-0.9.3/slither/solc_parsing/cfg/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/solc_parsing/cfg/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     3009 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/solc_parsing/cfg/node.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.845697 slither-analyzer-0.9.3/slither/solc_parsing/declarations/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/solc_parsing/declarations/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)      913 2022-08-03 15:19:25.000000 slither-analyzer-0.9.3/slither/solc_parsing/declarations/caller_context.py
--rw-r--r--   0 monty      (501) staff       (20)    35915 2023-03-17 18:21:51.000000 slither-analyzer-0.9.3/slither/solc_parsing/declarations/contract.py
--rw-r--r--   0 monty      (501) staff       (20)     4181 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/solc_parsing/declarations/custom_error.py
--rw-r--r--   0 monty      (501) staff       (20)     2103 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/solc_parsing/declarations/event.py
--rw-r--r--   0 monty      (501) staff       (20)    60878 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/solc_parsing/declarations/function.py
--rw-r--r--   0 monty      (501) staff       (20)     3686 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/solc_parsing/declarations/modifier.py
--rw-r--r--   0 monty      (501) staff       (20)     1925 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/solc_parsing/declarations/structure_contract.py
--rw-r--r--   0 monty      (501) staff       (20)     2610 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/solc_parsing/declarations/structure_top_level.py
--rw-r--r--   0 monty      (501) staff       (20)     7144 2023-03-17 18:21:51.000000 slither-analyzer-0.9.3/slither/solc_parsing/declarations/using_for_top_level.py
--rw-r--r--   0 monty      (501) staff       (20)      150 2022-08-02 11:30:48.000000 slither-analyzer-0.9.3/slither/solc_parsing/exceptions.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.846147 slither-analyzer-0.9.3/slither/solc_parsing/expressions/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/solc_parsing/expressions/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)    27648 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/solc_parsing/expressions/expression_parsing.py
--rw-r--r--   0 monty      (501) staff       (20)    16797 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/solc_parsing/expressions/find_variable.py
--rw-r--r--   0 monty      (501) staff       (20)    33403 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/solc_parsing/slither_compilation_unit_solc.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.846421 slither-analyzer-0.9.3/slither/solc_parsing/solidity_types/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/solc_parsing/solidity_types/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)    20463 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/solc_parsing/solidity_types/type_parsing.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.847739 slither-analyzer-0.9.3/slither/solc_parsing/variables/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/solc_parsing/variables/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)      991 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/solc_parsing/variables/event_variable.py
--rw-r--r--   0 monty      (501) staff       (20)      602 2022-08-02 11:30:48.000000 slither-analyzer-0.9.3/slither/solc_parsing/variables/function_type_variable.py
--rw-r--r--   0 monty      (501) staff       (20)     1268 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/solc_parsing/variables/local_variable.py
--rw-r--r--   0 monty      (501) staff       (20)      711 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/solc_parsing/variables/local_variable_init_from_tuple.py
--rw-r--r--   0 monty      (501) staff       (20)      567 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/solc_parsing/variables/state_variable.py
--rw-r--r--   0 monty      (501) staff       (20)      583 2022-08-02 11:30:48.000000 slither-analyzer-0.9.3/slither/solc_parsing/variables/structure_variable.py
--rw-r--r--   0 monty      (501) staff       (20)     1446 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/solc_parsing/variables/top_level_variable.py
--rw-r--r--   0 monty      (501) staff       (20)     8186 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/solc_parsing/variables/variable_declaration.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.848390 slither-analyzer-0.9.3/slither/solc_parsing/yul/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-08-02 11:30:48.000000 slither-analyzer-0.9.3/slither/solc_parsing/yul/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     5299 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/solc_parsing/yul/evm_functions.py
--rw-r--r--   0 monty      (501) staff       (20)    30043 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/solc_parsing/yul/parse_yul.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.848572 slither-analyzer-0.9.3/slither/tools/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/tools/__init__.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.848845 slither-analyzer-0.9.3/slither/tools/demo/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/tools/demo/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)      927 2022-12-06 11:59:34.000000 slither-analyzer-0.9.3/slither/tools/demo/__main__.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.849293 slither-analyzer-0.9.3/slither/tools/doctor/
--rw-r--r--   0 monty      (501) staff       (20)        0 2023-01-05 14:29:03.000000 slither-analyzer-0.9.3/slither/tools/doctor/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     1025 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/tools/doctor/__main__.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.849981 slither-analyzer-0.9.3/slither/tools/doctor/checks/
--rw-r--r--   0 monty      (501) staff       (20)      585 2023-02-14 09:06:15.000000 slither-analyzer-0.9.3/slither/tools/doctor/checks/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     2857 2023-02-14 09:06:15.000000 slither-analyzer-0.9.3/slither/tools/doctor/checks/paths.py
--rw-r--r--   0 monty      (501) staff       (20)     2249 2023-01-05 14:29:03.000000 slither-analyzer-0.9.3/slither/tools/doctor/checks/platform.py
--rw-r--r--   0 monty      (501) staff       (20)     1816 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/tools/doctor/checks/versions.py
--rw-r--r--   0 monty      (501) staff       (20)      774 2023-01-05 14:29:03.000000 slither-analyzer-0.9.3/slither/tools/doctor/utils.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.850329 slither-analyzer-0.9.3/slither/tools/documentation/
--rw-r--r--   0 monty      (501) staff       (20)        0 2023-02-14 09:06:15.000000 slither-analyzer-0.9.3/slither/tools/documentation/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     8470 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/tools/documentation/__main__.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.850611 slither-analyzer-0.9.3/slither/tools/erc_conformance/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/tools/erc_conformance/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     3136 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/tools/erc_conformance/__main__.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.851257 slither-analyzer-0.9.3/slither/tools/erc_conformance/erc/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/tools/erc_conformance/erc/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     2137 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/tools/erc_conformance/erc/erc1155.py
--rw-r--r--   0 monty      (501) staff       (20)     1412 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/tools/erc_conformance/erc/erc20.py
--rw-r--r--   0 monty      (501) staff       (20)     7555 2022-12-06 11:59:34.000000 slither-analyzer-0.9.3/slither/tools/erc_conformance/erc/ercs.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.851691 slither-analyzer-0.9.3/slither/tools/flattening/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/tools/flattening/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     3903 2022-12-06 11:59:34.000000 slither-analyzer-0.9.3/slither/tools/flattening/__main__.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.852070 slither-analyzer-0.9.3/slither/tools/flattening/export/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-08-03 15:19:25.000000 slither-analyzer-0.9.3/slither/tools/flattening/export/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     1459 2022-08-03 15:19:25.000000 slither-analyzer-0.9.3/slither/tools/flattening/export/export.py
--rw-r--r--   0 monty      (501) staff       (20)    19646 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/tools/flattening/flattening.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.852744 slither-analyzer-0.9.3/slither/tools/kspec_coverage/
--rwxr-xr-x   0 monty      (501) staff       (20)       36 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/tools/kspec_coverage/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     1820 2022-12-06 11:59:34.000000 slither-analyzer-0.9.3/slither/tools/kspec_coverage/__main__.py
--rwxr-xr-x   0 monty      (501) staff       (20)     6900 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/tools/kspec_coverage/analysis.py
--rwxr-xr-x   0 monty      (501) staff       (20)      534 2022-12-06 11:59:34.000000 slither-analyzer-0.9.3/slither/tools/kspec_coverage/kspec_coverage.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.853055 slither-analyzer-0.9.3/slither/tools/mutator/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-08-02 11:30:48.000000 slither-analyzer-0.9.3/slither/tools/mutator/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     2573 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/tools/mutator/__main__.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.854042 slither-analyzer-0.9.3/slither/tools/mutator/mutators/
--rw-r--r--   0 monty      (501) staff       (20)     1427 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/tools/mutator/mutators/MIA.py
--rw-r--r--   0 monty      (501) staff       (20)     1460 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/tools/mutator/mutators/MVIE.py
--rw-r--r--   0 monty      (501) staff       (20)     1447 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/tools/mutator/mutators/MVIV.py
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-08-02 11:30:48.000000 slither-analyzer-0.9.3/slither/tools/mutator/mutators/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     2856 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/tools/mutator/mutators/abstract_mutator.py
--rw-r--r--   0 monty      (501) staff       (20)      189 2022-08-02 11:30:48.000000 slither-analyzer-0.9.3/slither/tools/mutator/mutators/all_mutators.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.854734 slither-analyzer-0.9.3/slither/tools/mutator/utils/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-08-02 11:30:48.000000 slither-analyzer-0.9.3/slither/tools/mutator/utils/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)      970 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/tools/mutator/utils/command_line.py
--rw-r--r--   0 monty      (501) staff       (20)      944 2022-10-03 10:02:06.000000 slither-analyzer-0.9.3/slither/tools/mutator/utils/generic_patching.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.855288 slither-analyzer-0.9.3/slither/tools/possible_paths/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/tools/possible_paths/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     2844 2023-02-20 10:34:00.000000 slither-analyzer-0.9.3/slither/tools/possible_paths/__main__.py
--rw-r--r--   0 monty      (501) staff       (20)     6290 2023-02-20 10:34:00.000000 slither-analyzer-0.9.3/slither/tools/possible_paths/possible_paths.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.855834 slither-analyzer-0.9.3/slither/tools/properties/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/tools/properties/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     4232 2022-12-06 11:59:34.000000 slither-analyzer-0.9.3/slither/tools/properties/__main__.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.856150 slither-analyzer-0.9.3/slither/tools/properties/addresses/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/tools/properties/addresses/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)      740 2022-08-02 11:30:48.000000 slither-analyzer-0.9.3/slither/tools/properties/addresses/address.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.856585 slither-analyzer-0.9.3/slither/tools/properties/platforms/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/tools/properties/platforms/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)      683 2022-08-04 12:23:22.000000 slither-analyzer-0.9.3/slither/tools/properties/platforms/echidna.py
--rw-r--r--   0 monty      (501) staff       (20)     5766 2022-12-06 11:59:34.000000 slither-analyzer-0.9.3/slither/tools/properties/platforms/truffle.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.857059 slither-analyzer-0.9.3/slither/tools/properties/properties/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/tools/properties/properties/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     8234 2022-08-03 15:20:33.000000 slither-analyzer-0.9.3/slither/tools/properties/properties/erc20.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.857214 slither-analyzer-0.9.3/slither/tools/properties/properties/ercs/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/tools/properties/properties/ercs/__init__.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.857324 slither-analyzer-0.9.3/slither/tools/properties/properties/ercs/erc20/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/tools/properties/properties/ercs/erc20/__init__.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.858126 slither-analyzer-0.9.3/slither/tools/properties/properties/ercs/erc20/properties/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/tools/properties/properties/ercs/erc20/properties/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     1058 2022-08-02 11:30:48.000000 slither-analyzer-0.9.3/slither/tools/properties/properties/ercs/erc20/properties/burn.py
--rw-r--r--   0 monty      (501) staff       (20)     2656 2022-08-02 11:30:48.000000 slither-analyzer-0.9.3/slither/tools/properties/properties/ercs/erc20/properties/initialization.py
--rw-r--r--   0 monty      (501) staff       (20)      565 2022-08-03 15:19:25.000000 slither-analyzer-0.9.3/slither/tools/properties/properties/ercs/erc20/properties/mint.py
--rw-r--r--   0 monty      (501) staff       (20)      585 2022-08-02 11:30:48.000000 slither-analyzer-0.9.3/slither/tools/properties/properties/ercs/erc20/properties/mint_and_burn.py
--rw-r--r--   0 monty      (501) staff       (20)     8295 2022-08-03 15:19:25.000000 slither-analyzer-0.9.3/slither/tools/properties/properties/ercs/erc20/properties/transfer.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.858405 slither-analyzer-0.9.3/slither/tools/properties/properties/ercs/erc20/unit_tests/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/tools/properties/properties/ercs/erc20/unit_tests/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     1507 2022-08-03 15:19:25.000000 slither-analyzer-0.9.3/slither/tools/properties/properties/ercs/erc20/unit_tests/truffle.py
--rw-r--r--   0 monty      (501) staff       (20)      929 2022-08-02 11:30:48.000000 slither-analyzer-0.9.3/slither/tools/properties/properties/properties.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.858731 slither-analyzer-0.9.3/slither/tools/properties/solidity/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/tools/properties/solidity/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     3009 2022-10-03 10:02:06.000000 slither-analyzer-0.9.3/slither/tools/properties/solidity/generate_properties.py
--rw-r--r--   0 monty      (501) staff       (20)     1130 2022-12-06 11:59:34.000000 slither-analyzer-0.9.3/slither/tools/properties/utils.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.859153 slither-analyzer-0.9.3/slither/tools/read_storage/
--rw-r--r--   0 monty      (501) staff       (20)       45 2022-08-08 12:48:30.000000 slither-analyzer-0.9.3/slither/tools/read_storage/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     5119 2023-01-05 14:29:03.000000 slither-analyzer-0.9.3/slither/tools/read_storage/__main__.py
--rw-r--r--   0 monty      (501) staff       (20)    25082 2023-03-17 18:21:51.000000 slither-analyzer-0.9.3/slither/tools/read_storage/read_storage.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.859494 slither-analyzer-0.9.3/slither/tools/read_storage/utils/
--rw-r--r--   0 monty      (501) staff       (20)       67 2023-03-17 18:21:51.000000 slither-analyzer-0.9.3/slither/tools/read_storage/utils/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     2448 2023-03-17 18:21:51.000000 slither-analyzer-0.9.3/slither/tools/read_storage/utils/utils.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.860948 slither-analyzer-0.9.3/slither/tools/similarity/
--rw-r--r--   0 monty      (501) staff       (20)       30 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/tools/similarity/__init__.py
--rwxr-xr-x   0 monty      (501) staff       (20)     2701 2023-01-24 18:34:45.000000 slither-analyzer-0.9.3/slither/tools/similarity/__main__.py
--rw-r--r--   0 monty      (501) staff       (20)      552 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/tools/similarity/cache.py
--rw-r--r--   0 monty      (501) staff       (20)     7815 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/tools/similarity/encode.py
--rw-r--r--   0 monty      (501) staff       (20)     1538 2022-12-06 11:59:34.000000 slither-analyzer-0.9.3/slither/tools/similarity/info.py
--rw-r--r--   0 monty      (501) staff       (20)      357 2022-08-02 11:30:48.000000 slither-analyzer-0.9.3/slither/tools/similarity/model.py
--rw-r--r--   0 monty      (501) staff       (20)     2542 2022-12-06 11:59:34.000000 slither-analyzer-0.9.3/slither/tools/similarity/plot.py
--rw-r--r--   0 monty      (501) staff       (20)      316 2022-08-02 11:30:48.000000 slither-analyzer-0.9.3/slither/tools/similarity/similarity.py
--rwxr-xr-x   0 monty      (501) staff       (20)     1825 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/tools/similarity/test.py
--rwxr-xr-x   0 monty      (501) staff       (20)     2018 2022-12-06 11:59:34.000000 slither-analyzer-0.9.3/slither/tools/similarity/train.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.861376 slither-analyzer-0.9.3/slither/tools/slither_format/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/tools/slither_format/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     2975 2022-12-06 11:59:34.000000 slither-analyzer-0.9.3/slither/tools/slither_format/__main__.py
--rw-r--r--   0 monty      (501) staff       (20)     6791 2023-02-14 09:06:15.000000 slither-analyzer-0.9.3/slither/tools/slither_format/slither_format.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.861619 slither-analyzer-0.9.3/slither/tools/upgradeability/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/tools/upgradeability/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)    13249 2023-02-14 09:06:15.000000 slither-analyzer-0.9.3/slither/tools/upgradeability/__main__.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.862748 slither-analyzer-0.9.3/slither/tools/upgradeability/checks/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/tools/upgradeability/checks/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     5037 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/tools/upgradeability/checks/abstract_checks.py
--rw-r--r--   0 monty      (501) staff       (20)      769 2022-08-02 11:30:48.000000 slither-analyzer-0.9.3/slither/tools/upgradeability/checks/all_checks.py
--rw-r--r--   0 monty      (501) staff       (20)     5612 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/tools/upgradeability/checks/constant.py
--rw-r--r--   0 monty      (501) staff       (20)     5427 2022-10-03 10:02:06.000000 slither-analyzer-0.9.3/slither/tools/upgradeability/checks/functions_ids.py
--rw-r--r--   0 monty      (501) staff       (20)    12131 2022-10-03 10:02:06.000000 slither-analyzer-0.9.3/slither/tools/upgradeability/checks/initialization.py
--rw-r--r--   0 monty      (501) staff       (20)     1415 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/tools/upgradeability/checks/variable_initialization.py
--rw-r--r--   0 monty      (501) staff       (20)     8456 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/tools/upgradeability/checks/variables_order.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.863036 slither-analyzer-0.9.3/slither/tools/upgradeability/utils/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/tools/upgradeability/utils/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     4819 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/tools/upgradeability/utils/command_line.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.863187 slither-analyzer-0.9.3/slither/tools/utils/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/tools/utils/__init__.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.866640 slither-analyzer-0.9.3/slither/utils/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/utils/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     2520 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/utils/arithmetic.py
--rw-r--r--   0 monty      (501) staff       (20)     2182 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/utils/code_complexity.py
--rw-r--r--   0 monty      (501) staff       (20)     3537 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/utils/codex.py
--rw-r--r--   0 monty      (501) staff       (20)     3305 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/utils/colors.py
--rw-r--r--   0 monty      (501) staff       (20)    13140 2023-03-17 18:21:51.000000 slither-analyzer-0.9.3/slither/utils/command_line.py
--rw-r--r--   0 monty      (501) staff       (20)      714 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/utils/comparable_enum.py
--rw-r--r--   0 monty      (501) staff       (20)    12953 2022-10-03 10:02:06.000000 slither-analyzer-0.9.3/slither/utils/erc.py
--rw-r--r--   0 monty      (501) staff       (20)     8580 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/utils/expression_manipulations.py
--rw-r--r--   0 monty      (501) staff       (20)      326 2023-01-25 11:52:44.000000 slither-analyzer-0.9.3/slither/utils/function.py
--rw-r--r--   0 monty      (501) staff       (20)     2919 2022-08-03 15:19:25.000000 slither-analyzer-0.9.3/slither/utils/inheritance_analysis.py
--rw-r--r--   0 monty      (501) staff       (20)     1252 2023-01-25 11:52:11.000000 slither-analyzer-0.9.3/slither/utils/integer_conversion.py
--rw-r--r--   0 monty      (501) staff       (20)      641 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/utils/myprettytable.py
--rw-r--r--   0 monty      (501) staff       (20)    27059 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/utils/output.py
--rw-r--r--   0 monty      (501) staff       (20)     3225 2022-12-06 11:59:34.000000 slither-analyzer-0.9.3/slither/utils/output_capture.py
--rw-r--r--   0 monty      (501) staff       (20)   251870 2022-12-06 11:59:34.000000 slither-analyzer-0.9.3/slither/utils/oz_hashes.py
--rw-r--r--   0 monty      (501) staff       (20)     2292 2023-03-17 18:21:51.000000 slither-analyzer-0.9.3/slither/utils/source_mapping.py
--rw-r--r--   0 monty      (501) staff       (20)    11933 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/slither/utils/standard_libraries.py
--rw-r--r--   0 monty      (501) staff       (20)     1300 2022-10-03 10:02:06.000000 slither-analyzer-0.9.3/slither/utils/tests_pattern.py
--rw-r--r--   0 monty      (501) staff       (20)     6750 2023-03-17 18:21:51.000000 slither-analyzer-0.9.3/slither/utils/type.py
--rw-r--r--   0 monty      (501) staff       (20)      567 2023-03-10 15:15:31.000000 slither-analyzer-0.9.3/slither/utils/type_helpers.py
--rw-r--r--   0 monty      (501) staff       (20)      227 2023-01-25 11:50:38.000000 slither-analyzer-0.9.3/slither/utils/utils.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.866786 slither-analyzer-0.9.3/slither/visitors/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/visitors/__init__.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.868900 slither-analyzer-0.9.3/slither/visitors/expression/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/visitors/expression/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)     6961 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/visitors/expression/constants_folding.py
--rw-r--r--   0 monty      (501) staff       (20)     3595 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/visitors/expression/export_values.py
--rw-r--r--   0 monty      (501) staff       (20)    12392 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/visitors/expression/expression.py
--rw-r--r--   0 monty      (501) staff       (20)     3389 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/visitors/expression/expression_printer.py
--rw-r--r--   0 monty      (501) staff       (20)     4400 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/visitors/expression/find_calls.py
--rw-r--r--   0 monty      (501) staff       (20)     2994 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/visitors/expression/find_push.py
--rw-r--r--   0 monty      (501) staff       (20)      541 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/visitors/expression/has_conditional.py
--rw-r--r--   0 monty      (501) staff       (20)     3483 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/visitors/expression/left_value.py
--rw-r--r--   0 monty      (501) staff       (20)     5293 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/visitors/expression/read_var.py
--rw-r--r--   0 monty      (501) staff       (20)     3730 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/visitors/expression/right_value.py
--rw-r--r--   0 monty      (501) staff       (20)     5671 2023-03-17 11:08:34.000000 slither-analyzer-0.9.3/slither/visitors/expression/write_var.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.869198 slither-analyzer-0.9.3/slither/visitors/slithir/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-05-31 09:08:51.000000 slither-analyzer-0.9.3/slither/visitors/slithir/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)    26150 2023-03-17 18:21:51.000000 slither-analyzer-0.9.3/slither/visitors/slithir/expression_to_slithir.py
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.870379 slither-analyzer-0.9.3/slither_analyzer.egg-info/
--rw-r--r--   0 monty      (501) staff       (20)    27339 2023-03-17 18:25:11.000000 slither-analyzer-0.9.3/slither_analyzer.egg-info/PKG-INFO
--rw-r--r--   0 monty      (501) staff       (20)    20985 2023-03-17 18:25:11.000000 slither-analyzer-0.9.3/slither_analyzer.egg-info/SOURCES.txt
--rw-r--r--   0 monty      (501) staff       (20)        1 2023-03-17 18:25:11.000000 slither-analyzer-0.9.3/slither_analyzer.egg-info/dependency_links.txt
--rw-r--r--   0 monty      (501) staff       (20)      775 2023-03-17 18:25:11.000000 slither-analyzer-0.9.3/slither_analyzer.egg-info/entry_points.txt
--rw-r--r--   0 monty      (501) staff       (20)      184 2023-03-17 18:25:11.000000 slither-analyzer-0.9.3/slither_analyzer.egg-info/requires.txt
--rw-r--r--   0 monty      (501) staff       (20)       14 2023-03-17 18:25:11.000000 slither-analyzer-0.9.3/slither_analyzer.egg-info/top_level.txt
-drwxr-xr-x   0 monty      (501) staff       (20)        0 2023-03-17 18:25:11.872329 slither-analyzer-0.9.3/tests/
--rw-r--r--   0 monty      (501) staff       (20)        0 2022-08-03 15:19:25.000000 slither-analyzer-0.9.3/tests/__init__.py
--rw-r--r--   0 monty      (501) staff       (20)    20764 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/tests/test_ast_parsing.py
--rw-r--r--   0 monty      (501) staff       (20)     4340 2023-02-14 09:06:15.000000 slither-analyzer-0.9.3/tests/test_constant_folding.py
--rw-r--r--   0 monty      (501) staff       (20)    44160 2023-03-10 15:15:31.000000 slither-analyzer-0.9.3/tests/test_detectors.py
--rw-r--r--   0 monty      (501) staff       (20)     8731 2023-03-17 18:21:51.000000 slither-analyzer-0.9.3/tests/test_features.py
--rw-r--r--   0 monty      (501) staff       (20)    11835 2023-01-05 14:29:03.000000 slither-analyzer-0.9.3/tests/test_function.py
--rw-r--r--   0 monty      (501) staff       (20)     2946 2022-10-03 10:02:07.000000 slither-analyzer-0.9.3/tests/test_functions_ids.py
--rw-r--r--   0 monty      (501) staff       (20)     4577 2023-03-17 18:21:51.000000 slither-analyzer-0.9.3/tests/test_read_storage.py
--rw-r--r--   0 monty      (501) staff       (20)     5026 2023-03-10 10:24:06.000000 slither-analyzer-0.9.3/tests/test_source_mapping.py
--rw-r--r--   0 monty      (501) staff       (20)     1824 2023-02-14 09:06:15.000000 slither-analyzer-0.9.3/tests/test_source_unit.py
--rw-r--r--   0 monty      (501) staff       (20)    34816 2023-03-17 18:21:51.000000 slither-analyzer-0.9.3/tests/test_ssa_generation.py
--rw-r--r--   0 monty      (501) staff       (20)     1686 2022-08-08 12:48:30.000000 slither-analyzer-0.9.3/tests/test_storage_layout.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.360950 slither-analyzer-0.9.4/
+-rw-r--r--   0 runner    (1001) docker     (123)    34523 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)    28463 2023-06-26 18:41:10.360950 slither-analyzer-0.9.4/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)    28072 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/README.md
+-rw-r--r--   0 runner    (1001) docker     (123)      424 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/pyproject.toml
+-rw-r--r--   0 runner    (1001) docker     (123)       38 2023-06-26 18:41:10.360950 slither-analyzer-0.9.4/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (123)     2498 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.296949 slither-analyzer-0.9.4/slither/
+-rw-r--r--   0 runner    (1001) docker     (123)       63 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    32143 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/__main__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      310 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/all_exceptions.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.296949 slither-analyzer-0.9.4/slither/analyses/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/analyses/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.296949 slither-analyzer-0.9.4/slither/analyses/data_dependency/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/analyses/data_dependency/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    18363 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/analyses/data_dependency/data_dependency.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.296949 slither-analyzer-0.9.4/slither/analyses/evm/
+-rw-r--r--   0 runner    (1001) docker     (123)      106 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/analyses/evm/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7798 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/analyses/evm/convert.py
+-rw-r--r--   0 runner    (1001) docker     (123)      689 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/analyses/evm/evm_cfg_builder.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.296949 slither-analyzer-0.9.4/slither/analyses/write/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/analyses/write/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4184 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/analyses/write/are_variables_written.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.296949 slither-analyzer-0.9.4/slither/core/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.300950 slither-analyzer-0.9.4/slither/core/cfg/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/cfg/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    39734 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/cfg/node.py
+-rw-r--r--   0 runner    (1001) docker     (123)      483 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/cfg/scope.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.300950 slither-analyzer-0.9.4/slither/core/children/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/children/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/children/child_event.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11741 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/compilation_unit.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.300950 slither-analyzer-0.9.4/slither/core/context/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/context/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      368 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/context/context.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.300950 slither-analyzer-0.9.4/slither/core/declarations/
+-rw-r--r--   0 runner    (1001) docker     (123)      692 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/declarations/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    60320 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/declarations/contract.py
+-rw-r--r--   0 runner    (1001) docker     (123)      806 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/declarations/contract_level.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3276 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/declarations/custom_error.py
+-rw-r--r--   0 runner    (1001) docker     (123)      516 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/declarations/custom_error_contract.py
+-rw-r--r--   0 runner    (1001) docker     (123)      529 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/declarations/custom_error_top_level.py
+-rw-r--r--   0 runner    (1001) docker     (123)      883 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/declarations/enum.py
+-rw-r--r--   0 runner    (1001) docker     (123)      481 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/declarations/enum_contract.py
+-rw-r--r--   0 runner    (1001) docker     (123)      465 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/declarations/enum_top_level.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1757 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/declarations/event.py
+-rw-r--r--   0 runner    (1001) docker     (123)    69220 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/declarations/function.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5577 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/declarations/function_contract.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3851 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/declarations/function_top_level.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1112 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/declarations/import_directive.py
+-rw-r--r--   0 runner    (1001) docker     (123)      121 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/declarations/modifier.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1141 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/declarations/pragma_directive.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1522 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/declarations/solidity_import_placeholder.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7046 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/declarations/solidity_variables.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2074 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/declarations/structure.py
+-rw-r--r--   0 runner    (1001) docker     (123)      372 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/declarations/structure_contract.py
+-rw-r--r--   0 runner    (1001) docker     (123)      510 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/declarations/structure_top_level.py
+-rw-r--r--   0 runner    (1001) docker     (123)      223 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/declarations/top_level.py
+-rw-r--r--   0 runner    (1001) docker     (123)      642 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/declarations/using_for_top_level.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.300950 slither-analyzer-0.9.4/slither/core/dominators/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/dominators/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      581 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/dominators/node_dominator_tree.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3219 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/dominators/utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)      101 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/exceptions.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.304950 slither-analyzer-0.9.4/slither/core/expressions/
+-rw-r--r--   0 runner    (1001) docker     (123)      840 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/expressions/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4176 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/expressions/assignment_operation.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6059 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/expressions/binary_operation.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2241 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/expressions/call_expression.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1897 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/expressions/conditional_expression.py
+-rw-r--r--   0 runner    (1001) docker     (123)      707 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/expressions/elementary_type_name_expression.py
+-rw-r--r--   0 runner    (1001) docker     (123)      340 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/expressions/expression.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2118 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/expressions/identifier.py
+-rw-r--r--   0 runner    (1001) docker     (123)      894 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/expressions/index_access.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1749 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/expressions/literal.py
+-rw-r--r--   0 runner    (1001) docker     (123)      872 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/expressions/member_access.py
+-rw-r--r--   0 runner    (1001) docker     (123)      656 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/expressions/new_array.py
+-rw-r--r--   0 runner    (1001) docker     (123)      755 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/expressions/new_contract.py
+-rw-r--r--   0 runner    (1001) docker     (123)      455 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/expressions/new_elementary_type.py
+-rw-r--r--   0 runner    (1001) docker     (123)      122 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/expressions/super_call_expression.py
+-rw-r--r--   0 runner    (1001) docker     (123)      162 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/expressions/super_identifier.py
+-rw-r--r--   0 runner    (1001) docker     (123)      563 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/expressions/tuple_expression.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1517 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/expressions/type_conversion.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4440 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/expressions/unary_operation.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.304950 slither-analyzer-0.9.4/slither/core/scope/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/scope/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8701 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/scope/scope.py
+-rw-r--r--   0 runner    (1001) docker     (123)    22013 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/slither_core.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.304950 slither-analyzer-0.9.4/slither/core/solidity_types/
+-rw-r--r--   0 runner    (1001) docker     (123)      344 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/solidity_types/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2467 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/solidity_types/array_type.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4873 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/solidity_types/elementary_type.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2462 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/solidity_types/function_type.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1284 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/solidity_types/mapping_type.py
+-rw-r--r--   0 runner    (1001) docker     (123)      636 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/solidity_types/type.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1845 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/solidity_types/type_alias.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1646 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/solidity_types/type_information.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3065 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/solidity_types/user_defined_type.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.304950 slither-analyzer-0.9.4/slither/core/source_mapping/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/source_mapping/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7159 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/source_mapping/source_mapping.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.308950 slither-analyzer-0.9.4/slither/core/variables/
+-rw-r--r--   0 runner    (1001) docker     (123)       73 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/variables/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      547 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/variables/event_variable.py
+-rw-r--r--   0 runner    (1001) docker     (123)      185 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/variables/function_type_variable.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2239 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/variables/local_variable.py
+-rw-r--r--   0 runner    (1001) docker     (123)      693 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/variables/local_variable_init_from_tuple.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2443 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/variables/state_variable.py
+-rw-r--r--   0 runner    (1001) docker     (123)      502 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/variables/structure_variable.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1426 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/variables/top_level_variable.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5655 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/core/variables/variable.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.308950 slither-analyzer-0.9.4/slither/detectors/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10519 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/abstract_detector.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5734 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/all_detectors.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.308950 slither-analyzer-0.9.4/slither/detectors/assembly/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/assembly/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2511 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/assembly/shift_parameter_mixup.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.308950 slither-analyzer-0.9.4/slither/detectors/attributes/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/attributes/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3218 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/attributes/const_functions_asm.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3411 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/attributes/const_functions_state.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1743 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/attributes/constant_pragma.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6000 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/attributes/incorrect_solc.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4850 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/attributes/locked_ether.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5741 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/attributes/unimplemented_interface.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.308950 slither-analyzer-0.9.4/slither/detectors/compiler_bugs/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/compiler_bugs/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7714 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/compiler_bugs/array_by_reference.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2886 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/compiler_bugs/enum_conversion.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2560 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/compiler_bugs/multiple_constructor_schemes.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3741 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/compiler_bugs/public_mapping_nested.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6196 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/compiler_bugs/reused_base_constructor.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5574 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/compiler_bugs/storage_ABIEncoderV2_array.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5740 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/compiler_bugs/storage_signed_integer_array.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5086 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/compiler_bugs/uninitialized_function_ptr_in_constructor.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.308950 slither-analyzer-0.9.4/slither/detectors/erc/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/erc/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.312950 slither-analyzer-0.9.4/slither/detectors/erc/erc20/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/erc/erc20/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3983 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/erc/erc20/arbitrary_send_erc20.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1713 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/erc/erc20/arbitrary_send_erc20_no_permit.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2059 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/erc/erc20/arbitrary_send_erc20_permit.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4327 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/erc/erc20/incorrect_erc20_interface.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4752 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/erc/incorrect_erc721_interface.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4012 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/erc/unindexed_event_parameters.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.312950 slither-analyzer-0.9.4/slither/detectors/examples/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/examples/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1287 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/examples/backdoor.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.312950 slither-analyzer-0.9.4/slither/detectors/functions/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/functions/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5093 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/functions/arbitrary_send_eth.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4337 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/functions/codex.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1856 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/functions/cyclomatic_complexity.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2914 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/functions/dead_code.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12558 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/functions/external_function.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3314 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/functions/modifier.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3483 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/functions/permit_domain_signature_collision.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2964 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/functions/protected_variable.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2565 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/functions/suicidal.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4452 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/functions/unimplemented.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.312950 slither-analyzer-0.9.4/slither/detectors/naming_convention/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/naming_convention/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8306 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/naming_convention/naming_convention.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.316950 slither-analyzer-0.9.4/slither/detectors/operations/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/operations/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4662 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/operations/bad_prng.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3421 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/operations/block_timestamp.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8895 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/operations/cache_array_length.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3814 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/operations/encode_packed.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2553 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/operations/low_level_calls.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4493 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/operations/missing_events_access_control.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5179 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/operations/missing_events_arithmetic.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6633 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/operations/missing_zero_address_validation.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1545 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/operations/unchecked_low_level_return_values.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1442 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/operations/unchecked_send_return_value.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2099 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/operations/unchecked_transfer.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4623 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/operations/unused_return_values.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1671 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/operations/void_constructor.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.316950 slither-analyzer-0.9.4/slither/detectors/reentrancy/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/reentrancy/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10740 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/reentrancy/reentrancy.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7600 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/reentrancy/reentrancy_benign.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8599 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/reentrancy/reentrancy_eth.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7236 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/reentrancy/reentrancy_events.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9222 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/reentrancy/reentrancy_no_gas.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7125 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/reentrancy/reentrancy_read_before_write.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3692 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/reentrancy/token.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.316950 slither-analyzer-0.9.4/slither/detectors/shadowing/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/shadowing/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2795 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/shadowing/abstract.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6815 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/shadowing/builtin_symbols.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1164 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/shadowing/common.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6587 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/shadowing/local.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2870 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/shadowing/state.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.316950 slither-analyzer-0.9.4/slither/detectors/slither/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/slither/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4657 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/slither/name_reused.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.316950 slither-analyzer-0.9.4/slither/detectors/source/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/source/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3479 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/source/rtlo.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.320950 slither-analyzer-0.9.4/slither/detectors/statements/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/statements/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5711 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/statements/array_length_assignment.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2213 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/statements/assembly.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3467 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/statements/assert_state_change.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3159 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/statements/boolean_constant_equality.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4487 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/statements/boolean_constant_misuse.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3123 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/statements/calls_in_loop.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2704 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/statements/controlled_delegatecall.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3622 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/statements/costly_operations_in_loop.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3463 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/statements/delegatecall_in_loop.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7763 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/statements/deprecated_calls.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7618 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/statements/divide_before_multiply.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7608 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/statements/incorrect_strict_equality.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8455 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/statements/incorrect_using_for.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3489 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/statements/mapping_deletion.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2897 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/statements/msg_value_in_loop.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3493 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/statements/redundant_statements.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3512 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/statements/too_many_digits.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3056 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/statements/tx_origin.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5905 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/statements/type_based_tautology.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3765 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/statements/unary.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5222 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/statements/unprotected_upgradeable.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4910 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/statements/write_after_write.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.324950 slither-analyzer-0.9.4/slither/detectors/variables/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/variables/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2060 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/variables/could_be_constant.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2037 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/variables/could_be_immutable.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4975 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/variables/function_init_state_variables.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6911 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/variables/predeclaration_usage_local.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3546 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/variables/similar_variables.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4793 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/variables/unchanged_state_variables.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4804 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/variables/uninitialized_local_variables.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5947 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/variables/uninitialized_state_variables.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4218 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/variables/uninitialized_storage_variables.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3282 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/variables/unused_state_variables.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2347 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/detectors/variables/var_read_using_this.py
+-rw-r--r--   0 runner    (1001) docker     (123)       93 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/exceptions.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.324950 slither-analyzer-0.9.4/slither/formatters/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/formatters/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.324950 slither-analyzer-0.9.4/slither/formatters/attributes/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/formatters/attributes/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2200 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/formatters/attributes/const_functions.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3084 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/formatters/attributes/constant_pragma.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2369 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/formatters/attributes/incorrect_solc.py
+-rw-r--r--   0 runner    (1001) docker     (123)      149 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/formatters/exceptions.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.324950 slither-analyzer-0.9.4/slither/formatters/functions/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/formatters/functions/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2497 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/formatters/functions/external_function.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.324950 slither-analyzer-0.9.4/slither/formatters/naming_convention/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/formatters/naming_convention/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    27353 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/formatters/naming_convention/naming_convention.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.324950 slither-analyzer-0.9.4/slither/formatters/utils/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/formatters/utils/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1859 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/formatters/utils/patches.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.324950 slither-analyzer-0.9.4/slither/formatters/variables/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/formatters/variables/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2027 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/formatters/variables/unchanged_state_variables.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1222 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/formatters/variables/unused_state_variables.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.324950 slither-analyzer-0.9.4/slither/printers/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/printers/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1746 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/printers/abstract_printer.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1135 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/printers/all_printers.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.324950 slither-analyzer-0.9.4/slither/printers/call/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/printers/call/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8923 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/printers/call/call_graph.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.324950 slither-analyzer-0.9.4/slither/printers/functions/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/printers/functions/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2618 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/printers/functions/authorization.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1285 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/printers/functions/cfg.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1208 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/printers/functions/dominator.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.324950 slither-analyzer-0.9.4/slither/printers/guidance/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/printers/guidance/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17840 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/printers/guidance/echidna.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.324950 slither-analyzer-0.9.4/slither/printers/inheritance/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/printers/inheritance/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2998 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/printers/inheritance/inheritance.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8275 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/printers/inheritance/inheritance_graph.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.328950 slither-analyzer-0.9.4/slither/printers/summary/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/printers/summary/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2185 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/printers/summary/constructor_calls.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3462 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/printers/summary/contract.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2151 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/printers/summary/data_depenency.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2704 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/printers/summary/declaration.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5244 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/printers/summary/evm.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3945 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/printers/summary/function.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1698 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/printers/summary/function_ids.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14949 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/printers/summary/human_summary.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1204 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/printers/summary/loc.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1578 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/printers/summary/modifier_calls.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1939 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/printers/summary/require_calls.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1876 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/printers/summary/slithir.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1648 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/printers/summary/slithir_ssa.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1389 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/printers/summary/variable_order.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1942 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/printers/summary/when_not_paused.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9344 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slither.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.328950 slither-analyzer-0.9.4/slither/slithir/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    74572 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/convert.py
+-rw-r--r--   0 runner    (1001) docker     (123)       97 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/exceptions.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.332950 slither-analyzer-0.9.4/slither/slithir/operations/
+-rw-r--r--   0 runner    (1001) docker     (123)     1073 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/operations/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1992 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/operations/assignment.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5225 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/operations/binary.py
+-rw-r--r--   0 runner    (1001) docker     (123)      949 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/operations/call.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1193 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/operations/codesize.py
+-rw-r--r--   0 runner    (1001) docker     (123)      666 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/operations/condition.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1340 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/operations/delete.py
+-rw-r--r--   0 runner    (1001) docker     (123)      622 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/operations/event_call.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6958 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/operations/high_level_call.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1709 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/operations/index.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1531 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/operations/init_array.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3250 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/operations/internal_call.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2815 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/operations/internal_dynamic_call.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1401 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/operations/length.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2011 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/operations/library_call.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4141 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/operations/low_level_call.py
+-rw-r--r--   0 runner    (1001) docker     (123)      620 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/operations/lvalue.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2835 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/operations/member.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1159 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/operations/new_array.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3759 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/operations/new_contract.py
+-rw-r--r--   0 runner    (1001) docker     (123)      790 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/operations/new_elementary_type.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1476 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/operations/new_structure.py
+-rw-r--r--   0 runner    (1001) docker     (123)      320 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/operations/nop.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1745 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/operations/operation.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1686 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/operations/phi.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1575 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/operations/phi_callback.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1885 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/operations/return_operation.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1683 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/operations/send.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1885 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/operations/solidity_call.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1218 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/operations/transfer.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1689 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/operations/type_conversion.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2014 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/operations/unary.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1310 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/operations/unpack.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.332950 slither-analyzer-0.9.4/slither/slithir/tmp_operations/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/tmp_operations/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1201 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/tmp_operations/argument.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2895 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/tmp_operations/tmp_call.py
+-rw-r--r--   0 runner    (1001) docker     (123)      685 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/tmp_operations/tmp_new_array.py
+-rw-r--r--   0 runner    (1001) docker     (123)      947 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/tmp_operations/tmp_new_contract.py
+-rw-r--r--   0 runner    (1001) docker     (123)      648 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/tmp_operations/tmp_new_elementary_type.py
+-rw-r--r--   0 runner    (1001) docker     (123)      478 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/tmp_operations/tmp_new_structure.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.332950 slither-analyzer-0.9.4/slither/slithir/utils/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/utils/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    34585 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/utils/ssa.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1490 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/utils/utils.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.336950 slither-analyzer-0.9.4/slither/slithir/variables/
+-rw-r--r--   0 runner    (1001) docker     (123)      370 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/variables/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2626 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/variables/constant.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2434 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/variables/local_variable.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2153 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/variables/reference.py
+-rw-r--r--   0 runner    (1001) docker     (123)      704 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/variables/reference_ssa.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1387 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/variables/state_variable.py
+-rw-r--r--   0 runner    (1001) docker     (123)      873 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/variables/temporary.py
+-rw-r--r--   0 runner    (1001) docker     (123)      789 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/variables/temporary_ssa.py
+-rw-r--r--   0 runner    (1001) docker     (123)      881 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/variables/tuple.py
+-rw-r--r--   0 runner    (1001) docker     (123)      522 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/variables/tuple_ssa.py
+-rw-r--r--   0 runner    (1001) docker     (123)      327 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/slithir/variables/variable.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.336950 slither-analyzer-0.9.4/slither/solc_parsing/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/solc_parsing/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.336950 slither-analyzer-0.9.4/slither/solc_parsing/cfg/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/solc_parsing/cfg/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3009 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/solc_parsing/cfg/node.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.336950 slither-analyzer-0.9.4/slither/solc_parsing/declarations/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/solc_parsing/declarations/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      913 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/solc_parsing/declarations/caller_context.py
+-rw-r--r--   0 runner    (1001) docker     (123)    36106 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/solc_parsing/declarations/contract.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4181 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/solc_parsing/declarations/custom_error.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2103 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/solc_parsing/declarations/event.py
+-rw-r--r--   0 runner    (1001) docker     (123)    63686 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/solc_parsing/declarations/function.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3792 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/solc_parsing/declarations/modifier.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1925 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/solc_parsing/declarations/structure_contract.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2610 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/solc_parsing/declarations/structure_top_level.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8072 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/solc_parsing/declarations/using_for_top_level.py
+-rw-r--r--   0 runner    (1001) docker     (123)      150 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/solc_parsing/exceptions.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.336950 slither-analyzer-0.9.4/slither/solc_parsing/expressions/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/solc_parsing/expressions/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    27772 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/solc_parsing/expressions/expression_parsing.py
+-rw-r--r--   0 runner    (1001) docker     (123)    16797 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/solc_parsing/expressions/find_variable.py
+-rw-r--r--   0 runner    (1001) docker     (123)    36018 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/solc_parsing/slither_compilation_unit_solc.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.336950 slither-analyzer-0.9.4/slither/solc_parsing/solidity_types/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/solc_parsing/solidity_types/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    20463 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/solc_parsing/solidity_types/type_parsing.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.336950 slither-analyzer-0.9.4/slither/solc_parsing/variables/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/solc_parsing/variables/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      991 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/solc_parsing/variables/event_variable.py
+-rw-r--r--   0 runner    (1001) docker     (123)      602 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/solc_parsing/variables/function_type_variable.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1268 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/solc_parsing/variables/local_variable.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1412 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/solc_parsing/variables/local_variable_init_from_tuple.py
+-rw-r--r--   0 runner    (1001) docker     (123)      567 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/solc_parsing/variables/state_variable.py
+-rw-r--r--   0 runner    (1001) docker     (123)      583 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/solc_parsing/variables/structure_variable.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1446 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/solc_parsing/variables/top_level_variable.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8341 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/solc_parsing/variables/variable_declaration.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.340950 slither-analyzer-0.9.4/slither/solc_parsing/yul/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/solc_parsing/yul/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5387 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/solc_parsing/yul/evm_functions.py
+-rw-r--r--   0 runner    (1001) docker     (123)    30919 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/solc_parsing/yul/parse_yul.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.340950 slither-analyzer-0.9.4/slither/tools/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.340950 slither-analyzer-0.9.4/slither/tools/demo/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/demo/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      927 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/demo/__main__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.340950 slither-analyzer-0.9.4/slither/tools/doctor/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/doctor/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1025 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/doctor/__main__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.340950 slither-analyzer-0.9.4/slither/tools/doctor/checks/
+-rw-r--r--   0 runner    (1001) docker     (123)      585 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/doctor/checks/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2857 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/doctor/checks/paths.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2249 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/doctor/checks/platform.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1849 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/doctor/checks/versions.py
+-rw-r--r--   0 runner    (1001) docker     (123)      774 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/doctor/utils.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.340950 slither-analyzer-0.9.4/slither/tools/documentation/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/documentation/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8470 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/documentation/__main__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.340950 slither-analyzer-0.9.4/slither/tools/erc_conformance/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/erc_conformance/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3136 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/erc_conformance/__main__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.340950 slither-analyzer-0.9.4/slither/tools/erc_conformance/erc/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/erc_conformance/erc/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2137 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/erc_conformance/erc/erc1155.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1412 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/erc_conformance/erc/erc20.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7555 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/erc_conformance/erc/ercs.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.340950 slither-analyzer-0.9.4/slither/tools/flattening/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/flattening/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3903 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/flattening/__main__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.340950 slither-analyzer-0.9.4/slither/tools/flattening/export/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/flattening/export/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1464 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/flattening/export/export.py
+-rw-r--r--   0 runner    (1001) docker     (123)    20013 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/flattening/flattening.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.340950 slither-analyzer-0.9.4/slither/tools/interface/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/interface/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2979 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/interface/__main__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.340950 slither-analyzer-0.9.4/slither/tools/kspec_coverage/
+-rwxr-xr-x   0 runner    (1001) docker     (123)       36 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/kspec_coverage/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1820 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/kspec_coverage/__main__.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     6900 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/kspec_coverage/analysis.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)      534 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/kspec_coverage/kspec_coverage.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.344950 slither-analyzer-0.9.4/slither/tools/mutator/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/mutator/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2649 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/mutator/__main__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.344950 slither-analyzer-0.9.4/slither/tools/mutator/mutators/
+-rw-r--r--   0 runner    (1001) docker     (123)     1427 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/mutator/mutators/MIA.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1460 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/mutator/mutators/MVIE.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1447 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/mutator/mutators/MVIV.py
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/mutator/mutators/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3003 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/mutator/mutators/abstract_mutator.py
+-rw-r--r--   0 runner    (1001) docker     (123)      189 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/mutator/mutators/all_mutators.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.344950 slither-analyzer-0.9.4/slither/tools/mutator/utils/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/mutator/utils/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      975 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/mutator/utils/command_line.py
+-rw-r--r--   0 runner    (1001) docker     (123)      944 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/mutator/utils/generic_patching.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.344950 slither-analyzer-0.9.4/slither/tools/possible_paths/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/possible_paths/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2844 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/possible_paths/__main__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6290 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/possible_paths/possible_paths.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.344950 slither-analyzer-0.9.4/slither/tools/properties/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/properties/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4232 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/properties/__main__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.344950 slither-analyzer-0.9.4/slither/tools/properties/addresses/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/properties/addresses/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      740 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/properties/addresses/address.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.344950 slither-analyzer-0.9.4/slither/tools/properties/platforms/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/properties/platforms/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      683 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/properties/platforms/echidna.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5766 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/properties/platforms/truffle.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.344950 slither-analyzer-0.9.4/slither/tools/properties/properties/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/properties/properties/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8234 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/properties/properties/erc20.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.344950 slither-analyzer-0.9.4/slither/tools/properties/properties/ercs/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/properties/properties/ercs/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.344950 slither-analyzer-0.9.4/slither/tools/properties/properties/ercs/erc20/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/properties/properties/ercs/erc20/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.344950 slither-analyzer-0.9.4/slither/tools/properties/properties/ercs/erc20/properties/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/properties/properties/ercs/erc20/properties/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1058 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/properties/properties/ercs/erc20/properties/burn.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2656 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/properties/properties/ercs/erc20/properties/initialization.py
+-rw-r--r--   0 runner    (1001) docker     (123)      565 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/properties/properties/ercs/erc20/properties/mint.py
+-rw-r--r--   0 runner    (1001) docker     (123)      585 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/properties/properties/ercs/erc20/properties/mint_and_burn.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8295 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/properties/properties/ercs/erc20/properties/transfer.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.348950 slither-analyzer-0.9.4/slither/tools/properties/properties/ercs/erc20/unit_tests/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/properties/properties/ercs/erc20/unit_tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1507 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/properties/properties/ercs/erc20/unit_tests/truffle.py
+-rw-r--r--   0 runner    (1001) docker     (123)      929 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/properties/properties/properties.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.348950 slither-analyzer-0.9.4/slither/tools/properties/solidity/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/properties/solidity/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3009 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/properties/solidity/generate_properties.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1130 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/properties/utils.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.348950 slither-analyzer-0.9.4/slither/tools/read_storage/
+-rw-r--r--   0 runner    (1001) docker     (123)       54 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/read_storage/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5360 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/read_storage/__main__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    37543 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/read_storage/read_storage.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.348950 slither-analyzer-0.9.4/slither/tools/read_storage/utils/
+-rw-r--r--   0 runner    (1001) docker     (123)       67 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/read_storage/utils/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2572 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/read_storage/utils/utils.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.348950 slither-analyzer-0.9.4/slither/tools/similarity/
+-rw-r--r--   0 runner    (1001) docker     (123)       30 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/similarity/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     2701 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/similarity/__main__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      635 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/similarity/cache.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7815 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/similarity/encode.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1538 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/similarity/info.py
+-rw-r--r--   0 runner    (1001) docker     (123)      357 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/similarity/model.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2542 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/similarity/plot.py
+-rw-r--r--   0 runner    (1001) docker     (123)      316 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/similarity/similarity.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     1825 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/similarity/test.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     2018 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/similarity/train.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.348950 slither-analyzer-0.9.4/slither/tools/slither_format/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/slither_format/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2975 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/slither_format/__main__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6791 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/slither_format/slither_format.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.348950 slither-analyzer-0.9.4/slither/tools/upgradeability/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/upgradeability/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13249 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/upgradeability/__main__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.348950 slither-analyzer-0.9.4/slither/tools/upgradeability/checks/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/upgradeability/checks/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5050 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/upgradeability/checks/abstract_checks.py
+-rw-r--r--   0 runner    (1001) docker     (123)      769 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/upgradeability/checks/all_checks.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5952 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/upgradeability/checks/constant.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5427 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/upgradeability/checks/functions_ids.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12131 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/upgradeability/checks/initialization.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1524 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/upgradeability/checks/variable_initialization.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8563 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/upgradeability/checks/variables_order.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.352950 slither-analyzer-0.9.4/slither/tools/upgradeability/utils/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/upgradeability/utils/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4825 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/upgradeability/utils/command_line.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.352950 slither-analyzer-0.9.4/slither/tools/utils/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/tools/utils/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.352950 slither-analyzer-0.9.4/slither/utils/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/utils/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2520 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/utils/arithmetic.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2206 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/utils/code_complexity.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8092 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/utils/code_generation.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3537 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/utils/codex.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3329 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/utils/colors.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14761 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/utils/command_line.py
+-rw-r--r--   0 runner    (1001) docker     (123)      714 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/utils/comparable_enum.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12953 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/utils/erc.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8784 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/utils/expression_manipulations.py
+-rw-r--r--   0 runner    (1001) docker     (123)      326 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/utils/function.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2919 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/utils/inheritance_analysis.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1342 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/utils/integer_conversion.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3218 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/utils/loc.py
+-rw-r--r--   0 runner    (1001) docker     (123)      702 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/utils/myprettytable.py
+-rw-r--r--   0 runner    (1001) docker     (123)    27046 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/utils/output.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3225 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/utils/output_capture.py
+-rw-r--r--   0 runner    (1001) docker     (123)   251870 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/utils/oz_hashes.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2292 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/utils/source_mapping.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11933 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/utils/standard_libraries.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1300 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/utils/tests_pattern.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7196 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/utils/type.py
+-rw-r--r--   0 runner    (1001) docker     (123)      567 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/utils/type_helpers.py
+-rw-r--r--   0 runner    (1001) docker     (123)    30264 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/utils/upgradeability.py
+-rw-r--r--   0 runner    (1001) docker     (123)      227 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/utils/utils.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.352950 slither-analyzer-0.9.4/slither/visitors/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/visitors/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.356950 slither-analyzer-0.9.4/slither/visitors/expression/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/visitors/expression/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11548 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/visitors/expression/constants_folding.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4204 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/visitors/expression/export_values.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12460 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/visitors/expression/expression.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4237 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/visitors/expression/expression_printer.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4644 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/visitors/expression/find_calls.py
+-rw-r--r--   0 runner    (1001) docker     (123)      556 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/visitors/expression/has_conditional.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5620 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/visitors/expression/read_var.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5914 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/visitors/expression/write_var.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.356950 slither-analyzer-0.9.4/slither/visitors/slithir/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/visitors/slithir/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    27707 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/slither/visitors/slithir/expression_to_slithir.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.356950 slither-analyzer-0.9.4/slither_analyzer.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (123)    28463 2023-06-26 18:41:10.000000 slither-analyzer-0.9.4/slither_analyzer.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)    21926 2023-06-26 18:41:10.000000 slither-analyzer-0.9.4/slither_analyzer.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-06-26 18:41:10.000000 slither-analyzer-0.9.4/slither_analyzer.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      833 2023-06-26 18:41:10.000000 slither-analyzer-0.9.4/slither_analyzer.egg-info/entry_points.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      345 2023-06-26 18:41:10.000000 slither-analyzer-0.9.4/slither_analyzer.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       14 2023-06-26 18:41:10.000000 slither-analyzer-0.9.4/slither_analyzer.egg-info/top_level.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.356950 slither-analyzer-0.9.4/tests/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2443 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/tests/conftest.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.356950 slither-analyzer-0.9.4/tests/e2e/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/tests/e2e/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.356950 slither-analyzer-0.9.4/tests/e2e/compilation/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/tests/e2e/compilation/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1476 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/tests/e2e/compilation/test_resolution.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1960 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/tests/e2e/compilation/test_source_unit.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.356950 slither-analyzer-0.9.4/tests/e2e/detectors/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:40:59.000000 slither-analyzer-0.9.4/tests/e2e/detectors/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    42416 2023-06-26 18:41:00.000000 slither-analyzer-0.9.4/tests/e2e/detectors/test_detectors.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.356950 slither-analyzer-0.9.4/tests/e2e/solc_parsing/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:00.000000 slither-analyzer-0.9.4/tests/e2e/solc_parsing/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    21918 2023-06-26 18:41:00.000000 slither-analyzer-0.9.4/tests/e2e/solc_parsing/test_ast_parsing.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.356950 slither-analyzer-0.9.4/tests/tools/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:00.000000 slither-analyzer-0.9.4/tests/tools/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.356950 slither-analyzer-0.9.4/tests/tools/read-storage/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:00.000000 slither-analyzer-0.9.4/tests/tools/read-storage/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1597 2023-06-26 18:41:00.000000 slither-analyzer-0.9.4/tests/tools/read-storage/conftest.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3314 2023-06-26 18:41:00.000000 slither-analyzer-0.9.4/tests/tools/read-storage/test_read_storage.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.356950 slither-analyzer-0.9.4/tests/unit/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:00.000000 slither-analyzer-0.9.4/tests/unit/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.360950 slither-analyzer-0.9.4/tests/unit/core/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:00.000000 slither-analyzer-0.9.4/tests/unit/core/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1529 2023-06-26 18:41:00.000000 slither-analyzer-0.9.4/tests/unit/core/test_arithmetic.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2216 2023-06-26 18:41:00.000000 slither-analyzer-0.9.4/tests/unit/core/test_code_comments.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5460 2023-06-26 18:41:00.000000 slither-analyzer-0.9.4/tests/unit/core/test_constant_folding.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1875 2023-06-26 18:41:00.000000 slither-analyzer-0.9.4/tests/unit/core/test_contract_declaration.py
+-rw-r--r--   0 runner    (1001) docker     (123)      609 2023-06-26 18:41:00.000000 slither-analyzer-0.9.4/tests/unit/core/test_error_messages.py
+-rw-r--r--   0 runner    (1001) docker     (123)      769 2023-06-26 18:41:00.000000 slither-analyzer-0.9.4/tests/unit/core/test_fallback_receive.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12169 2023-06-26 18:41:00.000000 slither-analyzer-0.9.4/tests/unit/core/test_function_declaration.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4422 2023-06-26 18:41:00.000000 slither-analyzer-0.9.4/tests/unit/core/test_source_mapping.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1686 2023-06-26 18:41:00.000000 slither-analyzer-0.9.4/tests/unit/core/test_storage_layout.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4112 2023-06-26 18:41:00.000000 slither-analyzer-0.9.4/tests/unit/core/test_using_for.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.360950 slither-analyzer-0.9.4/tests/unit/slithir/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:00.000000 slither-analyzer-0.9.4/tests/unit/slithir/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2088 2023-06-26 18:41:00.000000 slither-analyzer-0.9.4/tests/unit/slithir/test_operation_reads.py
+-rw-r--r--   0 runner    (1001) docker     (123)    37161 2023-06-26 18:41:00.000000 slither-analyzer-0.9.4/tests/unit/slithir/test_ssa_generation.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1803 2023-06-26 18:41:00.000000 slither-analyzer-0.9.4/tests/unit/slithir/test_ternary_expressions.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:10.360950 slither-analyzer-0.9.4/tests/unit/utils/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-26 18:41:00.000000 slither-analyzer-0.9.4/tests/unit/utils/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1000 2023-06-26 18:41:00.000000 slither-analyzer-0.9.4/tests/unit/utils/test_code_generation.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2983 2023-06-26 18:41:00.000000 slither-analyzer-0.9.4/tests/unit/utils/test_functions_ids.py
+-rw-r--r--   0 runner    (1001) docker     (123)      466 2023-06-26 18:41:00.000000 slither-analyzer-0.9.4/tests/unit/utils/test_type_helpers.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4685 2023-06-26 18:41:00.000000 slither-analyzer-0.9.4/tests/unit/utils/test_upgradeability_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)      484 2023-06-26 18:41:00.000000 slither-analyzer-0.9.4/tests/utils.py
```

### Comparing `slither-analyzer-0.9.3/LICENSE` & `slither-analyzer-0.9.4/LICENSE`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/PKG-INFO` & `slither-analyzer-0.9.4/PKG-INFO`

 * *Files 2% similar despite different names*

```diff
@@ -1,21 +1,25 @@
 Metadata-Version: 2.1
 Name: slither-analyzer
-Version: 0.9.3
+Version: 0.9.4
 Summary: Slither is a Solidity static analysis framework written in Python 3.
 Home-page: https://github.com/crytic/slither
 Author: Trail of Bits
 License: AGPL-3.0
 Requires-Python: >=3.8
 Description-Content-Type: text/markdown
+Provides-Extra: lint
+Provides-Extra: test
+Provides-Extra: doc
 Provides-Extra: dev
 License-File: LICENSE
 
 # Slither, the Solidity source analyzer
-<img src="./logo.png" alt="Logo" width="500"/>
+
+<img src="https://raw.githubusercontent.com/crytic/slither/master/logo.png" alt="Logo" width="500"/>
 
 [![Build Status](https://img.shields.io/github/actions/workflow/status/crytic/slither/ci.yml?branch=master)](https://github.com/crytic/slither/actions?query=workflow%3ACI)
 [![Slack Status](https://empireslacking.herokuapp.com/badge.svg)](https://empireslacking.herokuapp.com)
 [![PyPI version](https://badge.fury.io/py/slither-analyzer.svg)](https://badge.fury.io/py/slither-analyzer)
 
 Slither is a Solidity static analysis framework written in Python3. It runs a suite of vulnerability detectors, prints visual information about contract details, and provides an API to easily write custom analyses. Slither enables developers to find vulnerabilities, enhance their code comprehension, and quickly prototype custom analyses.
 
@@ -28,34 +32,37 @@
 - [API Documentation](#api-documentation)
 - [Getting Help](#getting-help)
 - [FAQ](#faq)
 - [Publications](#publications)
 
 ## Features
 
-* Detects vulnerable Solidity code with low false positives (see the list of [trophies](./trophies.md))
-* Identifies where the error condition occurs in the source code
-* Easily integrates into continuous integration and Hardhat/Foundry builds
-* Built-in 'printers' quickly report crucial contract information
-* Detector API to write custom analyses in Python
-* Ability to analyze contracts written with Solidity >= 0.4
-* Intermediate representation ([SlithIR](https://github.com/trailofbits/slither/wiki/SlithIR)) enables simple, high-precision analyses
-* Correctly parses 99.9% of all public Solidity code
-* Average execution time of less than 1 second per contract
-* Integrates with Github's code scanning in [CI](https://github.com/marketplace/actions/slither-action)
+- Detects vulnerable Solidity code with low false positives (see the list of [trophies](./trophies.md))
+- Identifies where the error condition occurs in the source code
+- Easily integrates into continuous integration and Hardhat/Foundry builds
+- Built-in 'printers' quickly report crucial contract information
+- Detector API to write custom analyses in Python
+- Ability to analyze contracts written with Solidity >= 0.4
+- Intermediate representation ([SlithIR](https://github.com/trailofbits/slither/wiki/SlithIR)) enables simple, high-precision analyses
+- Correctly parses 99.9% of all public Solidity code
+- Average execution time of less than 1 second per contract
+- Integrates with Github's code scanning in [CI](https://github.com/marketplace/actions/slither-action)
 
 ## Usage
 
 Run Slither on a Hardhat/Foundry/Dapp/Brownie application:
+
 ```bash
 slither .
 ```
+
 This is the preferred option if your project has dependencies as Slither relies on the underlying compilation framework to compile source code.
 
 However, you can run Slither on a single file that does not import dependencies:
+
 ```bash
 slither tests/uninitialized.sol
 ```
 
 ## How to install
 
 Slither requires Python 3.8+.
@@ -87,182 +94,192 @@
 To share a directory in the container:
 
 ```bash
 docker run -it -v /home/share:/share trailofbits/eth-security-toolbox
 ```
 
 ### Integration
+
 - For GitHub action integration, use [slither-action](https://github.com/marketplace/actions/slither-action).
 - To generate a Markdown report, use `slither [target] --checklist`.
 - To generate a Markdown with GitHub source code highlighting, use `slither [target] --checklist --markdown-root https://github.com/ORG/REPO/blob/COMMIT/` (replace `ORG`, `REPO`, `COMMIT`)
 
 ## Detectors
 
-
 Num | Detector | What it Detects | Impact | Confidence
 --- | --- | --- | --- | ---
 1 | `abiencoderv2-array` | [Storage abiencoderv2 array](https://github.com/crytic/slither/wiki/Detector-Documentation#storage-abiencoderv2-array) | High | High
 2 | `arbitrary-send-erc20` | [transferFrom uses arbitrary `from`](https://github.com/crytic/slither/wiki/Detector-Documentation#arbitrary-from-in-transferfrom) | High | High
 3 | `array-by-reference` | [Modifying storage array by value](https://github.com/crytic/slither/wiki/Detector-Documentation#modifying-storage-array-by-value) | High | High
-4 | `incorrect-shift` | [The order of parameters in a shift instruction is incorrect.](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-shift-in-assembly) | High | High
-5 | `multiple-constructors` | [Multiple constructor schemes](https://github.com/crytic/slither/wiki/Detector-Documentation#multiple-constructor-schemes) | High | High
-6 | `name-reused` | [Contract's name reused](https://github.com/crytic/slither/wiki/Detector-Documentation#name-reused) | High | High
-7 | `protected-vars` | [Detected unprotected variables](https://github.com/crytic/slither/wiki/Detector-Documentation#protected-variables) | High | High
-8 | `public-mappings-nested` | [Public mappings with nested variables](https://github.com/crytic/slither/wiki/Detector-Documentation#public-mappings-with-nested-variables) | High | High
-9 | `rtlo` | [Right-To-Left-Override control character is used](https://github.com/crytic/slither/wiki/Detector-Documentation#right-to-left-override-character) | High | High
-10 | `shadowing-state` | [State variables shadowing](https://github.com/crytic/slither/wiki/Detector-Documentation#state-variable-shadowing) | High | High
-11 | `suicidal` | [Functions allowing anyone to destruct the contract](https://github.com/crytic/slither/wiki/Detector-Documentation#suicidal) | High | High
-12 | `uninitialized-state` | [Uninitialized state variables](https://github.com/crytic/slither/wiki/Detector-Documentation#uninitialized-state-variables) | High | High
-13 | `uninitialized-storage` | [Uninitialized storage variables](https://github.com/crytic/slither/wiki/Detector-Documentation#uninitialized-storage-variables) | High | High
-14 | `unprotected-upgrade` | [Unprotected upgradeable contract](https://github.com/crytic/slither/wiki/Detector-Documentation#unprotected-upgradeable-contract) | High | High
-15 | `codex` | [Use Codex to find vulnerabilities.](https://github.com/crytic/slither/wiki/Detector-Documentation#codex) | High | Low
-16 | `arbitrary-send-erc20-permit` | [transferFrom uses arbitrary from with permit](https://github.com/crytic/slither/wiki/Detector-Documentation#arbitrary-from-in-transferfrom-used-with-permit) | High | Medium
-17 | `arbitrary-send-eth` | [Functions that send Ether to arbitrary destinations](https://github.com/crytic/slither/wiki/Detector-Documentation#functions-that-send-ether-to-arbitrary-destinations) | High | Medium
-18 | `controlled-array-length` | [Tainted array length assignment](https://github.com/crytic/slither/wiki/Detector-Documentation#array-length-assignment) | High | Medium
-19 | `controlled-delegatecall` | [Controlled delegatecall destination](https://github.com/crytic/slither/wiki/Detector-Documentation#controlled-delegatecall) | High | Medium
-20 | `delegatecall-loop` | [Payable functions using `delegatecall` inside a loop](https://github.com/crytic/slither/wiki/Detector-Documentation/#payable-functions-using-delegatecall-inside-a-loop) | High | Medium
-21 | `msg-value-loop` | [msg.value inside a loop](https://github.com/crytic/slither/wiki/Detector-Documentation/#msgvalue-inside-a-loop) | High | Medium
-22 | `reentrancy-eth` | [Reentrancy vulnerabilities (theft of ethers)](https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities) | High | Medium
-23 | `storage-array` | [Signed storage integer array compiler bug](https://github.com/crytic/slither/wiki/Detector-Documentation#storage-signed-integer-array) | High | Medium
-24 | `unchecked-transfer` | [Unchecked tokens transfer](https://github.com/crytic/slither/wiki/Detector-Documentation#unchecked-transfer) | High | Medium
-25 | `weak-prng` | [Weak PRNG](https://github.com/crytic/slither/wiki/Detector-Documentation#weak-PRNG) | High | Medium
-26 | `domain-separator-collision` | [Detects ERC20 tokens that have a function whose signature collides with EIP-2612's DOMAIN_SEPARATOR()](https://github.com/crytic/slither/wiki/Detector-Documentation#domain-separator-collision) | Medium | High
-27 | `enum-conversion` | [Detect dangerous enum conversion](https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-enum-conversion) | Medium | High
-28 | `erc20-interface` | [Incorrect ERC20 interfaces](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-erc20-interface) | Medium | High
-29 | `erc721-interface` | [Incorrect ERC721 interfaces](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-erc721-interface) | Medium | High
-30 | `incorrect-equality` | [Dangerous strict equalities](https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-strict-equalities) | Medium | High
-31 | `locked-ether` | [Contracts that lock ether](https://github.com/crytic/slither/wiki/Detector-Documentation#contracts-that-lock-ether) | Medium | High
-32 | `mapping-deletion` | [Deletion on mapping containing a structure](https://github.com/crytic/slither/wiki/Detector-Documentation#deletion-on-mapping-containing-a-structure) | Medium | High
-33 | `shadowing-abstract` | [State variables shadowing from abstract contracts](https://github.com/crytic/slither/wiki/Detector-Documentation#state-variable-shadowing-from-abstract-contracts) | Medium | High
-34 | `tautology` | [Tautology or contradiction](https://github.com/crytic/slither/wiki/Detector-Documentation#tautology-or-contradiction) | Medium | High
-35 | `write-after-write` | [Unused write](https://github.com/crytic/slither/wiki/Detector-Documentation#write-after-write) | Medium | High
-36 | `boolean-cst` | [Misuse of Boolean constant](https://github.com/crytic/slither/wiki/Detector-Documentation#misuse-of-a-boolean-constant) | Medium | Medium
-37 | `constant-function-asm` | [Constant functions using assembly code](https://github.com/crytic/slither/wiki/Detector-Documentation#constant-functions-using-assembly-code) | Medium | Medium
-38 | `constant-function-state` | [Constant functions changing the state](https://github.com/crytic/slither/wiki/Detector-Documentation#constant-functions-changing-the-state) | Medium | Medium
-39 | `divide-before-multiply` | [Imprecise arithmetic operations order](https://github.com/crytic/slither/wiki/Detector-Documentation#divide-before-multiply) | Medium | Medium
-40 | `reentrancy-no-eth` | [Reentrancy vulnerabilities (no theft of ethers)](https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-1) | Medium | Medium
-41 | `reused-constructor` | [Reused base constructor](https://github.com/crytic/slither/wiki/Detector-Documentation#reused-base-constructors) | Medium | Medium
-42 | `tx-origin` | [Dangerous usage of `tx.origin`](https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-usage-of-txorigin) | Medium | Medium
-43 | `unchecked-lowlevel` | [Unchecked low-level calls](https://github.com/crytic/slither/wiki/Detector-Documentation#unchecked-low-level-calls) | Medium | Medium
-44 | `unchecked-send` | [Unchecked send](https://github.com/crytic/slither/wiki/Detector-Documentation#unchecked-send) | Medium | Medium
-45 | `uninitialized-local` | [Uninitialized local variables](https://github.com/crytic/slither/wiki/Detector-Documentation#uninitialized-local-variables) | Medium | Medium
-46 | `unused-return` | [Unused return values](https://github.com/crytic/slither/wiki/Detector-Documentation#unused-return) | Medium | Medium
-47 | `incorrect-modifier` | [Modifiers that can return the default value](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-modifier) | Low | High
-48 | `shadowing-builtin` | [Built-in symbol shadowing](https://github.com/crytic/slither/wiki/Detector-Documentation#builtin-symbol-shadowing) | Low | High
-49 | `shadowing-local` | [Local variables shadowing](https://github.com/crytic/slither/wiki/Detector-Documentation#local-variable-shadowing) | Low | High
-50 | `uninitialized-fptr-cst` | [Uninitialized function pointer calls in constructors](https://github.com/crytic/slither/wiki/Detector-Documentation#uninitialized-function-pointers-in-constructors) | Low | High
-51 | `variable-scope` | [Local variables used prior their declaration](https://github.com/crytic/slither/wiki/Detector-Documentation#pre-declaration-usage-of-local-variables) | Low | High
-52 | `void-cst` | [Constructor called not implemented](https://github.com/crytic/slither/wiki/Detector-Documentation#void-constructor) | Low | High
-53 | `calls-loop` | [Multiple calls in a loop](https://github.com/crytic/slither/wiki/Detector-Documentation/#calls-inside-a-loop) | Low | Medium
-54 | `events-access` | [Missing Events Access Control](https://github.com/crytic/slither/wiki/Detector-Documentation#missing-events-access-control) | Low | Medium
-55 | `events-maths` | [Missing Events Arithmetic](https://github.com/crytic/slither/wiki/Detector-Documentation#missing-events-arithmetic) | Low | Medium
-56 | `incorrect-unary` | [Dangerous unary expressions](https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-unary-expressions) | Low | Medium
-57 | `missing-zero-check` | [Missing Zero Address Validation](https://github.com/crytic/slither/wiki/Detector-Documentation#missing-zero-address-validation) | Low | Medium
-58 | `reentrancy-benign` | [Benign reentrancy vulnerabilities](https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-2) | Low | Medium
-59 | `reentrancy-events` | [Reentrancy vulnerabilities leading to out-of-order Events](https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-3) | Low | Medium
-60 | `timestamp` | [Dangerous usage of `block.timestamp`](https://github.com/crytic/slither/wiki/Detector-Documentation#block-timestamp) | Low | Medium
-61 | `assembly` | [Assembly usage](https://github.com/crytic/slither/wiki/Detector-Documentation#assembly-usage) | Informational | High
-62 | `assert-state-change` | [Assert state change](https://github.com/crytic/slither/wiki/Detector-Documentation#assert-state-change) | Informational | High
-63 | `boolean-equal` | [Comparison to boolean constant](https://github.com/crytic/slither/wiki/Detector-Documentation#boolean-equality) | Informational | High
-64 | `cyclomatic-complexity` | [Detects functions with high (> 11) cyclomatic complexity](https://github.com/crytic/slither/wiki/Detector-Documentation#cyclomatic-complexity) | Informational | High
-65 | `deprecated-standards` | [Deprecated Solidity Standards](https://github.com/crytic/slither/wiki/Detector-Documentation#deprecated-standards) | Informational | High
-66 | `erc20-indexed` | [Un-indexed ERC20 event parameters](https://github.com/crytic/slither/wiki/Detector-Documentation#unindexed-erc20-event-parameters) | Informational | High
-67 | `function-init-state` | [Function initializing state variables](https://github.com/crytic/slither/wiki/Detector-Documentation#function-initializing-state) | Informational | High
-68 | `low-level-calls` | [Low level calls](https://github.com/crytic/slither/wiki/Detector-Documentation#low-level-calls) | Informational | High
-69 | `missing-inheritance` | [Missing inheritance](https://github.com/crytic/slither/wiki/Detector-Documentation#missing-inheritance) | Informational | High
-70 | `naming-convention` | [Conformity to Solidity naming conventions](https://github.com/crytic/slither/wiki/Detector-Documentation#conformance-to-solidity-naming-conventions) | Informational | High
-71 | `pragma` | [If different pragma directives are used](https://github.com/crytic/slither/wiki/Detector-Documentation#different-pragma-directives-are-used) | Informational | High
-72 | `redundant-statements` | [Redundant statements](https://github.com/crytic/slither/wiki/Detector-Documentation#redundant-statements) | Informational | High
-73 | `solc-version` | [Incorrect Solidity version](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-versions-of-solidity) | Informational | High
-74 | `unimplemented-functions` | [Unimplemented functions](https://github.com/crytic/slither/wiki/Detector-Documentation#unimplemented-functions) | Informational | High
-75 | `unused-state` | [Unused state variables](https://github.com/crytic/slither/wiki/Detector-Documentation#unused-state-variable) | Informational | High
-76 | `costly-loop` | [Costly operations in a loop](https://github.com/crytic/slither/wiki/Detector-Documentation#costly-operations-inside-a-loop) | Informational | Medium
-77 | `dead-code` | [Functions that are not used](https://github.com/crytic/slither/wiki/Detector-Documentation#dead-code) | Informational | Medium
-78 | `reentrancy-unlimited-gas` | [Reentrancy vulnerabilities through send and transfer](https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-4) | Informational | Medium
-79 | `similar-names` | [Variable names are too similar](https://github.com/crytic/slither/wiki/Detector-Documentation#variable-names-too-similar) | Informational | Medium
-80 | `too-many-digits` | [Conformance to numeric notation best practices](https://github.com/crytic/slither/wiki/Detector-Documentation#too-many-digits) | Informational | Medium
-81 | `constable-states` | [State variables that could be declared constant](https://github.com/crytic/slither/wiki/Detector-Documentation#state-variables-that-could-be-declared-constant) | Optimization | High
-82 | `external-function` | [Public function that could be declared external](https://github.com/crytic/slither/wiki/Detector-Documentation#public-function-that-could-be-declared-external) | Optimization | High
-83 | `immutable-states` | [State variables that could be declared immutable](https://github.com/crytic/slither/wiki/Detector-Documentation#state-variables-that-could-be-declared-immutable) | Optimization | High
-84 | `var-read-using-this` | [Contract reads its own variable using `this`](https://github.com/crytic/slither/wiki/Vulnerabilities-Description#public-variable-read-in-external-context) | Optimization | High
+4 | `encode-packed-collision` | [ABI encodePacked Collision](https://github.com/crytic/slither/wiki/Detector-Documentation#abi-encodePacked-collision) | High | High
+5 | `incorrect-shift` | [The order of parameters in a shift instruction is incorrect.](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-shift-in-assembly) | High | High
+6 | `multiple-constructors` | [Multiple constructor schemes](https://github.com/crytic/slither/wiki/Detector-Documentation#multiple-constructor-schemes) | High | High
+7 | `name-reused` | [Contract's name reused](https://github.com/crytic/slither/wiki/Detector-Documentation#name-reused) | High | High
+8 | `protected-vars` | [Detected unprotected variables](https://github.com/crytic/slither/wiki/Detector-Documentation#protected-variables) | High | High
+9 | `public-mappings-nested` | [Public mappings with nested variables](https://github.com/crytic/slither/wiki/Detector-Documentation#public-mappings-with-nested-variables) | High | High
+10 | `rtlo` | [Right-To-Left-Override control character is used](https://github.com/crytic/slither/wiki/Detector-Documentation#right-to-left-override-character) | High | High
+11 | `shadowing-state` | [State variables shadowing](https://github.com/crytic/slither/wiki/Detector-Documentation#state-variable-shadowing) | High | High
+12 | `suicidal` | [Functions allowing anyone to destruct the contract](https://github.com/crytic/slither/wiki/Detector-Documentation#suicidal) | High | High
+13 | `uninitialized-state` | [Uninitialized state variables](https://github.com/crytic/slither/wiki/Detector-Documentation#uninitialized-state-variables) | High | High
+14 | `uninitialized-storage` | [Uninitialized storage variables](https://github.com/crytic/slither/wiki/Detector-Documentation#uninitialized-storage-variables) | High | High
+15 | `unprotected-upgrade` | [Unprotected upgradeable contract](https://github.com/crytic/slither/wiki/Detector-Documentation#unprotected-upgradeable-contract) | High | High
+16 | `codex` | [Use Codex to find vulnerabilities.](https://github.com/crytic/slither/wiki/Detector-Documentation#codex) | High | Low
+17 | `arbitrary-send-erc20-permit` | [transferFrom uses arbitrary from with permit](https://github.com/crytic/slither/wiki/Detector-Documentation#arbitrary-from-in-transferfrom-used-with-permit) | High | Medium
+18 | `arbitrary-send-eth` | [Functions that send Ether to arbitrary destinations](https://github.com/crytic/slither/wiki/Detector-Documentation#functions-that-send-ether-to-arbitrary-destinations) | High | Medium
+19 | `controlled-array-length` | [Tainted array length assignment](https://github.com/crytic/slither/wiki/Detector-Documentation#array-length-assignment) | High | Medium
+20 | `controlled-delegatecall` | [Controlled delegatecall destination](https://github.com/crytic/slither/wiki/Detector-Documentation#controlled-delegatecall) | High | Medium
+21 | `delegatecall-loop` | [Payable functions using `delegatecall` inside a loop](https://github.com/crytic/slither/wiki/Detector-Documentation/#payable-functions-using-delegatecall-inside-a-loop) | High | Medium
+22 | `msg-value-loop` | [msg.value inside a loop](https://github.com/crytic/slither/wiki/Detector-Documentation/#msgvalue-inside-a-loop) | High | Medium
+23 | `reentrancy-eth` | [Reentrancy vulnerabilities (theft of ethers)](https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities) | High | Medium
+24 | `storage-array` | [Signed storage integer array compiler bug](https://github.com/crytic/slither/wiki/Detector-Documentation#storage-signed-integer-array) | High | Medium
+25 | `unchecked-transfer` | [Unchecked tokens transfer](https://github.com/crytic/slither/wiki/Detector-Documentation#unchecked-transfer) | High | Medium
+26 | `weak-prng` | [Weak PRNG](https://github.com/crytic/slither/wiki/Detector-Documentation#weak-PRNG) | High | Medium
+27 | `domain-separator-collision` | [Detects ERC20 tokens that have a function whose signature collides with EIP-2612's DOMAIN_SEPARATOR()](https://github.com/crytic/slither/wiki/Detector-Documentation#domain-separator-collision) | Medium | High
+28 | `enum-conversion` | [Detect dangerous enum conversion](https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-enum-conversion) | Medium | High
+29 | `erc20-interface` | [Incorrect ERC20 interfaces](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-erc20-interface) | Medium | High
+30 | `erc721-interface` | [Incorrect ERC721 interfaces](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-erc721-interface) | Medium | High
+31 | `incorrect-equality` | [Dangerous strict equalities](https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-strict-equalities) | Medium | High
+32 | `locked-ether` | [Contracts that lock ether](https://github.com/crytic/slither/wiki/Detector-Documentation#contracts-that-lock-ether) | Medium | High
+33 | `mapping-deletion` | [Deletion on mapping containing a structure](https://github.com/crytic/slither/wiki/Detector-Documentation#deletion-on-mapping-containing-a-structure) | Medium | High
+34 | `shadowing-abstract` | [State variables shadowing from abstract contracts](https://github.com/crytic/slither/wiki/Detector-Documentation#state-variable-shadowing-from-abstract-contracts) | Medium | High
+35 | `tautology` | [Tautology or contradiction](https://github.com/crytic/slither/wiki/Detector-Documentation#tautology-or-contradiction) | Medium | High
+36 | `write-after-write` | [Unused write](https://github.com/crytic/slither/wiki/Detector-Documentation#write-after-write) | Medium | High
+37 | `boolean-cst` | [Misuse of Boolean constant](https://github.com/crytic/slither/wiki/Detector-Documentation#misuse-of-a-boolean-constant) | Medium | Medium
+38 | `constant-function-asm` | [Constant functions using assembly code](https://github.com/crytic/slither/wiki/Detector-Documentation#constant-functions-using-assembly-code) | Medium | Medium
+39 | `constant-function-state` | [Constant functions changing the state](https://github.com/crytic/slither/wiki/Detector-Documentation#constant-functions-changing-the-state) | Medium | Medium
+40 | `divide-before-multiply` | [Imprecise arithmetic operations order](https://github.com/crytic/slither/wiki/Detector-Documentation#divide-before-multiply) | Medium | Medium
+41 | `reentrancy-no-eth` | [Reentrancy vulnerabilities (no theft of ethers)](https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-1) | Medium | Medium
+42 | `reused-constructor` | [Reused base constructor](https://github.com/crytic/slither/wiki/Detector-Documentation#reused-base-constructors) | Medium | Medium
+43 | `tx-origin` | [Dangerous usage of `tx.origin`](https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-usage-of-txorigin) | Medium | Medium
+44 | `unchecked-lowlevel` | [Unchecked low-level calls](https://github.com/crytic/slither/wiki/Detector-Documentation#unchecked-low-level-calls) | Medium | Medium
+45 | `unchecked-send` | [Unchecked send](https://github.com/crytic/slither/wiki/Detector-Documentation#unchecked-send) | Medium | Medium
+46 | `uninitialized-local` | [Uninitialized local variables](https://github.com/crytic/slither/wiki/Detector-Documentation#uninitialized-local-variables) | Medium | Medium
+47 | `unused-return` | [Unused return values](https://github.com/crytic/slither/wiki/Detector-Documentation#unused-return) | Medium | Medium
+48 | `incorrect-modifier` | [Modifiers that can return the default value](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-modifier) | Low | High
+49 | `shadowing-builtin` | [Built-in symbol shadowing](https://github.com/crytic/slither/wiki/Detector-Documentation#builtin-symbol-shadowing) | Low | High
+50 | `shadowing-local` | [Local variables shadowing](https://github.com/crytic/slither/wiki/Detector-Documentation#local-variable-shadowing) | Low | High
+51 | `uninitialized-fptr-cst` | [Uninitialized function pointer calls in constructors](https://github.com/crytic/slither/wiki/Detector-Documentation#uninitialized-function-pointers-in-constructors) | Low | High
+52 | `variable-scope` | [Local variables used prior their declaration](https://github.com/crytic/slither/wiki/Detector-Documentation#pre-declaration-usage-of-local-variables) | Low | High
+53 | `void-cst` | [Constructor called not implemented](https://github.com/crytic/slither/wiki/Detector-Documentation#void-constructor) | Low | High
+54 | `calls-loop` | [Multiple calls in a loop](https://github.com/crytic/slither/wiki/Detector-Documentation/#calls-inside-a-loop) | Low | Medium
+55 | `events-access` | [Missing Events Access Control](https://github.com/crytic/slither/wiki/Detector-Documentation#missing-events-access-control) | Low | Medium
+56 | `events-maths` | [Missing Events Arithmetic](https://github.com/crytic/slither/wiki/Detector-Documentation#missing-events-arithmetic) | Low | Medium
+57 | `incorrect-unary` | [Dangerous unary expressions](https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-unary-expressions) | Low | Medium
+58 | `missing-zero-check` | [Missing Zero Address Validation](https://github.com/crytic/slither/wiki/Detector-Documentation#missing-zero-address-validation) | Low | Medium
+59 | `reentrancy-benign` | [Benign reentrancy vulnerabilities](https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-2) | Low | Medium
+60 | `reentrancy-events` | [Reentrancy vulnerabilities leading to out-of-order Events](https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-3) | Low | Medium
+61 | `timestamp` | [Dangerous usage of `block.timestamp`](https://github.com/crytic/slither/wiki/Detector-Documentation#block-timestamp) | Low | Medium
+62 | `assembly` | [Assembly usage](https://github.com/crytic/slither/wiki/Detector-Documentation#assembly-usage) | Informational | High
+63 | `assert-state-change` | [Assert state change](https://github.com/crytic/slither/wiki/Detector-Documentation#assert-state-change) | Informational | High
+64 | `boolean-equal` | [Comparison to boolean constant](https://github.com/crytic/slither/wiki/Detector-Documentation#boolean-equality) | Informational | High
+65 | `cyclomatic-complexity` | [Detects functions with high (> 11) cyclomatic complexity](https://github.com/crytic/slither/wiki/Detector-Documentation#cyclomatic-complexity) | Informational | High
+66 | `deprecated-standards` | [Deprecated Solidity Standards](https://github.com/crytic/slither/wiki/Detector-Documentation#deprecated-standards) | Informational | High
+67 | `erc20-indexed` | [Un-indexed ERC20 event parameters](https://github.com/crytic/slither/wiki/Detector-Documentation#unindexed-erc20-event-parameters) | Informational | High
+68 | `function-init-state` | [Function initializing state variables](https://github.com/crytic/slither/wiki/Detector-Documentation#function-initializing-state) | Informational | High
+69 | `incorrect-using-for` | [Detects using-for statement usage when no function from a given library matches a given type](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-using-for-usage) | Informational | High
+70 | `low-level-calls` | [Low level calls](https://github.com/crytic/slither/wiki/Detector-Documentation#low-level-calls) | Informational | High
+71 | `missing-inheritance` | [Missing inheritance](https://github.com/crytic/slither/wiki/Detector-Documentation#missing-inheritance) | Informational | High
+72 | `naming-convention` | [Conformity to Solidity naming conventions](https://github.com/crytic/slither/wiki/Detector-Documentation#conformance-to-solidity-naming-conventions) | Informational | High
+73 | `pragma` | [If different pragma directives are used](https://github.com/crytic/slither/wiki/Detector-Documentation#different-pragma-directives-are-used) | Informational | High
+74 | `redundant-statements` | [Redundant statements](https://github.com/crytic/slither/wiki/Detector-Documentation#redundant-statements) | Informational | High
+75 | `solc-version` | [Incorrect Solidity version](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-versions-of-solidity) | Informational | High
+76 | `unimplemented-functions` | [Unimplemented functions](https://github.com/crytic/slither/wiki/Detector-Documentation#unimplemented-functions) | Informational | High
+77 | `unused-state` | [Unused state variables](https://github.com/crytic/slither/wiki/Detector-Documentation#unused-state-variable) | Informational | High
+78 | `costly-loop` | [Costly operations in a loop](https://github.com/crytic/slither/wiki/Detector-Documentation#costly-operations-inside-a-loop) | Informational | Medium
+79 | `dead-code` | [Functions that are not used](https://github.com/crytic/slither/wiki/Detector-Documentation#dead-code) | Informational | Medium
+80 | `reentrancy-unlimited-gas` | [Reentrancy vulnerabilities through send and transfer](https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-4) | Informational | Medium
+81 | `similar-names` | [Variable names are too similar](https://github.com/crytic/slither/wiki/Detector-Documentation#variable-names-too-similar) | Informational | Medium
+82 | `too-many-digits` | [Conformance to numeric notation best practices](https://github.com/crytic/slither/wiki/Detector-Documentation#too-many-digits) | Informational | Medium
+83 | `cache-array-length` | [Detects `for` loops that use `length` member of some storage array in their loop condition and don't modify it.](https://github.com/crytic/slither/wiki/Detector-Documentation#cache-array-length) | Optimization | High
+84 | `constable-states` | [State variables that could be declared constant](https://github.com/crytic/slither/wiki/Detector-Documentation#state-variables-that-could-be-declared-constant) | Optimization | High
+85 | `external-function` | [Public function that could be declared external](https://github.com/crytic/slither/wiki/Detector-Documentation#public-function-that-could-be-declared-external) | Optimization | High
+86 | `immutable-states` | [State variables that could be declared immutable](https://github.com/crytic/slither/wiki/Detector-Documentation#state-variables-that-could-be-declared-immutable) | Optimization | High
+87 | `var-read-using-this` | [Contract reads its own variable using `this`](https://github.com/crytic/slither/wiki/Detector-Documentation#public-variable-read-in-external-context) | Optimization | High
 
 For more information, see
+
 - The [Detector Documentation](https://github.com/crytic/slither/wiki/Detector-Documentation) for details on each detector
 - The [Detection Selection](https://github.com/crytic/slither/wiki/Usage#detector-selection) to run only selected detectors. By default, all the detectors are run.
 - The [Triage Mode](https://github.com/crytic/slither/wiki/Usage#triage-mode) to filter individual results
 
 ## Printers
-
 ### Quick Review Printers
 - `human-summary`: [Print a human-readable summary of the contracts](https://github.com/trailofbits/slither/wiki/Printer-documentation#human-summary)
 - `inheritance-graph`: [Export the inheritance graph of each contract to a dot file](https://github.com/trailofbits/slither/wiki/Printer-documentation#inheritance-graph)
 - `contract-summary`: [Print a summary of the contracts](https://github.com/trailofbits/slither/wiki/Printer-documentation#contract-summary)
+- `loc`: [Count the total number lines of code (LOC), source lines of code (SLOC), and comment lines of code (CLOC) found in source files (SRC), dependencies (DEP), and test files (TEST).](https://github.com/trailofbits/slither/wiki/Printer-documentation#loc)
 
 ### In-Depth Review Printers
 - `call-graph`: [Export the call-graph of the contracts to a dot file](https://github.com/trailofbits/slither/wiki/Printer-documentation#call-graph)
 - `cfg`: [Export the CFG of each functions](https://github.com/trailofbits/slither/wiki/Printer-documentation#cfg)
 - `function-summary`: [Print a summary of the functions](https://github.com/trailofbits/slither/wiki/Printer-documentation#function-summary)
 - `vars-and-auth`: [Print the state variables written and the authorization of the functions](https://github.com/crytic/slither/wiki/Printer-documentation#variables-written-and-authorization)
-- `when-not-paused`: [Print functions that do not use `whenNotPaused` modifier](https://github.com/trailofbits/slither/wiki/Printer-documentation#when-not-paused).
+- `not-pausable`: [Print functions that do not use `whenNotPaused` modifier](https://github.com/trailofbits/slither/wiki/Printer-documentation#when-not-paused).
 
 To run a printer, use `--print` and a comma-separated list of printers.
 
 See the [Printer documentation](https://github.com/crytic/slither/wiki/Printer-documentation) for the complete lists.
 
 ## Tools
 
 - `slither-check-upgradeability`: [Review `delegatecall`-based upgradeability](https://github.com/crytic/slither/wiki/Upgradeability-Checks)
 - `slither-prop`: [Automatic unit test and property generation](https://github.com/crytic/slither/wiki/Property-generation)
 - `slither-flat`: [Flatten a codebase](https://github.com/crytic/slither/wiki/Contract-Flattening)
 - `slither-check-erc`: [Check the ERC's conformance](https://github.com/crytic/slither/wiki/ERC-Conformance)
 - `slither-format`: [Automatic patch generation](https://github.com/crytic/slither/wiki/Slither-format)
 - `slither-read-storage`: [Read storage values from contracts](./slither/tools/read_storage/README.md)
+- `slither-interface`: [Generate an interface for a contract](./slither/tools/interface/README.md)
 
 See the [Tool documentation](https://github.com/crytic/slither/wiki/Tool-Documentation) for additional tools.
 
 [Contact us](https://www.trailofbits.com/contact/) to get help on building custom tools.
 
 ## API Documentation
+
 Documentation on Slither's internals is available [here](https://crytic.github.io/slither/slither.html).
 
 ## Getting Help
 
 Feel free to stop by our [Slack channel](https://empireslacking.herokuapp.com) (#ethereum) for help using or extending Slither.
 
-* The [Printer documentation](https://github.com/trailofbits/slither/wiki/Printer-documentation) describes the information Slither is capable of visualizing for each contract.
+- The [Printer documentation](https://github.com/trailofbits/slither/wiki/Printer-documentation) describes the information Slither is capable of visualizing for each contract.
 
-* The [Detector documentation](https://github.com/trailofbits/slither/wiki/Adding-a-new-detector) describes how to write a new vulnerability analyses.
+- The [Detector documentation](https://github.com/trailofbits/slither/wiki/Adding-a-new-detector) describes how to write a new vulnerability analyses.
 
-* The [API documentation](https://github.com/crytic/slither/wiki/Python-API) describes the methods and objects available for custom analyses.
+- The [API documentation](https://github.com/crytic/slither/wiki/Python-API) describes the methods and objects available for custom analyses.
 
-* The [SlithIR documentation](https://github.com/trailofbits/slither/wiki/SlithIR) describes the SlithIR intermediate representation.
+- The [SlithIR documentation](https://github.com/trailofbits/slither/wiki/SlithIR) describes the SlithIR intermediate representation.
 
 ## FAQ
 
 How do I exclude mocks or tests?
+
 - View our documentation on [path filtering](https://github.com/crytic/slither/wiki/Usage#path-filtering).
 
 How do I fix "unknown file" or compilation issues?
+
 - Because slither requires the solc AST, it must have all dependencies available.
 If a contract has dependencies, `slither contract.sol` will fail.
 Instead, use `slither .` in the parent directory of `contracts/` (you should see `contracts/` when you run `ls`).
 If you have a `node_modules/` folder, it must be in the same directory as `contracts/`. To verify that this issue is related to slither,
 run the compilation command for the framework you are using e.g `npx hardhat compile`. That must work successfully;
 otherwise, slither's compilation engine, crytic-compile, cannot generate the AST.
 
 ## License
 
 Slither is licensed and distributed under the AGPLv3 license. [Contact us](mailto:opensource@trailofbits.com) if you're looking for an exception to the terms.
 
 ## Publications
 
 ### Trail of Bits publication
+
 - [Slither: A Static Analysis Framework For Smart Contracts](https://arxiv.org/abs/1908.09878), Josselin Feist, Gustavo Grieco, Alex Groce - WETSEB '19
 
 ### External publications
+
 Title | Usage | Authors | Venue | Code
 --- | --- | --- | --- | ---
 [ReJection: A AST-Based Reentrancy Vulnerability Detection Method](https://www.researchgate.net/publication/339354823_ReJection_A_AST-Based_Reentrancy_Vulnerability_Detection_Method) | AST-based analysis built on top of Slither | Rui Ma, Zefeng Jian, Guangyuan Chen, Ke Ma, Yujia Chen | CTCIS 19
 [MPro: Combining Static and Symbolic Analysis forScalable Testing of Smart Contract](https://arxiv.org/pdf/1911.00570.pdf) | Leverage data dependency through Slither | William Zhang, Sebastian Banescu, Leodardo Pasos, Steven Stewart, Vijay Ganesh | ISSRE 2019 | [MPro](https://github.com/QuanZhang-William/M-Pro)
 [ETHPLOIT: From Fuzzing to Efficient Exploit Generation against Smart Contracts](https://wcventure.github.io/FuzzingPaper/Paper/SANER20_ETHPLOIT.pdf) | Leverage data dependency through Slither | Qingzhao Zhang, Yizhuo Wang, Juanru Li, Siqi Ma | SANER 20
 [Verification of Ethereum Smart Contracts: A Model Checking Approach](http://www.ijmlc.org/vol10/977-AM0059.pdf) | Symbolic execution built on top of Slithers CFG | Tam Bang, Hoang H Nguyen, Dung Nguyen, Toan Trieu, Tho Quan | IJMLC 20
 [Smart Contract Repair](https://arxiv.org/pdf/1912.05823.pdf) | Rely on Slithers vulnerabilities detectors | Xiao Liang Yu, Omar Al-Bataineh, David Lo, Abhik Roychoudhury | TOSEM 20 | [SCRepair](https://github.com/xiaoly8/SCRepair/)
```

### Comparing `slither-analyzer-0.9.3/README.md` & `slither-analyzer-0.9.4/README.md`

 * *Files 5% similar despite different names*

```diff
@@ -1,9 +1,10 @@
 # Slither, the Solidity source analyzer
-<img src="./logo.png" alt="Logo" width="500"/>
+
+<img src="https://raw.githubusercontent.com/crytic/slither/master/logo.png" alt="Logo" width="500"/>
 
 [![Build Status](https://img.shields.io/github/actions/workflow/status/crytic/slither/ci.yml?branch=master)](https://github.com/crytic/slither/actions?query=workflow%3ACI)
 [![Slack Status](https://empireslacking.herokuapp.com/badge.svg)](https://empireslacking.herokuapp.com)
 [![PyPI version](https://badge.fury.io/py/slither-analyzer.svg)](https://badge.fury.io/py/slither-analyzer)
 
 Slither is a Solidity static analysis framework written in Python3. It runs a suite of vulnerability detectors, prints visual information about contract details, and provides an API to easily write custom analyses. Slither enables developers to find vulnerabilities, enhance their code comprehension, and quickly prototype custom analyses.
 
@@ -16,34 +17,37 @@
 - [API Documentation](#api-documentation)
 - [Getting Help](#getting-help)
 - [FAQ](#faq)
 - [Publications](#publications)
 
 ## Features
 
-* Detects vulnerable Solidity code with low false positives (see the list of [trophies](./trophies.md))
-* Identifies where the error condition occurs in the source code
-* Easily integrates into continuous integration and Hardhat/Foundry builds
-* Built-in 'printers' quickly report crucial contract information
-* Detector API to write custom analyses in Python
-* Ability to analyze contracts written with Solidity >= 0.4
-* Intermediate representation ([SlithIR](https://github.com/trailofbits/slither/wiki/SlithIR)) enables simple, high-precision analyses
-* Correctly parses 99.9% of all public Solidity code
-* Average execution time of less than 1 second per contract
-* Integrates with Github's code scanning in [CI](https://github.com/marketplace/actions/slither-action)
+- Detects vulnerable Solidity code with low false positives (see the list of [trophies](./trophies.md))
+- Identifies where the error condition occurs in the source code
+- Easily integrates into continuous integration and Hardhat/Foundry builds
+- Built-in 'printers' quickly report crucial contract information
+- Detector API to write custom analyses in Python
+- Ability to analyze contracts written with Solidity >= 0.4
+- Intermediate representation ([SlithIR](https://github.com/trailofbits/slither/wiki/SlithIR)) enables simple, high-precision analyses
+- Correctly parses 99.9% of all public Solidity code
+- Average execution time of less than 1 second per contract
+- Integrates with Github's code scanning in [CI](https://github.com/marketplace/actions/slither-action)
 
 ## Usage
 
 Run Slither on a Hardhat/Foundry/Dapp/Brownie application:
+
 ```bash
 slither .
 ```
+
 This is the preferred option if your project has dependencies as Slither relies on the underlying compilation framework to compile source code.
 
 However, you can run Slither on a single file that does not import dependencies:
+
 ```bash
 slither tests/uninitialized.sol
 ```
 
 ## How to install
 
 Slither requires Python 3.8+.
@@ -75,182 +79,192 @@
 To share a directory in the container:
 
 ```bash
 docker run -it -v /home/share:/share trailofbits/eth-security-toolbox
 ```
 
 ### Integration
+
 - For GitHub action integration, use [slither-action](https://github.com/marketplace/actions/slither-action).
 - To generate a Markdown report, use `slither [target] --checklist`.
 - To generate a Markdown with GitHub source code highlighting, use `slither [target] --checklist --markdown-root https://github.com/ORG/REPO/blob/COMMIT/` (replace `ORG`, `REPO`, `COMMIT`)
 
 ## Detectors
 
-
 Num | Detector | What it Detects | Impact | Confidence
 --- | --- | --- | --- | ---
 1 | `abiencoderv2-array` | [Storage abiencoderv2 array](https://github.com/crytic/slither/wiki/Detector-Documentation#storage-abiencoderv2-array) | High | High
 2 | `arbitrary-send-erc20` | [transferFrom uses arbitrary `from`](https://github.com/crytic/slither/wiki/Detector-Documentation#arbitrary-from-in-transferfrom) | High | High
 3 | `array-by-reference` | [Modifying storage array by value](https://github.com/crytic/slither/wiki/Detector-Documentation#modifying-storage-array-by-value) | High | High
-4 | `incorrect-shift` | [The order of parameters in a shift instruction is incorrect.](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-shift-in-assembly) | High | High
-5 | `multiple-constructors` | [Multiple constructor schemes](https://github.com/crytic/slither/wiki/Detector-Documentation#multiple-constructor-schemes) | High | High
-6 | `name-reused` | [Contract's name reused](https://github.com/crytic/slither/wiki/Detector-Documentation#name-reused) | High | High
-7 | `protected-vars` | [Detected unprotected variables](https://github.com/crytic/slither/wiki/Detector-Documentation#protected-variables) | High | High
-8 | `public-mappings-nested` | [Public mappings with nested variables](https://github.com/crytic/slither/wiki/Detector-Documentation#public-mappings-with-nested-variables) | High | High
-9 | `rtlo` | [Right-To-Left-Override control character is used](https://github.com/crytic/slither/wiki/Detector-Documentation#right-to-left-override-character) | High | High
-10 | `shadowing-state` | [State variables shadowing](https://github.com/crytic/slither/wiki/Detector-Documentation#state-variable-shadowing) | High | High
-11 | `suicidal` | [Functions allowing anyone to destruct the contract](https://github.com/crytic/slither/wiki/Detector-Documentation#suicidal) | High | High
-12 | `uninitialized-state` | [Uninitialized state variables](https://github.com/crytic/slither/wiki/Detector-Documentation#uninitialized-state-variables) | High | High
-13 | `uninitialized-storage` | [Uninitialized storage variables](https://github.com/crytic/slither/wiki/Detector-Documentation#uninitialized-storage-variables) | High | High
-14 | `unprotected-upgrade` | [Unprotected upgradeable contract](https://github.com/crytic/slither/wiki/Detector-Documentation#unprotected-upgradeable-contract) | High | High
-15 | `codex` | [Use Codex to find vulnerabilities.](https://github.com/crytic/slither/wiki/Detector-Documentation#codex) | High | Low
-16 | `arbitrary-send-erc20-permit` | [transferFrom uses arbitrary from with permit](https://github.com/crytic/slither/wiki/Detector-Documentation#arbitrary-from-in-transferfrom-used-with-permit) | High | Medium
-17 | `arbitrary-send-eth` | [Functions that send Ether to arbitrary destinations](https://github.com/crytic/slither/wiki/Detector-Documentation#functions-that-send-ether-to-arbitrary-destinations) | High | Medium
-18 | `controlled-array-length` | [Tainted array length assignment](https://github.com/crytic/slither/wiki/Detector-Documentation#array-length-assignment) | High | Medium
-19 | `controlled-delegatecall` | [Controlled delegatecall destination](https://github.com/crytic/slither/wiki/Detector-Documentation#controlled-delegatecall) | High | Medium
-20 | `delegatecall-loop` | [Payable functions using `delegatecall` inside a loop](https://github.com/crytic/slither/wiki/Detector-Documentation/#payable-functions-using-delegatecall-inside-a-loop) | High | Medium
-21 | `msg-value-loop` | [msg.value inside a loop](https://github.com/crytic/slither/wiki/Detector-Documentation/#msgvalue-inside-a-loop) | High | Medium
-22 | `reentrancy-eth` | [Reentrancy vulnerabilities (theft of ethers)](https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities) | High | Medium
-23 | `storage-array` | [Signed storage integer array compiler bug](https://github.com/crytic/slither/wiki/Detector-Documentation#storage-signed-integer-array) | High | Medium
-24 | `unchecked-transfer` | [Unchecked tokens transfer](https://github.com/crytic/slither/wiki/Detector-Documentation#unchecked-transfer) | High | Medium
-25 | `weak-prng` | [Weak PRNG](https://github.com/crytic/slither/wiki/Detector-Documentation#weak-PRNG) | High | Medium
-26 | `domain-separator-collision` | [Detects ERC20 tokens that have a function whose signature collides with EIP-2612's DOMAIN_SEPARATOR()](https://github.com/crytic/slither/wiki/Detector-Documentation#domain-separator-collision) | Medium | High
-27 | `enum-conversion` | [Detect dangerous enum conversion](https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-enum-conversion) | Medium | High
-28 | `erc20-interface` | [Incorrect ERC20 interfaces](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-erc20-interface) | Medium | High
-29 | `erc721-interface` | [Incorrect ERC721 interfaces](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-erc721-interface) | Medium | High
-30 | `incorrect-equality` | [Dangerous strict equalities](https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-strict-equalities) | Medium | High
-31 | `locked-ether` | [Contracts that lock ether](https://github.com/crytic/slither/wiki/Detector-Documentation#contracts-that-lock-ether) | Medium | High
-32 | `mapping-deletion` | [Deletion on mapping containing a structure](https://github.com/crytic/slither/wiki/Detector-Documentation#deletion-on-mapping-containing-a-structure) | Medium | High
-33 | `shadowing-abstract` | [State variables shadowing from abstract contracts](https://github.com/crytic/slither/wiki/Detector-Documentation#state-variable-shadowing-from-abstract-contracts) | Medium | High
-34 | `tautology` | [Tautology or contradiction](https://github.com/crytic/slither/wiki/Detector-Documentation#tautology-or-contradiction) | Medium | High
-35 | `write-after-write` | [Unused write](https://github.com/crytic/slither/wiki/Detector-Documentation#write-after-write) | Medium | High
-36 | `boolean-cst` | [Misuse of Boolean constant](https://github.com/crytic/slither/wiki/Detector-Documentation#misuse-of-a-boolean-constant) | Medium | Medium
-37 | `constant-function-asm` | [Constant functions using assembly code](https://github.com/crytic/slither/wiki/Detector-Documentation#constant-functions-using-assembly-code) | Medium | Medium
-38 | `constant-function-state` | [Constant functions changing the state](https://github.com/crytic/slither/wiki/Detector-Documentation#constant-functions-changing-the-state) | Medium | Medium
-39 | `divide-before-multiply` | [Imprecise arithmetic operations order](https://github.com/crytic/slither/wiki/Detector-Documentation#divide-before-multiply) | Medium | Medium
-40 | `reentrancy-no-eth` | [Reentrancy vulnerabilities (no theft of ethers)](https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-1) | Medium | Medium
-41 | `reused-constructor` | [Reused base constructor](https://github.com/crytic/slither/wiki/Detector-Documentation#reused-base-constructors) | Medium | Medium
-42 | `tx-origin` | [Dangerous usage of `tx.origin`](https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-usage-of-txorigin) | Medium | Medium
-43 | `unchecked-lowlevel` | [Unchecked low-level calls](https://github.com/crytic/slither/wiki/Detector-Documentation#unchecked-low-level-calls) | Medium | Medium
-44 | `unchecked-send` | [Unchecked send](https://github.com/crytic/slither/wiki/Detector-Documentation#unchecked-send) | Medium | Medium
-45 | `uninitialized-local` | [Uninitialized local variables](https://github.com/crytic/slither/wiki/Detector-Documentation#uninitialized-local-variables) | Medium | Medium
-46 | `unused-return` | [Unused return values](https://github.com/crytic/slither/wiki/Detector-Documentation#unused-return) | Medium | Medium
-47 | `incorrect-modifier` | [Modifiers that can return the default value](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-modifier) | Low | High
-48 | `shadowing-builtin` | [Built-in symbol shadowing](https://github.com/crytic/slither/wiki/Detector-Documentation#builtin-symbol-shadowing) | Low | High
-49 | `shadowing-local` | [Local variables shadowing](https://github.com/crytic/slither/wiki/Detector-Documentation#local-variable-shadowing) | Low | High
-50 | `uninitialized-fptr-cst` | [Uninitialized function pointer calls in constructors](https://github.com/crytic/slither/wiki/Detector-Documentation#uninitialized-function-pointers-in-constructors) | Low | High
-51 | `variable-scope` | [Local variables used prior their declaration](https://github.com/crytic/slither/wiki/Detector-Documentation#pre-declaration-usage-of-local-variables) | Low | High
-52 | `void-cst` | [Constructor called not implemented](https://github.com/crytic/slither/wiki/Detector-Documentation#void-constructor) | Low | High
-53 | `calls-loop` | [Multiple calls in a loop](https://github.com/crytic/slither/wiki/Detector-Documentation/#calls-inside-a-loop) | Low | Medium
-54 | `events-access` | [Missing Events Access Control](https://github.com/crytic/slither/wiki/Detector-Documentation#missing-events-access-control) | Low | Medium
-55 | `events-maths` | [Missing Events Arithmetic](https://github.com/crytic/slither/wiki/Detector-Documentation#missing-events-arithmetic) | Low | Medium
-56 | `incorrect-unary` | [Dangerous unary expressions](https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-unary-expressions) | Low | Medium
-57 | `missing-zero-check` | [Missing Zero Address Validation](https://github.com/crytic/slither/wiki/Detector-Documentation#missing-zero-address-validation) | Low | Medium
-58 | `reentrancy-benign` | [Benign reentrancy vulnerabilities](https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-2) | Low | Medium
-59 | `reentrancy-events` | [Reentrancy vulnerabilities leading to out-of-order Events](https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-3) | Low | Medium
-60 | `timestamp` | [Dangerous usage of `block.timestamp`](https://github.com/crytic/slither/wiki/Detector-Documentation#block-timestamp) | Low | Medium
-61 | `assembly` | [Assembly usage](https://github.com/crytic/slither/wiki/Detector-Documentation#assembly-usage) | Informational | High
-62 | `assert-state-change` | [Assert state change](https://github.com/crytic/slither/wiki/Detector-Documentation#assert-state-change) | Informational | High
-63 | `boolean-equal` | [Comparison to boolean constant](https://github.com/crytic/slither/wiki/Detector-Documentation#boolean-equality) | Informational | High
-64 | `cyclomatic-complexity` | [Detects functions with high (> 11) cyclomatic complexity](https://github.com/crytic/slither/wiki/Detector-Documentation#cyclomatic-complexity) | Informational | High
-65 | `deprecated-standards` | [Deprecated Solidity Standards](https://github.com/crytic/slither/wiki/Detector-Documentation#deprecated-standards) | Informational | High
-66 | `erc20-indexed` | [Un-indexed ERC20 event parameters](https://github.com/crytic/slither/wiki/Detector-Documentation#unindexed-erc20-event-parameters) | Informational | High
-67 | `function-init-state` | [Function initializing state variables](https://github.com/crytic/slither/wiki/Detector-Documentation#function-initializing-state) | Informational | High
-68 | `low-level-calls` | [Low level calls](https://github.com/crytic/slither/wiki/Detector-Documentation#low-level-calls) | Informational | High
-69 | `missing-inheritance` | [Missing inheritance](https://github.com/crytic/slither/wiki/Detector-Documentation#missing-inheritance) | Informational | High
-70 | `naming-convention` | [Conformity to Solidity naming conventions](https://github.com/crytic/slither/wiki/Detector-Documentation#conformance-to-solidity-naming-conventions) | Informational | High
-71 | `pragma` | [If different pragma directives are used](https://github.com/crytic/slither/wiki/Detector-Documentation#different-pragma-directives-are-used) | Informational | High
-72 | `redundant-statements` | [Redundant statements](https://github.com/crytic/slither/wiki/Detector-Documentation#redundant-statements) | Informational | High
-73 | `solc-version` | [Incorrect Solidity version](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-versions-of-solidity) | Informational | High
-74 | `unimplemented-functions` | [Unimplemented functions](https://github.com/crytic/slither/wiki/Detector-Documentation#unimplemented-functions) | Informational | High
-75 | `unused-state` | [Unused state variables](https://github.com/crytic/slither/wiki/Detector-Documentation#unused-state-variable) | Informational | High
-76 | `costly-loop` | [Costly operations in a loop](https://github.com/crytic/slither/wiki/Detector-Documentation#costly-operations-inside-a-loop) | Informational | Medium
-77 | `dead-code` | [Functions that are not used](https://github.com/crytic/slither/wiki/Detector-Documentation#dead-code) | Informational | Medium
-78 | `reentrancy-unlimited-gas` | [Reentrancy vulnerabilities through send and transfer](https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-4) | Informational | Medium
-79 | `similar-names` | [Variable names are too similar](https://github.com/crytic/slither/wiki/Detector-Documentation#variable-names-too-similar) | Informational | Medium
-80 | `too-many-digits` | [Conformance to numeric notation best practices](https://github.com/crytic/slither/wiki/Detector-Documentation#too-many-digits) | Informational | Medium
-81 | `constable-states` | [State variables that could be declared constant](https://github.com/crytic/slither/wiki/Detector-Documentation#state-variables-that-could-be-declared-constant) | Optimization | High
-82 | `external-function` | [Public function that could be declared external](https://github.com/crytic/slither/wiki/Detector-Documentation#public-function-that-could-be-declared-external) | Optimization | High
-83 | `immutable-states` | [State variables that could be declared immutable](https://github.com/crytic/slither/wiki/Detector-Documentation#state-variables-that-could-be-declared-immutable) | Optimization | High
-84 | `var-read-using-this` | [Contract reads its own variable using `this`](https://github.com/crytic/slither/wiki/Vulnerabilities-Description#public-variable-read-in-external-context) | Optimization | High
+4 | `encode-packed-collision` | [ABI encodePacked Collision](https://github.com/crytic/slither/wiki/Detector-Documentation#abi-encodePacked-collision) | High | High
+5 | `incorrect-shift` | [The order of parameters in a shift instruction is incorrect.](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-shift-in-assembly) | High | High
+6 | `multiple-constructors` | [Multiple constructor schemes](https://github.com/crytic/slither/wiki/Detector-Documentation#multiple-constructor-schemes) | High | High
+7 | `name-reused` | [Contract's name reused](https://github.com/crytic/slither/wiki/Detector-Documentation#name-reused) | High | High
+8 | `protected-vars` | [Detected unprotected variables](https://github.com/crytic/slither/wiki/Detector-Documentation#protected-variables) | High | High
+9 | `public-mappings-nested` | [Public mappings with nested variables](https://github.com/crytic/slither/wiki/Detector-Documentation#public-mappings-with-nested-variables) | High | High
+10 | `rtlo` | [Right-To-Left-Override control character is used](https://github.com/crytic/slither/wiki/Detector-Documentation#right-to-left-override-character) | High | High
+11 | `shadowing-state` | [State variables shadowing](https://github.com/crytic/slither/wiki/Detector-Documentation#state-variable-shadowing) | High | High
+12 | `suicidal` | [Functions allowing anyone to destruct the contract](https://github.com/crytic/slither/wiki/Detector-Documentation#suicidal) | High | High
+13 | `uninitialized-state` | [Uninitialized state variables](https://github.com/crytic/slither/wiki/Detector-Documentation#uninitialized-state-variables) | High | High
+14 | `uninitialized-storage` | [Uninitialized storage variables](https://github.com/crytic/slither/wiki/Detector-Documentation#uninitialized-storage-variables) | High | High
+15 | `unprotected-upgrade` | [Unprotected upgradeable contract](https://github.com/crytic/slither/wiki/Detector-Documentation#unprotected-upgradeable-contract) | High | High
+16 | `codex` | [Use Codex to find vulnerabilities.](https://github.com/crytic/slither/wiki/Detector-Documentation#codex) | High | Low
+17 | `arbitrary-send-erc20-permit` | [transferFrom uses arbitrary from with permit](https://github.com/crytic/slither/wiki/Detector-Documentation#arbitrary-from-in-transferfrom-used-with-permit) | High | Medium
+18 | `arbitrary-send-eth` | [Functions that send Ether to arbitrary destinations](https://github.com/crytic/slither/wiki/Detector-Documentation#functions-that-send-ether-to-arbitrary-destinations) | High | Medium
+19 | `controlled-array-length` | [Tainted array length assignment](https://github.com/crytic/slither/wiki/Detector-Documentation#array-length-assignment) | High | Medium
+20 | `controlled-delegatecall` | [Controlled delegatecall destination](https://github.com/crytic/slither/wiki/Detector-Documentation#controlled-delegatecall) | High | Medium
+21 | `delegatecall-loop` | [Payable functions using `delegatecall` inside a loop](https://github.com/crytic/slither/wiki/Detector-Documentation/#payable-functions-using-delegatecall-inside-a-loop) | High | Medium
+22 | `msg-value-loop` | [msg.value inside a loop](https://github.com/crytic/slither/wiki/Detector-Documentation/#msgvalue-inside-a-loop) | High | Medium
+23 | `reentrancy-eth` | [Reentrancy vulnerabilities (theft of ethers)](https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities) | High | Medium
+24 | `storage-array` | [Signed storage integer array compiler bug](https://github.com/crytic/slither/wiki/Detector-Documentation#storage-signed-integer-array) | High | Medium
+25 | `unchecked-transfer` | [Unchecked tokens transfer](https://github.com/crytic/slither/wiki/Detector-Documentation#unchecked-transfer) | High | Medium
+26 | `weak-prng` | [Weak PRNG](https://github.com/crytic/slither/wiki/Detector-Documentation#weak-PRNG) | High | Medium
+27 | `domain-separator-collision` | [Detects ERC20 tokens that have a function whose signature collides with EIP-2612's DOMAIN_SEPARATOR()](https://github.com/crytic/slither/wiki/Detector-Documentation#domain-separator-collision) | Medium | High
+28 | `enum-conversion` | [Detect dangerous enum conversion](https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-enum-conversion) | Medium | High
+29 | `erc20-interface` | [Incorrect ERC20 interfaces](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-erc20-interface) | Medium | High
+30 | `erc721-interface` | [Incorrect ERC721 interfaces](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-erc721-interface) | Medium | High
+31 | `incorrect-equality` | [Dangerous strict equalities](https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-strict-equalities) | Medium | High
+32 | `locked-ether` | [Contracts that lock ether](https://github.com/crytic/slither/wiki/Detector-Documentation#contracts-that-lock-ether) | Medium | High
+33 | `mapping-deletion` | [Deletion on mapping containing a structure](https://github.com/crytic/slither/wiki/Detector-Documentation#deletion-on-mapping-containing-a-structure) | Medium | High
+34 | `shadowing-abstract` | [State variables shadowing from abstract contracts](https://github.com/crytic/slither/wiki/Detector-Documentation#state-variable-shadowing-from-abstract-contracts) | Medium | High
+35 | `tautology` | [Tautology or contradiction](https://github.com/crytic/slither/wiki/Detector-Documentation#tautology-or-contradiction) | Medium | High
+36 | `write-after-write` | [Unused write](https://github.com/crytic/slither/wiki/Detector-Documentation#write-after-write) | Medium | High
+37 | `boolean-cst` | [Misuse of Boolean constant](https://github.com/crytic/slither/wiki/Detector-Documentation#misuse-of-a-boolean-constant) | Medium | Medium
+38 | `constant-function-asm` | [Constant functions using assembly code](https://github.com/crytic/slither/wiki/Detector-Documentation#constant-functions-using-assembly-code) | Medium | Medium
+39 | `constant-function-state` | [Constant functions changing the state](https://github.com/crytic/slither/wiki/Detector-Documentation#constant-functions-changing-the-state) | Medium | Medium
+40 | `divide-before-multiply` | [Imprecise arithmetic operations order](https://github.com/crytic/slither/wiki/Detector-Documentation#divide-before-multiply) | Medium | Medium
+41 | `reentrancy-no-eth` | [Reentrancy vulnerabilities (no theft of ethers)](https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-1) | Medium | Medium
+42 | `reused-constructor` | [Reused base constructor](https://github.com/crytic/slither/wiki/Detector-Documentation#reused-base-constructors) | Medium | Medium
+43 | `tx-origin` | [Dangerous usage of `tx.origin`](https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-usage-of-txorigin) | Medium | Medium
+44 | `unchecked-lowlevel` | [Unchecked low-level calls](https://github.com/crytic/slither/wiki/Detector-Documentation#unchecked-low-level-calls) | Medium | Medium
+45 | `unchecked-send` | [Unchecked send](https://github.com/crytic/slither/wiki/Detector-Documentation#unchecked-send) | Medium | Medium
+46 | `uninitialized-local` | [Uninitialized local variables](https://github.com/crytic/slither/wiki/Detector-Documentation#uninitialized-local-variables) | Medium | Medium
+47 | `unused-return` | [Unused return values](https://github.com/crytic/slither/wiki/Detector-Documentation#unused-return) | Medium | Medium
+48 | `incorrect-modifier` | [Modifiers that can return the default value](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-modifier) | Low | High
+49 | `shadowing-builtin` | [Built-in symbol shadowing](https://github.com/crytic/slither/wiki/Detector-Documentation#builtin-symbol-shadowing) | Low | High
+50 | `shadowing-local` | [Local variables shadowing](https://github.com/crytic/slither/wiki/Detector-Documentation#local-variable-shadowing) | Low | High
+51 | `uninitialized-fptr-cst` | [Uninitialized function pointer calls in constructors](https://github.com/crytic/slither/wiki/Detector-Documentation#uninitialized-function-pointers-in-constructors) | Low | High
+52 | `variable-scope` | [Local variables used prior their declaration](https://github.com/crytic/slither/wiki/Detector-Documentation#pre-declaration-usage-of-local-variables) | Low | High
+53 | `void-cst` | [Constructor called not implemented](https://github.com/crytic/slither/wiki/Detector-Documentation#void-constructor) | Low | High
+54 | `calls-loop` | [Multiple calls in a loop](https://github.com/crytic/slither/wiki/Detector-Documentation/#calls-inside-a-loop) | Low | Medium
+55 | `events-access` | [Missing Events Access Control](https://github.com/crytic/slither/wiki/Detector-Documentation#missing-events-access-control) | Low | Medium
+56 | `events-maths` | [Missing Events Arithmetic](https://github.com/crytic/slither/wiki/Detector-Documentation#missing-events-arithmetic) | Low | Medium
+57 | `incorrect-unary` | [Dangerous unary expressions](https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-unary-expressions) | Low | Medium
+58 | `missing-zero-check` | [Missing Zero Address Validation](https://github.com/crytic/slither/wiki/Detector-Documentation#missing-zero-address-validation) | Low | Medium
+59 | `reentrancy-benign` | [Benign reentrancy vulnerabilities](https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-2) | Low | Medium
+60 | `reentrancy-events` | [Reentrancy vulnerabilities leading to out-of-order Events](https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-3) | Low | Medium
+61 | `timestamp` | [Dangerous usage of `block.timestamp`](https://github.com/crytic/slither/wiki/Detector-Documentation#block-timestamp) | Low | Medium
+62 | `assembly` | [Assembly usage](https://github.com/crytic/slither/wiki/Detector-Documentation#assembly-usage) | Informational | High
+63 | `assert-state-change` | [Assert state change](https://github.com/crytic/slither/wiki/Detector-Documentation#assert-state-change) | Informational | High
+64 | `boolean-equal` | [Comparison to boolean constant](https://github.com/crytic/slither/wiki/Detector-Documentation#boolean-equality) | Informational | High
+65 | `cyclomatic-complexity` | [Detects functions with high (> 11) cyclomatic complexity](https://github.com/crytic/slither/wiki/Detector-Documentation#cyclomatic-complexity) | Informational | High
+66 | `deprecated-standards` | [Deprecated Solidity Standards](https://github.com/crytic/slither/wiki/Detector-Documentation#deprecated-standards) | Informational | High
+67 | `erc20-indexed` | [Un-indexed ERC20 event parameters](https://github.com/crytic/slither/wiki/Detector-Documentation#unindexed-erc20-event-parameters) | Informational | High
+68 | `function-init-state` | [Function initializing state variables](https://github.com/crytic/slither/wiki/Detector-Documentation#function-initializing-state) | Informational | High
+69 | `incorrect-using-for` | [Detects using-for statement usage when no function from a given library matches a given type](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-using-for-usage) | Informational | High
+70 | `low-level-calls` | [Low level calls](https://github.com/crytic/slither/wiki/Detector-Documentation#low-level-calls) | Informational | High
+71 | `missing-inheritance` | [Missing inheritance](https://github.com/crytic/slither/wiki/Detector-Documentation#missing-inheritance) | Informational | High
+72 | `naming-convention` | [Conformity to Solidity naming conventions](https://github.com/crytic/slither/wiki/Detector-Documentation#conformance-to-solidity-naming-conventions) | Informational | High
+73 | `pragma` | [If different pragma directives are used](https://github.com/crytic/slither/wiki/Detector-Documentation#different-pragma-directives-are-used) | Informational | High
+74 | `redundant-statements` | [Redundant statements](https://github.com/crytic/slither/wiki/Detector-Documentation#redundant-statements) | Informational | High
+75 | `solc-version` | [Incorrect Solidity version](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-versions-of-solidity) | Informational | High
+76 | `unimplemented-functions` | [Unimplemented functions](https://github.com/crytic/slither/wiki/Detector-Documentation#unimplemented-functions) | Informational | High
+77 | `unused-state` | [Unused state variables](https://github.com/crytic/slither/wiki/Detector-Documentation#unused-state-variable) | Informational | High
+78 | `costly-loop` | [Costly operations in a loop](https://github.com/crytic/slither/wiki/Detector-Documentation#costly-operations-inside-a-loop) | Informational | Medium
+79 | `dead-code` | [Functions that are not used](https://github.com/crytic/slither/wiki/Detector-Documentation#dead-code) | Informational | Medium
+80 | `reentrancy-unlimited-gas` | [Reentrancy vulnerabilities through send and transfer](https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-4) | Informational | Medium
+81 | `similar-names` | [Variable names are too similar](https://github.com/crytic/slither/wiki/Detector-Documentation#variable-names-too-similar) | Informational | Medium
+82 | `too-many-digits` | [Conformance to numeric notation best practices](https://github.com/crytic/slither/wiki/Detector-Documentation#too-many-digits) | Informational | Medium
+83 | `cache-array-length` | [Detects `for` loops that use `length` member of some storage array in their loop condition and don't modify it.](https://github.com/crytic/slither/wiki/Detector-Documentation#cache-array-length) | Optimization | High
+84 | `constable-states` | [State variables that could be declared constant](https://github.com/crytic/slither/wiki/Detector-Documentation#state-variables-that-could-be-declared-constant) | Optimization | High
+85 | `external-function` | [Public function that could be declared external](https://github.com/crytic/slither/wiki/Detector-Documentation#public-function-that-could-be-declared-external) | Optimization | High
+86 | `immutable-states` | [State variables that could be declared immutable](https://github.com/crytic/slither/wiki/Detector-Documentation#state-variables-that-could-be-declared-immutable) | Optimization | High
+87 | `var-read-using-this` | [Contract reads its own variable using `this`](https://github.com/crytic/slither/wiki/Detector-Documentation#public-variable-read-in-external-context) | Optimization | High
 
 For more information, see
+
 - The [Detector Documentation](https://github.com/crytic/slither/wiki/Detector-Documentation) for details on each detector
 - The [Detection Selection](https://github.com/crytic/slither/wiki/Usage#detector-selection) to run only selected detectors. By default, all the detectors are run.
 - The [Triage Mode](https://github.com/crytic/slither/wiki/Usage#triage-mode) to filter individual results
 
 ## Printers
-
 ### Quick Review Printers
 - `human-summary`: [Print a human-readable summary of the contracts](https://github.com/trailofbits/slither/wiki/Printer-documentation#human-summary)
 - `inheritance-graph`: [Export the inheritance graph of each contract to a dot file](https://github.com/trailofbits/slither/wiki/Printer-documentation#inheritance-graph)
 - `contract-summary`: [Print a summary of the contracts](https://github.com/trailofbits/slither/wiki/Printer-documentation#contract-summary)
+- `loc`: [Count the total number lines of code (LOC), source lines of code (SLOC), and comment lines of code (CLOC) found in source files (SRC), dependencies (DEP), and test files (TEST).](https://github.com/trailofbits/slither/wiki/Printer-documentation#loc)
 
 ### In-Depth Review Printers
 - `call-graph`: [Export the call-graph of the contracts to a dot file](https://github.com/trailofbits/slither/wiki/Printer-documentation#call-graph)
 - `cfg`: [Export the CFG of each functions](https://github.com/trailofbits/slither/wiki/Printer-documentation#cfg)
 - `function-summary`: [Print a summary of the functions](https://github.com/trailofbits/slither/wiki/Printer-documentation#function-summary)
 - `vars-and-auth`: [Print the state variables written and the authorization of the functions](https://github.com/crytic/slither/wiki/Printer-documentation#variables-written-and-authorization)
-- `when-not-paused`: [Print functions that do not use `whenNotPaused` modifier](https://github.com/trailofbits/slither/wiki/Printer-documentation#when-not-paused).
+- `not-pausable`: [Print functions that do not use `whenNotPaused` modifier](https://github.com/trailofbits/slither/wiki/Printer-documentation#when-not-paused).
 
 To run a printer, use `--print` and a comma-separated list of printers.
 
 See the [Printer documentation](https://github.com/crytic/slither/wiki/Printer-documentation) for the complete lists.
 
 ## Tools
 
 - `slither-check-upgradeability`: [Review `delegatecall`-based upgradeability](https://github.com/crytic/slither/wiki/Upgradeability-Checks)
 - `slither-prop`: [Automatic unit test and property generation](https://github.com/crytic/slither/wiki/Property-generation)
 - `slither-flat`: [Flatten a codebase](https://github.com/crytic/slither/wiki/Contract-Flattening)
 - `slither-check-erc`: [Check the ERC's conformance](https://github.com/crytic/slither/wiki/ERC-Conformance)
 - `slither-format`: [Automatic patch generation](https://github.com/crytic/slither/wiki/Slither-format)
 - `slither-read-storage`: [Read storage values from contracts](./slither/tools/read_storage/README.md)
+- `slither-interface`: [Generate an interface for a contract](./slither/tools/interface/README.md)
 
 See the [Tool documentation](https://github.com/crytic/slither/wiki/Tool-Documentation) for additional tools.
 
 [Contact us](https://www.trailofbits.com/contact/) to get help on building custom tools.
 
 ## API Documentation
+
 Documentation on Slither's internals is available [here](https://crytic.github.io/slither/slither.html).
 
 ## Getting Help
 
 Feel free to stop by our [Slack channel](https://empireslacking.herokuapp.com) (#ethereum) for help using or extending Slither.
 
-* The [Printer documentation](https://github.com/trailofbits/slither/wiki/Printer-documentation) describes the information Slither is capable of visualizing for each contract.
+- The [Printer documentation](https://github.com/trailofbits/slither/wiki/Printer-documentation) describes the information Slither is capable of visualizing for each contract.
 
-* The [Detector documentation](https://github.com/trailofbits/slither/wiki/Adding-a-new-detector) describes how to write a new vulnerability analyses.
+- The [Detector documentation](https://github.com/trailofbits/slither/wiki/Adding-a-new-detector) describes how to write a new vulnerability analyses.
 
-* The [API documentation](https://github.com/crytic/slither/wiki/Python-API) describes the methods and objects available for custom analyses.
+- The [API documentation](https://github.com/crytic/slither/wiki/Python-API) describes the methods and objects available for custom analyses.
 
-* The [SlithIR documentation](https://github.com/trailofbits/slither/wiki/SlithIR) describes the SlithIR intermediate representation.
+- The [SlithIR documentation](https://github.com/trailofbits/slither/wiki/SlithIR) describes the SlithIR intermediate representation.
 
 ## FAQ
 
 How do I exclude mocks or tests?
+
 - View our documentation on [path filtering](https://github.com/crytic/slither/wiki/Usage#path-filtering).
 
 How do I fix "unknown file" or compilation issues?
+
 - Because slither requires the solc AST, it must have all dependencies available.
 If a contract has dependencies, `slither contract.sol` will fail.
 Instead, use `slither .` in the parent directory of `contracts/` (you should see `contracts/` when you run `ls`).
 If you have a `node_modules/` folder, it must be in the same directory as `contracts/`. To verify that this issue is related to slither,
 run the compilation command for the framework you are using e.g `npx hardhat compile`. That must work successfully;
 otherwise, slither's compilation engine, crytic-compile, cannot generate the AST.
 
 ## License
 
 Slither is licensed and distributed under the AGPLv3 license. [Contact us](mailto:opensource@trailofbits.com) if you're looking for an exception to the terms.
 
 ## Publications
 
 ### Trail of Bits publication
+
 - [Slither: A Static Analysis Framework For Smart Contracts](https://arxiv.org/abs/1908.09878), Josselin Feist, Gustavo Grieco, Alex Groce - WETSEB '19
 
 ### External publications
+
 Title | Usage | Authors | Venue | Code
 --- | --- | --- | --- | ---
 [ReJection: A AST-Based Reentrancy Vulnerability Detection Method](https://www.researchgate.net/publication/339354823_ReJection_A_AST-Based_Reentrancy_Vulnerability_Detection_Method) | AST-based analysis built on top of Slither | Rui Ma, Zefeng Jian, Guangyuan Chen, Ke Ma, Yujia Chen | CTCIS 19
 [MPro: Combining Static and Symbolic Analysis forScalable Testing of Smart Contract](https://arxiv.org/pdf/1911.00570.pdf) | Leverage data dependency through Slither | William Zhang, Sebastian Banescu, Leodardo Pasos, Steven Stewart, Vijay Ganesh | ISSRE 2019 | [MPro](https://github.com/QuanZhang-William/M-Pro)
 [ETHPLOIT: From Fuzzing to Efficient Exploit Generation against Smart Contracts](https://wcventure.github.io/FuzzingPaper/Paper/SANER20_ETHPLOIT.pdf) | Leverage data dependency through Slither | Qingzhao Zhang, Yizhuo Wang, Juanru Li, Siqi Ma | SANER 20
 [Verification of Ethereum Smart Contracts: A Model Checking Approach](http://www.ijmlc.org/vol10/977-AM0059.pdf) | Symbolic execution built on top of Slithers CFG | Tam Bang, Hoang H Nguyen, Dung Nguyen, Toan Trieu, Tho Quan | IJMLC 20
 [Smart Contract Repair](https://arxiv.org/pdf/1912.05823.pdf) | Rely on Slithers vulnerabilities detectors | Xiao Liang Yu, Omar Al-Bataineh, David Lo, Abhik Roychoudhury | TOSEM 20 | [SCRepair](https://github.com/xiaoly8/SCRepair/)
```

### Comparing `slither-analyzer-0.9.3/setup.py` & `slither-analyzer-0.9.4/setup.py`

 * *Files 6% similar despite different names*

```diff
@@ -4,37 +4,51 @@
     long_description = f.read()
 
 setup(
     name="slither-analyzer",
     description="Slither is a Solidity static analysis framework written in Python 3.",
     url="https://github.com/crytic/slither",
     author="Trail of Bits",
-    version="0.9.3",
+    version="0.9.4",
     packages=find_packages(),
     python_requires=">=3.8",
     install_requires=[
         "packaging",
-        "prettytable>=0.7.2",
+        "prettytable>=3.3.0",
         "pycryptodome>=3.4.6",
-        "crytic-compile>=0.3.1,<0.4.0",
-        # "crytic-compile@git+https://github.com/crytic/crytic-compile.git@master#egg=crytic-compile",
+        "crytic-compile>=0.3.2,<0.4.0",
+        # "crytic-compile@git+https://github.com/crytic/crytic-compile.git@dev#egg=crytic-compile",
         "web3>=6.0.0",
+        "eth-abi>=4.0.0",
+        "eth-typing>=3.0.0",
+        "eth-utils>=2.1.0",
     ],
     extras_require={
-        "dev": [
+        "lint": [
             "black==22.3.0",
             "pylint==2.13.4",
+        ],
+        "test": [
             "pytest",
             "pytest-cov",
             "pytest-xdist",
             "deepdiff",
             "numpy",
-            "openai",
+            "coverage[toml]",
+            "filelock",
+            "pytest-insta",
+            "solc-select>=1.0.4",
+        ],
+        "doc": [
             "pdoc",
         ],
+        "dev": [
+            "slither-analyzer[lint,test,doc]",
+            "openai",
+        ],
     },
     license="AGPL-3.0",
     long_description=long_description,
     long_description_content_type="text/markdown",
     entry_points={
         "console_scripts": [
             "slither = slither.__main__:main",
@@ -46,10 +60,11 @@
             "slither-check-erc = slither.tools.erc_conformance.__main__:main",
             "slither-check-kspec = slither.tools.kspec_coverage.__main__:main",
             "slither-prop = slither.tools.properties.__main__:main",
             "slither-mutate = slither.tools.mutator.__main__:main",
             "slither-read-storage = slither.tools.read_storage.__main__:main",
             "slither-doctor = slither.tools.doctor.__main__:main",
             "slither-documentation = slither.tools.documentation.__main__:main",
+            "slither-interface = slither.tools.interface.__main__:main",
         ]
     },
 )
```

### Comparing `slither-analyzer-0.9.3/slither/__main__.py` & `slither-analyzer-0.9.4/slither/__main__.py`

 * *Files 4% similar despite different names*

```diff
@@ -31,14 +31,15 @@
     output_to_sarif,
     ZIP_TYPES_ACCEPTED,
     Output,
 )
 from slither.utils.output_capture import StandardOutputCapture
 from slither.utils.colors import red, set_colorization_enabled
 from slither.utils.command_line import (
+    FailOnLevel,
     output_detectors,
     output_results_to_markdown,
     output_detectors_json,
     output_printers,
     output_printers_json,
     output_to_markdown,
     output_wiki,
@@ -62,15 +63,15 @@
 
 
 def process_single(
     target: Union[str, CryticCompile],
     args: argparse.Namespace,
     detector_classes: List[Type[AbstractDetector]],
     printer_classes: List[Type[AbstractPrinter]],
-) -> Tuple[Slither, List[Dict], List[Dict], int]:
+) -> Tuple[Slither, List[Dict], List[Output], int]:
     """
     The core high-level code for running Slither static analysis.
 
     Returns:
         list(result), int: Result list and number of contracts analyzed
     """
     ast = "--ast-compact-json"
@@ -82,15 +83,15 @@
 
 
 def process_all(
     target: str,
     args: argparse.Namespace,
     detector_classes: List[Type[AbstractDetector]],
     printer_classes: List[Type[AbstractPrinter]],
-) -> Tuple[List[Slither], List[Dict], List[Dict], int]:
+) -> Tuple[List[Slither], List[Dict], List[Output], int]:
     compilations = compile_all(target, **vars(args))
     slither_instances = []
     results_detectors = []
     results_printers = []
     analyzed_contracts_count = 0
     for compilation in compilations:
         (
@@ -137,31 +138,14 @@
         printer_results = slither.run_printers()
         printer_results = [x for x in printer_results if x]  # remove empty results
         results_printers.extend(printer_results)
 
     return slither, results_detectors, results_printers, analyzed_contracts_count
 
 
-# TODO: delete me?
-def process_from_asts(
-    filenames: List[str],
-    args: argparse.Namespace,
-    detector_classes: List[Type[AbstractDetector]],
-    printer_classes: List[Type[AbstractPrinter]],
-) -> Tuple[Slither, List[Dict], List[Dict], int]:
-    all_contracts: List[str] = []
-
-    for filename in filenames:
-        with open(filename, encoding="utf8") as file_open:
-            contract_loaded = json.load(file_open)
-            all_contracts.append(contract_loaded["ast"])
-
-    return process_single(all_contracts, args, detector_classes, printer_classes)
-
-
 # endregion
 ###################################################################################
 ###################################################################################
 
 # region Detectors and printers
 ###################################################################################
 ###################################################################################
@@ -219,30 +203,30 @@
             if detector in detectors:
                 detectors_to_run.append(detectors[detector])
             else:
                 raise Exception(f"Error: {detector} is not a detector")
         detectors_to_run = sorted(detectors_to_run, key=lambda x: x.IMPACT)
         return detectors_to_run
 
-    if args.exclude_optimization and not args.fail_pedantic:
+    if args.exclude_optimization:
         detectors_to_run = [
             d for d in detectors_to_run if d.IMPACT != DetectorClassification.OPTIMIZATION
         ]
 
-    if args.exclude_informational and not args.fail_pedantic:
+    if args.exclude_informational:
         detectors_to_run = [
             d for d in detectors_to_run if d.IMPACT != DetectorClassification.INFORMATIONAL
         ]
-    if args.exclude_low and not args.fail_low:
+    if args.exclude_low:
         detectors_to_run = [d for d in detectors_to_run if d.IMPACT != DetectorClassification.LOW]
-    if args.exclude_medium and not args.fail_medium:
+    if args.exclude_medium:
         detectors_to_run = [
             d for d in detectors_to_run if d.IMPACT != DetectorClassification.MEDIUM
         ]
-    if args.exclude_high and not args.fail_high:
+    if args.exclude_high:
         detectors_to_run = [d for d in detectors_to_run if d.IMPACT != DetectorClassification.HIGH]
     if args.detectors_to_exclude:
         detectors_to_run = [
             d for d in detectors_to_run if d.ARGUMENT not in args.detectors_to_exclude
         ]
 
     detectors_to_run = sorted(detectors_to_run, key=lambda x: x.IMPACT)
@@ -399,49 +383,52 @@
     group_detector.add_argument(
         "--exclude-high",
         help="Exclude high impact analyses",
         action="store_true",
         default=defaults_flag_in_config["exclude_high"],
     )
 
-    group_detector.add_argument(
+    fail_on_group = group_detector.add_mutually_exclusive_group()
+    fail_on_group.add_argument(
         "--fail-pedantic",
-        help="Return the number of findings in the exit code",
-        action="store_true",
-        default=defaults_flag_in_config["fail_pedantic"],
+        help="Fail if any findings are detected",
+        action="store_const",
+        dest="fail_on",
+        const=FailOnLevel.PEDANTIC,
     )
-
-    group_detector.add_argument(
-        "--no-fail-pedantic",
-        help="Do not return the number of findings in the exit code. Opposite of --fail-pedantic",
-        dest="fail_pedantic",
-        action="store_false",
-        required=False,
-    )
-
-    group_detector.add_argument(
+    fail_on_group.add_argument(
         "--fail-low",
-        help="Fail if low or greater impact finding is detected",
-        action="store_true",
-        default=defaults_flag_in_config["fail_low"],
+        help="Fail if any low or greater impact findings are detected",
+        action="store_const",
+        dest="fail_on",
+        const=FailOnLevel.LOW,
     )
-
-    group_detector.add_argument(
+    fail_on_group.add_argument(
         "--fail-medium",
-        help="Fail if medium or greater impact finding is detected",
-        action="store_true",
-        default=defaults_flag_in_config["fail_medium"],
+        help="Fail if any medium or greater impact findings are detected",
+        action="store_const",
+        dest="fail_on",
+        const=FailOnLevel.MEDIUM,
     )
-
-    group_detector.add_argument(
+    fail_on_group.add_argument(
         "--fail-high",
-        help="Fail if high impact finding is detected",
-        action="store_true",
-        default=defaults_flag_in_config["fail_high"],
+        help="Fail if any high impact findings are detected",
+        action="store_const",
+        dest="fail_on",
+        const=FailOnLevel.HIGH,
     )
+    fail_on_group.add_argument(
+        "--fail-none",
+        "--no-fail-pedantic",
+        help="Do not return the number of findings in the exit code",
+        action="store_const",
+        dest="fail_on",
+        const=FailOnLevel.NONE,
+    )
+    fail_on_group.set_defaults(fail_on=FailOnLevel.PEDANTIC)
 
     group_detector.add_argument(
         "--show-ignored-findings",
         help="Show all the findings",
         action="store_true",
         default=defaults_flag_in_config["show_ignored_findings"],
     )
@@ -601,17 +588,14 @@
     parser.add_argument(
         "--perf",
         help=argparse.SUPPRESS,
         action="store_true",
         default=False,
     )
 
-    # if the json is splitted in different files
-    parser.add_argument("--splitted", help=argparse.SUPPRESS, action="store_true", default=False)
-
     # Disable the throw/catch on partial analyses
     parser.add_argument(
         "--disallow-partial", help=argparse.SUPPRESS, action="store_true", default=False
     )
 
     if len(sys.argv) == 1:
         parser.print_help(sys.stderr)
@@ -619,24 +603,26 @@
 
     args = parser.parse_args()
     read_config_file(args)
 
     args.filter_paths = parse_filter_paths(args)
 
     # Verify our json-type output is valid
-    args.json_types = set(args.json_types.split(","))
+    args.json_types = set(args.json_types.split(","))  # type:ignore
     for json_type in args.json_types:
         if json_type not in JSON_OUTPUT_TYPES:
             raise Exception(f'Error: "{json_type}" is not a valid JSON result output type.')
 
     return args
 
 
 class ListDetectors(argparse.Action):  # pylint: disable=too-few-public-methods
-    def __call__(self, parser, *args, **kwargs):  # pylint: disable=signature-differs
+    def __call__(
+        self, parser: Any, *args: Any, **kwargs: Any
+    ) -> None:  # pylint: disable=signature-differs
         detectors, _ = get_detectors_and_printers()
         output_detectors(detectors)
         parser.exit()
 
 
 class ListDetectorsJson(argparse.Action):  # pylint: disable=too-few-public-methods
     def __call__(
@@ -690,22 +676,22 @@
 ###################################################################################
 # region CustomFormatter
 ###################################################################################
 ###################################################################################
 
 
 class FormatterCryticCompile(logging.Formatter):
-    def format(self, record):
+    def format(self, record: logging.LogRecord) -> str:
         # for i, msg in enumerate(record.msg):
         if record.msg.startswith("Compilation warnings/errors on "):
-            txt = record.args[1]
-            txt = txt.split("\n")
+            txt = record.args[1]  # type:ignore
+            txt = txt.split("\n")  # type:ignore
             txt = [red(x) if "Error" in x else x for x in txt]
             txt = "\n".join(txt)
-            record.args = (record.args[0], txt)
+            record.args = (record.args[0], txt)  # type:ignore
         return super().format(record)
 
 
 # endregion
 ###################################################################################
 ###################################################################################
 # region Main
@@ -740,15 +726,15 @@
         cp = cProfile.Profile()
         cp.enable()
 
     # Set colorization option
     set_colorization_enabled(False if args.disable_color else sys.stdout.isatty())
 
     # Define some variables for potential JSON output
-    json_results = {}
+    json_results: Dict[str, Any] = {}
     output_error = None
     outputting_json = args.json is not None
     outputting_json_stdout = args.json == "-"
     outputting_sarif = args.sarif is not None
     outputting_sarif_stdout = args.sarif == "-"
     outputting_zip = args.zip is not None
     if args.zip_type not in ZIP_TYPES_ACCEPTED:
@@ -789,47 +775,38 @@
 
     crytic_compile_error = logging.getLogger(("CryticCompile"))
     crytic_compile_error.addHandler(console_handler)
     crytic_compile_error.propagate = False
     crytic_compile_error.setLevel(logging.INFO)
 
     results_detectors: List[Dict] = []
-    results_printers: List[Dict] = []
+    results_printers: List[Output] = []
     try:
         filename = args.filename
 
         # Determine if we are handling ast from solc
         if args.solc_ast or (filename.endswith(".json") and not is_supported(filename)):
             globbed_filenames = glob.glob(filename, recursive=True)
             filenames = glob.glob(os.path.join(filename, "*.json"))
             if not filenames:
                 filenames = globbed_filenames
             number_contracts = 0
 
             slither_instances = []
-            if args.splitted:
+            for filename in filenames:
                 (
                     slither_instance,
-                    results_detectors,
-                    results_printers,
-                    number_contracts,
-                ) = process_from_asts(filenames, args, detector_classes, printer_classes)
+                    results_detectors_tmp,
+                    results_printers_tmp,
+                    number_contracts_tmp,
+                ) = process_single(filename, args, detector_classes, printer_classes)
+                number_contracts += number_contracts_tmp
+                results_detectors += results_detectors_tmp
+                results_printers += results_printers_tmp
                 slither_instances.append(slither_instance)
-            else:
-                for filename in filenames:
-                    (
-                        slither_instance,
-                        results_detectors_tmp,
-                        results_printers_tmp,
-                        number_contracts_tmp,
-                    ) = process_single(filename, args, detector_classes, printer_classes)
-                    number_contracts += number_contracts_tmp
-                    results_detectors += results_detectors_tmp
-                    results_printers += results_printers_tmp
-                    slither_instances.append(slither_instance)
 
         # Rely on CryticCompile to discern the underlying type of compilations.
         else:
             (
                 slither_instances,
                 results_detectors,
                 results_printers,
@@ -919,25 +896,26 @@
         output_to_zip(args.zip, output_error, json_results, args.zip_type)
 
     if args.perf and cp:
         cp.disable()
         stats = pstats.Stats(cp).sort_stats("cumtime")
         stats.print_stats()
 
-    if args.fail_high:
+    fail_on = FailOnLevel(args.fail_on)
+    if fail_on == FailOnLevel.HIGH:
         fail_on_detection = any(result["impact"] == "High" for result in results_detectors)
-    elif args.fail_medium:
+    elif fail_on == FailOnLevel.MEDIUM:
         fail_on_detection = any(
             result["impact"] in ["Medium", "High"] for result in results_detectors
         )
-    elif args.fail_low:
+    elif fail_on == FailOnLevel.LOW:
         fail_on_detection = any(
             result["impact"] in ["Low", "Medium", "High"] for result in results_detectors
         )
-    elif args.fail_pedantic:
+    elif fail_on == FailOnLevel.PEDANTIC:
         fail_on_detection = bool(results_detectors)
     else:
         fail_on_detection = False
 
     # Exit with them appropriate status code
     if output_error or fail_on_detection:
         sys.exit(-1)
```

### Comparing `slither-analyzer-0.9.3/slither/analyses/data_dependency/data_dependency.py` & `slither-analyzer-0.9.4/slither/analyses/data_dependency/data_dependency.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,68 +1,84 @@
 """
     Compute the data depenency between all the SSA variables
 """
 from collections import defaultdict
-from typing import Union, Set, Dict, TYPE_CHECKING
+from typing import Union, Set, Dict, TYPE_CHECKING, List
 
+from slither.core.cfg.node import Node
 from slither.core.declarations import (
     Contract,
     Enum,
     Function,
     SolidityFunction,
     SolidityVariable,
     SolidityVariableComposed,
     Structure,
+    FunctionContract,
 )
 from slither.core.declarations.solidity_import_placeholder import SolidityImportPlaceHolder
+from slither.core.solidity_types.type import Type
 from slither.core.variables.top_level_variable import TopLevelVariable
 from slither.core.variables.variable import Variable
 from slither.slithir.operations import Index, OperationWithLValue, InternalCall, Operation
+from slither.slithir.utils.utils import LVALUE
 from slither.slithir.variables import (
     Constant,
     LocalIRVariable,
     ReferenceVariable,
     ReferenceVariableSSA,
     StateIRVariable,
     TemporaryVariableSSA,
     TupleVariableSSA,
 )
-from slither.core.solidity_types.type import Type
+from slither.slithir.variables.variable import SlithIRVariable
 
 if TYPE_CHECKING:
     from slither.core.compilation_unit import SlitherCompilationUnit
 
-
 ###################################################################################
 ###################################################################################
 # region User APIs
 ###################################################################################
 ###################################################################################
 
 
-Variable_types = Union[Variable, SolidityVariable]
+SUPPORTED_TYPES = Union[Variable, SolidityVariable]
+
+# TODO refactor the data deps to be better suited for top level function object
+# Right now we allow to pass a node to ease the API, but we need something
+# better
+# The deps propagation for top level elements is also not working as expected
+Context_types_API = Union[Contract, Function, Node]
 Context_types = Union[Contract, Function]
 
 
 def is_dependent(
-    variable: Variable_types,
-    source: Variable_types,
-    context: Context_types,
+    variable: SUPPORTED_TYPES,
+    source: SUPPORTED_TYPES,
+    context: Context_types_API,
     only_unprotected: bool = False,
 ) -> bool:
     """
+    If Node is provided as context, the context will be the broader context, either the contract or the function,
+    depending on if the node is in a top level function or not
+
     Args:
         variable (Variable)
         source (Variable)
-        context (Contract|Function)
+        context (Contract|Function|Node).
         only_unprotected (bool): True only unprotected function are considered
     Returns:
         bool
     """
-    assert isinstance(context, (Contract, Function))
+    assert isinstance(context, (Contract, Function, Node))
+    if isinstance(context, Node):
+        func = context.function
+        context = func.contract if isinstance(func, FunctionContract) else func
+
     if isinstance(variable, Constant):
         return False
     if variable == source:
         return True
     context_dict = context.context
 
     if only_unprotected:
@@ -70,29 +86,35 @@
             variable in context_dict[KEY_NON_SSA_UNPROTECTED]
             and source in context_dict[KEY_NON_SSA_UNPROTECTED][variable]
         )
     return variable in context_dict[KEY_NON_SSA] and source in context_dict[KEY_NON_SSA][variable]
 
 
 def is_dependent_ssa(
-    variable: Variable_types,
-    source: Variable_types,
-    context: Context_types,
+    variable: SUPPORTED_TYPES,
+    source: SUPPORTED_TYPES,
+    context: Context_types_API,
     only_unprotected: bool = False,
 ) -> bool:
     """
+    If Node is provided as context, the context will be the broader context, either the contract or the function,
+    depending on if the node is in a top level function or not
+
     Args:
         variable (Variable)
         taint (Variable)
         context (Contract|Function)
         only_unprotected (bool): True only unprotected function are considered
     Returns:
         bool
     """
-    assert isinstance(context, (Contract, Function))
+    assert isinstance(context, (Contract, Function, Node))
+    if isinstance(context, Node):
+        func = context.function
+        context = func.contract if isinstance(func, FunctionContract) else func
     context_dict = context.context
     if isinstance(variable, Constant):
         return False
     if variable == source:
         return True
     if only_unprotected:
         return (
@@ -103,139 +125,172 @@
 
 
 GENERIC_TAINT = {
     SolidityVariableComposed("msg.sender"),
     SolidityVariableComposed("msg.value"),
     SolidityVariableComposed("msg.data"),
     SolidityVariableComposed("tx.origin"),
+    SolidityVariableComposed("tx.gasprice"),
 }
 
 
 def is_tainted(
-    variable: Variable_types,
-    context: Context_types,
+    variable: SUPPORTED_TYPES,
+    context: Context_types_API,
     only_unprotected: bool = False,
     ignore_generic_taint: bool = False,
 ) -> bool:
     """
+    If Node is provided as context, the context will be the broader context, either the contract or the function,
+    depending on if the node is in a top level function or not
+
         Args:
         variable
         context (Contract|Function)
         only_unprotected (bool): True only unprotected function are considered
     Returns:
         bool
     """
-    assert isinstance(context, (Contract, Function))
+    assert isinstance(context, (Contract, Function, Node))
+    if isinstance(context, Node):
+        func = context.function
+        context = func.contract if isinstance(func, FunctionContract) else func
     assert isinstance(only_unprotected, bool)
     if isinstance(variable, Constant):
         return False
     compilation_unit = context.compilation_unit
     taints = compilation_unit.context[KEY_INPUT]
     if not ignore_generic_taint:
         taints |= GENERIC_TAINT
     return variable in taints or any(
         is_dependent(variable, t, context, only_unprotected) for t in taints
     )
 
 
 def is_tainted_ssa(
-    variable: Variable_types,
-    context: Context_types,
+    variable: SUPPORTED_TYPES,
+    context: Context_types_API,
     only_unprotected: bool = False,
     ignore_generic_taint: bool = False,
-):
+) -> bool:
     """
+    If Node is provided as context, the context will be the broader context, either the contract or the function,
+    depending on if the node is in a top level function or not
+
     Args:
         variable
         context (Contract|Function)
         only_unprotected (bool): True only unprotected function are considered
     Returns:
         bool
     """
-    assert isinstance(context, (Contract, Function))
+    assert isinstance(context, (Contract, Function, Node))
+    if isinstance(context, Node):
+        func = context.function
+        context = func.contract if isinstance(func, FunctionContract) else func
     assert isinstance(only_unprotected, bool)
     if isinstance(variable, Constant):
         return False
     compilation_unit = context.compilation_unit
     taints = compilation_unit.context[KEY_INPUT_SSA]
     if not ignore_generic_taint:
         taints |= GENERIC_TAINT
     return variable in taints or any(
         is_dependent_ssa(variable, t, context, only_unprotected) for t in taints
     )
 
 
 def get_dependencies(
-    variable: Variable_types,
-    context: Context_types,
+    variable: SUPPORTED_TYPES,
+    context: Context_types_API,
     only_unprotected: bool = False,
 ) -> Set[Variable]:
     """
     Return the variables for which `variable` depends on.
+    If Node is provided as context, the context will be the broader context, either the contract or the function,
+    depending on if the node is in a top level function or not
 
     :param variable: The target
     :param context: Either a function (interprocedural) or a contract (inter transactional)
     :param only_unprotected: True if consider only protected functions
     :return: set(Variable)
     """
-    assert isinstance(context, (Contract, Function))
+    assert isinstance(context, (Contract, Function, Node))
+    if isinstance(context, Node):
+        func = context.function
+        context = func.contract if isinstance(func, FunctionContract) else func
     assert isinstance(only_unprotected, bool)
     if only_unprotected:
         return context.context[KEY_NON_SSA_UNPROTECTED].get(variable, set())
     return context.context[KEY_NON_SSA].get(variable, set())
 
 
 def get_all_dependencies(
-    context: Context_types, only_unprotected: bool = False
+    context: Context_types_API, only_unprotected: bool = False
 ) -> Dict[Variable, Set[Variable]]:
     """
     Return the dictionary of dependencies.
+    If Node is provided as context, the context will be the broader context, either the contract or the function,
+    depending on if the node is in a top level function or not
 
     :param context: Either a function (interprocedural) or a contract (inter transactional)
     :param only_unprotected: True if consider only protected functions
     :return: Dict(Variable, set(Variable))
     """
-    assert isinstance(context, (Contract, Function))
+    assert isinstance(context, (Contract, Function, Node))
+    if isinstance(context, Node):
+        func = context.function
+        context = func.contract if isinstance(func, FunctionContract) else func
     assert isinstance(only_unprotected, bool)
     if only_unprotected:
         return context.context[KEY_NON_SSA_UNPROTECTED]
     return context.context[KEY_NON_SSA]
 
 
 def get_dependencies_ssa(
-    variable: Variable_types,
-    context: Context_types,
+    variable: SUPPORTED_TYPES,
+    context: Context_types_API,
     only_unprotected: bool = False,
 ) -> Set[Variable]:
     """
     Return the variables for which `variable` depends on (SSA version).
+    If Node is provided as context, the context will be the broader context, either the contract or the function,
+    depending on if the node is in a top level function or not
 
     :param variable: The target (must be SSA variable)
     :param context: Either a function (interprocedural) or a contract (inter transactional)
     :param only_unprotected: True if consider only protected functions
     :return: set(Variable)
     """
-    assert isinstance(context, (Contract, Function))
+    assert isinstance(context, (Contract, Function, Node))
+    if isinstance(context, Node):
+        func = context.function
+        context = func.contract if isinstance(func, FunctionContract) else func
     assert isinstance(only_unprotected, bool)
     if only_unprotected:
         return context.context[KEY_SSA_UNPROTECTED].get(variable, set())
     return context.context[KEY_SSA].get(variable, set())
 
 
 def get_all_dependencies_ssa(
-    context: Context_types, only_unprotected: bool = False
+    context: Context_types_API, only_unprotected: bool = False
 ) -> Dict[Variable, Set[Variable]]:
     """
     Return the dictionary of dependencies.
+    If Node is provided as context, the context will be the broader context, either the contract or the function,
+    depending on if the node is in a top level function or not
 
     :param context: Either a function (interprocedural) or a contract (inter transactional)
     :param only_unprotected: True if consider only protected functions
     :return: Dict(Variable, set(Variable))
     """
-    assert isinstance(context, (Contract, Function))
+    assert isinstance(context, (Contract, Function, Node))
+    if isinstance(context, Node):
+        func = context.function
+        context = func.contract if isinstance(func, FunctionContract) else func
     assert isinstance(only_unprotected, bool)
     if only_unprotected:
         return context.context[KEY_SSA_UNPROTECTED]
     return context.context[KEY_SSA]
 
 
 # endregion
@@ -337,21 +392,17 @@
 ) -> None:
     # transitive closure
     changed = True
     keys = context.context[context_key].keys()
     while changed:
         changed = False
         to_add = defaultdict(set)
-        [  # pylint: disable=expression-not-assigned
-            [
+        for key, items in context.context[context_key].items():
+            for item in items & keys:
                 to_add[key].update(context.context[context_key][item] - {key} - items)
-                for item in items & keys
-            ]
-            for key, items in context.context[context_key].items()
-        ]
         for k, v in to_add.items():
             # Because we dont have any check on the update operation
             # We might update an empty set with an empty set
             if v:
                 changed = True
                 context.context[context_key][k] |= v
     context.context[context_key_non_ssa] = convert_to_non_ssa(context.context[context_key])
@@ -362,28 +413,28 @@
 
 
 def add_dependency(lvalue: Variable, function: Function, ir: Operation, is_protected: bool) -> None:
     if not lvalue in function.context[KEY_SSA]:
         function.context[KEY_SSA][lvalue] = set()
         if not is_protected:
             function.context[KEY_SSA_UNPROTECTED][lvalue] = set()
+    read: Union[List[Union[LVALUE, SolidityVariableComposed]], List[SlithIRVariable]]
     if isinstance(ir, Index):
         read = [ir.variable_left]
-    elif isinstance(ir, InternalCall):
+    elif isinstance(ir, InternalCall) and ir.function:
         read = ir.function.return_values_ssa
     else:
         read = ir.read
-    # pylint: disable=expression-not-assigned
-    [function.context[KEY_SSA][lvalue].add(v) for v in read if not isinstance(v, Constant)]
+    for v in read:
+        if not isinstance(v, Constant):
+            function.context[KEY_SSA][lvalue].add(v)
     if not is_protected:
-        [
-            function.context[KEY_SSA_UNPROTECTED][lvalue].add(v)
-            for v in read
-            if not isinstance(v, Constant)
-        ]
+        for v in read:
+            if not isinstance(v, Constant):
+                function.context[KEY_SSA_UNPROTECTED][lvalue].add(v)
 
 
 def compute_dependency_function(function: Function) -> None:
     if KEY_SSA in function.context:
         return
 
     function.context[KEY_SSA] = {}
@@ -403,15 +454,15 @@
 
     function.context[KEY_NON_SSA] = convert_to_non_ssa(function.context[KEY_SSA])
     function.context[KEY_NON_SSA_UNPROTECTED] = convert_to_non_ssa(
         function.context[KEY_SSA_UNPROTECTED]
     )
 
 
-def convert_variable_to_non_ssa(v: Variable_types) -> Variable_types:
+def convert_variable_to_non_ssa(v: SUPPORTED_TYPES) -> SUPPORTED_TYPES:
     if isinstance(
         v,
         (
             LocalIRVariable,
             StateIRVariable,
             TemporaryVariableSSA,
             ReferenceVariableSSA,
@@ -434,18 +485,18 @@
             TopLevelVariable,
         ),
     )
     return v
 
 
 def convert_to_non_ssa(
-    data_depencies: Dict[Variable_types, Set[Variable_types]]
-) -> Dict[Variable_types, Set[Variable_types]]:
+    data_depencies: Dict[SUPPORTED_TYPES, Set[SUPPORTED_TYPES]]
+) -> Dict[SUPPORTED_TYPES, Set[SUPPORTED_TYPES]]:
     # Need to create new set() as its changed during iteration
-    ret: Dict[Variable_types, Set[Variable_types]] = {}
+    ret: Dict[SUPPORTED_TYPES, Set[SUPPORTED_TYPES]] = {}
     for (k, values) in data_depencies.items():
         var = convert_variable_to_non_ssa(k)
         if not var in ret:
             ret[var] = set()
         ret[var] = ret[var].union({convert_variable_to_non_ssa(v) for v in values})
 
     return ret
```

### Comparing `slither-analyzer-0.9.3/slither/analyses/evm/convert.py` & `slither-analyzer-0.9.4/slither/analyses/evm/convert.py`

 * *Files 0% similar despite different names*

```diff
@@ -182,15 +182,15 @@
         mapping_item = mapping.split(":")
         mapping_item += prev_mapping[len(mapping_item) :]
 
         for i, _ in enumerate(mapping_item):
             if mapping_item[i] == "":
                 mapping_item[i] = int(prev_mapping[i])
 
-        offset, _length, file_id, _ = mapping_item
+        offset, _length, file_id, *_ = mapping_item
         prev_mapping = mapping_item
 
         if file_id == "-1":
             # Internal compiler-generated code snippets to be ignored
             # See https://github.com/ethereum/solidity/issues/6119#issuecomment-467797635
             continue
```

### Comparing `slither-analyzer-0.9.3/slither/analyses/evm/evm_cfg_builder.py` & `slither-analyzer-0.9.4/slither/analyses/evm/evm_cfg_builder.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/analyses/write/are_variables_written.py` & `slither-analyzer-0.9.4/slither/analyses/write/are_variables_written.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,28 +1,28 @@
 """
     Detect if all the given variables are written in all the paths of the function
 """
 from collections import defaultdict
-from typing import Dict, Set, List
+from typing import Dict, Set, List, Any, Optional
 
 from slither.core.cfg.node import NodeType, Node
-from slither.core.declarations import SolidityFunction
+from slither.core.declarations import SolidityFunction, Function
 from slither.core.variables.variable import Variable
 from slither.slithir.operations import (
     Index,
     Member,
     OperationWithLValue,
     SolidityCall,
     Length,
 )
 from slither.slithir.variables import ReferenceVariable, TemporaryVariable
 
 
 class State:  # pylint: disable=too-few-public-methods
-    def __init__(self):
+    def __init__(self) -> None:
         # Map node -> list of variables set
         # Were each variables set represents a configuration of a path
         # If two paths lead to the exact same set of variables written, we dont need to explore both
         # We need to keep different set per path, because we want to capture stuff like
         # if (..){
         #    v = 10
         # }
@@ -30,31 +30,33 @@
         # We would lose this information
         # In other words, in each in the list represents a set of path that has the same outcome
         self.nodes: Dict[Node, List[Set[Variable]]] = defaultdict(list)
 
 
 # pylint: disable=too-many-branches
 def _visit(
-    node: Node,
+    node: Optional[Node],
     state: State,
     variables_written: Set[Variable],
     variables_to_write: List[Variable],
-):
+) -> List[Variable]:
     """
     Explore all the nodes to look for values not written when the node's function return
     Fixpoint reaches if no new written variables are found
 
     :param node:
     :param state:
     :param variables_to_write:
     :return:
     """
 
     refs = {}
     variables_written = set(variables_written)
+    if not node:
+        return []
     for ir in node.irs:
         if isinstance(ir, SolidityCall):
             # TODO convert the revert to a THROW node
             if ir.function in [
                 SolidityFunction("revert(string)"),
                 SolidityFunction("revert()"),
             ]:
@@ -66,25 +68,28 @@
             refs[ir.lvalue] = ir.variable_left
         if isinstance(ir, Length):
             refs[ir.lvalue] = ir.value
 
         if ir.lvalue and not isinstance(ir.lvalue, (TemporaryVariable, ReferenceVariable)):
             variables_written.add(ir.lvalue)
 
-        lvalue = ir.lvalue
+        lvalue: Any = ir.lvalue
         while isinstance(lvalue, ReferenceVariable):
             if lvalue not in refs:
                 break
-            if refs[lvalue] and not isinstance(
-                refs[lvalue], (TemporaryVariable, ReferenceVariable)
+            refs_lvalues = refs[lvalue]
+            if (
+                refs_lvalues
+                and isinstance(refs_lvalues, Variable)
+                and not isinstance(refs_lvalues, (TemporaryVariable, ReferenceVariable))
             ):
-                variables_written.add(refs[lvalue])
-            lvalue = refs[lvalue]
+                variables_written.add(refs_lvalues)
+            lvalue = refs_lvalues
 
-    ret = []
+    ret: List[Variable] = []
     if not node.sons and node.type not in [NodeType.THROW, NodeType.RETURN]:
         ret += [v for v in variables_to_write if v not in variables_written]
 
     # Explore sons if
     # - Before is none: its the first time we explored the node
     # - variables_written is not before: it means that this path has a configuration of set variables
     # that we haven't seen yet
@@ -92,15 +97,15 @@
     if before is None or variables_written not in before:
         state.nodes[node].append(variables_written)
         for son in node.sons:
             ret += _visit(son, state, variables_written, variables_to_write)
     return ret
 
 
-def are_variables_written(function, variables_to_write):
+def are_variables_written(function: Function, variables_to_write: List[Variable]) -> List[Variable]:
     """
         Return the list of variable that are not written at the end of the function
 
     Args:
         function (Function)
         variables_to_write (list Variable): variable that must be written
     Returns:
```

### Comparing `slither-analyzer-0.9.3/slither/core/cfg/node.py` & `slither-analyzer-0.9.4/slither/core/cfg/node.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,15 @@
 """
     Node module
 """
 from enum import Enum
 from typing import Optional, List, Set, Dict, Tuple, Union, TYPE_CHECKING
 
 from slither.all_exceptions import SlitherException
-from slither.core.children.child_function import ChildFunction
-from slither.core.declarations import Contract, Function
+from slither.core.declarations import Contract, Function, FunctionContract
 from slither.core.declarations.solidity_variables import (
     SolidityVariable,
     SolidityFunction,
 )
 from slither.core.expressions.expression import Expression
 from slither.core.solidity_types import ElementaryType
 from slither.core.source_mapping.source_mapping import SourceMapping
@@ -29,14 +28,15 @@
     OperationWithLValue,
     Phi,
     PhiCallback,
     SolidityCall,
     Return,
     Operation,
 )
+from slither.slithir.utils.utils import RVALUE
 from slither.slithir.variables import (
     Constant,
     LocalIRVariable,
     ReferenceVariable,
     StateIRVariable,
     TemporaryVariable,
     TupleVariable,
@@ -102,15 +102,15 @@
     OTHER_ENTRYPOINT = "OTHER_ENTRYPOINT"
 
 
 # endregion
 
 # I am not sure why, but pylint reports a lot of "no-member" issue that are not real (Josselin)
 # pylint: disable=no-member
-class Node(SourceMapping, ChildFunction):  # pylint: disable=too-many-public-methods
+class Node(SourceMapping):  # pylint: disable=too-many-public-methods
     """
     Node class
 
     """
 
     def __init__(
         self,
@@ -142,20 +142,20 @@
         # self._phi_origins_member_variables: Dict[str, Tuple[MemberVariable, Set["Node"]]] = {}
 
         self._expression: Optional[Expression] = None
         self._variable_declaration: Optional[LocalVariable] = None
         self._node_id: int = node_id
 
         self._vars_written: List[Variable] = []
-        self._vars_read: List[Variable] = []
+        self._vars_read: List[Union[Variable, SolidityVariable]] = []
 
         self._ssa_vars_written: List["SlithIRVariable"] = []
         self._ssa_vars_read: List["SlithIRVariable"] = []
 
-        self._internal_calls: List["Function"] = []
+        self._internal_calls: List[Union["Function", "SolidityFunction"]] = []
         self._solidity_calls: List[SolidityFunction] = []
         self._high_level_calls: List["HighLevelCallType"] = []  # contains library calls
         self._library_calls: List["LibraryCallType"] = []
         self._low_level_calls: List["LowLevelCallType"] = []
         self._external_calls_as_expressions: List[Expression] = []
         self._internal_calls_as_expressions: List[Expression] = []
         self._irs: List[Operation] = []
@@ -168,15 +168,17 @@
 
         self._ssa_state_vars_written: List[StateIRVariable] = []
         self._ssa_state_vars_read: List[StateIRVariable] = []
 
         self._local_vars_read: List[LocalVariable] = []
         self._local_vars_written: List[LocalVariable] = []
 
-        self._slithir_vars: Set["SlithIRVariable"] = set()  # non SSA
+        self._slithir_vars: Set[
+            Union["SlithIRVariable", ReferenceVariable, TemporaryVariable, TupleVariable]
+        ] = set()  # non SSA
 
         self._ssa_local_vars_read: List[LocalIRVariable] = []
         self._ssa_local_vars_written: List[LocalIRVariable] = []
 
         self._expression_vars_written: List[Expression] = []
         self._expression_vars_read: List[Expression] = []
         self._expression_calls: List[Expression] = []
@@ -185,14 +187,15 @@
         self._can_reenter: Optional[bool] = None
         self._can_send_eth: Optional[bool] = None
 
         self._asm_source_code: Optional[Union[str, Dict]] = None
 
         self.scope: Union["Scope", "Function"] = scope
         self.file_scope: "FileScope" = file_scope
+        self._function: Optional["Function"] = None
 
     ###################################################################################
     ###################################################################################
     # region General's properties
     ###################################################################################
     ###################################################################################
 
@@ -209,34 +212,41 @@
     def type(self) -> NodeType:
         """
         NodeType: type of the node
         """
         return self._node_type
 
     @type.setter
-    def type(self, new_type: NodeType):
+    def type(self, new_type: NodeType) -> None:
         self._node_type = new_type
 
     @property
     def will_return(self) -> bool:
         if not self.sons and self.type != NodeType.THROW:
             if SolidityFunction("revert()") not in self.solidity_calls:
                 if SolidityFunction("revert(string)") not in self.solidity_calls:
                     return True
         return False
 
+    def set_function(self, function: "Function") -> None:
+        self._function = function
+
+    @property
+    def function(self) -> "Function":
+        return self._function
+
     # endregion
     ###################################################################################
     ###################################################################################
     # region Variables
     ###################################################################################
     ###################################################################################
 
     @property
-    def variables_read(self) -> List[Variable]:
+    def variables_read(self) -> List[Union[Variable, SolidityVariable]]:
         """
         list(Variable): Variables read (local/state/solidity)
         """
         return list(self._vars_read)
 
     @property
     def state_variables_read(self) -> List[StateVariable]:
@@ -281,19 +291,21 @@
         return list(self._ssa_local_vars_read)
 
     @property
     def variables_read_as_expression(self) -> List[Expression]:
         return self._expression_vars_read
 
     @variables_read_as_expression.setter
-    def variables_read_as_expression(self, exprs: List[Expression]):
+    def variables_read_as_expression(self, exprs: List[Expression]) -> None:
         self._expression_vars_read = exprs
 
     @property
-    def slithir_variables(self) -> List["SlithIRVariable"]:
+    def slithir_variables(
+        self,
+    ) -> List[Union["SlithIRVariable", ReferenceVariable, TemporaryVariable, TupleVariable]]:
         return list(self._slithir_vars)
 
     @property
     def variables_written(self) -> List[Variable]:
         """
         list(Variable): Variables written (local/state/solidity)
         """
@@ -335,15 +347,15 @@
         return list(self._ssa_local_vars_written)
 
     @property
     def variables_written_as_expression(self) -> List[Expression]:
         return self._expression_vars_written
 
     @variables_written_as_expression.setter
-    def variables_written_as_expression(self, exprs: List[Expression]):
+    def variables_written_as_expression(self, exprs: List[Expression]) -> None:
         self._expression_vars_written = exprs
 
     # endregion
     ###################################################################################
     ###################################################################################
     # region Calls
     ###################################################################################
@@ -395,37 +407,37 @@
     def external_calls_as_expressions(self) -> List[Expression]:
         """
         list(CallExpression): List of message calls (that creates a transaction)
         """
         return self._external_calls_as_expressions
 
     @external_calls_as_expressions.setter
-    def external_calls_as_expressions(self, exprs: List[Expression]):
+    def external_calls_as_expressions(self, exprs: List[Expression]) -> None:
         self._external_calls_as_expressions = exprs
 
     @property
     def internal_calls_as_expressions(self) -> List[Expression]:
         """
         list(CallExpression): List of internal calls (that dont create a transaction)
         """
         return self._internal_calls_as_expressions
 
     @internal_calls_as_expressions.setter
-    def internal_calls_as_expressions(self, exprs: List[Expression]):
+    def internal_calls_as_expressions(self, exprs: List[Expression]) -> None:
         self._internal_calls_as_expressions = exprs
 
     @property
     def calls_as_expression(self) -> List[Expression]:
         return list(self._expression_calls)
 
     @calls_as_expression.setter
-    def calls_as_expression(self, exprs: List[Expression]):
+    def calls_as_expression(self, exprs: List[Expression]) -> None:
         self._expression_calls = exprs
 
-    def can_reenter(self, callstack=None) -> bool:
+    def can_reenter(self, callstack: Optional[List[Union[Function, Variable]]] = None) -> bool:
         """
         Check if the node can re-enter
         Do not consider CREATE as potential re-enter, but check if the
         destination's constructor can contain a call (recurs. follow nested CREATE)
         For Solidity > 0.5, filter access to public variables and constant/pure/view
         For call to this. check if the destination can re-enter
         Do not consider Send/Transfer as there is not enough gas
@@ -563,15 +575,15 @@
         """Add a father node
 
         Args:
             father: father to add
         """
         self._fathers.append(father)
 
-    def set_fathers(self, fathers: List["Node"]):
+    def set_fathers(self, fathers: List["Node"]) -> None:
         """Set the father nodes
 
         Args:
             fathers: list of fathers to add
         """
         self._fathers = fathers
 
@@ -604,14 +616,29 @@
         """Add a son node
 
         Args:
             son: son to add
         """
         self._sons.append(son)
 
+    def replace_son(self, ori_son: "Node", new_son: "Node") -> None:
+        """Replace a son node. Do nothing if the node to replace is not a son
+
+        Args:
+            ori_son: son to replace
+            new_son: son to replace with
+        """
+        for i, s in enumerate(self._sons):
+            if s.node_id == ori_son.node_id:
+                idx = i
+                break
+        else:
+            return
+        self._sons[idx] = new_son
+
     def set_sons(self, sons: List["Node"]) -> None:
         """Set the son nodes
 
         Args:
             sons: list of fathers to add
         """
         self._sons = sons
@@ -659,28 +686,28 @@
 
         return
             list(slithIR.Operation)
         """
         return self._irs_ssa
 
     @irs_ssa.setter
-    def irs_ssa(self, irs):
+    def irs_ssa(self, irs: List[Operation]) -> None:
         self._irs_ssa = irs
 
     def add_ssa_ir(self, ir: Operation) -> None:
         """
         Use to place phi operation
         """
-        ir.set_node(self)
+        ir.set_node(self)  # type: ignore
         self._irs_ssa.append(ir)
 
     def slithir_generation(self) -> None:
         if self.expression:
             expression = self.expression
-            self._irs = convert_expression(expression, self)
+            self._irs = convert_expression(expression, self)  # type:ignore
 
         self._find_read_write_call()
 
     def all_slithir_operations(self) -> List[Operation]:
         if self._all_slithir_operations is None:
             irs = list(self.irs)
             for ir in self.irs:
@@ -709,39 +736,39 @@
         """
         Returns:
             set(Node)
         """
         return self._dominators
 
     @dominators.setter
-    def dominators(self, dom: Set["Node"]):
+    def dominators(self, dom: Set["Node"]) -> None:
         self._dominators = dom
 
     @property
     def immediate_dominator(self) -> Optional["Node"]:
         """
         Returns:
             Node or None
         """
         return self._immediate_dominator
 
     @immediate_dominator.setter
-    def immediate_dominator(self, idom: "Node"):
+    def immediate_dominator(self, idom: "Node") -> None:
         self._immediate_dominator = idom
 
     @property
     def dominance_frontier(self) -> Set["Node"]:
         """
         Returns:
             set(Node)
         """
         return self._dominance_frontier
 
     @dominance_frontier.setter
-    def dominance_frontier(self, doms: Set["Node"]):
+    def dominance_frontier(self, doms: Set["Node"]) -> None:
         """
         Returns:
             set(Node)
         """
         self._dominance_frontier = doms
 
     @property
@@ -785,14 +812,15 @@
 
     # @property
     # def phi_origin_member_variables(self) -> Dict[str, Tuple[MemberVariable, Set["Node"]]]:
     #     return self._phi_origins_member_variables
 
     def add_phi_origin_local_variable(self, variable: LocalVariable, node: "Node") -> None:
         if variable.name not in self._phi_origins_local_variables:
+            assert variable.name
             self._phi_origins_local_variables[variable.name] = (variable, set())
         (v, nodes) = self._phi_origins_local_variables[variable.name]
         assert v == variable
         nodes.add(node)
 
     def add_phi_origin_state_variable(self, variable: StateVariable, node: "Node") -> None:
         if variable.canonical_name not in self._phi_origins_state_variables:
@@ -823,24 +851,26 @@
         for ir in self.irs:
 
             self._slithir_vars |= {v for v in ir.read if self._is_valid_slithir_var(v)}
 
             if isinstance(ir, OperationWithLValue):
                 var = ir.lvalue
                 if var and self._is_valid_slithir_var(var):
-                    self._slithir_vars.add(var)
+                    # The type is checked by is_valid_slithir_var
+                    self._slithir_vars.add(var)  # type: ignore
 
             if not isinstance(ir, (Phi, Index, Member)):
                 self._vars_read += [v for v in ir.read if self._is_non_slithir_var(v)]
                 for var in ir.read:
                     if isinstance(var, ReferenceVariable):
                         self._vars_read.append(var.points_to_origin)
             elif isinstance(ir, (Member, Index)):
+                # TODO investigate types for member variable left
                 var = ir.variable_left if isinstance(ir, Member) else ir.variable_right
-                if self._is_non_slithir_var(var):
+                if var and self._is_non_slithir_var(var):
                     self._vars_read.append(var)
                 if isinstance(var, ReferenceVariable):
                     origin = var.points_to_origin
                     if self._is_non_slithir_var(origin):
                         self._vars_read.append(origin)
 
             if isinstance(ir, OperationWithLValue):
@@ -856,22 +886,29 @@
                 self._internal_calls.append(ir.function)
             if isinstance(ir, SolidityCall):
                 # TODO: consider removing dependancy of solidity_call to internal_call
                 self._solidity_calls.append(ir.function)
                 self._internal_calls.append(ir.function)
             if isinstance(ir, LowLevelCall):
                 assert isinstance(ir.destination, (Variable, SolidityVariable))
-                self._low_level_calls.append((ir.destination, ir.function_name.value))
+                self._low_level_calls.append((ir.destination, str(ir.function_name.value)))
             elif isinstance(ir, HighLevelCall) and not isinstance(ir, LibraryCall):
+                # Todo investigate this if condition
+                # It does seem right to compare against a contract
+                # This might need a refactoring
                 if isinstance(ir.destination.type, Contract):
                     self._high_level_calls.append((ir.destination.type, ir.function))
                 elif ir.destination == SolidityVariable("this"):
-                    self._high_level_calls.append((self.function.contract, ir.function))
+                    func = self.function
+                    # Can't use this in a top level function
+                    assert isinstance(func, FunctionContract)
+                    self._high_level_calls.append((func.contract, ir.function))
                 else:
                     try:
+                        # Todo this part needs more tests and documentation
                         self._high_level_calls.append((ir.destination.type.type, ir.function))
                     except AttributeError as error:
                         #  pylint: disable=raise-missing-from
                         raise SlitherException(
                             f"Function not found on IR: {ir}.\nNode: {self} ({self.source_mapping})\nFunction: {self.function}\nPlease try compiling with a recent Solidity version. {error}"
                         )
             elif isinstance(ir, LibraryCall):
@@ -879,32 +916,37 @@
                 assert isinstance(ir.function, Function)
                 self._high_level_calls.append((ir.destination, ir.function))
                 self._library_calls.append((ir.destination, ir.function))
 
         self._vars_read = list(set(self._vars_read))
         self._state_vars_read = [v for v in self._vars_read if isinstance(v, StateVariable)]
         self._local_vars_read = [v for v in self._vars_read if isinstance(v, LocalVariable)]
-        self._solidity_vars_read = [v for v in self._vars_read if isinstance(v, SolidityVariable)]
+        self._solidity_vars_read = [
+            v_ for v_ in self._vars_read if isinstance(v_, SolidityVariable)
+        ]
         self._vars_written = list(set(self._vars_written))
         self._state_vars_written = [v for v in self._vars_written if isinstance(v, StateVariable)]
         self._local_vars_written = [v for v in self._vars_written if isinstance(v, LocalVariable)]
         self._internal_calls = list(set(self._internal_calls))
         self._solidity_calls = list(set(self._solidity_calls))
         self._high_level_calls = list(set(self._high_level_calls))
         self._library_calls = list(set(self._library_calls))
         self._low_level_calls = list(set(self._low_level_calls))
 
     @staticmethod
     def _convert_ssa(v: Variable) -> Optional[Union[StateVariable, LocalVariable]]:
+        non_ssa_var: Optional[Union[StateVariable, LocalVariable]]
         if isinstance(v, StateIRVariable):
             contract = v.contract
+            assert v.name
             non_ssa_var = contract.get_state_variable_from_name(v.name)
             return non_ssa_var
         assert isinstance(v, LocalIRVariable)
         function = v.function
+        assert v.name
         non_ssa_var = function.get_local_variable_from_name(v.name)
         return non_ssa_var
 
     def update_read_write_using_ssa(self) -> None:
         if not self.expression:
             return
         for ir in self.irs_ssa:
@@ -917,18 +959,19 @@
                 for var in ir.read:
                     if isinstance(var, ReferenceVariable):
                         origin = var.points_to_origin
                         if isinstance(origin, (StateIRVariable, LocalIRVariable)):
                             self._ssa_vars_read.append(origin)
 
             elif isinstance(ir, (Member, Index)):
-                if isinstance(ir.variable_right, (StateIRVariable, LocalIRVariable)):
-                    self._ssa_vars_read.append(ir.variable_right)
-                if isinstance(ir.variable_right, ReferenceVariable):
-                    origin = ir.variable_right.points_to_origin
+                variable_right: RVALUE = ir.variable_right
+                if isinstance(variable_right, (StateIRVariable, LocalIRVariable)):
+                    self._ssa_vars_read.append(variable_right)
+                if isinstance(variable_right, ReferenceVariable):
+                    origin = variable_right.points_to_origin
                     if isinstance(origin, (StateIRVariable, LocalIRVariable)):
                         self._ssa_vars_read.append(origin)
 
             if isinstance(ir, OperationWithLValue):
                 if isinstance(ir, (Index, Member, Length)):
                     continue  # Don't consider Member and Index operations -> ReferenceVariable
                 var = ir.lvalue
@@ -940,28 +983,28 @@
                         continue
                     self._ssa_vars_written.append(var)
         self._ssa_vars_read = list(set(self._ssa_vars_read))
         self._ssa_state_vars_read = [v for v in self._ssa_vars_read if isinstance(v, StateVariable)]
         self._ssa_local_vars_read = [v for v in self._ssa_vars_read if isinstance(v, LocalVariable)]
         self._ssa_vars_written = list(set(self._ssa_vars_written))
         self._ssa_state_vars_written = [
-            v for v in self._ssa_vars_written if isinstance(v, StateVariable)
+            v for v in self._ssa_vars_written if v and isinstance(v, StateIRVariable)
         ]
         self._ssa_local_vars_written = [
-            v for v in self._ssa_vars_written if isinstance(v, LocalVariable)
+            v for v in self._ssa_vars_written if v and isinstance(v, LocalIRVariable)
         ]
 
         vars_read = [self._convert_ssa(x) for x in self._ssa_vars_read]
         vars_written = [self._convert_ssa(x) for x in self._ssa_vars_written]
 
-        self._vars_read += [v for v in vars_read if v not in self._vars_read]
+        self._vars_read += [v_ for v_ in vars_read if v_ and v_ not in self._vars_read]
         self._state_vars_read = [v for v in self._vars_read if isinstance(v, StateVariable)]
         self._local_vars_read = [v for v in self._vars_read if isinstance(v, LocalVariable)]
 
-        self._vars_written += [v for v in vars_written if v not in self._vars_written]
+        self._vars_written += [v_ for v_ in vars_written if v_ and v_ not in self._vars_written]
         self._state_vars_written = [v for v in self._vars_written if isinstance(v, StateVariable)]
         self._local_vars_written = [v for v in self._vars_written if isinstance(v, LocalVariable)]
 
     # endregion
     ###################################################################################
     ###################################################################################
     # region Built in definitions
@@ -970,15 +1013,15 @@
 
     def __str__(self) -> str:
         additional_info = ""
         if self.expression:
             additional_info += " " + str(self.expression)
         elif self.variable_declaration:
             additional_info += " " + str(self.variable_declaration)
-        txt = self._node_type.value + additional_info
+        txt = str(self._node_type.value) + additional_info
         return txt
 
 
 # endregion
 ###################################################################################
 ###################################################################################
 # region Utils
```

### Comparing `slither-analyzer-0.9.3/slither/core/children/child_expression.py` & `slither-analyzer-0.9.4/slither/visitors/expression/has_conditional.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,18 +1,15 @@
-from typing import TYPE_CHECKING, Union
+from slither.core.expressions.expression import Expression
+from slither.visitors.expression.expression import ExpressionVisitor
+from slither.core.expressions.conditional_expression import ConditionalExpression
 
-if TYPE_CHECKING:
-    from slither.core.expressions.expression import Expression
-    from slither.slithir.operations import Operation
 
+class HasConditional(ExpressionVisitor):
+    def __init__(self, expression: Expression) -> None:
+        self._result: bool = False
+        super().__init__(expression)
 
-class ChildExpression:
-    def __init__(self) -> None:
-        super().__init__()
-        self._expression = None
+    def result(self) -> bool:
+        return self._result
 
-    def set_expression(self, expression: Union["Expression", "Operation"]) -> None:
-        self._expression = expression
-
-    @property
-    def expression(self) -> Union["Expression", "Operation"]:
-        return self._expression
+    def _post_conditional_expression(self, expression: ConditionalExpression) -> None:
+        self._result = True
```

### Comparing `slither-analyzer-0.9.3/slither/core/compilation_unit.py` & `slither-analyzer-0.9.4/slither/core/compilation_unit.py`

 * *Files 5% similar despite different names*

```diff
@@ -9,15 +9,15 @@
 from slither.core.declarations import (
     Contract,
     Pragma,
     Import,
     Function,
     Modifier,
 )
-from slither.core.declarations.custom_error import CustomError
+from slither.core.declarations.custom_error_top_level import CustomErrorTopLevel
 from slither.core.declarations.enum_top_level import EnumTopLevel
 from slither.core.declarations.function_top_level import FunctionTopLevel
 from slither.core.declarations.structure_top_level import StructureTopLevel
 from slither.core.declarations.using_for_top_level import UsingForTopLevel
 from slither.core.scope.scope import FileScope
 from slither.core.solidity_types.type_alias import TypeAliasTopLevel
 from slither.core.variables.state_variable import StateVariable
@@ -42,26 +42,26 @@
         self._structures_top_level: List[StructureTopLevel] = []
         self._enums_top_level: List[EnumTopLevel] = []
         self._variables_top_level: List[TopLevelVariable] = []
         self._functions_top_level: List[FunctionTopLevel] = []
         self._using_for_top_level: List[UsingForTopLevel] = []
         self._pragma_directives: List[Pragma] = []
         self._import_directives: List[Import] = []
-        self._custom_errors: List[CustomError] = []
+        self._custom_errors: List[CustomErrorTopLevel] = []
         self._user_defined_value_types: Dict[str, TypeAliasTopLevel] = {}
 
         self._all_functions: Set[Function] = set()
         self._all_modifiers: Set[Modifier] = set()
 
         # Memoize
         self._all_state_variables: Optional[Set[StateVariable]] = None
 
         self._storage_layouts: Dict[str, Dict[str, Tuple[int, int]]] = {}
 
-        self._contract_with_missing_inheritance = set()
+        self._contract_with_missing_inheritance: Set[Contract] = set()
 
         self._source_units: Dict[int, str] = {}
 
         self.counter_slithir_tuple = 0
         self.counter_slithir_temporary = 0
         self.counter_slithir_reference = 0
 
@@ -84,15 +84,16 @@
 
     @property
     def compiler_version(self) -> CompilerVersion:
         return self._crytic_compile_compilation_unit.compiler_version
 
     @property
     def solc_version(self) -> str:
-        return self._crytic_compile_compilation_unit.compiler_version.version
+        # TODO: make version a non optional argument of compiler version in cc
+        return self._crytic_compile_compilation_unit.compiler_version.version  # type:ignore
 
     @property
     def crytic_compile_compilation_unit(self) -> CompilationUnit:
         return self._crytic_compile_compilation_unit
 
     @property
     def crytic_compile(self) -> CryticCompile:
@@ -123,15 +124,15 @@
     ###################################################################################
 
     @property
     def contracts_derived(self) -> List[Contract]:
         """list(Contract): List of contracts that are derived and not inherited."""
         inheritances = [x.inheritance for x in self.contracts]
         inheritance = [item for sublist in inheritances for item in sublist]
-        return [c for c in self.contracts if c not in inheritance and not c.is_top_level]
+        return [c for c in self.contracts if c not in inheritance]
 
     def get_contract_from_name(self, contract_name: Union[str, Constant]) -> List[Contract]:
         """
             Return a list of contract from a name
         Args:
             contract_name (str): name of the contract
         Returns:
@@ -158,35 +159,36 @@
         return list(self._all_modifiers)
 
     def add_modifier(self, modif: Modifier) -> None:
         self._all_modifiers.add(modif)
 
     @property
     def functions_and_modifiers(self) -> List[Function]:
-        return self.functions + self.modifiers
+        return self.functions + list(self.modifiers)
 
     def propagate_function_calls(self) -> None:
         for f in self.functions_and_modifiers:
             for node in f.nodes:
                 for ir in node.irs_ssa:
                     if isinstance(ir, InternalCall):
+                        assert ir.function
                         ir.function.add_reachable_from_node(node, ir)
 
     # endregion
     ###################################################################################
     ###################################################################################
     # region Variables
     ###################################################################################
     ###################################################################################
 
     @property
     def state_variables(self) -> List[StateVariable]:
         if self._all_state_variables is None:
-            state_variables = [c.state_variables for c in self.contracts]
-            state_variables = [item for sublist in state_variables for item in sublist]
+            state_variabless = [c.state_variables for c in self.contracts]
+            state_variables = [item for sublist in state_variabless for item in sublist]
             self._all_state_variables = set(state_variables)
         return list(self._all_state_variables)
 
     # endregion
     ###################################################################################
     ###################################################################################
     # region Top level
@@ -210,30 +212,30 @@
         return self._functions_top_level
 
     @property
     def using_for_top_level(self) -> List[UsingForTopLevel]:
         return self._using_for_top_level
 
     @property
-    def custom_errors(self) -> List[CustomError]:
+    def custom_errors(self) -> List[CustomErrorTopLevel]:
         return self._custom_errors
 
     @property
     def user_defined_value_types(self) -> Dict[str, TypeAliasTopLevel]:
         return self._user_defined_value_types
 
     # endregion
     ###################################################################################
     ###################################################################################
     # region Internals
     ###################################################################################
     ###################################################################################
 
     @property
-    def contracts_with_missing_inheritance(self) -> Set:
+    def contracts_with_missing_inheritance(self) -> Set[Contract]:
         return self._contract_with_missing_inheritance
 
     # endregion
     ###################################################################################
     ###################################################################################
     # region Scope
     ###################################################################################
@@ -262,14 +264,15 @@
 
             slot = 0
             offset = 0
             for var in contract.state_variables_ordered:
                 if var.is_constant or var.is_immutable:
                     continue
 
+                assert var.type
                 size, new_slot = var.type.storage_size
 
                 if new_slot:
                     if offset > 0:
                         slot += 1
                         offset = 0
                 elif size + offset > 32:
@@ -281,11 +284,11 @@
                     offset,
                 )
                 if new_slot:
                     slot += math.ceil(size / 32)
                 else:
                     offset += size
 
-    def storage_layout_of(self, contract, var) -> Tuple[int, int]:
+    def storage_layout_of(self, contract: Contract, var: StateVariable) -> Tuple[int, int]:
         return self._storage_layouts[contract.name][var.canonical_name]
 
     # endregion
```

### Comparing `slither-analyzer-0.9.3/slither/core/declarations/__init__.py` & `slither-analyzer-0.9.4/slither/core/declarations/__init__.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/core/declarations/contract.py` & `slither-analyzer-0.9.4/slither/core/declarations/contract.py`

 * *Files 2% similar despite different names*

```diff
@@ -45,14 +45,17 @@
     from slither.core.compilation_unit import SlitherCompilationUnit
     from slither.core.scope.scope import FileScope
     from slither.core.cfg.node import Node
 
 
 LOGGER = logging.getLogger("Contract")
 
+USING_FOR_KEY = Union[str, Type]
+USING_FOR_ITEM = List[Union[Type, Function]]
+
 
 class Contract(SourceMapping):  # pylint: disable=too-many-public-methods
     """
     Contract class
     """
 
     def __init__(self, compilation_unit: "SlitherCompilationUnit", scope: "FileScope") -> None:
@@ -76,30 +79,31 @@
         self._variables_ordered: List["StateVariable"] = []
         self._modifiers: Dict[str, "Modifier"] = {}
         self._functions: Dict[str, "FunctionContract"] = {}
         self._linearizedBaseContracts: List[int] = []
         self._custom_errors: Dict[str, "CustomErrorContract"] = {}
 
         # The only str is "*"
-        self._using_for: Dict[Union[str, Type], List[Type]] = {}
-        self._using_for_complete: Dict[Union[str, Type], List[Type]] = None
+        self._using_for: Dict[USING_FOR_KEY, USING_FOR_ITEM] = {}
+        self._using_for_complete: Optional[Dict[USING_FOR_KEY, USING_FOR_ITEM]] = None
         self._kind: Optional[str] = None
         self._is_interface: bool = False
         self._is_library: bool = False
         self._is_fully_implemented: bool = False
 
         self._signatures: Optional[List[str]] = None
         self._signatures_declared: Optional[List[str]] = None
 
+        self._fallback_function: Optional["FunctionContract"] = None
+        self._receive_function: Optional["FunctionContract"] = None
+
         self._is_upgradeable: Optional[bool] = None
         self._is_upgradeable_proxy: Optional[bool] = None
         self._upgradeable_version: Optional[str] = None
 
-        self.is_top_level = False  # heavily used, so no @property
-
         self._initial_state_variables: List["StateVariable"] = []  # ssa
 
         self._is_incorrectly_parsed: bool = False
 
         self._available_functions_as_dict: Optional[Dict[str, "Function"]] = None
         self._all_functions_called: Optional[List["InternalCallType"]] = None
 
@@ -122,54 +126,54 @@
     @property
     def name(self) -> str:
         """str: Name of the contract."""
         assert self._name
         return self._name
 
     @name.setter
-    def name(self, name: str):
+    def name(self, name: str) -> None:
         self._name = name
 
     @property
     def id(self) -> int:
         """Unique id."""
         assert self._id
         return self._id
 
     @id.setter
-    def id(self, new_id):
+    def id(self, new_id: int) -> None:
         """Unique id."""
         self._id = new_id
 
     @property
     def contract_kind(self) -> Optional[str]:
         """
         contract_kind can be None if the legacy ast format is used
         :return:
         """
         return self._kind
 
     @contract_kind.setter
-    def contract_kind(self, kind):
+    def contract_kind(self, kind: str) -> None:
         self._kind = kind
 
     @property
     def is_interface(self) -> bool:
         return self._is_interface
 
     @is_interface.setter
-    def is_interface(self, is_interface: bool):
+    def is_interface(self, is_interface: bool) -> None:
         self._is_interface = is_interface
 
     @property
     def is_library(self) -> bool:
         return self._is_library
 
     @is_library.setter
-    def is_library(self, is_library: bool):
+    def is_library(self, is_library: bool) -> None:
         self._is_library = is_library
 
     @property
     def comments(self) -> Optional[str]:
         """
         Return the comments associated with the contract.
 
@@ -298,24 +302,26 @@
     ###################################################################################
     ###################################################################################
     # region Using for
     ###################################################################################
     ###################################################################################
 
     @property
-    def using_for(self) -> Dict[Union[str, Type], List[Type]]:
+    def using_for(self) -> Dict[USING_FOR_KEY, USING_FOR_ITEM]:
         return self._using_for
 
     @property
-    def using_for_complete(self) -> Dict[Union[str, Type], List[Type]]:
+    def using_for_complete(self) -> Dict[USING_FOR_KEY, USING_FOR_ITEM]:
         """
         Dict[Union[str, Type], List[Type]]: Dict of merged local using for directive with top level directive
         """
 
-        def _merge_using_for(uf1, uf2):
+        def _merge_using_for(
+            uf1: Dict[USING_FOR_KEY, USING_FOR_ITEM], uf2: Dict[USING_FOR_KEY, USING_FOR_ITEM]
+        ) -> Dict[USING_FOR_KEY, USING_FOR_ITEM]:
             result = {**uf1, **uf2}
             for key, value in result.items():
                 if key in uf1 and key in uf2:
                     result[key] = value + uf1[key]
             return result
 
         if self._using_for_complete is None:
@@ -487,15 +493,15 @@
                 for func in self.functions
                 if func.is_constructor and func.contract_declarer == self
             ),
             None,
         )
 
     @property
-    def constructors(self) -> List["Function"]:
+    def constructors(self) -> List["FunctionContract"]:
         """
         Return the list of constructors (including inherited)
         """
         return [func for func in self.functions if func.is_constructor]
 
     @property
     def explicit_base_constructor_calls(self) -> List["Function"]:
@@ -556,22 +562,22 @@
     @property
     def functions(self) -> List["FunctionContract"]:
         """
         list(Function): List of the functions
         """
         return list(self._functions.values())
 
-    def available_functions_as_dict(self) -> Dict[str, "FunctionContract"]:
+    def available_functions_as_dict(self) -> Dict[str, "Function"]:
         if self._available_functions_as_dict is None:
             self._available_functions_as_dict = {
                 f.full_name: f for f in self._functions.values() if not f.is_shadowed
             }
         return self._available_functions_as_dict
 
-    def add_function(self, func: "FunctionContract"):
+    def add_function(self, func: "FunctionContract") -> None:
         self._functions[func.canonical_name] = func
 
     def set_functions(self, functions: Dict[str, "FunctionContract"]) -> None:
         """
         Set the functions
 
         :param functions:  dict full_name -> function
@@ -654,14 +660,32 @@
     @property
     def functions_and_modifiers_declared(self) -> List["Function"]:
         """
         list(Function|Modifier): List of the functions and modifiers defined within the contract (not inherited)
         """
         return self.functions_declared + self.modifiers_declared  # type: ignore
 
+    @property
+    def fallback_function(self) -> Optional["FunctionContract"]:
+        if self._fallback_function is None:
+            for f in self.functions:
+                if f.is_fallback:
+                    self._fallback_function = f
+                    break
+        return self._fallback_function
+
+    @property
+    def receive_function(self) -> Optional["FunctionContract"]:
+        if self._receive_function is None:
+            for f in self.functions:
+                if f.is_receive:
+                    self._receive_function = f
+                    break
+        return self._receive_function
+
     def available_elements_from_inheritances(
         self,
         elements: Dict[str, "Function"],
         getter_available: Callable[["Contract"], List["FunctionContract"]],
     ) -> Dict[str, "Function"]:
         """
 
@@ -731,15 +755,15 @@
 
     @property
     def derived_contracts(self) -> List["Contract"]:
         """
         list(Contract): Return the list of contracts derived from self
         """
         candidates = self.compilation_unit.contracts
-        return [c for c in candidates if self in c.inheritance]
+        return [c for c in candidates if self in c.inheritance]  # type: ignore
 
     # endregion
     ###################################################################################
     ###################################################################################
     # region Getters from/to object
     ###################################################################################
     ###################################################################################
@@ -887,15 +911,15 @@
         Args:
             enum_name (str): name of the enum
         Returns:
             Enum
         """
         return next((e for e in self.enums if e.name == enum_name), None)
 
-    def get_enum_from_canonical_name(self, enum_name) -> Optional["Enum"]:
+    def get_enum_from_canonical_name(self, enum_name: str) -> Optional["Enum"]:
         """
             Return an enum from a canonical name
         Args:
             enum_name (str): canonical name of the enum
         Returns:
             Enum
         """
@@ -988,15 +1012,17 @@
     # endregion
     ###################################################################################
     ###################################################################################
     # region Summary information
     ###################################################################################
     ###################################################################################
 
-    def get_summary(self, include_shadowed=True) -> Tuple[str, List[str], List[str], List, List]:
+    def get_summary(
+        self, include_shadowed: bool = True
+    ) -> Tuple[str, List[str], List[str], List, List]:
         """Return the function summary
 
         :param include_shadowed: boolean to indicate if shadowed functions should be included (default True)
         Returns:
             (str, list, list, list, list): (name, inheritance, variables, fuction summaries, modifier summaries)
         """
         func_summaries = [
@@ -1241,25 +1267,25 @@
                 paths = Path(self.source_mapping.filename.absolute).parts
                 if len(paths) >= 2:
                     return paths[-2] == "contracts" and paths[-1] == "migrations.sol"
         return False
 
     @property
     def is_test(self) -> bool:
-        return is_test_contract(self) or self.is_truffle_migration
+        return is_test_contract(self) or self.is_truffle_migration  # type: ignore
 
     # endregion
     ###################################################################################
     ###################################################################################
     # region Function analyses
     ###################################################################################
     ###################################################################################
 
     def update_read_write_using_ssa(self) -> None:
-        for function in self.functions + self.modifiers:
+        for function in self.functions + list(self.modifiers):
             function.update_read_write_using_ssa()
 
     # endregion
     ###################################################################################
     ###################################################################################
     # region Upgradeability
     ###################################################################################
@@ -1286,15 +1312,15 @@
                         break
                     if "initializable" in lower_name:
                         self._is_upgradeable = True
                         break
         return self._is_upgradeable
 
     @is_upgradeable.setter
-    def is_upgradeable(self, upgradeable: bool):
+    def is_upgradeable(self, upgradeable: bool) -> None:
         self._is_upgradeable = upgradeable
 
     @property
     def is_upgradeable_proxy(self) -> bool:
         from slither.core.cfg.node import NodeType
         from slither.slithir.operations import LowLevelCall
 
@@ -1315,23 +1341,23 @@
                             if inline_asm:
                                 if "delegatecall" in inline_asm:
                                     self._is_upgradeable_proxy = True
                                     return self._is_upgradeable_proxy
         return self._is_upgradeable_proxy
 
     @is_upgradeable_proxy.setter
-    def is_upgradeable_proxy(self, upgradeable_proxy: bool):
+    def is_upgradeable_proxy(self, upgradeable_proxy: bool) -> None:
         self._is_upgradeable_proxy = upgradeable_proxy
 
     @property
     def upgradeable_version(self) -> Optional[str]:
         return self._upgradeable_version
 
     @upgradeable_version.setter
-    def upgradeable_version(self, version_name: str):
+    def upgradeable_version(self, version_name: str) -> None:
         self._upgradeable_version = version_name
 
     # endregion
     ###################################################################################
     ###################################################################################
     # region Internals
     ###################################################################################
@@ -1342,28 +1368,28 @@
         """
         Return true if there was an internal Slither's issue when analyzing the contract
         :return:
         """
         return self._is_incorrectly_parsed
 
     @is_incorrectly_constructed.setter
-    def is_incorrectly_constructed(self, incorrect: bool):
+    def is_incorrectly_constructed(self, incorrect: bool) -> None:
         self._is_incorrectly_parsed = incorrect
 
     def add_constructor_variables(self) -> None:
         from slither.core.declarations.function_contract import FunctionContract
 
         if self.state_variables:
             for (idx, variable_candidate) in enumerate(self.state_variables):
                 if variable_candidate.expression and not variable_candidate.is_constant:
 
                     constructor_variable = FunctionContract(self.compilation_unit)
                     constructor_variable.set_function_type(FunctionType.CONSTRUCTOR_VARIABLES)
-                    constructor_variable.set_contract(self)
-                    constructor_variable.set_contract_declarer(self)
+                    constructor_variable.set_contract(self)  # type: ignore
+                    constructor_variable.set_contract_declarer(self)  # type: ignore
                     constructor_variable.set_visibility("internal")
                     # For now, source mapping of the constructor variable is the whole contract
                     # Could be improved with a targeted source mapping
                     constructor_variable.set_offset(self.source_mapping, self.compilation_unit)
                     self._functions[constructor_variable.canonical_name] = constructor_variable
 
                     prev_node = self._create_node(
@@ -1386,16 +1412,16 @@
             for (idx, variable_candidate) in enumerate(self.state_variables):
                 if variable_candidate.expression and variable_candidate.is_constant:
 
                     constructor_variable = FunctionContract(self.compilation_unit)
                     constructor_variable.set_function_type(
                         FunctionType.CONSTRUCTOR_CONSTANT_VARIABLES
                     )
-                    constructor_variable.set_contract(self)
-                    constructor_variable.set_contract_declarer(self)
+                    constructor_variable.set_contract(self)  # type: ignore
+                    constructor_variable.set_contract_declarer(self)  # type: ignore
                     constructor_variable.set_visibility("internal")
                     # For now, source mapping of the constructor variable is the whole contract
                     # Could be improved with a targeted source mapping
                     constructor_variable.set_offset(self.source_mapping, self.compilation_unit)
                     self._functions[constructor_variable.canonical_name] = constructor_variable
 
                     prev_node = self._create_node(
@@ -1468,49 +1494,50 @@
 
         for v in self.variables:
             if v.contract == self:
                 new_var = StateIRVariable(v)
                 all_ssa_state_variables_instances[v.canonical_name] = new_var
                 self._initial_state_variables.append(new_var)
 
-        for func in self.functions + self.modifiers:
+        for func in self.functions + list(self.modifiers):
             func.generate_slithir_ssa(all_ssa_state_variables_instances)
 
     def fix_phi(self) -> None:
-        last_state_variables_instances = {}
-        initial_state_variables_instances = {}
+        last_state_variables_instances: Dict[str, List["StateVariable"]] = {}
+        initial_state_variables_instances: Dict[str, "StateVariable"] = {}
         for v in self._initial_state_variables:
             last_state_variables_instances[v.canonical_name] = []
             initial_state_variables_instances[v.canonical_name] = v
 
-        for func in self.functions + self.modifiers:
+        for func in self.functions + list(self.modifiers):
             result = func.get_last_ssa_state_variables_instances()
             for variable_name, instances in result.items():
-                last_state_variables_instances[variable_name] += instances
+                # TODO: investigate the next operation
+                last_state_variables_instances[variable_name] += list(instances)
 
-        for func in self.functions + self.modifiers:
+        for func in self.functions + list(self.modifiers):
             func.fix_phi(last_state_variables_instances, initial_state_variables_instances)
 
     # endregion
     ###################################################################################
     ###################################################################################
     # region Built in definitions
     ###################################################################################
     ###################################################################################
 
-    def __eq__(self, other: SourceMapping) -> bool:
+    def __eq__(self, other: Any) -> bool:
         if isinstance(other, str):
             return other == self.name
         return NotImplemented
 
     def __neq__(self, other: Any) -> bool:
         if isinstance(other, str):
             return other != self.name
         return NotImplemented
 
     def __str__(self) -> str:
         return self.name
 
     def __hash__(self) -> int:
-        return self._id
+        return self._id  # type:ignore
 
     # endregion
```

### Comparing `slither-analyzer-0.9.3/slither/core/declarations/custom_error.py` & `slither-analyzer-0.9.4/slither/core/declarations/custom_error.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,12 +1,12 @@
-from typing import List, TYPE_CHECKING, Optional, Type, Union
+from typing import List, TYPE_CHECKING, Optional, Type
 
-from slither.core.solidity_types import UserDefinedType
 from slither.core.source_mapping.source_mapping import SourceMapping
 from slither.core.variables.local_variable import LocalVariable
+from slither.utils.type import is_underlying_type_address
 
 if TYPE_CHECKING:
     from slither.core.compilation_unit import SlitherCompilationUnit
 
 
 class CustomError(SourceMapping):
     def __init__(self, compilation_unit: "SlitherCompilationUnit") -> None:
@@ -38,45 +38,42 @@
         return self._compilation_unit
 
     # region Signature
     ###################################################################################
     ###################################################################################
 
     @staticmethod
-    def _convert_type_for_solidity_signature(t: Optional[Union[Type, List[Type]]]) -> str:
-        # pylint: disable=import-outside-toplevel
-        from slither.core.declarations import Contract
-
-        if isinstance(t, UserDefinedType) and isinstance(t.type, Contract):
+    def _convert_type_for_solidity_signature(t: Optional[Type]) -> str:
+        if is_underlying_type_address(t):
             return "address"
         return str(t)
 
     @property
-    def solidity_signature(self) -> Optional[str]:
+    def solidity_signature(self) -> str:
         """
         Return a signature following the Solidity Standard
         Contract and converted into address
         :return: the solidity signature
         """
         # Ideally this should be an assert
         # But due to a logic limitation in the solc parsing (find_variable)
         # We need to raise an error if the custom error sig was not yet built
         # (set_solidity_sig was not called before find_variable)
         if self._solidity_signature is None:
             raise ValueError("Custom Error not yet built")
-        return self._solidity_signature
+        return self._solidity_signature  # type: ignore
 
     def set_solidity_sig(self) -> None:
         """
         Function to be called once all the parameters have been set
 
         Returns:
 
         """
-        parameters = [x.type for x in self.parameters]
+        parameters = [x.type for x in self.parameters if x.type]
         self._full_name = self.name + "(" + ",".join(map(str, parameters)) + ")"
         solidity_parameters = map(self._convert_type_for_solidity_signature, parameters)
         self._solidity_signature = self.name + "(" + ",".join(solidity_parameters) + ")"
 
     @property
     def full_name(self) -> Optional[str]:
         """
```

### Comparing `slither-analyzer-0.9.3/slither/core/declarations/custom_error_top_level.py` & `slither-analyzer-0.9.4/slither/core/declarations/custom_error_top_level.py`

 * *Files 20% similar despite different names*

```diff
@@ -5,10 +5,10 @@
 
 if TYPE_CHECKING:
     from slither.core.compilation_unit import SlitherCompilationUnit
     from slither.core.scope.scope import FileScope
 
 
 class CustomErrorTopLevel(CustomError, TopLevel):
-    def __init__(self, compilation_unit: "SlitherCompilationUnit", scope: "FileScope"):
+    def __init__(self, compilation_unit: "SlitherCompilationUnit", scope: "FileScope") -> None:
         super().__init__(compilation_unit)
         self.file_scope: "FileScope" = scope
```

### Comparing `slither-analyzer-0.9.3/slither/core/declarations/enum.py` & `slither-analyzer-0.9.4/slither/core/declarations/enum.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/core/declarations/event.py` & `slither-analyzer-0.9.4/slither/core/declarations/event.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,18 +1,18 @@
 from typing import List, Tuple, TYPE_CHECKING
 
-from slither.core.children.child_contract import ChildContract
+from slither.core.declarations.contract_level import ContractLevel
 from slither.core.source_mapping.source_mapping import SourceMapping
 from slither.core.variables.event_variable import EventVariable
 
 if TYPE_CHECKING:
     from slither.core.declarations import Contract
 
 
-class Event(ChildContract, SourceMapping):
+class Event(ContractLevel, SourceMapping):
     def __init__(self) -> None:
         super().__init__()
         self._name = None
         self._elems: List[EventVariable] = []
 
     @property
     def name(self) -> str:
@@ -41,15 +41,15 @@
 
     @property
     def canonical_name(self) -> str:
         """Return the function signature as a str
         Returns:
             str: contract.func_name(type1,type2)
         """
-        return self.contract.name + self.full_name
+        return self.contract.name + "." + self.full_name
 
     @property
     def elems(self) -> List["EventVariable"]:
         return self._elems
 
     def is_declared_by(self, contract: "Contract") -> bool:
         """
```

### Comparing `slither-analyzer-0.9.3/slither/core/declarations/function.py` & `slither-analyzer-0.9.4/slither/core/declarations/function.py`

 * *Files 0% similar despite different names*

```diff
@@ -43,15 +43,14 @@
     from slither.slithir.variables.variable import SlithIRVariable
     from slither.slithir.variables import LocalIRVariable
     from slither.core.expressions.expression import Expression
     from slither.slithir.operations import Operation
     from slither.core.compilation_unit import SlitherCompilationUnit
     from slither.core.scope.scope import FileScope
     from slither.slithir.variables.state_variable import StateIRVariable
-    from slither.core.declarations.function_contract import FunctionContract
 
 LOGGER = logging.getLogger("Function")
 ReacheableNode = namedtuple("ReacheableNode", ["node", "ir"])
 
 
 class ModifierStatements:
     def __init__(
@@ -294,15 +293,15 @@
     def contains_assembly(self) -> bool:
         return self._contains_assembly
 
     @contains_assembly.setter
     def contains_assembly(self, c: bool):
         self._contains_assembly = c
 
-    def can_reenter(self, callstack: Optional[List["FunctionContract"]] = None) -> bool:
+    def can_reenter(self, callstack: Optional[List[Union["Function", "Variable"]]] = None) -> bool:
         """
         Check if the function can re-enter
         Follow internal calls.
         Do not consider CREATE as potential re-enter, but check if the
         destination's constructor can contain a call (recurs. follow nested CREATE)
         For Solidity > 0.5, filter access to public variables and constant/pure/view
         For call to this. check if the destination can re-enter
@@ -1716,16 +1715,16 @@
             return False
         if not ir.rvalues:
             return True
         return ir.rvalues[0] == ir.lvalue
 
     def fix_phi(
         self,
-        last_state_variables_instances: Dict[str, List["StateIRVariable"]],
-        initial_state_variables_instances: Dict[str, "StateIRVariable"],
+        last_state_variables_instances: Dict[str, List["StateVariable"]],
+        initial_state_variables_instances: Dict[str, "StateVariable"],
     ) -> None:
         from slither.slithir.operations import InternalCall, PhiCallback
         from slither.slithir.variables import Constant, StateIRVariable
 
         for node in self.nodes:
             for ir in node.irs_ssa:
                 if node == self.entry_point:
```

### Comparing `slither-analyzer-0.9.3/slither/core/declarations/function_contract.py` & `slither-analyzer-0.9.4/slither/detectors/functions/arbitrary_send_eth.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,116 +1,153 @@
 """
-    Function module
+    Module detecting send to arbitrary address
+
+    To avoid FP, it does not report:
+        - If msg.sender is used as index (withdraw situation)
+        - If the function is protected
+        - If the value sent is msg.value (repay situation)
+        - If there is a call to transferFrom
+
+    TODO: dont report if the value is tainted by msg.value
 """
-from typing import Dict, TYPE_CHECKING, List, Tuple
+from typing import Any, Tuple, Union, List
 
-from slither.core.children.child_contract import ChildContract
-from slither.core.children.child_inheritance import ChildInheritance
-from slither.core.declarations import Function
-from slither.utils.code_complexity import compute_cyclomatic_complexity
-
-
-# pylint: disable=import-outside-toplevel,too-many-instance-attributes,too-many-statements,too-many-lines
-
-if TYPE_CHECKING:
-    from slither.core.declarations import Contract
-    from slither.core.scope.scope import FileScope
-    from slither.slithir.variables.state_variable import StateIRVariable
-
-
-class FunctionContract(Function, ChildContract, ChildInheritance):
-    @property
-    def canonical_name(self) -> str:
-        """
-        str: contract.func_name(type1,type2)
-        Return the function signature without the return values
-        """
-        if self._canonical_name is None:
-            name, parameters, _ = self.signature
-            self._canonical_name = (
-                ".".join([self.contract_declarer.name] + self._internal_scope + [name])
-                + "("
-                + ",".join(parameters)
-                + ")"
-            )
-        return self._canonical_name
-
-    def is_declared_by(self, contract: "Contract") -> bool:
-        """
-        Check if the element is declared by the contract
-        :param contract:
-        :return:
-        """
-        return self.contract_declarer == contract
-
-    @property
-    def file_scope(self) -> "FileScope":
-        return self.contract.file_scope
-
-    # endregion
-    ###################################################################################
-    ###################################################################################
-    # region Functions
-    ###################################################################################
-    ###################################################################################
-
-    @property
-    def functions_shadowed(self) -> List["Function"]:
-        """
-            Return the list of functions shadowed
-        Returns:
-            list(core.Function)
-
-        """
-        candidates = [c.functions_declared for c in self.contract.inheritance]
-        candidates = [candidate for sublist in candidates for candidate in sublist]
-        return [f for f in candidates if f.full_name == self.full_name]
-
-    # endregion
-    ###################################################################################
-    ###################################################################################
-    # region Summary information
-    ###################################################################################
-    ###################################################################################
-
-    def get_summary(
-        self,
-    ) -> Tuple[str, str, str, List[str], List[str], List[str], List[str], List[str], int]:
-        """
-            Return the function summary
-        Returns:
-            (str, str, str, list(str), list(str), listr(str), list(str), list(str);
-            contract_name, name, visibility, modifiers, vars read, vars written, internal_calls, external_calls_as_expressions
-        """
-        return (
-            self.contract_declarer.name,
-            self.full_name,
-            self.visibility,
-            [str(x) for x in self.modifiers],
-            [str(x) for x in self.state_variables_read + self.solidity_variables_read],
-            [str(x) for x in self.state_variables_written],
-            [str(x) for x in self.internal_calls],
-            [str(x) for x in self.external_calls_as_expressions],
-            compute_cyclomatic_complexity(self),
+from slither.analyses.data_dependency.data_dependency import is_tainted, is_dependent
+from slither.core.cfg.node import Node
+from slither.core.declarations import Function, Contract
+from slither.core.declarations.function_contract import FunctionContract
+from slither.core.declarations.solidity_variables import (
+    SolidityFunction,
+    SolidityVariableComposed,
+    SolidityVariable,
+)
+from slither.core.variables import Variable
+from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.slithir.operations import (
+    HighLevelCall,
+    Index,
+    LowLevelCall,
+    Send,
+    SolidityCall,
+    Transfer,
+)
+
+# pylint: disable=too-many-nested-blocks,too-many-branches
+from slither.utils.output import Output
+
+
+def arbitrary_send(func: Function) -> Union[bool, List[Node]]:
+    if func.is_protected():
+        return []
+
+    ret: List[Node] = []
+    for node in func.nodes:
+        func = node.function
+        deps_target: Union[Contract, Function] = (
+            func.contract if isinstance(func, FunctionContract) else func
         )
+        for ir in node.irs:
+            if isinstance(ir, SolidityCall):
+                if ir.function == SolidityFunction("ecrecover(bytes32,uint8,bytes32,bytes32)"):
+                    return False
+            if isinstance(ir, Index):
+                if ir.variable_right == SolidityVariableComposed("msg.sender"):
+                    return False
+                if is_dependent(
+                    ir.variable_right,
+                    SolidityVariableComposed("msg.sender"),
+                    deps_target,
+                ):
+                    return False
+            if isinstance(ir, (HighLevelCall, LowLevelCall, Transfer, Send)):
+                if isinstance(ir, (HighLevelCall)):
+                    if isinstance(ir.function, Function):
+                        if ir.function.full_name == "transferFrom(address,address,uint256)":
+                            return False
+                if ir.call_value is None:
+                    continue
+                if ir.call_value == SolidityVariableComposed("msg.value"):
+                    continue
+                if is_dependent(
+                    ir.call_value,
+                    SolidityVariableComposed("msg.value"),
+                    node,
+                ):
+                    continue
+
+                if isinstance(ir.destination, (Variable, SolidityVariable)):
+                    if is_tainted(ir.destination, node):
+                        ret.append(node)
+
+    return ret
+
+
+def detect_arbitrary_send(
+    contract: Contract,
+) -> List[Union[Tuple[FunctionContract, List[Node]], Any]]:
+    """
+        Detect arbitrary send
+    Args:
+        contract (Contract)
+    Returns:
+        list((Function), (list (Node)))
+    """
+    ret = []
+    for f in [f for f in contract.functions if f.contract_declarer == contract]:
+        nodes = arbitrary_send(f)
+        if nodes:
+            ret.append((f, nodes))
+    return ret
+
+
+class ArbitrarySendEth(AbstractDetector):
+    ARGUMENT = "arbitrary-send-eth"
+    HELP = "Functions that send Ether to arbitrary destinations"
+    IMPACT = DetectorClassification.HIGH
+    CONFIDENCE = DetectorClassification.MEDIUM
+
+    WIKI = "https://github.com/crytic/slither/wiki/Detector-Documentation#functions-that-send-ether-to-arbitrary-destinations"
+
+    WIKI_TITLE = "Functions that send Ether to arbitrary destinations"
+    WIKI_DESCRIPTION = "Unprotected call to a function sending Ether to an arbitrary address."
+
+    # region wiki_exploit_scenario
+    WIKI_EXPLOIT_SCENARIO = """
+```solidity
+contract ArbitrarySendEth{
+    address destination;
+    function setDestination(){
+        destination = msg.sender;
+    }
+
+    function withdraw() public{
+        destination.transfer(this.balance);
+    }
+}
+```
+Bob calls `setDestination` and `withdraw`. As a result he withdraws the contract's balance."""
+    # endregion wiki_exploit_scenario
+
+    WIKI_RECOMMENDATION = "Ensure that an arbitrary user cannot withdraw unauthorized funds."
+
+    def _detect(self) -> List[Output]:
+        """"""
+        results = []
+
+        for c in self.contracts:
+            arbitrary_send_result = detect_arbitrary_send(c)
+            for (func, nodes) in arbitrary_send_result:
+
+                info = [func, " sends eth to arbitrary user\n"]
+                info += ["\tDangerous calls:\n"]
+
+                # sort the nodes to get deterministic results
+                nodes.sort(key=lambda x: x.node_id)
 
-    # endregion
-    ###################################################################################
-    ###################################################################################
-    # region SlithIr and SSA
-    ###################################################################################
-    ###################################################################################
-
-    def generate_slithir_ssa(
-        self, all_ssa_state_variables_instances: Dict[str, "StateIRVariable"]
-    ) -> None:
-        from slither.slithir.utils.ssa import add_ssa_ir, transform_slithir_vars_to_ssa
-        from slither.core.dominators.utils import (
-            compute_dominance_frontier,
-            compute_dominators,
-        )
+                for node in nodes:
+                    info += ["\t- ", node, "\n"]
+
+                res = self.generate_result(info)
+
+                results.append(res)
 
-        compute_dominators(self.nodes)
-        compute_dominance_frontier(self.nodes)
-        transform_slithir_vars_to_ssa(self)
-        if not self.contract.is_incorrectly_constructed:
-            add_ssa_ir(self, all_ssa_state_variables_instances)
+        return results
```

### Comparing `slither-analyzer-0.9.3/slither/core/declarations/function_top_level.py` & `slither-analyzer-0.9.4/slither/core/declarations/function_top_level.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/core/declarations/import_directive.py` & `slither-analyzer-0.9.4/slither/core/declarations/import_directive.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/core/declarations/pragma_directive.py` & `slither-analyzer-0.9.4/slither/core/declarations/pragma_directive.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/core/declarations/solidity_import_placeholder.py` & `slither-analyzer-0.9.4/slither/core/declarations/solidity_import_placeholder.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/core/declarations/solidity_variables.py` & `slither-analyzer-0.9.4/slither/core/declarations/solidity_variables.py`

 * *Files 3% similar despite different names*

```diff
@@ -17,18 +17,19 @@
     "super": "",
 }
 
 SOLIDITY_VARIABLES_COMPOSED = {
     "block.basefee": "uint",
     "block.coinbase": "address",
     "block.difficulty": "uint256",
+    "block.prevrandao": "uint256",
     "block.gaslimit": "uint256",
     "block.number": "uint256",
     "block.timestamp": "uint256",
-    "block.blockhash": "uint256",  # alias for blockhash. It's a call
+    "block.blockhash": "bytes32",  # alias for blockhash. It's a call
     "block.chainid": "uint256",
     "msg.data": "bytes",
     "msg.gas": "uint256",
     "msg.sender": "address",
     "msg.sig": "bytes4",
     "msg.value": "uint256",
     "tx.gasprice": "uint256",
@@ -56,14 +57,15 @@
     "selfdestruct(address)": [],
     "suicide(address)": [],
     "log0(bytes32)": [],
     "log1(bytes32,bytes32)": [],
     "log2(bytes32,bytes32,bytes32)": [],
     "log3(bytes32,bytes32,bytes32,bytes32)": [],
     "blockhash(uint256)": ["bytes32"],
+    "prevrandao()": ["uint256"],
     # the following need a special handling
     # as they are recognized as a SolidityVariableComposed
     # and converted to a SolidityFunction by SlithIR
     "this.balance()": ["uint256"],
     "abi.encode()": ["bytes"],
     "abi.encodePacked()": ["bytes"],
     "abi.encodeWithSelector()": ["bytes"],
@@ -78,15 +80,15 @@
     # The following are conversion from address.something
     "balance(address)": ["uint256"],
     "code(address)": ["bytes"],
     "codehash(address)": ["bytes32"],
 }
 
 
-def solidity_function_signature(name):
+def solidity_function_signature(name: str) -> str:
     """
         Return the function signature (containing the return value)
         It is useful if a solidity function is used as a pointer
         (see exoressionParsing.find_variable documentation)
     Args:
         name(str):
     Returns:
@@ -102,15 +104,15 @@
         self._name = name
 
     # dev function, will be removed once the code is stable
     def _check_name(self, name: str) -> None:  # pylint: disable=no-self-use
         assert name in SOLIDITY_VARIABLES or name.endswith(("_slot", "_offset"))
 
     @property
-    def state_variable(self):
+    def state_variable(self) -> str:
         if self._name.endswith("_slot"):
             return self._name[:-5]
         if self._name.endswith("_offset"):
             return self._name[:-7]
         to_log = f"Incorrect YUL parsing. {self} is not a solidity variable that can be seen as a state variable"
         raise SlitherException(to_log)
 
@@ -121,15 +123,15 @@
     @property
     def type(self) -> ElementaryType:
         return ElementaryType(SOLIDITY_VARIABLES[self.name])
 
     def __str__(self) -> str:
         return self._name
 
-    def __eq__(self, other: SourceMapping) -> bool:
+    def __eq__(self, other: Any) -> bool:
         return self.__class__ == other.__class__ and self.name == other.name
 
     def __hash__(self) -> int:
         return hash(self.name)
 
 
 class SolidityVariableComposed(SolidityVariable):
@@ -178,34 +180,38 @@
         return self.name
 
     @property
     def return_type(self) -> List[Union[TypeInformation, ElementaryType]]:
         return self._return_type
 
     @return_type.setter
-    def return_type(self, r: List[Union[TypeInformation, ElementaryType]]):
+    def return_type(self, r: List[Union[TypeInformation, ElementaryType]]) -> None:
         self._return_type = r
 
     def __str__(self) -> str:
         return self._name
 
-    def __eq__(self, other: "SolidityFunction") -> bool:
+    def __eq__(self, other: Any) -> bool:
         return self.__class__ == other.__class__ and self.name == other.name
 
     def __hash__(self) -> int:
         return hash(self.name)
 
 
 class SolidityCustomRevert(SolidityFunction):
     def __init__(self, custom_error: CustomError) -> None:  # pylint: disable=super-init-not-called
         self._name = "revert " + custom_error.solidity_signature
         self._custom_error = custom_error
         self._return_type: List[Union[TypeInformation, ElementaryType]] = []
 
-    def __eq__(self, other: Union["SolidityCustomRevert", SolidityFunction]) -> bool:
+    @property
+    def custom_error(self) -> CustomError:
+        return self._custom_error
+
+    def __eq__(self, other: Any) -> bool:
         return (
             self.__class__ == other.__class__
             and self.name == other.name
             and self._custom_error == other._custom_error
         )
 
     def __hash__(self) -> int:
```

### Comparing `slither-analyzer-0.9.3/slither/core/declarations/structure.py` & `slither-analyzer-0.9.4/slither/core/declarations/structure.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/core/dominators/node_dominator_tree.py` & `slither-analyzer-0.9.4/slither/core/dominators/node_dominator_tree.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/core/dominators/utils.py` & `slither-analyzer-0.9.4/slither/core/dominators/utils.py`

 * *Files 3% similar despite different names*

```diff
@@ -91,8 +91,9 @@
                     runner == node.immediate_dominator
                     and runner.type == NodeType.IF
                     and node.type == NodeType.ENDIF
                 ):
                     runner.dominance_frontier = runner.dominance_frontier.union({node})
                 while runner != node.immediate_dominator:
                     runner.dominance_frontier = runner.dominance_frontier.union({node})
+                    assert runner.immediate_dominator
                     runner = runner.immediate_dominator
```

### Comparing `slither-analyzer-0.9.3/slither/core/expressions/__init__.py` & `slither-analyzer-0.9.4/slither/core/expressions/__init__.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/core/expressions/assignment_operation.py` & `slither-analyzer-0.9.4/slither/core/expressions/assignment_operation.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,12 +1,11 @@
 import logging
 from enum import Enum
 from typing import Optional, TYPE_CHECKING, List
 
-from slither.core.expressions.expression_typed import ExpressionTyped
 from slither.core.expressions.expression import Expression
 from slither.core.exceptions import SlitherCoreError
 
 if TYPE_CHECKING:
     from slither.core.solidity_types.type import Type
 
 logger = logging.getLogger("AssignmentOperation")
@@ -74,28 +73,28 @@
         if self == AssignmentOperationType.ASSIGN_DIVISION:
             return "/="
         if self == AssignmentOperationType.ASSIGN_MODULO:
             return "%="
         raise SlitherCoreError(f"str: Unknown operation type {self})")
 
 
-class AssignmentOperation(ExpressionTyped):
+class AssignmentOperation(Expression):
     def __init__(
         self,
         left_expression: Expression,
         right_expression: Expression,
         expression_type: AssignmentOperationType,
         expression_return_type: Optional["Type"],
     ) -> None:
         assert isinstance(left_expression, Expression)
         assert isinstance(right_expression, Expression)
         super().__init__()
         left_expression.set_lvalue()
         self._expressions = [left_expression, right_expression]
-        self._type: Optional["AssignmentOperationType"] = expression_type
+        self._type: AssignmentOperationType = expression_type
         self._expression_return_type: Optional["Type"] = expression_return_type
 
     @property
     def expressions(self) -> List[Expression]:
         return self._expressions
 
     @property
```

### Comparing `slither-analyzer-0.9.3/slither/core/expressions/binary_operation.py` & `slither-analyzer-0.9.4/slither/core/expressions/binary_operation.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,12 +1,11 @@
 import logging
 from enum import Enum
 from typing import List
 
-from slither.core.expressions.expression_typed import ExpressionTyped
 from slither.core.expressions.expression import Expression
 from slither.core.exceptions import SlitherCoreError
 
 
 logger = logging.getLogger("BinaryOperation")
 
 
@@ -144,15 +143,15 @@
         if self == BinaryOperationType.GREATER_SIGNED:
             return ">'"
         if self == BinaryOperationType.RIGHT_SHIFT_ARITHMETIC:
             return ">>'"
         raise SlitherCoreError(f"str: Unknown operation type {self})")
 
 
-class BinaryOperation(ExpressionTyped):
+class BinaryOperation(Expression):
     def __init__(
         self,
         left_expression: Expression,
         right_expression: Expression,
         expression_type: BinaryOperationType,
     ) -> None:
         assert isinstance(left_expression, Expression)
```

### Comparing `slither-analyzer-0.9.3/slither/core/expressions/call_expression.py` & `slither-analyzer-0.9.4/slither/core/expressions/call_expression.py`

 * *Files 14% similar despite different names*

```diff
@@ -18,31 +18,31 @@
         self._salt: Optional[Expression] = None
 
     @property
     def call_value(self) -> Optional[Expression]:
         return self._value
 
     @call_value.setter
-    def call_value(self, v):
+    def call_value(self, v: Optional[Expression]) -> None:
         self._value = v
 
     @property
     def call_gas(self) -> Optional[Expression]:
         return self._gas
 
     @call_gas.setter
-    def call_gas(self, gas):
+    def call_gas(self, gas: Optional[Expression]) -> None:
         self._gas = gas
 
     @property
-    def call_salt(self):
+    def call_salt(self) -> Optional[Expression]:
         return self._salt
 
     @call_salt.setter
-    def call_salt(self, salt):
+    def call_salt(self, salt: Optional[Expression]) -> None:
         self._salt = salt
 
     @property
     def called(self) -> Expression:
         return self._called
 
     @property
```

### Comparing `slither-analyzer-0.9.3/slither/core/expressions/conditional_expression.py` & `slither-analyzer-0.9.4/slither/core/expressions/conditional_expression.py`

 * *Files 1% similar despite different names*

```diff
@@ -38,15 +38,15 @@
     def else_expression(self) -> Expression:
         return self._else_expression
 
     @property
     def then_expression(self) -> Expression:
         return self._then_expression
 
-    def __str__(self):
+    def __str__(self) -> str:
         return (
             "if "
             + str(self._if_expression)
             + " then "
             + str(self._then_expression)
             + " else "
             + str(self._else_expression)
```

### Comparing `slither-analyzer-0.9.3/slither/core/expressions/elementary_type_name_expression.py` & `slither-analyzer-0.9.4/slither/core/expressions/elementary_type_name_expression.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/core/expressions/index_access.py` & `slither-analyzer-0.9.4/slither/core/expressions/type_conversion.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,43 +1,43 @@
-from typing import Union, List, TYPE_CHECKING
-
-from slither.core.expressions.expression_typed import ExpressionTyped
-from slither.core.expressions.identifier import Identifier
-from slither.core.expressions.literal import Literal
+from typing import Union, TYPE_CHECKING
 
+from slither.core.expressions.expression import Expression
+from slither.core.solidity_types.type import Type
 
 if TYPE_CHECKING:
-    from slither.core.expressions.expression import Expression
-    from slither.core.solidity_types.type import Type
+    from slither.core.expressions.call_expression import CallExpression
+    from slither.core.expressions.identifier import Identifier
+    from slither.core.expressions.literal import Literal
+    from slither.core.expressions.member_access import MemberAccess
+    from slither.core.solidity_types.elementary_type import ElementaryType
+    from slither.core.solidity_types.type_alias import TypeAliasContract
+    from slither.core.solidity_types.user_defined_type import UserDefinedType
 
 
-class IndexAccess(ExpressionTyped):
+class TypeConversion(Expression):
     def __init__(
         self,
-        left_expression: Union["IndexAccess", Identifier],
-        right_expression: Union[Literal, Identifier],
-        index_type: str,
+        expression: Union[
+            "MemberAccess", "Literal", "CallExpression", "TypeConversion", "Identifier"
+        ],
+        expression_type: Union["ElementaryType", "UserDefinedType", "TypeAliasContract"],
     ) -> None:
         super().__init__()
-        self._expressions = [left_expression, right_expression]
-        # TODO type of undexAccess is not always a Type
-        #        assert isinstance(index_type, Type)
-        self._type: "Type" = index_type
-
-    @property
-    def expressions(self) -> List["Expression"]:
-        return self._expressions
+        assert isinstance(expression, Expression)
+        assert isinstance(expression_type, Type)
+        self._expression: Expression = expression
+        self._type: Type = expression_type
 
     @property
-    def expression_left(self) -> "Expression":
-        return self._expressions[0]
+    def type(self) -> Type:
+        return self._type
 
-    @property
-    def expression_right(self) -> "Expression":
-        return self._expressions[1]
+    @type.setter
+    def type(self, new_type: Type) -> None:
+        self._type = new_type
 
     @property
-    def type(self) -> "Type":
-        return self._type
+    def expression(self) -> Expression:
+        return self._expression
 
     def __str__(self) -> str:
-        return str(self.expression_left) + "[" + str(self.expression_right) + "]"
+        return str(self.type) + "(" + str(self.expression) + ")"
```

### Comparing `slither-analyzer-0.9.3/slither/core/expressions/literal.py` & `slither-analyzer-0.9.4/slither/core/expressions/literal.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-from typing import Optional, Union, TYPE_CHECKING
+from typing import Optional, Union, TYPE_CHECKING, Any
 
 from slither.core.expressions.expression import Expression
 from slither.core.solidity_types.elementary_type import Fixed, Int, Ufixed, Uint
 from slither.utils.arithmetic import convert_subdenomination
 from slither.utils.integer_conversion import convert_string_to_int
 
 if TYPE_CHECKING:
@@ -43,11 +43,11 @@
 
         if self.type in Int + Uint + Fixed + Ufixed + ["address"]:
             return str(convert_string_to_int(self._value))
 
         # be sure to handle any character
         return str(self._value)
 
-    def __eq__(self, other) -> bool:
+    def __eq__(self, other: Any) -> bool:
         if not isinstance(other, Literal):
             return False
         return (self.value, self.subdenomination) == (other.value, other.subdenomination)
```

### Comparing `slither-analyzer-0.9.3/slither/core/expressions/member_access.py` & `slither-analyzer-0.9.4/slither/core/expressions/member_access.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,14 +1,13 @@
 from slither.core.expressions.expression import Expression
-from slither.core.expressions.expression_typed import ExpressionTyped
 
 from slither.core.solidity_types.type import Type
 
 
-class MemberAccess(ExpressionTyped):
+class MemberAccess(Expression):
     def __init__(self, member_name: str, member_type: str, expression: Expression) -> None:
         # assert isinstance(member_type, Type)
         # TODO member_type is not always a Type
         assert isinstance(expression, Expression)
         super().__init__()
         self._type: Type = member_type
         self._member_name: str = member_name
```

### Comparing `slither-analyzer-0.9.3/slither/core/expressions/new_contract.py` & `slither-analyzer-0.9.4/slither/core/expressions/new_contract.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/core/expressions/tuple_expression.py` & `slither-analyzer-0.9.4/slither/core/expressions/tuple_expression.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/core/expressions/unary_operation.py` & `slither-analyzer-0.9.4/slither/core/expressions/unary_operation.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,12 +1,11 @@
 import logging
 from typing import Union
 from enum import Enum
 
-from slither.core.expressions.expression_typed import ExpressionTyped
 from slither.core.expressions.expression import Expression
 from slither.core.exceptions import SlitherCoreError
 from slither.core.expressions.identifier import Identifier
 from slither.core.expressions.index_access import IndexAccess
 from slither.core.expressions.literal import Literal
 from slither.core.expressions.tuple_expression import TupleExpression
 
@@ -87,15 +86,15 @@
             UnaryOperationType.MINUSMINUS_POST,
         ]:
             return False
 
         raise SlitherCoreError(f"is_prefix: Unknown operation type {operation_type}")
 
 
-class UnaryOperation(ExpressionTyped):
+class UnaryOperation(Expression):
     def __init__(
         self,
         expression: Union[Literal, Identifier, IndexAccess, TupleExpression],
         expression_type: UnaryOperationType,
     ) -> None:
         assert isinstance(expression, Expression)
         super().__init__()
```

### Comparing `slither-analyzer-0.9.3/slither/core/scope/scope.py` & `slither-analyzer-0.9.4/slither/core/scope/scope.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/core/slither_core.py` & `slither-analyzer-0.9.4/slither/core/slither_core.py`

 * *Files 1% similar despite different names*

```diff
@@ -9,15 +9,15 @@
 import re
 from collections import defaultdict
 from typing import Optional, Dict, List, Set, Union, Tuple
 
 from crytic_compile import CryticCompile
 from crytic_compile.utils.naming import Filename
 
-from slither.core.children.child_contract import ChildContract
+from slither.core.declarations.contract_level import ContractLevel
 from slither.core.compilation_unit import SlitherCompilationUnit
 from slither.core.context.context import Context
 from slither.core.declarations import Contract, FunctionContract
 from slither.core.declarations.top_level import TopLevel
 from slither.core.source_mapping.source_mapping import SourceMapping, Source
 from slither.slithir.variables import Constant
 from slither.utils.colors import red
@@ -202,15 +202,15 @@
 
             if (
                 isinstance(thing, TopLevel)
                 or (
                     isinstance(thing, FunctionContract)
                     and thing.contract_declarer == thing.contract
                 )
-                or (isinstance(thing, ChildContract) and not isinstance(thing, FunctionContract))
+                or (isinstance(thing, ContractLevel) and not isinstance(thing, FunctionContract))
             ):
                 self._offset_to_objects[definition.filename][offset].add(thing)
 
             self._offset_to_definitions[definition.filename][offset].add(definition)
             self._offset_to_implementations[definition.filename][offset].add(implementation)
             self._offset_to_references[definition.filename][offset] |= set(references)
 
@@ -220,15 +220,15 @@
                 if (
                     isinstance(thing, TopLevel)
                     or (
                         isinstance(thing, FunctionContract)
                         and thing.contract_declarer == thing.contract
                     )
                     or (
-                        isinstance(thing, ChildContract) and not isinstance(thing, FunctionContract)
+                        isinstance(thing, ContractLevel) and not isinstance(thing, FunctionContract)
                     )
                 ):
                     self._offset_to_objects[definition.filename][offset].add(thing)
 
                 self._offset_to_definitions[ref.filename][offset].add(definition)
                 self._offset_to_implementations[ref.filename][offset].add(implementation)
                 self._offset_to_references[ref.filename][offset] |= set(references)
@@ -478,16 +478,16 @@
     ###################################################################################
     ###################################################################################
     # region Crytic compile
     ###################################################################################
     ###################################################################################
 
     @property
-    def crytic_compile(self) -> Optional[CryticCompile]:
-        return self._crytic_compile
+    def crytic_compile(self) -> CryticCompile:
+        return self._crytic_compile  # type: ignore
 
     # endregion
     ###################################################################################
     ###################################################################################
     # region Format
     ###################################################################################
     ###################################################################################
```

### Comparing `slither-analyzer-0.9.3/slither/core/solidity_types/array_type.py` & `slither-analyzer-0.9.4/slither/core/solidity_types/array_type.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,42 +1,41 @@
 from typing import Union, Optional, Tuple, Any, TYPE_CHECKING
 
 from slither.core.expressions.expression import Expression
+from slither.core.expressions.literal import Literal
+from slither.core.solidity_types.elementary_type import ElementaryType
 from slither.core.solidity_types.type import Type
 from slither.visitors.expression.constants_folding import ConstantFolding
-from slither.core.expressions.literal import Literal
 
 if TYPE_CHECKING:
     from slither.core.expressions.binary_operation import BinaryOperation
     from slither.core.expressions.identifier import Identifier
-    from slither.core.solidity_types.elementary_type import ElementaryType
-    from slither.core.solidity_types.function_type import FunctionType
-    from slither.core.solidity_types.type_alias import TypeAliasTopLevel
 
 
 class ArrayType(Type):
     def __init__(
         self,
-        t: Union["TypeAliasTopLevel", "ArrayType", "FunctionType", "ElementaryType"],
+        t: Type,
         length: Optional[Union["Identifier", Literal, "BinaryOperation", int]],
     ) -> None:
         assert isinstance(t, Type)
         if length:
             if isinstance(length, int):
-                length = Literal(length, "uint256")
-            assert isinstance(length, Expression)
+                length = Literal(length, ElementaryType("uint256"))
+
         super().__init__()
         self._type: Type = t
+        assert length is None or isinstance(length, Expression)
         self._length: Optional[Expression] = length
 
         if length:
             if not isinstance(length, Literal):
                 cf = ConstantFolding(length, "uint256")
                 length = cf.result()
-            self._length_value = length
+            self._length_value: Optional[Literal] = length
         else:
             self._length_value = None
 
     @property
     def type(self) -> Type:
         return self._type
```

### Comparing `slither-analyzer-0.9.3/slither/core/solidity_types/elementary_type.py` & `slither-analyzer-0.9.4/slither/core/solidity_types/elementary_type.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 import itertools
-from typing import Tuple
+from typing import Tuple, Optional, Any
 
 from slither.core.solidity_types.type import Type
 
 
 # see https://solidity.readthedocs.io/en/v0.4.24/miscellaneous.html?highlight=grammar
 from slither.exceptions import SlitherException
 
@@ -172,15 +172,15 @@
         return self._type
 
     @property
     def name(self) -> str:
         return self.type
 
     @property
-    def size(self) -> int:
+    def size(self) -> Optional[int]:
         """
             Return the size in bits
             Return None if the size is not known
         Returns:
             int
         """
         t = self._type
@@ -215,14 +215,14 @@
         if self.name in MaxValues:
             return MaxValues[self.name]
         raise SlitherException(f"{self.name} does not have a max value")
 
     def __str__(self) -> str:
         return self._type
 
-    def __eq__(self, other) -> bool:
+    def __eq__(self, other: Any) -> bool:
         if not isinstance(other, ElementaryType):
             return False
         return self.type == other.type
 
     def __hash__(self) -> int:
         return hash(str(self))
```

### Comparing `slither-analyzer-0.9.3/slither/core/solidity_types/function_type.py` & `slither-analyzer-0.9.4/slither/core/solidity_types/function_type.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/core/solidity_types/mapping_type.py` & `slither-analyzer-0.9.4/slither/core/solidity_types/mapping_type.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-from typing import Union, Tuple, TYPE_CHECKING
+from typing import Union, Tuple, TYPE_CHECKING, Any
 
 from slither.core.solidity_types.type import Type
 
 if TYPE_CHECKING:
     from slither.core.solidity_types.elementary_type import ElementaryType
     from slither.core.solidity_types.type_alias import TypeAliasTopLevel
 
@@ -34,14 +34,14 @@
     @property
     def is_dynamic(self) -> bool:
         return True
 
     def __str__(self) -> str:
         return f"mapping({str(self._from)} => {str(self._to)})"
 
-    def __eq__(self, other):
+    def __eq__(self, other: Any) -> bool:
         if not isinstance(other, MappingType):
             return False
         return self.type_from == other.type_from and self.type_to == other.type_to
 
     def __hash__(self) -> int:
         return hash(str(self))
```

### Comparing `slither-analyzer-0.9.3/slither/core/solidity_types/type.py` & `slither-analyzer-0.9.4/slither/core/solidity_types/type.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/core/solidity_types/type_alias.py` & `slither-analyzer-0.9.4/slither/core/solidity_types/type_alias.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,14 +1,15 @@
-from typing import TYPE_CHECKING, Tuple
+from typing import TYPE_CHECKING, Tuple, Dict
 
-from slither.core.children.child_contract import ChildContract
 from slither.core.declarations.top_level import TopLevel
+from slither.core.declarations.contract_level import ContractLevel
 from slither.core.solidity_types import Type, ElementaryType
 
 if TYPE_CHECKING:
+    from slither.core.declarations.function_top_level import FunctionTopLevel
     from slither.core.declarations import Contract
     from slither.core.scope.scope import FileScope
 
 
 class TypeAlias(Type):
     def __init__(self, underlying_type: ElementaryType, name: str) -> None:
         super().__init__()
@@ -36,22 +37,24 @@
 
     @property
     def is_dynamic(self) -> bool:
         return self.underlying_type.is_dynamic
 
 
 class TypeAliasTopLevel(TypeAlias, TopLevel):
-    def __init__(self, underlying_type: Type, name: str, scope: "FileScope") -> None:
+    def __init__(self, underlying_type: ElementaryType, name: str, scope: "FileScope") -> None:
         super().__init__(underlying_type, name)
         self.file_scope: "FileScope" = scope
+        # operators redefined
+        self.operators: Dict[str, "FunctionTopLevel"] = {}
 
     def __str__(self) -> str:
         return self.name
 
 
-class TypeAliasContract(TypeAlias, ChildContract):
-    def __init__(self, underlying_type: Type, name: str, contract: "Contract") -> None:
+class TypeAliasContract(TypeAlias, ContractLevel):
+    def __init__(self, underlying_type: ElementaryType, name: str, contract: "Contract") -> None:
         super().__init__(underlying_type, name)
         self._contract: "Contract" = contract
 
     def __str__(self) -> str:
         return self.contract.name + "." + self.name
```

### Comparing `slither-analyzer-0.9.3/slither/core/solidity_types/type_information.py` & `slither-analyzer-0.9.4/slither/core/solidity_types/type_information.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-from typing import Union, TYPE_CHECKING, Tuple
+from typing import Union, TYPE_CHECKING, Tuple, Any
 
 from slither.core.solidity_types import ElementaryType
 from slither.core.solidity_types.type import Type
 
 if TYPE_CHECKING:
     from slither.core.declarations.contract import Contract
     from slither.core.declarations.enum import Enum
@@ -36,14 +36,14 @@
         """
         return 32, True
 
     @property
     def is_dynamic(self) -> bool:
         raise NotImplementedError
 
-    def __str__(self):
+    def __str__(self) -> str:
         return f"type({self.type.name})"
 
-    def __eq__(self, other):
+    def __eq__(self, other: Any) -> bool:
         if not isinstance(other, TypeInformation):
             return False
         return self.type == other.type
```

### Comparing `slither-analyzer-0.9.3/slither/core/solidity_types/user_defined_type.py` & `slither-analyzer-0.9.4/slither/core/solidity_types/user_defined_type.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/core/source_mapping/source_mapping.py` & `slither-analyzer-0.9.4/slither/core/source_mapping/source_mapping.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 import re
 from abc import ABCMeta
-from typing import Dict, Union, List, Tuple, TYPE_CHECKING, Optional
+from typing import Dict, Union, List, Tuple, TYPE_CHECKING, Optional, Any
 
 from Crypto.Hash import SHA1
 from crytic_compile.utils.naming import Filename
 from slither.core.context.context import Context
 
 if TYPE_CHECKING:
     from slither.core.compilation_unit import SlitherCompilationUnit
@@ -94,18 +94,18 @@
         return h.hexdigest()
 
     def __str__(self) -> str:
         lines = self._get_lines_str()
         filename_short: str = self.filename.short if self.filename.short else ""
         return f"{filename_short}{lines}"
 
-    def __hash__(self):
+    def __hash__(self) -> int:
         return hash(str(self))
 
-    def __eq__(self, other):
+    def __eq__(self, other: Any) -> bool:
         if not isinstance(other, type(self)):
             return NotImplemented
         return (
             self.start == other.start
             and self.length == other.length
             and self.filename == other.filename
             and self.is_dependency == other.is_dependency
```

### Comparing `slither-analyzer-0.9.3/slither/core/variables/event_variable.py` & `slither-analyzer-0.9.4/slither/core/variables/local_variable_init_from_tuple.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,20 +1,26 @@
-from slither.core.variables.variable import Variable
-from slither.core.children.child_event import ChildEvent
+from typing import Optional
 
+from slither.core.variables.local_variable import LocalVariable
+
+
+class LocalVariableInitFromTuple(LocalVariable):
+    """
+    Use on this pattern:
+    var(a,b) = f()
+
+    It is not possible to split the variable declaration in sigleton and keep the init value
+    We init a and b with f(). get_tuple_index ret() returns which returns values of f is to be used
+
+    """
 
-class EventVariable(ChildEvent, Variable):
     def __init__(self) -> None:
         super().__init__()
-        self._indexed = False
+        self._tuple_index: Optional[int] = None
 
     @property
-    def indexed(self) -> bool:
-        """
-        Indicates whether the event variable is indexed in the bloom filter.
-        :return: Returns True if the variable is indexed in bloom filter, False otherwise.
-        """
-        return self._indexed
-
-    @indexed.setter
-    def indexed(self, is_indexed: bool):
-        self._indexed = is_indexed
+    def tuple_index(self) -> Optional[int]:
+        return self._tuple_index
+
+    @tuple_index.setter
+    def tuple_index(self, idx: int):
+        self._tuple_index = idx
```

### Comparing `slither-analyzer-0.9.3/slither/core/variables/local_variable.py` & `slither-analyzer-0.9.4/slither/core/variables/local_variable.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,23 +1,34 @@
-from typing import Optional
+from typing import Optional, TYPE_CHECKING
 
 from slither.core.variables.variable import Variable
-from slither.core.children.child_function import ChildFunction
 from slither.core.solidity_types.user_defined_type import UserDefinedType
 from slither.core.solidity_types.array_type import ArrayType
 from slither.core.solidity_types.mapping_type import MappingType
 from slither.core.solidity_types.elementary_type import ElementaryType
 
 from slither.core.declarations.structure import Structure
 
+if TYPE_CHECKING:  # type: ignore
+    from slither.core.declarations import Function
 
-class LocalVariable(ChildFunction, Variable):
+
+class LocalVariable(Variable):
     def __init__(self) -> None:
         super().__init__()
         self._location: Optional[str] = None
+        self._function: Optional["Function"] = None
+
+    def set_function(self, function: "Function") -> None:
+        self._function = function
+
+    @property
+    def function(self) -> "Function":
+        assert self._function
+        return self._function
 
     def set_location(self, loc: str) -> None:
         self._location = loc
 
     @property
     def location(self) -> Optional[str]:
         """
@@ -38,14 +49,16 @@
             Return true if the variable is located in storage
             See https://solidity.readthedocs.io/en/v0.4.24/types.html?highlight=storage%20location#data-location
         Returns:
             (bool)
         """
         if self.location == "memory":
             return False
+        if self.location == "calldata":
+            return False
         # Use by slithIR SSA
         if self.location == "reference_to_storage":
             return False
         if self.location == "storage":
             return True
 
         if isinstance(self.type, (ArrayType, MappingType)):
```

### Comparing `slither-analyzer-0.9.3/slither/core/variables/state_variable.py` & `slither-analyzer-0.9.4/slither/core/variables/state_variable.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,18 +1,18 @@
 from typing import Optional, TYPE_CHECKING
 
-from slither.core.children.child_contract import ChildContract
+from slither.core.declarations.contract_level import ContractLevel
 from slither.core.variables.variable import Variable
 
 if TYPE_CHECKING:
     from slither.core.cfg.node import Node
     from slither.core.declarations import Contract
 
 
-class StateVariable(ChildContract, Variable):
+class StateVariable(ContractLevel, Variable):
     def __init__(self) -> None:
         super().__init__()
         self._node_initialization: Optional["Node"] = None
 
     def is_declared_by(self, contract: "Contract") -> bool:
         """
         Check if the element is declared by the contract
```

### Comparing `slither-analyzer-0.9.3/slither/core/variables/top_level_variable.py` & `slither-analyzer-0.9.4/slither/core/variables/top_level_variable.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/core/variables/variable.py` & `slither-analyzer-0.9.4/slither/core/variables/variable.py`

 * *Files 6% similar despite different names*

```diff
@@ -51,15 +51,15 @@
     def initialized(self) -> Optional[bool]:
         """
         boolean: True if the variable is initialized at construction
         """
         return self._initialized
 
     @initialized.setter
-    def initialized(self, is_init: bool):
+    def initialized(self, is_init: bool) -> None:
         self._initialized = is_init
 
     @property
     def uninitialized(self) -> bool:
         """
         boolean: True if the variable is not initialized
         """
@@ -69,31 +69,32 @@
     def name(self) -> Optional[str]:
         """
         str: variable name
         """
         return self._name
 
     @name.setter
-    def name(self, name):
+    def name(self, name: str) -> None:
         self._name = name
 
     @property
-    def type(self) -> Optional[Union[Type, List[Type]]]:
+    def type(self) -> Optional[Type]:
         return self._type
 
     @type.setter
-    def type(self, types: Union[Type, List[Type]]):
-        self._type = types
+    def type(self, new_type: Type) -> None:
+        assert isinstance(new_type, Type)
+        self._type = new_type
 
     @property
     def is_constant(self) -> bool:
         return self._is_constant
 
     @is_constant.setter
-    def is_constant(self, is_cst: bool):
+    def is_constant(self, is_cst: bool) -> None:
         self._is_constant = is_cst
 
     @property
     def is_reentrant(self) -> bool:
         return self._is_reentrant
 
     @is_reentrant.setter
@@ -155,16 +156,16 @@
         from slither.utils.type import (
             export_nested_types_from_variable,
             export_return_type_from_variable,
         )
 
         return (
             self.name,
-            [str(x) for x in export_nested_types_from_variable(self)],
-            [str(x) for x in export_return_type_from_variable(self)],
+            [str(x) for x in export_nested_types_from_variable(self)],  # type: ignore
+            [str(x) for x in export_return_type_from_variable(self)],  # type: ignore
         )
 
     @property
     def signature_str(self) -> str:
         """
         Return the signature of the state variable as a function signature
         :return: str: func_name(type1,type2) returns(type3)
@@ -174,8 +175,9 @@
 
     @property
     def solidity_signature(self) -> str:
         name, parameters, _ = self.signature
         return f'{name}({",".join(parameters)})'
 
     def __str__(self) -> str:
+        assert self._name
         return self._name
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/abstract_detector.py` & `slither-analyzer-0.9.4/slither/detectors/abstract_detector.py`

 * *Files 4% similar despite different names*

```diff
@@ -55,14 +55,16 @@
 
 ALL_SOLC_VERSIONS_04 = make_solc_versions(4, 0, 26)
 ALL_SOLC_VERSIONS_05 = make_solc_versions(5, 0, 17)
 ALL_SOLC_VERSIONS_06 = make_solc_versions(6, 0, 12)
 ALL_SOLC_VERSIONS_07 = make_solc_versions(7, 0, 6)
 # No VERSIONS_08 as it is still in dev
 
+DETECTOR_INFO = List[Union[str, SupportedOutput]]
+
 
 class AbstractDetector(metaclass=abc.ABCMeta):
     ARGUMENT = ""  # run the detector with slither.py --ARGUMENT
     HELP = ""  # help information
     IMPACT: DetectorClassification = DetectorClassification.UNIMPLEMENTED
     CONFIDENCE: DetectorClassification = DetectorClassification.UNIMPLEMENTED
 
@@ -247,15 +249,15 @@
 
     @property
     def color(self) -> Callable[[str], str]:
         return classification_colors[self.IMPACT]
 
     def generate_result(
         self,
-        info: Union[str, List[Union[str, SupportedOutput]]],
+        info: DETECTOR_INFO,
         additional_fields: Optional[Dict] = None,
     ) -> Output:
         output = Output(
             info,
             additional_fields,
             standard_format=self.STANDARD_JSON,
             markdown_root=self.slither.markdown_root,
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/all_detectors.py` & `slither-analyzer-0.9.4/slither/detectors/all_detectors.py`

 * *Files 4% similar despite different names*

```diff
@@ -85,7 +85,10 @@
 from .statements.write_after_write import WriteAfterWrite
 from .statements.msg_value_in_loop import MsgValueInLoop
 from .statements.delegatecall_in_loop import DelegatecallInLoop
 from .functions.protected_variable import ProtectedVariables
 from .functions.permit_domain_signature_collision import DomainSeparatorCollision
 from .functions.codex import Codex
 from .functions.cyclomatic_complexity import CyclomaticComplexity
+from .operations.cache_array_length import CacheArrayLength
+from .statements.incorrect_using_for import IncorrectUsingFor
+from .operations.encode_packed import EncodePackedCollision
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/assembly/shift_parameter_mixup.py` & `slither-analyzer-0.9.4/slither/detectors/assembly/shift_parameter_mixup.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,9 +1,13 @@
 from typing import List
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.slithir.operations import Binary, BinaryType
 from slither.slithir.variables import Constant
 from slither.core.declarations.function_contract import FunctionContract
 from slither.utils.output import Output
 
 
 class ShiftParameterMixup(AbstractDetector):
@@ -44,16 +48,23 @@
 
         for node in f.nodes:
             for ir in node.irs:
                 if isinstance(ir, Binary) and ir.type in [
                     BinaryType.LEFT_SHIFT,
                     BinaryType.RIGHT_SHIFT,
                 ]:
-                    if isinstance(ir.variable_left, Constant):
-                        info = [f, " contains an incorrect shift operation: ", node, "\n"]
+                    if isinstance(ir.variable_left, Constant) and not isinstance(
+                        ir.variable_right, Constant
+                    ):
+                        info: DETECTOR_INFO = [
+                            f,
+                            " contains an incorrect shift operation: ",
+                            node,
+                            "\n",
+                        ]
                         json = self.generate_result(info)
 
                         results.append(json)
         return results
 
     def _detect(self) -> List[Output]:
         results = []
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/attributes/const_functions_asm.py` & `slither-analyzer-0.9.4/slither/detectors/attributes/const_functions_asm.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,16 +1,19 @@
 """
 Module detecting constant functions
 Recursively check the called functions
 """
-from typing import List
+from typing import List, Dict
+
+from slither.core.compilation_unit import SlitherCompilationUnit
 from slither.detectors.abstract_detector import (
     AbstractDetector,
     DetectorClassification,
     ALL_SOLC_VERSIONS_04,
+    DETECTOR_INFO,
 )
 from slither.formatters.attributes.const_functions import custom_format
 from slither.utils.output import Output
 
 
 class ConstantFunctionsAsm(AbstractDetector):
     """
@@ -69,17 +72,20 @@
             for f in c.functions:
                 if f.contract_declarer != c:
                     continue
                 if f.view or f.pure:
                     if f.contains_assembly:
                         attr = "view" if f.view else "pure"
 
-                        info = [f, f" is declared {attr} but contains assembly code\n"]
+                        info: DETECTOR_INFO = [
+                            f,
+                            f" is declared {attr} but contains assembly code\n",
+                        ]
                         res = self.generate_result(info, {"contains_assembly": True})
 
                         results.append(res)
 
         return results
 
     @staticmethod
-    def _format(comilation_unit, result):
+    def _format(comilation_unit: SlitherCompilationUnit, result: Dict) -> None:
         custom_format(comilation_unit, result)
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/attributes/const_functions_state.py` & `slither-analyzer-0.9.4/slither/detectors/attributes/const_functions_state.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,16 +1,19 @@
 """
 Module detecting constant functions
 Recursively check the called functions
 """
-from typing import List
+from typing import List, Dict
+
+from slither.core.compilation_unit import SlitherCompilationUnit
 from slither.detectors.abstract_detector import (
     AbstractDetector,
     DetectorClassification,
     ALL_SOLC_VERSIONS_04,
+    DETECTOR_INFO,
 )
 from slither.formatters.attributes.const_functions import custom_format
 from slither.utils.output import Output
 
 
 class ConstantFunctionsState(AbstractDetector):
     """
@@ -70,24 +73,24 @@
                 if f.contract_declarer != c:
                     continue
                 if f.view or f.pure:
                     variables_written = f.all_state_variables_written()
                     if variables_written:
                         attr = "view" if f.view else "pure"
 
-                        info = [
+                        info: DETECTOR_INFO = [
                             f,
                             f" is declared {attr} but changes state variables:\n",
                         ]
 
                         for variable_written in variables_written:
                             info += ["\t- ", variable_written, "\n"]
 
                         res = self.generate_result(info, {"contains_assembly": False})
 
                         results.append(res)
 
         return results
 
     @staticmethod
-    def _format(slither, result):
+    def _format(slither: SlitherCompilationUnit, result: Dict) -> None:
         custom_format(slither, result)
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/attributes/constant_pragma.py` & `slither-analyzer-0.9.4/slither/detectors/attributes/constant_pragma.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,13 +1,18 @@
 """
     Check that the same pragma is used in all the files
 """
-from typing import List
+from typing import List, Dict
 
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.core.compilation_unit import SlitherCompilationUnit
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.formatters.attributes.constant_pragma import custom_format
 from slither.utils.output import Output
 
 
 class ConstantPragma(AbstractDetector):
     """
     Check that the same pragma is used in all the files
@@ -27,22 +32,22 @@
     def _detect(self) -> List[Output]:
         results = []
         pragma = self.compilation_unit.pragma_directives
         versions = [p.version for p in pragma if p.is_solidity_version]
         versions = sorted(list(set(versions)))
 
         if len(versions) > 1:
-            info = ["Different versions of Solidity are used:\n"]
+            info: DETECTOR_INFO = ["Different versions of Solidity are used:\n"]
             info += [f"\t- Version used: {[str(v) for v in versions]}\n"]
 
             for p in sorted(pragma, key=lambda x: x.version):
                 info += ["\t- ", p, "\n"]
 
             res = self.generate_result(info)
 
             results.append(res)
 
         return results
 
     @staticmethod
-    def _format(slither, result):
+    def _format(slither: SlitherCompilationUnit, result: Dict) -> None:
         custom_format(slither, result)
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/attributes/incorrect_solc.py` & `slither-analyzer-0.9.4/slither/detectors/attributes/incorrect_solc.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,19 @@
 """
     Check if an incorrect version of solc is used
 """
 
 import re
 from typing import List, Optional, Tuple
 
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.formatters.attributes.incorrect_solc import custom_format
 from slither.utils.output import Output
 
 # group:
 # 0: ^ > >= < <= (optional)
 # 1: ' ' (optional)
 # 2: version number
@@ -137,15 +141,15 @@
             reason = self._check_pragma(p.version)
             if reason:
                 disallowed_pragmas.append((reason, p))
 
         # If we found any disallowed pragmas, we output our findings.
         if disallowed_pragmas:
             for (reason, p) in disallowed_pragmas:
-                info = ["Pragma version", p, f" {reason}\n"]
+                info: DETECTOR_INFO = ["Pragma version", p, f" {reason}\n"]
 
                 json = self.generate_result(info)
 
                 results.append(json)
 
         if self.compilation_unit.solc_version not in self.ALLOWED_VERSIONS:
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/attributes/locked_ether.py` & `slither-analyzer-0.9.4/slither/detectors/attributes/locked_ether.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,23 +1,29 @@
 """
     Check if ethers are locked in the contract
 """
 from typing import List
 
-from slither.core.declarations.contract import Contract
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.core.declarations import Contract, SolidityFunction
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.slithir.operations import (
     HighLevelCall,
     LowLevelCall,
     Send,
     Transfer,
     NewContract,
     LibraryCall,
     InternalCall,
+    SolidityCall,
 )
+from slither.slithir.variables import Constant
 from slither.utils.output import Output
 
 
 class LockedEther(AbstractDetector):  # pylint: disable=too-many-nested-blocks
 
     ARGUMENT = "locked-ether"
     HELP = "Contracts that lock ether"
@@ -60,16 +66,36 @@
                     for ir in node.irs:
                         if isinstance(
                             ir,
                             (Send, Transfer, HighLevelCall, LowLevelCall, NewContract),
                         ):
                             if ir.call_value and ir.call_value != 0:
                                 return False
-                        if isinstance(ir, (LowLevelCall)):
-                            if ir.function_name in ["delegatecall", "callcode"]:
+                        if isinstance(ir, (LowLevelCall)) and ir.function_name in [
+                            "delegatecall",
+                            "callcode",
+                        ]:
+                            return False
+                        if isinstance(ir, SolidityCall):
+                            call_can_send_ether = ir.function in [
+                                SolidityFunction(
+                                    "delegatecall(uint256,uint256,uint256,uint256,uint256,uint256)"
+                                ),
+                                SolidityFunction(
+                                    "callcode(uint256,uint256,uint256,uint256,uint256,uint256,uint256)"
+                                ),
+                                SolidityFunction(
+                                    "call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)"
+                                ),
+                            ]
+                            nonzero_call_value = call_can_send_ether and (
+                                not isinstance(ir.arguments[2], Constant)
+                                or ir.arguments[2].value != 0
+                            )
+                            if nonzero_call_value:
                                 return False
                         # If a new internal call or librarycall
                         # Add it to the list to explore
                         # InternalCall if to follow internal call in libraries
                         if isinstance(ir, (InternalCall, LibraryCall)):
                             if not ir.function in explored:
                                 to_explore.append(ir.function)
@@ -81,15 +107,15 @@
 
         for contract in self.compilation_unit.contracts_derived:
             if contract.is_signature_only():
                 continue
             funcs_payable = [function for function in contract.functions if function.payable]
             if funcs_payable:
                 if self.do_no_send_ether(contract):
-                    info = ["Contract locking ether found:\n"]
+                    info: DETECTOR_INFO = ["Contract locking ether found:\n"]
                     info += ["\tContract ", contract, " has payable functions:\n"]
                     for function in funcs_payable:
                         info += ["\t - ", function, "\n"]
                     info += "\tBut does not have a function to withdraw the ether\n"
 
                     json = self.generate_result(info)
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/attributes/unimplemented_interface.py` & `slither-analyzer-0.9.4/slither/detectors/attributes/unimplemented_interface.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,19 @@
 """
 Module detecting unimplemented interfaces
 
 Collect all the interfaces
 Check for contracts which implement all interface functions but do not explicitly derive from those interfaces.
 """
 from typing import List
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.core.declarations.contract import Contract
 from slither.utils.output import Output
 
 
 class MissingInheritance(AbstractDetector):
     """
     Unimplemented interface detector
@@ -135,11 +139,11 @@
         results = []
         for contract in self.compilation_unit.contracts_derived:
             # Skip interfaces
             if contract in interfaces:
                 continue
             intended_interfaces = self.detect_unimplemented_interface(contract, interfaces)
             for interface in intended_interfaces:
-                info = [contract, " should inherit from ", interface, "\n"]
+                info: DETECTOR_INFO = [contract, " should inherit from ", interface, "\n"]
                 res = self.generate_result(info)
                 results.append(res)
         return results
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/compiler_bugs/array_by_reference.py` & `slither-analyzer-0.9.4/slither/detectors/compiler_bugs/array_by_reference.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,12 +1,19 @@
 """
 Detects the passing of arrays located in memory to functions which expect to modify arrays via storage reference.
 """
 from typing import List, Set, Tuple, Union
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+
+from slither.core.declarations import Function
+from slither.core.variables import Variable
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.core.solidity_types.array_type import ArrayType
 from slither.core.variables.state_variable import StateVariable
 from slither.core.variables.local_variable import LocalVariable
 from slither.slithir.operations.high_level_call import HighLevelCall
 from slither.slithir.operations.internal_call import InternalCall
 from slither.core.cfg.node import Node
 from slither.core.declarations.contract import Contract
@@ -85,31 +92,26 @@
                             break
 
         return results
 
     @staticmethod
     def detect_calls_passing_ref_to_function(
         contracts: List[Contract], array_modifying_funcs: Set[FunctionContract]
-    ) -> List[
-        Union[
-            Tuple[Node, StateVariable, FunctionContract],
-            Tuple[Node, LocalVariable, FunctionContract],
-        ]
-    ]:
+    ) -> List[Tuple[Node, Variable, Union[Function, Variable]]]:
         """
         Obtains all calls passing storage arrays by value to a function which cannot write to them successfully.
         :param contracts: The collection of contracts to check for problematic calls in.
         :param array_modifying_funcs: The collection of functions which take non-storage arrays as input and writes to
         them.
         :return: A list of tuples (calling_node, affected_argument, invoked_function) which denote all problematic
         nodes invoking a function with some storage array argument where the invoked function seemingly attempts to
         write to the array unsuccessfully.
         """
         # Define our resulting array.
-        results = []
+        results: List[Tuple[Node, Variable, Union[Function, Variable]]] = []
 
         # Verify we have functions in our list to check for.
         if not array_modifying_funcs:
             return results
 
         # Loop for each node in each function/modifier in each contract
         # pylint: disable=too-many-nested-blocks
@@ -127,24 +129,27 @@
                             continue
 
                         # Verify this references a function in our array modifying functions collection.
                         if ir.function not in array_modifying_funcs:
                             continue
 
                         # Verify one of these parameters is an array in storage.
-                        for arg in ir.arguments:
+                        for (param, arg) in zip(ir.function.parameters, ir.arguments):
                             # Verify this argument is a variable that is an array type.
                             if not isinstance(arg, (StateVariable, LocalVariable)):
                                 continue
                             if not isinstance(arg.type, ArrayType):
                                 continue
 
                             # If it is a state variable OR a local variable referencing storage, we add it to the list.
-                            if isinstance(arg, StateVariable) or (
-                                isinstance(arg, LocalVariable) and arg.location == "storage"
+                            if (
+                                isinstance(arg, StateVariable)
+                                or (isinstance(arg, LocalVariable) and arg.location == "storage")
+                            ) and (
+                                isinstance(param.type, ArrayType) and param.location != "storage"
                             ):
                                 results.append((node, arg, ir.function))
         return results
 
     def _detect(self) -> List[Output]:
         """
         Detects passing of arrays located in memory to functions which expect to modify arrays via storage reference.
@@ -155,20 +160,20 @@
         array_modifying_funcs = self.get_funcs_modifying_array_params(self.contracts)
         problematic_calls = self.detect_calls_passing_ref_to_function(
             self.contracts, array_modifying_funcs
         )
 
         if problematic_calls:
             for calling_node, affected_argument, invoked_function in problematic_calls:
-                info = [
+                info: DETECTOR_INFO = [
                     calling_node.function,
                     " passes array ",
                     affected_argument,
-                    "by reference to ",
+                    " by reference to ",
                     invoked_function,
-                    "which only takes arrays by value\n",
+                    " which only takes arrays by value\n",
                 ]
 
                 res = self.generate_result(info)
                 results.append(res)
 
         return results
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/compiler_bugs/enum_conversion.py` & `slither-analyzer-0.9.4/slither/detectors/compiler_bugs/enum_conversion.py`

 * *Files 8% similar despite different names*

```diff
@@ -6,14 +6,15 @@
 from slither.core.cfg.node import Node
 from slither.core.declarations import Contract
 from slither.core.source_mapping.source_mapping import SourceMapping
 from slither.detectors.abstract_detector import (
     AbstractDetector,
     DetectorClassification,
     make_solc_versions,
+    DETECTOR_INFO,
 )
 from slither.slithir.operations import TypeConversion
 from slither.core.declarations.enum import Enum
 from slither.utils.output import Output
 
 
 def _detect_dangerous_enum_conversions(contract: Contract) -> List[Tuple[Node, SourceMapping]]:
@@ -69,15 +70,19 @@
     def _detect(self) -> List[Output]:
         """Detect dangerous conversion to enum"""
         results = []
 
         for c in self.compilation_unit.contracts:
             ret = _detect_dangerous_enum_conversions(c)
             for node, var in ret:
-                func_info = [node, " has a dangerous enum conversion\n"]
+                func_info: DETECTOR_INFO = [node, " has a dangerous enum conversion\n"]
                 # Output each node with the function info header as a separate result.
-                variable_info = ["\t- Variable: ", var, f" of type: {str(var.type)}\n"]
-                node_info = ["\t- Enum conversion: ", node, "\n"]
+                variable_info: DETECTOR_INFO = [
+                    "\t- Variable: ",
+                    var,
+                    f" of type: {str(var.type)}\n",
+                ]
+                node_info: DETECTOR_INFO = ["\t- Enum conversion: ", node, "\n"]
                 json = self.generate_result(func_info + variable_info + node_info)
                 results.append(json)
 
         return results
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/compiler_bugs/multiple_constructor_schemes.py` & `slither-analyzer-0.9.4/slither/detectors/compiler_bugs/multiple_constructor_schemes.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,10 +1,14 @@
 from typing import List
 
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.utils.output import Output
 
 
 class MultipleConstructorSchemes(AbstractDetector):
     """
     Module detecting multiple constructors in the same contract.
     (This was possible prior to Solidity 0.4.23, using old and new constructor schemes).
@@ -54,15 +58,18 @@
         results = []
         for contract in self.contracts:
             # Obtain any constructors defined in this contract
             constructors = [f for f in contract.constructors if f.contract_declarer == contract]
 
             # If there is more than one, we encountered the described issue occurring.
             if constructors and len(constructors) > 1:
-                info = [contract, " contains multiple constructors in the same contract:\n"]
+                info: DETECTOR_INFO = [
+                    contract,
+                    " contains multiple constructors in the same contract:\n",
+                ]
                 for constructor in constructors:
                     info += ["\t- ", constructor, "\n"]
 
                 res = self.generate_result(info)
                 results.append(res)
 
         return results
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/compiler_bugs/public_mapping_nested.py` & `slither-analyzer-0.9.4/slither/detectors/compiler_bugs/public_mapping_nested.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/detectors/compiler_bugs/reused_base_constructor.py` & `slither-analyzer-0.9.4/slither/detectors/compiler_bugs/reused_base_constructor.py`

 * *Files 1% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 Module detecting re-used base constructors in inheritance hierarchy.
 """
 from typing import Any, Dict, List, Tuple, Union
 from slither.detectors.abstract_detector import (
     AbstractDetector,
     DetectorClassification,
     ALL_SOLC_VERSIONS_04,
+    DETECTOR_INFO,
 )
 from slither.core.declarations.contract import Contract
 from slither.core.declarations.function_contract import FunctionContract
 from slither.utils.output import Output
 
 
 # Helper: adds explicitly called constructors with arguments to the results lookup.
@@ -147,15 +148,15 @@
             called_base_constructors = self._detect_explicitly_called_base_constructors(contract)
             for base_constructor, call_list in called_base_constructors.items():
                 # Only report if there are multiple calls to the same base constructor.
                 if len(call_list) <= 1:
                     continue
 
                 # Generate data to output.
-                info = [
+                info: DETECTOR_INFO = [
                     contract,
                     " gives base constructor ",
                     base_constructor,
                     " arguments more than once in inheritance hierarchy:\n",
                 ]
 
                 for (calling_contract, called_by_constructor) in call_list:
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/compiler_bugs/storage_ABIEncoderV2_array.py` & `slither-analyzer-0.9.4/slither/detectors/compiler_bugs/storage_ABIEncoderV2_array.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 Module detecting ABIEncoderV2 array bug
 """
 from typing import List, Set, Tuple
 from slither.detectors.abstract_detector import (
     AbstractDetector,
     DetectorClassification,
     make_solc_versions,
+    DETECTOR_INFO,
 )
 from slither.core.solidity_types import ArrayType
 from slither.core.solidity_types import UserDefinedType
 from slither.core.variables.local_variable import LocalVariable
 from slither.core.variables.state_variable import StateVariable
 from slither.slithir.operations import SolidityCall
 from slither.core.declarations.solidity_variables import SolidityFunction
@@ -118,12 +119,18 @@
             return results
 
         # Check for storage-allocated abiencoderv2 arrays of arrays/structs
         # in arguments of abi.encode, events or external calls
         for contract in self.contracts:
             storage_abiencoderv2_arrays = self._detect_storage_abiencoderv2_arrays(contract)
             for function, node in storage_abiencoderv2_arrays:
-                info = ["Function ", function, " trigger an abi encoding bug:\n\t- ", node, "\n"]
+                info: DETECTOR_INFO = [
+                    "Function ",
+                    function,
+                    " trigger an abi encoding bug:\n\t- ",
+                    node,
+                    "\n",
+                ]
                 res = self.generate_result(info)
                 results.append(res)
 
         return results
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/compiler_bugs/storage_signed_integer_array.py` & `slither-analyzer-0.9.4/slither/detectors/compiler_bugs/storage_signed_integer_array.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,22 +1,25 @@
 """
 Module detecting storage signed integer array bug
 """
-from typing import List
+from typing import List, Tuple, Set
 
+from slither.core.declarations import Function, Contract
 from slither.detectors.abstract_detector import (
     AbstractDetector,
     DetectorClassification,
     make_solc_versions,
+    DETECTOR_INFO,
 )
-from slither.core.cfg.node import NodeType
+from slither.core.cfg.node import NodeType, Node
 from slither.core.solidity_types import ArrayType
 from slither.core.solidity_types.elementary_type import Int, ElementaryType
 from slither.core.variables.local_variable import LocalVariable
 from slither.core.variables.state_variable import StateVariable
+from slither.slithir.operations import Operation, OperationWithLValue
 from slither.slithir.operations.assignment import Assignment
 from slither.slithir.operations.init_array import InitArray
 from slither.utils.output import Output
 
 
 class StorageSignedIntegerArray(AbstractDetector):
     """
@@ -56,39 +59,44 @@
     # endregion wiki_exploit_scenario
 
     WIKI_RECOMMENDATION = "Use a compiler version >= `0.5.10`."
 
     VULNERABLE_SOLC_VERSIONS = make_solc_versions(4, 7, 25) + make_solc_versions(5, 0, 9)
 
     @staticmethod
-    def _is_vulnerable_type(ir):
+    def _is_vulnerable_type(ir: Operation) -> bool:
         """
         Detect if the IR lvalue is a vulnerable type
         Must be a storage allocation, and an array of Int
         Assume the IR is a InitArray, or an Assignement to an ArrayType
         """
         # Storage allocation
         # Base type is signed integer
+        if not isinstance(ir, OperationWithLValue):
+            return False
+
         return (
             (
                 isinstance(ir.lvalue, StateVariable)
                 or (isinstance(ir.lvalue, LocalVariable) and ir.lvalue.is_storage)
             )
-            and isinstance(ir.lvalue.type.type, ElementaryType)
-            and ir.lvalue.type.type.type in Int
+            and isinstance(ir.lvalue.type.type, ElementaryType)  # type: ignore
+            and ir.lvalue.type.type.type in Int  # type: ignore
         )
 
-    def detect_storage_signed_integer_arrays(self, contract):
+    def detect_storage_signed_integer_arrays(
+        self, contract: Contract
+    ) -> Set[Tuple[Function, Node]]:
         """
         Detects and returns all nodes with storage-allocated signed integer array init/assignment
         :param contract: Contract to detect within
         :return: A list of tuples with (function, node) where function node has storage-allocated signed integer array init/assignment
         """
         # Create our result set.
-        results = set()
+        results: Set[Tuple[Function, Node]] = set()
 
         # Loop for each function and modifier.
         for function in contract.functions_and_modifiers_declared:
             # Loop for every node in this function, looking for storage-allocated
             # signed integer array initializations/assignments
             for node in function.nodes:
                 if node.type == NodeType.EXPRESSION:
@@ -114,14 +122,18 @@
         """
         Detect storage signed integer array init/assignment
         """
         results = []
         for contract in self.contracts:
             storage_signed_integer_arrays = self.detect_storage_signed_integer_arrays(contract)
             for function, node in storage_signed_integer_arrays:
-                contract_info = ["Contract ", contract, " \n"]
-                function_info = ["\t- Function ", function, "\n"]
-                node_info = ["\t\t- ", node, " has a storage signed integer array assignment\n"]
+                contract_info: DETECTOR_INFO = ["Contract ", contract, " \n"]
+                function_info: DETECTOR_INFO = ["\t- Function ", function, "\n"]
+                node_info: DETECTOR_INFO = [
+                    "\t\t- ",
+                    node,
+                    " has a storage signed integer array assignment\n",
+                ]
                 res = self.generate_result(contract_info + function_info + node_info)
                 results.append(res)
 
         return results
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/compiler_bugs/uninitialized_function_ptr_in_constructor.py` & `slither-analyzer-0.9.4/slither/detectors/compiler_bugs/uninitialized_function_ptr_in_constructor.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 Module detecting uninitialized function pointer calls in constructors
 """
 from typing import Any, List, Union
 from slither.detectors.abstract_detector import (
     AbstractDetector,
     DetectorClassification,
     make_solc_versions,
+    DETECTOR_INFO,
 )
 from slither.slithir.operations import InternalDynamicCall, OperationWithLValue
 from slither.slithir.variables import ReferenceVariable
 from slither.slithir.variables.variable import SlithIRVariable
 from slither.core.cfg.node import Node
 from slither.core.declarations.contract import Contract
 from slither.core.declarations.function_contract import FunctionContract
@@ -111,18 +112,18 @@
         Detect uninitialized function pointer calls in constructors of contracts
         Returns:
             list: ['uninitialized function pointer calls in constructors']
         """
         results = []
 
         for contract in self.compilation_unit.contracts:
-            contract_info = ["Contract ", contract, " \n"]
+            contract_info: DETECTOR_INFO = ["Contract ", contract, " \n"]
             nodes = self._detect_uninitialized_function_ptr_in_constructor(contract)
             for node in nodes:
-                node_info = [
+                node_info: DETECTOR_INFO = [
                     "\t ",
                     node,
                     " is an unintialized function pointer call in a constructor\n",
                 ]
                 json = self.generate_result(contract_info + node_info)
                 results.append(json)
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/erc/erc20/arbitrary_send_erc20.py` & `slither-analyzer-0.9.4/slither/detectors/erc/erc20/arbitrary_send_erc20.py`

 * *Files 4% similar despite different names*

```diff
@@ -57,38 +57,38 @@
                     isinstance(ir, HighLevelCall)
                     and isinstance(ir.function, Function)
                     and ir.function.solidity_signature == "transferFrom(address,address,uint256)"
                     and not (
                         is_dependent(
                             ir.arguments[0],
                             SolidityVariableComposed("msg.sender"),
-                            node.function.contract,
+                            node,
                         )
                         or is_dependent(
                             ir.arguments[0],
                             SolidityVariable("this"),
-                            node.function.contract,
+                            node,
                         )
                     )
                 ):
                     results.append(ir.node)
                 elif (
                     isinstance(ir, LibraryCall)
                     and ir.function.solidity_signature
                     == "safeTransferFrom(address,address,address,uint256)"
                     and not (
                         is_dependent(
                             ir.arguments[1],
                             SolidityVariableComposed("msg.sender"),
-                            node.function.contract,
+                            node,
                         )
                         or is_dependent(
                             ir.arguments[1],
                             SolidityVariable("this"),
-                            node.function.contract,
+                            node,
                         )
                     )
                 ):
                     results.append(ir.node)
 
     def detect(self) -> None:
         """Detect transfers that use arbitrary `from` parameter."""
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/erc/erc20/arbitrary_send_erc20_no_permit.py` & `slither-analyzer-0.9.4/slither/detectors/erc/erc20/arbitrary_send_erc20_no_permit.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,9 +1,13 @@
 from typing import List
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.utils.output import Output
 from .arbitrary_send_erc20 import ArbitrarySendErc20
 
 
 class ArbitrarySendErc20NoPermit(AbstractDetector):
     """
     Detect when `msg.sender` is not used as `from` in transferFrom
@@ -34,12 +38,12 @@
         """"""
         results: List[Output] = []
 
         arbitrary_sends = ArbitrarySendErc20(self.compilation_unit)
         arbitrary_sends.detect()
         for node in arbitrary_sends.no_permit_results:
             func = node.function
-            info = [func, " uses arbitrary from in transferFrom: ", node, "\n"]
+            info: DETECTOR_INFO = [func, " uses arbitrary from in transferFrom: ", node, "\n"]
             res = self.generate_result(info)
             results.append(res)
 
         return results
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/erc/erc20/arbitrary_send_erc20_permit.py` & `slither-analyzer-0.9.4/slither/detectors/erc/erc20/arbitrary_send_erc20_permit.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,9 +1,13 @@
 from typing import List
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.utils.output import Output
 from .arbitrary_send_erc20 import ArbitrarySendErc20
 
 
 class ArbitrarySendErc20Permit(AbstractDetector):
     """
     Detect when `msg.sender` is not used as `from` in transferFrom along with the use of permit.
@@ -37,15 +41,15 @@
         """"""
         results: List[Output] = []
 
         arbitrary_sends = ArbitrarySendErc20(self.compilation_unit)
         arbitrary_sends.detect()
         for node in arbitrary_sends.permit_results:
             func = node.function
-            info = [
+            info: DETECTOR_INFO = [
                 func,
                 " uses arbitrary from in transferFrom in combination with permit: ",
                 node,
                 "\n",
             ]
             res = self.generate_result(info)
             results.append(res)
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/erc/erc20/incorrect_erc20_interface.py` & `slither-analyzer-0.9.4/slither/detectors/erc/erc20/incorrect_erc20_interface.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,19 @@
 Detect incorrect erc20 interface.
 Some contracts do not return a bool on transfer/transferFrom/approve, which may lead to preventing the contract to be used with contracts compiled with recent solc (>0.4.22)
 """
 from typing import List, Tuple
 
 from slither.core.declarations.contract import Contract
 from slither.core.declarations.function_contract import FunctionContract
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.utils.output import Output
 
 
 class IncorrectERC20InterfaceDetection(AbstractDetector):
     """
     Incorrect ERC20 Interface
     """
@@ -105,15 +109,15 @@
             dict: [contract name] = set(str)  events
         """
         results = []
         for c in self.compilation_unit.contracts_derived:
             functions = IncorrectERC20InterfaceDetection.detect_incorrect_erc20_interface(c)
             if functions:
                 for function in functions:
-                    info = [
+                    info: DETECTOR_INFO = [
                         c,
                         " has incorrect ERC20 function interface:",
                         function,
                         "\n",
                     ]
                     json = self.generate_result(info)
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/erc/incorrect_erc721_interface.py` & `slither-analyzer-0.9.4/slither/detectors/erc/incorrect_erc721_interface.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,12 +1,16 @@
 """
 Detect incorrect erc721 interface.
 """
 from typing import Any, List, Tuple, Union
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.core.declarations.contract import Contract
 from slither.core.declarations.function_contract import FunctionContract
 from slither.utils.output import Output
 
 
 class IncorrectERC721InterfaceDetection(AbstractDetector):
     """
@@ -85,15 +89,17 @@
         # ERC165 (dependency)
         if name == "supportsInterface" and parameters == ["bytes4"] and returnVars != ["bool"]:
             return True
 
         return False
 
     @staticmethod
-    def detect_incorrect_erc721_interface(contract: Contract) -> List[Union[FunctionContract, Any]]:
+    def detect_incorrect_erc721_interface(
+        contract: Contract,
+    ) -> List[Union[FunctionContract, Any]]:
         """Detect incorrect ERC721 interface
 
         Returns:
             list(str) : list of incorrect function signatures
         """
 
         # Verify this is an ERC721 contract.
@@ -115,15 +121,15 @@
             dict: [contract name] = set(str)  events
         """
         results = []
         for c in self.compilation_unit.contracts_derived:
             functions = IncorrectERC721InterfaceDetection.detect_incorrect_erc721_interface(c)
             if functions:
                 for function in functions:
-                    info = [
+                    info: DETECTOR_INFO = [
                         c,
                         " has incorrect ERC721 function interface:",
                         function,
                         "\n",
                     ]
                     res = self.generate_result(info)
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/erc/unindexed_event_parameters.py` & `slither-analyzer-0.9.4/slither/detectors/erc/unindexed_event_parameters.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/detectors/examples/backdoor.py` & `slither-analyzer-0.9.4/slither/detectors/examples/backdoor.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,10 +1,14 @@
 from typing import List
 
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.utils.output import Output
 
 
 class Backdoor(AbstractDetector):
     """
     Detect function named backdoor
     """
@@ -24,15 +28,15 @@
         results = []
 
         for contract in self.compilation_unit.contracts_derived:
             # Check if a function has 'backdoor' in its name
             for f in contract.functions:
                 if "backdoor" in f.name:
                     # Info to be printed
-                    info = ["Backdoor function found in ", f, "\n"]
+                    info: DETECTOR_INFO = ["Backdoor function found in ", f, "\n"]
 
                     # Add the result in result
                     res = self.generate_result(info)
 
                     results.append(res)
 
         return results
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/functions/arbitrary_send_eth.py` & `slither-analyzer-0.9.4/slither/detectors/statements/unprotected_upgradeable.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,146 +1,130 @@
-"""
-    Module detecting send to arbitrary address
+from typing import List
 
-    To avoid FP, it does not report:
-        - If msg.sender is used as index (withdraw situation)
-        - If the function is protected
-        - If the value sent is msg.value (repay situation)
-        - If there is a call to transferFrom
+from slither.core.declarations import SolidityFunction, Function
+from slither.core.declarations.contract import Contract
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
+from slither.slithir.operations import LowLevelCall, SolidityCall
+from slither.utils.output import Output
 
-    TODO: dont report if the value is tainted by msg.value
-"""
-from typing import Any, Tuple, Union, List
 
-from slither.analyses.data_dependency.data_dependency import is_tainted, is_dependent
-from slither.core.cfg.node import Node
-from slither.core.declarations import Function, Contract
-from slither.core.declarations.function_contract import FunctionContract
-from slither.core.declarations.solidity_variables import (
-    SolidityFunction,
-    SolidityVariableComposed,
-)
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
-from slither.slithir.operations import (
-    HighLevelCall,
-    Index,
-    LowLevelCall,
-    Send,
-    SolidityCall,
-    Transfer,
-)
+def _can_be_destroyed(contract: Contract) -> List[Function]:
+    targets = []
+    for f in contract.functions_entry_points:
+        for ir in f.all_slithir_operations():
+            if (
+                isinstance(ir, LowLevelCall) and ir.function_name in ["delegatecall", "codecall"]
+            ) or (
+                isinstance(ir, SolidityCall)
+                and ir.function
+                in [SolidityFunction("suicide(address)"), SolidityFunction("selfdestruct(address)")]
+            ):
+                targets.append(f)
+                break
+    return targets
+
+
+def _has_initializing_protection(functions: List[Function]) -> bool:
+    # Detects "initializer" constructor modifiers and "_disableInitializers()" constructor internal calls
+    # https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializing_the_implementation_contract
+
+    for f in functions:
+        for m in f.modifiers:
+            if m.name == "initializer":
+                return True
+        for ifc in f.all_internal_calls():
+            if ifc.name == "_disableInitializers":
+                return True
+
+    # to avoid future FPs in different modifier + function naming implementations, we can also implement a broader check for state var "_initialized" being written to in the constructor
+    #   though this is still subject to naming false positives...
+    return False
+
+
+def _whitelisted_modifiers(f: Function) -> bool:
+    # The onlyProxy modifier prevents calling the implementation contract (must be delegatecall)
+    #  https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/3dec82093ea4a490d63aab3e925fed4f692909e8/contracts/proxy/utils/UUPSUpgradeable.sol#L38-L42
+    return "onlyProxy" not in [modifier.name for modifier in f.modifiers]
+
+
+def _initialize_functions(contract: Contract) -> List[Function]:
+    return list(
+        filter(_whitelisted_modifiers, [f for f in contract.functions if f.name == "initialize"])
+    )
 
-# pylint: disable=too-many-nested-blocks,too-many-branches
-from slither.utils.output import Output
 
+class UnprotectedUpgradeable(AbstractDetector):
 
-def arbitrary_send(func: Function) -> Union[bool, List[Node]]:
-    if func.is_protected():
-        return []
-
-    ret: List[Node] = []
-    for node in func.nodes:
-        for ir in node.irs:
-            if isinstance(ir, SolidityCall):
-                if ir.function == SolidityFunction("ecrecover(bytes32,uint8,bytes32,bytes32)"):
-                    return False
-            if isinstance(ir, Index):
-                if ir.variable_right == SolidityVariableComposed("msg.sender"):
-                    return False
-                if is_dependent(
-                    ir.variable_right,
-                    SolidityVariableComposed("msg.sender"),
-                    func.contract,
-                ):
-                    return False
-            if isinstance(ir, (HighLevelCall, LowLevelCall, Transfer, Send)):
-                if isinstance(ir, (HighLevelCall)):
-                    if isinstance(ir.function, Function):
-                        if ir.function.full_name == "transferFrom(address,address,uint256)":
-                            return False
-                if ir.call_value is None:
-                    continue
-                if ir.call_value == SolidityVariableComposed("msg.value"):
-                    continue
-                if is_dependent(
-                    ir.call_value,
-                    SolidityVariableComposed("msg.value"),
-                    func.contract,
-                ):
-                    continue
-
-                if is_tainted(ir.destination, func.contract):
-                    ret.append(node)
-
-    return ret
-
-
-def detect_arbitrary_send(
-    contract: Contract,
-) -> List[Union[Tuple[FunctionContract, List[Node]], Any]]:
-    """
-        Detect arbitrary send
-    Args:
-        contract (Contract)
-    Returns:
-        list((Function), (list (Node)))
-    """
-    ret = []
-    for f in [f for f in contract.functions if f.contract_declarer == contract]:
-        nodes = arbitrary_send(f)
-        if nodes:
-            ret.append((f, nodes))
-    return ret
-
-
-class ArbitrarySendEth(AbstractDetector):
-    ARGUMENT = "arbitrary-send-eth"
-    HELP = "Functions that send Ether to arbitrary destinations"
+    ARGUMENT = "unprotected-upgrade"
+    HELP = "Unprotected upgradeable contract"
     IMPACT = DetectorClassification.HIGH
-    CONFIDENCE = DetectorClassification.MEDIUM
+    CONFIDENCE = DetectorClassification.HIGH
 
-    WIKI = "https://github.com/crytic/slither/wiki/Detector-Documentation#functions-that-send-ether-to-arbitrary-destinations"
+    WIKI = "https://github.com/crytic/slither/wiki/Detector-Documentation#unprotected-upgradeable-contract"
 
-    WIKI_TITLE = "Functions that send Ether to arbitrary destinations"
-    WIKI_DESCRIPTION = "Unprotected call to a function sending Ether to an arbitrary address."
+    WIKI_TITLE = "Unprotected upgradeable contract"
+    WIKI_DESCRIPTION = """Detects logic contract that can be destructed."""
 
     # region wiki_exploit_scenario
     WIKI_EXPLOIT_SCENARIO = """
 ```solidity
-contract ArbitrarySendEth{
-    address destination;
-    function setDestination(){
-        destination = msg.sender;
-    }
+contract Buggy is Initializable{
+    address payable owner;
 
-    function withdraw() public{
-        destination.transfer(this.balance);
+    function initialize() external initializer{
+        require(owner == address(0));
+        owner = msg.sender;
+    }
+    function kill() external{
+        require(msg.sender == owner);
+        selfdestruct(owner);
     }
 }
 ```
-Bob calls `setDestination` and `withdraw`. As a result he withdraws the contract's balance."""
+Buggy is an upgradeable contract. Anyone can call initialize on the logic contract, and destruct the contract.
+"""
     # endregion wiki_exploit_scenario
 
-    WIKI_RECOMMENDATION = "Ensure that an arbitrary user cannot withdraw unauthorized funds."
+    WIKI_RECOMMENDATION = (
+        """Add a constructor to ensure `initialize` cannot be called on the logic contract."""
+    )
 
     def _detect(self) -> List[Output]:
-        """"""
         results = []
 
-        for c in self.contracts:
-            arbitrary_send_result = detect_arbitrary_send(c)
-            for (func, nodes) in arbitrary_send_result:
-
-                info = [func, " sends eth to arbitrary user\n"]
-                info += ["\tDangerous calls:\n"]
-
-                # sort the nodes to get deterministic results
-                nodes.sort(key=lambda x: x.node_id)
-
-                for node in nodes:
-                    info += ["\t- ", node, "\n"]
-
-                res = self.generate_result(info)
+        for contract in self.compilation_unit.contracts_derived:
+            if contract.is_upgradeable:
+                if not _has_initializing_protection(contract.constructors):
+                    functions_that_can_destroy = _can_be_destroyed(contract)
+                    if functions_that_can_destroy:
+                        initialize_functions = _initialize_functions(contract)
+
+                        vars_init_ = [
+                            init.all_state_variables_written() for init in initialize_functions
+                        ]
+                        vars_init = [item for sublist in vars_init_ for item in sublist]
+
+                        vars_init_in_constructors_ = [
+                            f.all_state_variables_written() for f in contract.constructors
+                        ]
+                        vars_init_in_constructors = [
+                            item for sublist in vars_init_in_constructors_ for item in sublist
+                        ]
+                        if vars_init and (set(vars_init) - set(vars_init_in_constructors)):
+                            info: DETECTOR_INFO = [
+                                contract,
+                                " is an upgradeable contract that does not protect its initialize functions: ",
+                            ]
+                            info += initialize_functions
+                            info += [
+                                ". Anyone can delete the contract with: ",
+                            ]
+                            info += functions_that_can_destroy
 
-                results.append(res)
+                            res = self.generate_result(info)
+                            results.append(res)
 
         return results
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/functions/codex.py` & `slither-analyzer-0.9.4/slither/detectors/functions/codex.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/detectors/functions/cyclomatic_complexity.py` & `slither-analyzer-0.9.4/slither/detectors/functions/cyclomatic_complexity.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,11 +1,15 @@
 from typing import List, Tuple
 
 from slither.core.declarations import Function
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.utils.code_complexity import compute_cyclomatic_complexity
 from slither.utils.output import Output
 
 
 def _check_for_high_cc(high_cc_functions: List[Tuple[Function, int]], f: Function) -> None:
     cc = compute_cyclomatic_complexity(f)
     if cc > 11:
@@ -40,11 +44,11 @@
             for f in c.functions_declared:
                 _check_for_high_cc(high_cc_functions, f)
 
         for f in self.compilation_unit.functions_top_level:
             _check_for_high_cc(high_cc_functions, f)
 
         for f, cc in high_cc_functions:
-            info = [f, f" has a high cyclomatic complexity ({cc}).\n"]
+            info: DETECTOR_INFO = [f, f" has a high cyclomatic complexity ({cc}).\n"]
             res = self.generate_result(info)
             results.append(res)
         return results
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/functions/dead_code.py` & `slither-analyzer-0.9.4/slither/detectors/functions/dead_code.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,14 +1,18 @@
 """
 Module detecting dead code
 """
 from typing import List, Tuple
 
 from slither.core.declarations import Function, FunctionContract, Contract
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.utils.output import Output
 
 
 class DeadCode(AbstractDetector):
     """
     Unprotected function detector
     """
@@ -68,12 +72,12 @@
             if isinstance(function, FunctionContract) and (
                 function.contract_declarer.is_from_dependency()
             ):
                 continue
             # Continue if the functon is not implemented because it means the contract is abstract
             if not function.is_implemented:
                 continue
-            info = [function, " is never used and should be removed\n"]
+            info: DETECTOR_INFO = [function, " is never used and should be removed\n"]
             res = self.generate_result(info)
             results.append(res)
 
         return results
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/functions/external_function.py` & `slither-analyzer-0.9.4/slither/detectors/functions/external_function.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/detectors/functions/modifier.py` & `slither-analyzer-0.9.4/slither/detectors/functions/modifier.py`

 * *Files 13% similar despite different names*

```diff
@@ -2,15 +2,19 @@
 Module detecting modifiers that are not guaranteed to execute _; or revert()/throw
 
 Note that require()/assert() are not considered here. Even if they
 are in the outermost scope, they do not guarantee a revert, so a
 default value can still be returned.
 """
 from typing import List
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.core.cfg.node import Node, NodeType
 from slither.utils.output import Output
 
 
 def is_revert(node: Node) -> bool:
     return node.type == NodeType.THROW or any(
         c.name in ["revert()", "revert(string"] for c in node.internal_calls
@@ -78,13 +82,17 @@
                     # Move down, staying on the outer scope in branches
                     if len(node.sons) > 0:
                         node = _get_false_son(node) if node.contains_if() else node.sons[0]
                     else:
                         node = None
                 else:
                     # Nothing was found in the outer scope
-                    info = ["Modifier ", mod, " does not always execute _; or revert"]
+                    info: DETECTOR_INFO = [
+                        "Modifier ",
+                        mod,
+                        " does not always execute _; or revert",
+                    ]
 
                     res = self.generate_result(info)
                     results.append(res)
 
         return results
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/functions/permit_domain_signature_collision.py` & `slither-analyzer-0.9.4/slither/detectors/functions/permit_domain_signature_collision.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,19 @@
 Module detecting EIP-2612 domain separator collision
 """
 from typing import Union, List
 
 from slither.core.declarations import Function
 from slither.core.solidity_types.elementary_type import ElementaryType
 from slither.core.variables.state_variable import StateVariable
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.utils.function import get_function_id
 from slither.utils.output import Output
 
 
 class DomainSeparatorCollision(AbstractDetector):
     """
     Domain separator collision
@@ -59,15 +63,15 @@
                                 not func_or_var.return_type
                                 or func_or_var.return_type[0] != ElementaryType("bytes32")
                             )
                         else:
                             assert isinstance(func_or_var, StateVariable)
                             incorrect_return_type = func_or_var.type != ElementaryType("bytes32")
                     if hash_collision or incorrect_return_type:
-                        info = [
+                        info: DETECTOR_INFO = [
                             "The function signature of ",
                             func_or_var,
                             " collides with DOMAIN_SEPARATOR and should be renamed or removed.\n",
                         ]
                         res = self.generate_result(info)
                         return [res]
         return []
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/functions/protected_variable.py` & `slither-analyzer-0.9.4/slither/detectors/functions/protected_variable.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,15 +2,19 @@
 Module detecting suicidal contract
 
 A suicidal contract is an unprotected function that calls selfdestruct
 """
 from typing import List
 
 from slither.core.declarations import Function, Contract
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.utils.output import Output
 
 
 class ProtectedVariables(AbstractDetector):
 
     ARGUMENT = "protected-vars"
     HELP = "Detected unprotected variables"
@@ -54,15 +58,15 @@
                     function_protection = contract.get_function_from_signature(function_sig)
                     if not function_protection:
                         function_protection = contract.get_modifier_from_signature(function_sig)
                     if not function_protection:
                         self.logger.error(f"{function_sig} not found")
                         continue
                     if function_protection not in function.all_internal_calls():
-                        info = [
+                        info: DETECTOR_INFO = [
                             function,
                             " should have ",
                             function_protection,
                             " to protect ",
                             state_variable_written,
                             "\n",
                         ]
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/functions/suicidal.py` & `slither-analyzer-0.9.4/slither/detectors/functions/suicidal.py`

 * *Files 3% similar despite different names*

```diff
@@ -3,15 +3,19 @@
 
 A suicidal contract is an unprotected function that calls selfdestruct
 """
 from typing import List
 
 from slither.core.declarations.contract import Contract
 from slither.core.declarations.function_contract import FunctionContract
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.utils.output import Output
 
 
 class Suicidal(AbstractDetector):
     """
     Unprotected function detector
     """
@@ -74,14 +78,14 @@
     def _detect(self) -> List[Output]:
         """Detect the suicidal functions"""
         results = []
         for c in self.contracts:
             functions = self.detect_suicidal(c)
             for func in functions:
 
-                info = [func, " allows anyone to destruct the contract\n"]
+                info: DETECTOR_INFO = [func, " allows anyone to destruct the contract\n"]
 
                 res = self.generate_result(info)
 
                 results.append(res)
 
         return results
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/functions/unimplemented.py` & `slither-analyzer-0.9.4/slither/detectors/functions/unimplemented.py`

 * *Files 5% similar despite different names*

```diff
@@ -4,15 +4,21 @@
 
 Collect all the implemented and unimplemented functions of all the contracts
 Check for unimplemented functions that are never implemented
 Consider public state variables as implemented functions
 Do not consider fallback function or constructor
 """
 from typing import List, Set
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+
+from slither.core.declarations import Function
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.core.declarations.contract import Contract
 from slither.core.declarations.function_contract import FunctionContract
 from slither.utils.output import Output
 
 
 # Since 0.5.1, Solidity allows creating state variable matching a function signature.
 older_solc_versions = ["0.5.0"] + ["0.4." + str(x) for x in range(0, 27)]
@@ -58,29 +64,31 @@
 
     WIKI_RECOMMENDATION = "Implement all unimplemented functions in any contract you intend to use directly (not simply inherit from)."
 
     @staticmethod
     def _match_state_variable(contract: Contract, f: FunctionContract) -> bool:
         return any(s.full_name == f.full_name for s in contract.state_variables)
 
-    def _detect_unimplemented_function(self, contract: Contract) -> Set[FunctionContract]:
+    def _detect_unimplemented_function(self, contract: Contract) -> Set[Function]:
         """
         Detects any function definitions which are not implemented in the given contract.
         :param contract: The contract to search unimplemented functions for.
         :return: A list of functions which are not implemented.
         """
 
         # If it's simply a contract signature, we have no functions.
         if contract.is_signature_only():
             return set()
 
         # Populate our unimplemented functions set with any functions not implemented in this contract, excluding the
         # fallback function and constructor.
         unimplemented = set()
         for f in contract.all_functions_called:
+            if not isinstance(f, Function):
+                continue
             if (
                 not f.is_implemented
                 and not f.is_constructor
                 and not f.is_fallback
                 and not f.is_constructor_variables
             ):
                 if self.compilation_unit.solc_version not in older_solc_versions:
@@ -98,15 +106,15 @@
         Returns:
             list: {'vuln', 'filename,'contract','func'}
         """
         results = []
         for contract in self.compilation_unit.contracts_derived:
             functions = self._detect_unimplemented_function(contract)
             if functions:
-                info = [contract, " does not implement functions:\n"]
+                info: DETECTOR_INFO = [contract, " does not implement functions:\n"]
 
                 for function in sorted(functions, key=lambda x: x.full_name):
                     info += ["\t- ", function, "\n"]
 
                 res = self.generate_result(info)
                 results.append(res)
         return results
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/naming_convention/naming_convention.py` & `slither-analyzer-0.9.4/slither/detectors/naming_convention/naming_convention.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,14 @@
 import re
 from typing import List
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.formatters.naming_convention.naming_convention import custom_format
 from slither.utils.output import Output
 
 
 class NamingConvention(AbstractDetector):
     """
     Check if naming conventions are followed
@@ -59,14 +63,15 @@
     def should_avoid_name(name: str) -> bool:
         return re.search("^[lOI]$", name) is not None
 
     # pylint: disable=too-many-branches,too-many-statements
     def _detect(self) -> List[Output]:
 
         results = []
+        info: DETECTOR_INFO
         for contract in self.contracts:
 
             if not self.is_cap_words(contract.name):
                 info = ["Contract ", contract, " is not in CapWords\n"]
 
                 res = self.generate_result(info)
                 res.add(contract, {"target": "contract", "convention": "CapWords"})
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/operations/bad_prng.py` & `slither-analyzer-0.9.4/slither/detectors/operations/bad_prng.py`

 * *Files 10% similar despite different names*

```diff
@@ -46,22 +46,25 @@
         (nodes)
     """
     ret = set()
     # pylint: disable=too-many-nested-blocks
     for node in func.nodes:
         for ir in node.irs_ssa:
             if isinstance(ir, Binary) and ir.type == BinaryType.MODULO:
+                var_left = ir.variable_left
+                if not isinstance(var_left, (Variable, SolidityVariable)):
+                    continue
                 if is_dependent_ssa(
-                    ir.variable_left, SolidityVariableComposed("block.timestamp"), func.contract
-                ) or is_dependent_ssa(ir.variable_left, SolidityVariable("now"), func.contract):
+                    var_left, SolidityVariableComposed("block.timestamp"), node
+                ) or is_dependent_ssa(var_left, SolidityVariable("now"), node):
                     ret.add(node)
                     break
 
                 for ret_val in blockhash_ret_values:
-                    if is_dependent_ssa(ir.variable_left, ret_val, func.contract):
+                    if is_dependent_ssa(var_left, ret_val, node):
                         ret.add(node)
                         break
     return list(ret)
 
 
 def detect_bad_PRNG(contract: Contract) -> List[Tuple[Function, List[Node]]]:
     """
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/operations/block_timestamp.py` & `slither-analyzer-0.9.4/slither/detectors/operations/block_timestamp.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,57 +2,62 @@
     Module detecting dangerous use of block.timestamp
 
 """
 from typing import List, Tuple
 
 from slither.analyses.data_dependency.data_dependency import is_dependent
 from slither.core.cfg.node import Node
-from slither.core.declarations import Function, Contract
+from slither.core.declarations import Function, Contract, FunctionContract
 from slither.core.declarations.solidity_variables import (
     SolidityVariableComposed,
     SolidityVariable,
 )
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.core.variables import Variable
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.slithir.operations import Binary, BinaryType
 from slither.utils.output import Output
 
 
 def _timestamp(func: Function) -> List[Node]:
     ret = set()
     for node in func.nodes:
         if node.contains_require_or_assert():
             for var in node.variables_read:
-                if is_dependent(var, SolidityVariableComposed("block.timestamp"), func.contract):
+                if is_dependent(var, SolidityVariableComposed("block.timestamp"), node):
                     ret.add(node)
-                if is_dependent(var, SolidityVariable("now"), func.contract):
+                if is_dependent(var, SolidityVariable("now"), node):
                     ret.add(node)
         for ir in node.irs:
             if isinstance(ir, Binary) and BinaryType.return_bool(ir.type):
-                for var in ir.read:
-                    if is_dependent(
-                        var, SolidityVariableComposed("block.timestamp"), func.contract
-                    ):
+                for var_read in ir.read:
+                    if not isinstance(var_read, (Variable, SolidityVariable)):
+                        continue
+                    if is_dependent(var_read, SolidityVariableComposed("block.timestamp"), node):
                         ret.add(node)
-                    if is_dependent(var, SolidityVariable("now"), func.contract):
+                    if is_dependent(var_read, SolidityVariable("now"), node):
                         ret.add(node)
     return sorted(list(ret), key=lambda x: x.node_id)
 
 
 def _detect_dangerous_timestamp(
     contract: Contract,
-) -> List[Tuple[Function, List[Node]]]:
+) -> List[Tuple[FunctionContract, List[Node]]]:
     """
     Args:
         contract (Contract)
     Returns:
         list((Function), (list (Node)))
     """
     ret = []
     for f in [f for f in contract.functions if f.contract_declarer == contract]:
-        nodes = _timestamp(f)
+        nodes: List[Node] = _timestamp(f)
         if nodes:
             ret.append((f, nodes))
     return ret
 
 
 class Timestamp(AbstractDetector):
 
@@ -74,15 +79,15 @@
         """"""
         results = []
 
         for c in self.contracts:
             dangerous_timestamp = _detect_dangerous_timestamp(c)
             for (func, nodes) in dangerous_timestamp:
 
-                info = [func, " uses timestamp for comparisons\n"]
+                info: DETECTOR_INFO = [func, " uses timestamp for comparisons\n"]
 
                 info += ["\tDangerous comparisons:\n"]
 
                 # sort the nodes to get deterministic results
                 nodes.sort(key=lambda x: x.node_id)
 
                 for node in nodes:
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/operations/low_level_calls.py` & `slither-analyzer-0.9.4/slither/detectors/operations/low_level_calls.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,12 +1,16 @@
 """
 Module detecting usage of low level calls
 """
 from typing import List, Tuple
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.slithir.operations import LowLevelCall
 from slither.core.cfg.node import Node
 from slither.core.declarations.contract import Contract
 from slither.core.declarations.function_contract import FunctionContract
 from slither.utils.output import Output
 
 
@@ -48,15 +52,15 @@
 
     def _detect(self) -> List[Output]:
         """Detect the functions that use low level calls"""
         results = []
         for c in self.contracts:
             values = self.detect_low_level_calls(c)
             for func, nodes in values:
-                info = ["Low level call in ", func, ":\n"]
+                info: DETECTOR_INFO = ["Low level call in ", func, ":\n"]
 
                 # sort the nodes to get deterministic results
                 nodes.sort(key=lambda x: x.node_id)
 
                 for node in nodes:
                     info += ["\t- ", node, "\n"]
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/operations/missing_events_access_control.py` & `slither-analyzer-0.9.4/slither/detectors/operations/missing_events_access_control.py`

 * *Files 2% similar despite different names*

```diff
@@ -7,15 +7,19 @@
 from slither.analyses.data_dependency.data_dependency import is_tainted
 from slither.core.cfg.node import Node
 from slither.core.declarations.contract import Contract
 from slither.core.declarations.function_contract import FunctionContract
 from slither.core.declarations.modifier import Modifier
 from slither.core.solidity_types.elementary_type import ElementaryType
 from slither.core.variables.state_variable import StateVariable
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.slithir.operations.event_call import EventCall
 from slither.utils.output import Output
 
 
 class MissingEventsAccessControl(AbstractDetector):
     """
     Missing events for critical contract parameters set by owners and used in access control
@@ -96,13 +100,13 @@
         """
 
         # Check derived contracts for missing events
         results = []
         for contract in self.compilation_unit.contracts_derived:
             missing_events = self._detect_missing_events(contract)
             for (function, nodes) in missing_events:
-                info = [function, " should emit an event for: \n"]
+                info: DETECTOR_INFO = [function, " should emit an event for: \n"]
                 for (node, _sv, _mod) in nodes:
                     info += ["\t- ", node, " \n"]
                 res = self.generate_result(info)
                 results.append(res)
         return results
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/operations/missing_events_arithmetic.py` & `slither-analyzer-0.9.4/slither/detectors/operations/missing_events_arithmetic.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,15 +6,19 @@
 
 from slither.analyses.data_dependency.data_dependency import is_tainted
 from slither.core.cfg.node import Node
 from slither.core.declarations.contract import Contract
 from slither.core.declarations.function_contract import FunctionContract
 from slither.core.solidity_types.elementary_type import ElementaryType, Int, Uint
 from slither.core.variables.state_variable import StateVariable
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.slithir.operations.event_call import EventCall
 from slither.utils.output import Output
 
 
 class MissingEventsArithmetic(AbstractDetector):
     """
     Missing events for critical contract parameters set by owners and used in arithmetic
@@ -118,13 +122,13 @@
         """
 
         # Check derived contracts for missing events
         results = []
         for contract in self.compilation_unit.contracts_derived:
             missing_events = self._detect_missing_events(contract)
             for (function, nodes) in missing_events:
-                info = [function, " should emit an event for: \n"]
+                info: DETECTOR_INFO = [function, " should emit an event for: \n"]
                 for (node, _) in nodes:
                     info += ["\t- ", node, " \n"]
                 res = self.generate_result(info)
                 results.append(res)
         return results
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/operations/missing_zero_address_validation.py` & `slither-analyzer-0.9.4/slither/detectors/operations/missing_zero_address_validation.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,15 +8,19 @@
 from slither.analyses.data_dependency.data_dependency import is_tainted
 from slither.core.cfg.node import Node
 from slither.core.declarations.contract import Contract
 from slither.core.declarations.function import ModifierStatements
 from slither.core.declarations.function_contract import FunctionContract
 from slither.core.solidity_types.elementary_type import ElementaryType
 from slither.core.variables.local_variable import LocalVariable
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.slithir.operations import Call
 from slither.slithir.operations import Send, Transfer, LowLevelCall
 from slither.utils.output import Output
 
 
 class MissingZeroAddressValidation(AbstractDetector):
     """
@@ -151,13 +155,13 @@
 
         # Check derived contracts for missing zero address validation
         results = []
         for contract in self.compilation_unit.contracts_derived:
             missing_zero_address_validation = self._detect_missing_zero_address_validation(contract)
             for (_, var_nodes) in missing_zero_address_validation:
                 for var, nodes in var_nodes.items():
-                    info = [var, " lacks a zero-check on ", ":\n"]
+                    info: DETECTOR_INFO = [var, " lacks a zero-check on ", ":\n"]
                     for node in nodes:
                         info += ["\t\t- ", node, "\n"]
                     res = self.generate_result(info)
                     results.append(res)
         return results
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/operations/unchecked_low_level_return_values.py` & `slither-analyzer-0.9.4/slither/detectors/operations/unchecked_low_level_return_values.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/detectors/operations/unchecked_send_return_value.py` & `slither-analyzer-0.9.4/slither/detectors/operations/unchecked_send_return_value.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/detectors/operations/unchecked_transfer.py` & `slither-analyzer-0.9.4/slither/detectors/operations/unchecked_transfer.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/detectors/operations/void_constructor.py` & `slither-analyzer-0.9.4/slither/detectors/operations/void_constructor.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,10 +1,14 @@
 from typing import List
 
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.slithir.operations import Nop
 from slither.utils.output import Output
 
 
 class VoidConstructor(AbstractDetector):
 
     ARGUMENT = "void-cst"
@@ -35,14 +39,14 @@
         for c in self.contracts:
             cst = c.constructor
             if cst:
 
                 for constructor_call in cst.explicit_base_constructor_calls_statements:
                     for node in constructor_call.nodes:
                         if any(isinstance(ir, Nop) for ir in node.irs):
-                            info = ["Void constructor called in ", cst, ":\n"]
+                            info: DETECTOR_INFO = ["Void constructor called in ", cst, ":\n"]
                             info += ["\t- ", node, "\n"]
 
                             res = self.generate_result(info)
 
                             results.append(res)
         return results
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/reentrancy/reentrancy.py` & `slither-analyzer-0.9.4/slither/detectors/reentrancy/reentrancy.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/detectors/reentrancy/reentrancy_benign.py` & `slither-analyzer-0.9.4/slither/detectors/reentrancy/reentrancy_benign.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/detectors/reentrancy/reentrancy_eth.py` & `slither-analyzer-0.9.4/slither/detectors/reentrancy/reentrancy_eth.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/detectors/reentrancy/reentrancy_events.py` & `slither-analyzer-0.9.4/slither/detectors/reentrancy/reentrancy_events.py`

 * *Files 8% similar despite different names*

```diff
@@ -25,32 +25,53 @@
         "https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-3"
     )
 
     WIKI_TITLE = "Reentrancy vulnerabilities"
 
     # region wiki_description
     WIKI_DESCRIPTION = """
-Detection of the [reentrancy bug](https://github.com/trailofbits/not-so-smart-contracts/tree/master/reentrancy).
-Only report reentrancies leading to out-of-order events."""
+Detects [reentrancies](https://github.com/trailofbits/not-so-smart-contracts/tree/master/reentrancy) that allow manipulation of the order or value of events."""
     # endregion wiki_description
 
     # region wiki_exploit_scenario
     WIKI_EXPLOIT_SCENARIO = """
 ```solidity
-    function bug(Called d){
+contract ReentrantContract {
+	function f() external {
+		if (BugReentrancyEvents(msg.sender).counter() == 1) {
+			BugReentrancyEvents(msg.sender).count(this);
+		}
+	}
+}
+contract Counter {
+	uint public counter;
+	event Counter(uint);
+
+}
+contract BugReentrancyEvents is Counter {
+    function count(ReentrantContract d) external {
         counter += 1;
         d.f();
         emit Counter(counter);
     }
+}
+contract NoReentrancyEvents is Counter {
+	function count(ReentrantContract d) external {
+        counter += 1;
+        emit Counter(counter);
+        d.f();
+    }
+}
 ```
 
-If `d.()` re-enters, the `Counter` events will be shown in an incorrect order, which might lead to issues for third parties."""
+If the external call `d.f()` re-enters `BugReentrancyEvents`, the `Counter` events will be incorrect (`Counter(2)`, `Counter(2)`) whereas `NoReentrancyEvents` will correctly emit 
+(`Counter(1)`, `Counter(2)`). This may cause issues for offchain components that rely on the values of events e.g. checking for the amount deposited to a bridge."""
     # endregion wiki_exploit_scenario
 
-    WIKI_RECOMMENDATION = "Apply the [`check-effects-interactions` pattern](http://solidity.readthedocs.io/en/v0.4.21/security-considerations.html#re-entrancy)."
+    WIKI_RECOMMENDATION = "Apply the [`check-effects-interactions` pattern](https://docs.soliditylang.org/en/latest/security-considerations.html#re-entrancy)."
 
     STANDARD_JSON = False
 
     def find_reentrancies(self) -> DefaultDict[FindingKey, Set[FindingValue]]:
         result = defaultdict(set)
         for contract in self.contracts:
             for f in contract.functions_and_modifiers_declared:
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/reentrancy/reentrancy_no_gas.py` & `slither-analyzer-0.9.4/slither/detectors/reentrancy/reentrancy_no_gas.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/detectors/reentrancy/reentrancy_read_before_write.py` & `slither-analyzer-0.9.4/slither/detectors/reentrancy/reentrancy_read_before_write.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/detectors/reentrancy/token.py` & `slither-analyzer-0.9.4/slither/detectors/reentrancy/token.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,14 +1,18 @@
 from collections import defaultdict
 from typing import Dict, List
 
 from slither.analyses.data_dependency.data_dependency import is_dependent
 from slither.core.cfg.node import Node
 from slither.core.declarations import Function, Contract, SolidityVariableComposed
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.slithir.operations import LowLevelCall, HighLevelCall
 from slither.utils.output import Output
 
 
 def _detect_token_reentrant(contract: Contract) -> Dict[Function, List[Node]]:
     ret: Dict[Function, List[Node]] = defaultdict(list)
     for function in contract.functions_entry_points:
@@ -84,14 +88,14 @@
     # endregion wiki_recommendation
 
     def _detect(self) -> List[Output]:
         results = []
         for contract in self.compilation_unit.contracts_derived:
             vulns = _detect_token_reentrant(contract)
             for function, nodes in vulns.items():
-                info = [function, " is an reentrancy unsafe token function:\n"]
+                info: DETECTOR_INFO = [function, " is an reentrancy unsafe token function:\n"]
                 for node in nodes:
                     info += ["\t-", node, "\n"]
                 json = self.generate_result(info)
                 results.append(json)
 
         return results
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/shadowing/abstract.py` & `slither-analyzer-0.9.4/slither/detectors/shadowing/abstract.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/detectors/shadowing/builtin_symbols.py` & `slither-analyzer-0.9.4/slither/detectors/shadowing/builtin_symbols.py`

 * *Files 2% similar despite different names*

```diff
@@ -5,15 +5,19 @@
 
 from slither.core.declarations import Function, Event
 from slither.core.declarations.contract import Contract
 from slither.core.declarations.function_contract import FunctionContract
 from slither.core.declarations.modifier import Modifier
 from slither.core.variables import Variable
 from slither.core.variables.local_variable import LocalVariable
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.utils.output import Output
 
 
 class BuiltinSymbolShadowing(AbstractDetector):
     """
     Built-in symbol shadowing
     """
@@ -190,15 +194,15 @@
             shadows = self.detect_builtin_shadowing_definitions(contract)
             if shadows:
                 for shadow in shadows:
                     # Obtain components
                     shadow_type = shadow[0]
                     shadow_object = shadow[1]
 
-                    info = [
+                    info: DETECTOR_INFO = [
                         shadow_object,
                         f' ({shadow_type}) shadows built-in symbol"\n',
                     ]
 
                     res = self.generate_result(info)
                     results.append(res)
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/shadowing/common.py` & `slither-analyzer-0.9.4/slither/detectors/shadowing/common.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/detectors/shadowing/local.py` & `slither-analyzer-0.9.4/slither/detectors/shadowing/local.py`

 * *Files 8% similar despite different names*

```diff
@@ -5,15 +5,19 @@
 
 from slither.core.declarations.contract import Contract
 from slither.core.declarations.event import Event
 from slither.core.declarations.function_contract import FunctionContract
 from slither.core.declarations.modifier import Modifier
 from slither.core.variables.local_variable import LocalVariable
 from slither.core.variables.state_variable import StateVariable
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.utils.output import Output
 
 
 class LocalShadowing(AbstractDetector):
     """
     Local variable shadowing
     """
@@ -81,15 +85,15 @@
                 Tuple[LocalVariable, List[Tuple[str, FunctionContract]]],
                 Tuple[LocalVariable, List[Tuple[str, Modifier]]],
                 Tuple[LocalVariable, List[Tuple[str, Event]]],
             ]
         ] = []
 
         # Loop through all functions + modifiers in this contract.
-        for function in contract.functions + contract.modifiers:
+        for function in contract.functions + list(contract.modifiers):
             # We should only look for functions declared directly in this contract (not in a base contract).
             if function.contract_declarer != contract:
                 continue
 
             # This function was declared in this contract, we check what its local variables might shadow.
             for variable in function.variables:
                 overshadowed = []
@@ -140,15 +144,15 @@
         results = []
         for contract in self.contracts:
             shadows = self.detect_shadowing_definitions(contract)
             if shadows:
                 for shadow in shadows:
                     local_variable = shadow[0]
                     overshadowed = shadow[1]
-                    info = [local_variable, " shadows:\n"]
+                    info: DETECTOR_INFO = [local_variable, " shadows:\n"]
                     for overshadowed_entry in overshadowed:
                         info += [
                             "\t- ",
                             overshadowed_entry[1],
                             f" ({overshadowed_entry[0]})\n",
                         ]
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/shadowing/state.py` & `slither-analyzer-0.9.4/slither/detectors/shadowing/state.py`

 * *Files 15% similar despite different names*

```diff
@@ -2,15 +2,19 @@
 Module detecting shadowing of state variables
 """
 
 from typing import List
 
 from slither.core.declarations import Contract
 from slither.core.variables.state_variable import StateVariable
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.detectors.shadowing.common import is_upgradable_gap_variable
 from slither.utils.output import Output
 
 
 def detect_shadowing(contract: Contract) -> List[List[StateVariable]]:
     ret = []
     variables_fathers = []
@@ -85,15 +89,15 @@
         results = []
         for c in self.contracts:
             shadowing = detect_shadowing(c)
             if shadowing:
                 for all_variables in shadowing:
                     shadow = all_variables[0]
                     variables = all_variables[1:]
-                    info = [shadow, " shadows:\n"]
+                    info: DETECTOR_INFO = [shadow, " shadows:\n"]
                     for var in variables:
                         info += ["\t- ", var, "\n"]
 
                     res = self.generate_result(info)
                     results.append(res)
 
         return results
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/slither/name_reused.py` & `slither-analyzer-0.9.4/slither/detectors/slither/name_reused.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,16 +1,21 @@
 from collections import defaultdict
-from typing import Any, List
+from typing import List
 
 from slither.core.compilation_unit import SlitherCompilationUnit
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.core.declarations import Contract
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.utils.output import Output
 
 
-def _find_missing_inheritance(compilation_unit: SlitherCompilationUnit) -> List[Any]:
+def _find_missing_inheritance(compilation_unit: SlitherCompilationUnit) -> List[Contract]:
     """
     Filter contracts with missing inheritance to return only the "most base" contracts
     in the inheritance tree.
     :param slither:
     :return:
     """
     missings = compilation_unit.contracts_with_missing_inheritance
@@ -76,15 +81,15 @@
 
         inheritance_corrupted = defaultdict(list)
         for contract in incorrectly_constructed:
             for father in contract.inheritance:
                 inheritance_corrupted[father.name].append(contract)
 
         for contract_name, files in names_reused.items():
-            info = [contract_name, " is re-used:\n"]
+            info: DETECTOR_INFO = [contract_name, " is re-used:\n"]
             for file in files:
                 if file is None:
                     info += ["\t- In an file not found, most likely in\n"]
                 else:
                     info += ["\t- ", file, "\n"]
 
             if contract_name in inheritance_corrupted:
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/source/rtlo.py` & `slither-analyzer-0.9.4/slither/detectors/source/rtlo.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,11 +1,15 @@
 import re
 from typing import List
 
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.utils.output import Output
 
 
 # pylint: disable=bidirectional-unicode
 class RightToLeftOverride(AbstractDetector):
     """
     Detect the usage of a Right-To-Left-Override (U+202E) character
@@ -74,15 +78,15 @@
                 if result_index == -1:
                     break
 
                 # We found another instance of the character, define our output
                 idx = start_index + result_index
 
                 relative = self.slither.crytic_compile.filename_lookup(filename).relative
-                info = f"{relative} contains a unicode right-to-left-override character at byte offset {idx}:\n"
+                info: DETECTOR_INFO = f"{relative} contains a unicode right-to-left-override character at byte offset {idx}:\n"
 
                 # We have a patch, so pattern.find will return at least one result
 
                 info += f"\t- {pattern.findall(source_encoded)[0]}\n"
                 res = self.generate_result(info)
                 res.add_other(
                     "rtlo-character",
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/statements/array_length_assignment.py` & `slither-analyzer-0.9.4/slither/detectors/statements/array_length_assignment.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,24 +1,26 @@
 """
 Module detecting assignment of array length
 """
-from typing import List, Set
+from typing import List, Set, Union
+
+from slither.core.variables import Variable
 from slither.detectors.abstract_detector import (
     AbstractDetector,
     DetectorClassification,
     ALL_SOLC_VERSIONS_04,
     ALL_SOLC_VERSIONS_05,
 )
 from slither.core.cfg.node import Node, NodeType
 from slither.slithir.operations import Assignment, Length
 from slither.slithir.variables.reference import ReferenceVariable
 from slither.slithir.operations.binary import Binary
 from slither.analyses.data_dependency.data_dependency import is_tainted
 from slither.core.declarations.contract import Contract
-from slither.utils.output import Output
+from slither.utils.output import Output, SupportedOutput
 
 
 def detect_array_length_assignment(contract: Contract) -> Set[Node]:
     """
     Detects and returns all nodes which assign array length.
     :param contract: Contract to detect assignment within.
     :return: A list of tuples with (Variable, node) where Variable references an array whose length was set by node.
@@ -46,15 +48,15 @@
                         array_length_refs.add(ir.lvalue)
 
                     # If we have an assignment/binary operation, verify the left side refers to a reference variable
                     # which is in our list or array length references. (Array length is being assigned to).
                     elif isinstance(ir, (Assignment, Binary)):
                         if isinstance(ir.lvalue, ReferenceVariable):
                             if ir.lvalue in array_length_refs and any(
-                                is_tainted(v, contract) for v in ir.read
+                                is_tainted(v, contract) for v in ir.read if isinstance(v, Variable)
                             ):
                                 # the taint is not precise enough yet
                                 # as a result, REF_0 = REF_0 + 1
                                 # where REF_0 points to a LENGTH operation
                                 # is considered as tainted
                                 if ir.lvalue in ir.read:
                                     continue
@@ -116,17 +118,21 @@
         """
         Detect array length assignments
         """
         results = []
         for contract in self.contracts:
             array_length_assignments = detect_array_length_assignment(contract)
             if array_length_assignments:
-                contract_info = [
+                contract_info: List[Union[str, SupportedOutput]] = [
                     contract,
                     " contract sets array length with a user-controlled value:\n",
                 ]
                 for node in array_length_assignments:
-                    node_info = contract_info + ["\t- ", node, "\n"]
+                    node_info: List[Union[str, SupportedOutput]] = contract_info + [
+                        "\t- ",
+                        node,
+                        "\n",
+                    ]
                     res = self.generate_result(node_info)
                     results.append(res)
 
         return results
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/statements/assembly.py` & `slither-analyzer-0.9.4/slither/detectors/statements/assembly.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,15 +2,19 @@
 Module detecting usage of inline assembly
 """
 from typing import List, Tuple
 
 from slither.core.cfg.node import Node, NodeType
 from slither.core.declarations.contract import Contract
 from slither.core.declarations.function_contract import FunctionContract
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.utils.output import Output
 
 
 class Assembly(AbstractDetector):
     """
     Detect usage of inline assembly
     """
@@ -48,15 +52,15 @@
 
     def _detect(self) -> List[Output]:
         """Detect the functions that use inline assembly"""
         results = []
         for c in self.contracts:
             values = self.detect_assembly(c)
             for func, nodes in values:
-                info = [func, " uses assembly\n"]
+                info: DETECTOR_INFO = [func, " uses assembly\n"]
 
                 # sort the nodes to get deterministic results
                 nodes.sort(key=lambda x: x.node_id)
 
                 for node in nodes:
                     info += ["\t- ", node, "\n"]
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/statements/assert_state_change.py` & `slither-analyzer-0.9.4/slither/detectors/statements/assert_state_change.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,15 +2,19 @@
 Module detecting state changes in assert calls
 """
 from typing import List, Tuple
 
 from slither.core.cfg.node import Node
 from slither.core.declarations.contract import Contract
 from slither.core.declarations.function_contract import FunctionContract
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.slithir.operations.internal_call import InternalCall
 from slither.utils.output import Output
 
 
 def detect_assert_state_change(
     contract: Contract,
 ) -> List[Tuple[FunctionContract, Node]]:
@@ -21,26 +25,28 @@
     """
 
     # Create our result set.
     # List of tuples (function, node)
     results = []
 
     # Loop for each function and modifier.
-    for function in contract.functions_declared + contract.modifiers_declared:
+    for function in contract.functions_declared + list(contract.modifiers_declared):
         for node in function.nodes:
             # Detect assert() calls
             if any(c.name == "assert(bool)" for c in node.internal_calls) and (
                 # Detect direct changes to state
                 node.state_variables_written
                 or
                 # Detect changes to state via function calls
                 any(
                     ir
                     for ir in node.irs
-                    if isinstance(ir, InternalCall) and ir.function.state_variables_written
+                    if isinstance(ir, InternalCall)
+                    and ir.function
+                    and ir.function.state_variables_written
                 )
             ):
                 results.append((function, node))
 
     # Return the resulting set of nodes
     return results
 
@@ -81,15 +87,18 @@
         """
         Detect assert calls that change state from within the invariant
         """
         results = []
         for contract in self.contracts:
             assert_state_change = detect_assert_state_change(contract)
             for (func, node) in assert_state_change:
-                info = [func, " has an assert() call which possibly changes state.\n"]
+                info: DETECTOR_INFO = [
+                    func,
+                    " has an assert() call which possibly changes state.\n",
+                ]
                 info += ["\t-", node, "\n"]
                 info += [
                     "Consider using require() or change the invariant to not modify the state.\n"
                 ]
                 res = self.generate_result(info)
                 results.append(res)
         return results
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/statements/boolean_constant_equality.py` & `slither-analyzer-0.9.4/slither/detectors/statements/boolean_constant_equality.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,19 @@
 Module detecting misuse of Boolean constants
 """
 from typing import List, Set, Tuple
 
 from slither.core.cfg.node import Node
 from slither.core.declarations import Function
 from slither.core.declarations.contract import Contract
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.slithir.operations import (
     Binary,
     BinaryType,
 )
 from slither.slithir.variables import Constant
 from slither.utils.output import Output
 
@@ -80,15 +84,15 @@
         Detect Boolean constant misuses
         """
         results = []
         for contract in self.contracts:
             boolean_constant_misuses = self._detect_boolean_equality(contract)
             for (func, nodes) in boolean_constant_misuses:
                 for node in nodes:
-                    info = [
+                    info: DETECTOR_INFO = [
                         func,
                         " compares to a boolean constant:\n\t-",
                         node,
                         "\n",
                     ]
 
                     res = self.generate_result(info)
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/statements/boolean_constant_misuse.py` & `slither-analyzer-0.9.4/slither/detectors/statements/boolean_constant_misuse.py`

 * *Files 3% similar despite different names*

```diff
@@ -3,15 +3,19 @@
 """
 from typing import List, Set, Tuple
 
 from slither.core.cfg.node import Node, NodeType
 from slither.core.declarations import Function
 from slither.core.declarations.contract import Contract
 from slither.core.solidity_types import ElementaryType
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.slithir.operations import (
     Assignment,
     Call,
     Return,
     InitArray,
     Binary,
     BinaryType,
@@ -116,15 +120,15 @@
         Detect Boolean constant misuses
         """
         results = []
         for contract in self.contracts:
             boolean_constant_misuses = self._detect_boolean_constant_misuses(contract)
             for (func, nodes) in boolean_constant_misuses:
                 for node in nodes:
-                    info = [
+                    info: DETECTOR_INFO = [
                         func,
                         " uses a Boolean constant improperly:\n\t-",
                         node,
                         "\n",
                     ]
 
                     res = self.generate_result(info)
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/statements/calls_in_loop.py` & `slither-analyzer-0.9.4/slither/detectors/statements/calls_in_loop.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,10 +1,14 @@
 from typing import List, Optional
 from slither.core.cfg.node import NodeType, Node
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.core.declarations import Contract
 from slither.utils.output import Output
 from slither.slithir.operations import (
     HighLevelCall,
     LibraryCall,
     LowLevelCall,
     Send,
@@ -40,14 +44,15 @@
     if in_loop_counter > 0:
         for ir in node.all_slithir_operations():
             if isinstance(ir, (LowLevelCall, HighLevelCall, Send, Transfer)):
                 if isinstance(ir, LibraryCall):
                     continue
                 ret.append(ir.node)
             if isinstance(ir, (InternalCall)):
+                assert ir.function
                 call_in_loop(ir.function.entry_point, in_loop_counter, visited, ret)
 
     for son in node.sons:
         call_in_loop(son, in_loop_counter, visited, ret)
 
 
 class MultipleCallsInLoop(AbstractDetector):
@@ -90,12 +95,12 @@
         """"""
         results: List[Output] = []
         for c in self.compilation_unit.contracts_derived:
             values = detect_call_in_loop(c)
             for node in values:
                 func = node.function
 
-                info = [func, " has external calls inside a loop: ", node, "\n"]
+                info: DETECTOR_INFO = [func, " has external calls inside a loop: ", node, "\n"]
                 res = self.generate_result(info)
                 results.append(res)
 
         return results
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/statements/controlled_delegatecall.py` & `slither-analyzer-0.9.4/slither/detectors/statements/controlled_delegatecall.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,13 +1,17 @@
 from typing import List
 
 from slither.analyses.data_dependency.data_dependency import is_tainted
 from slither.core.cfg.node import Node
 from slither.core.declarations.function_contract import FunctionContract
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.slithir.operations import LowLevelCall
 from slither.utils.output import Output
 
 
 def controlled_delegatecall(function: FunctionContract) -> List[Node]:
     ret = []
     for node in function.nodes:
@@ -54,18 +58,18 @@
             for f in contract.functions:
                 # If its an upgradeable proxy, do not report protected function
                 # As functions to upgrades the destination lead to too many FPs
                 if contract.is_upgradeable_proxy and f.is_protected():
                     continue
                 nodes = controlled_delegatecall(f)
                 if nodes:
-                    func_info = [
+                    func_info: DETECTOR_INFO = [
                         f,
                         " uses delegatecall to a input-controlled function id\n",
                     ]
 
                     for node in nodes:
-                        node_info = func_info + ["\t- ", node, "\n"]
+                        node_info: DETECTOR_INFO = func_info + ["\t- ", node, "\n"]
                         res = self.generate_result(node_info)
                         results.append(res)
 
         return results
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/statements/costly_operations_in_loop.py` & `slither-analyzer-0.9.4/slither/detectors/statements/costly_operations_in_loop.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,14 @@
 from typing import List, Optional
 from slither.core.cfg.node import NodeType, Node
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.core.declarations import Contract
 from slither.utils.output import Output
 from slither.slithir.operations import InternalCall, OperationWithLValue
 from slither.core.variables.state_variable import StateVariable
 
 
 def detect_costly_operations_in_loop(contract: Contract) -> List[Node]:
@@ -35,15 +39,15 @@
 
     if in_loop_counter > 0:
         for ir in node.all_slithir_operations():
             # Ignore Array/Mapping/Struct types for now
             if isinstance(ir, OperationWithLValue) and isinstance(ir.lvalue, StateVariable):
                 ret.append(ir.node)
                 break
-            if isinstance(ir, (InternalCall)):
+            if isinstance(ir, (InternalCall)) and ir.function:
                 costly_operations_in_loop(ir.function.entry_point, in_loop_counter, visited, ret)
 
     for son in node.sons:
         costly_operations_in_loop(son, in_loop_counter, visited, ret)
 
 
 class CostlyOperationsInLoop(AbstractDetector):
@@ -94,13 +98,13 @@
     def _detect(self) -> List[Output]:
         """"""
         results: List[Output] = []
         for c in self.compilation_unit.contracts_derived:
             values = detect_costly_operations_in_loop(c)
             for node in values:
                 func = node.function
-                info = [func, " has costly operations inside a loop:\n"]
+                info: DETECTOR_INFO = [func, " has costly operations inside a loop:\n"]
                 info += ["\t- ", node, "\n"]
                 res = self.generate_result(info)
                 results.append(res)
 
         return results
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/statements/delegatecall_in_loop.py` & `slither-analyzer-0.9.4/slither/detectors/statements/delegatecall_in_loop.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,14 @@
 from typing import List, Optional
 from slither.core.cfg.node import NodeType, Node
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.slithir.operations import LowLevelCall, InternalCall
 from slither.core.declarations import Contract
 from slither.utils.output import Output
 
 
 def detect_delegatecall_in_loop(contract: Contract) -> List[Node]:
     results: List[Node] = []
@@ -34,15 +38,15 @@
     for ir in node.all_slithir_operations():
         if (
             in_loop_counter > 0
             and isinstance(ir, (LowLevelCall))
             and ir.function_name == "delegatecall"
         ):
             results.append(ir.node)
-        if isinstance(ir, (InternalCall)):
+        if isinstance(ir, (InternalCall)) and ir.function:
             delegatecall_in_loop(ir.function.entry_point, in_loop_counter, visited, results)
 
     for son in node.sons:
         delegatecall_in_loop(son, in_loop_counter, visited, results)
 
 
 class DelegatecallInLoop(AbstractDetector):
@@ -90,12 +94,17 @@
         """"""
         results: List[Output] = []
         for c in self.compilation_unit.contracts_derived:
             values = detect_delegatecall_in_loop(c)
             for node in values:
                 func = node.function
 
-                info = [func, " has delegatecall inside a loop in a payable function: ", node, "\n"]
+                info: DETECTOR_INFO = [
+                    func,
+                    " has delegatecall inside a loop in a payable function: ",
+                    node,
+                    "\n",
+                ]
                 res = self.generate_result(info)
                 results.append(res)
 
         return results
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/statements/deprecated_calls.py` & `slither-analyzer-0.9.4/slither/detectors/statements/deprecated_calls.py`

 * *Files 1% similar despite different names*

```diff
@@ -7,15 +7,19 @@
 from slither.core.declarations.contract import Contract
 from slither.core.declarations.solidity_variables import (
     SolidityVariableComposed,
     SolidityFunction,
 )
 from slither.core.expressions.expression import Expression
 from slither.core.variables import StateVariable
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.slithir.operations import LowLevelCall
 from slither.utils.output import Output
 from slither.visitors.expression.export_values import ExportValues
 
 
 # Reference: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-111
 class DeprecatedStandards(AbstractDetector):
@@ -182,15 +186,15 @@
         results = []
         for contract in self.contracts:
             deprecated_references = self.detect_deprecated_references_in_contract(contract)
             if deprecated_references:
                 for deprecated_reference in deprecated_references:
                     source_object = deprecated_reference[0]
                     deprecated_entries = deprecated_reference[1]
-                    info = ["Deprecated standard detected ", source_object, ":\n"]
+                    info: DETECTOR_INFO = ["Deprecated standard detected ", source_object, ":\n"]
 
                     for (_dep_id, original_desc, recommended_disc) in deprecated_entries:
                         info += [
                             f'\t- Usage of "{original_desc}" should be replaced with "{recommended_disc}"\n'
                         ]
 
                     res = self.generate_result(info)
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/statements/divide_before_multiply.py` & `slither-analyzer-0.9.4/slither/detectors/statements/divide_before_multiply.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,29 +1,34 @@
 """
 Module detecting possible loss of precision due to divide before multiple
 """
 from collections import defaultdict
-from typing import Any, DefaultDict, List, Set, Tuple
+from typing import DefaultDict, List, Set, Tuple
 
 from slither.core.cfg.node import Node
 from slither.core.declarations.contract import Contract
 from slither.core.declarations.function_contract import FunctionContract
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.slithir.operations import Binary, Assignment, BinaryType, LibraryCall, Operation
+from slither.slithir.utils.utils import LVALUE
 from slither.slithir.variables import Constant
 from slither.utils.output import Output
 
 
 def is_division(ir: Operation) -> bool:
     if isinstance(ir, Binary):
         if ir.type == BinaryType.DIVISION:
             return True
 
     if isinstance(ir, LibraryCall):
-        if ir.function.name.lower() in [
+        if ir.function.name and ir.function.name.lower() in [
             "div",
             "safediv",
         ]:
             if len(ir.arguments) == 2:
                 if ir.lvalue:
                     return True
     return False
@@ -31,15 +36,15 @@
 
 def is_multiplication(ir: Operation) -> bool:
     if isinstance(ir, Binary):
         if ir.type == BinaryType.MULTIPLICATION:
             return True
 
     if isinstance(ir, LibraryCall):
-        if ir.function.name.lower() in [
+        if ir.function.name and ir.function.name.lower() in [
             "mul",
             "safemul",
         ]:
             if len(ir.arguments) == 2:
                 if ir.lvalue:
                     return True
     return False
@@ -54,42 +59,42 @@
     if "assert(bool)" in [c.full_name for c in node.internal_calls]:
         return True
     return False
 
 
 # pylint: disable=too-many-branches
 def _explore(
-    to_explore: Set[Node], f_results: List[Node], divisions: DefaultDict[Any, Any]
+    to_explore: Set[Node], f_results: List[List[Node]], divisions: DefaultDict[LVALUE, List[Node]]
 ) -> None:
     explored = set()
     while to_explore:  # pylint: disable=too-many-nested-blocks
         node = to_explore.pop()
 
         if node in explored:
             continue
         explored.add(node)
 
         equality_found = False
         # List of nodes related to one bug instance
-        node_results = []
+        node_results: List[Node] = []
 
         for ir in node.irs:
             if isinstance(ir, Assignment):
                 if ir.rvalue in divisions:
                     # Avoid dupplicate. We dont use set so we keep the order of the nodes
-                    if node not in divisions[ir.rvalue]:
-                        divisions[ir.lvalue] = divisions[ir.rvalue] + [node]
+                    if node not in divisions[ir.rvalue]:  # type: ignore
+                        divisions[ir.lvalue] = divisions[ir.rvalue] + [node]  # type: ignore
                     else:
-                        divisions[ir.lvalue] = divisions[ir.rvalue]
+                        divisions[ir.lvalue] = divisions[ir.rvalue]  # type: ignore
 
             if is_division(ir):
-                divisions[ir.lvalue] = [node]
+                divisions[ir.lvalue] = [node]  # type: ignore
 
             if is_multiplication(ir):
-                mul_arguments = ir.read if isinstance(ir, Binary) else ir.arguments
+                mul_arguments = ir.read if isinstance(ir, Binary) else ir.arguments  # type: ignore
                 nodes = []
                 for r in mul_arguments:
                     if not isinstance(r, Constant) and (r in divisions):
                         # Dont add node already present to avoid dupplicate
                         # We dont use set to keep the order of the nodes
                         if node in divisions[r]:
                             nodes += [n for n in divisions[r] if n not in nodes]
@@ -121,28 +126,28 @@
     :return: A list of nodes with multiplications of divisions.
     """
 
     # Create our result set.
     # List of tuple (function -> list(list(nodes)))
     # Each list(nodes) of the list is one bug instances
     # Each node in the list(nodes) is involved in the bug
-    results = []
+    results: List[Tuple[FunctionContract, List[Node]]] = []
 
     # Loop for each function and modifier.
     for function in contract.functions_declared:
         if not function.entry_point:
             continue
 
         # List of list(nodes)
         # Each list(nodes) is one bug instances
-        f_results = []
+        f_results: List[List[Node]] = []
 
         # lvalue -> node
         # track all the division results (and the assignment of the division results)
-        divisions = defaultdict(list)
+        divisions: DefaultDict[LVALUE, List[Node]] = defaultdict(list)
 
         _explore({function.entry_point}, f_results, divisions)
 
         for f_result in f_results:
             results.append((function, f_result))
 
     # Return the resulting set of nodes with divisions before multiplications
@@ -186,15 +191,15 @@
         """
         results = []
         for contract in self.contracts:
             divisions_before_multiplications = detect_divide_before_multiply(contract)
             if divisions_before_multiplications:
                 for (func, nodes) in divisions_before_multiplications:
 
-                    info = [
+                    info: DETECTOR_INFO = [
                         func,
                         " performs a multiplication on the result of a division:\n",
                     ]
 
                     # sort the nodes to get deterministic results
                     nodes.sort(key=lambda x: x.node_id)
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/statements/incorrect_strict_equality.py` & `slither-analyzer-0.9.4/slither/detectors/statements/incorrect_strict_equality.py`

 * *Files 4% similar despite different names*

```diff
@@ -27,14 +27,15 @@
 from slither.core.declarations.contract import Contract
 from slither.core.declarations.function_contract import FunctionContract
 from slither.slithir.operations.operation import Operation
 from slither.slithir.variables.constant import Constant
 from slither.slithir.variables.local_variable import LocalIRVariable
 from slither.slithir.variables.temporary_ssa import TemporaryVariableSSA
 from slither.utils.output import Output
+from slither.utils.type import is_underlying_type_address
 
 
 class IncorrectStrictEquality(AbstractDetector):
     ARGUMENT = "incorrect-equality"
     HELP = "Dangerous strict equalities"
     IMPACT = DetectorClassification.MEDIUM
     CONFIDENCE = DetectorClassification.HIGH
@@ -69,14 +70,27 @@
     ]
 
     @staticmethod
     def is_direct_comparison(ir: Operation) -> bool:
         return isinstance(ir, Binary) and ir.type == BinaryType.EQUAL
 
     @staticmethod
+    def is_not_comparing_addresses(ir: Binary) -> bool:
+        """
+        Comparing addresses strictly should not be flagged.
+        """
+
+        if is_underlying_type_address(ir.variable_left.type) and is_underlying_type_address(
+            ir.variable_right.type
+        ):
+            return False
+
+        return True
+
+    @staticmethod
     def is_any_tainted(
         variables: List[
             Union[
                 Constant,
                 LocalIRVariable,
                 TemporaryVariableSSA,
                 SolidityVariableComposed,
@@ -104,15 +118,14 @@
             for node in func.nodes:
                 for ir in node.irs_ssa:
                     if isinstance(ir, SolidityCall) and ir.function == SolidityFunction(
                         "balance(address)"
                     ):
                         taints.append(ir.lvalue)
                     if isinstance(ir, HighLevelCall):
-                        # print(ir.function.full_name)
                         if (
                             isinstance(ir.function, Function)
                             and ir.function.full_name == "balanceOf(address)"
                         ):
                             taints.append(ir.lvalue)
                         if (
                             isinstance(ir.function, StateVariable)
@@ -121,15 +134,14 @@
                             and ir.function.type.type_from == ElementaryType("address")
                             and ir.function.type.type_to == ElementaryType("uint256")
                         ):
                             taints.append(ir.lvalue)
                     if isinstance(ir, Assignment):
                         if ir.rvalue in self.sources_taint:
                             taints.append(ir.lvalue)
-
         return taints
 
     # Retrieve all tainted (node, function) pairs
     def tainted_equality_nodes(
         self,
         funcs: List[Union[FunctionContract, Any]],
         taints: List[Union[LocalIRVariable, TemporaryVariableSSA, Any]],
@@ -141,15 +153,20 @@
             # Disable the detector on top level function until we have good taint on those
             if isinstance(func, FunctionTopLevel):
                 continue
             for node in func.nodes:
                 for ir in node.irs_ssa:
 
                     # Filter to only tainted equality (==) comparisons
-                    if self.is_direct_comparison(ir) and self.is_any_tainted(ir.used, taints, func):
+                    if (
+                        self.is_direct_comparison(ir)
+                        # Filter out address comparisons which may occur due to lack of field sensitivity in data dependency
+                        and self.is_not_comparing_addresses(ir)
+                        and self.is_any_tainted(ir.used, taints, func)
+                    ):
                         if func not in results:
                             results[func] = []
                         results[func].append(node)
 
         return results
 
     def detect_strict_equality(self, contract: Contract) -> Dict[FunctionContract, List[Node]]:
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/statements/mapping_deletion.py` & `slither-analyzer-0.9.4/slither/detectors/statements/mapping_deletion.py`

 * *Files 8% similar despite different names*

```diff
@@ -4,15 +4,19 @@
 from typing import List, Tuple
 
 from slither.core.cfg.node import Node
 from slither.core.declarations import Structure
 from slither.core.declarations.contract import Contract
 from slither.core.declarations.function_contract import FunctionContract
 from slither.core.solidity_types import MappingType, UserDefinedType
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.slithir.operations import Delete
 from slither.utils.output import Output
 
 
 class MappingDeletionDetection(AbstractDetector):
     """
     Mapping deletion detector
@@ -79,14 +83,14 @@
         Returns:
             list: {'vuln', 'filename,'contract','func','struct''}
         """
         results = []
         for c in self.contracts:
             mapping = MappingDeletionDetection.detect_mapping_deletion(c)
             for (func, struct, node) in mapping:
-                info = [func, " deletes ", struct, " which contains a mapping:\n"]
+                info: DETECTOR_INFO = [func, " deletes ", struct, " which contains a mapping:\n"]
                 info += ["\t-", node, "\n"]
 
                 res = self.generate_result(info)
                 results.append(res)
 
         return results
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/statements/msg_value_in_loop.py` & `slither-analyzer-0.9.4/slither/detectors/statements/msg_value_in_loop.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,10 +1,14 @@
 from typing import List, Optional
 from slither.core.cfg.node import NodeType, Node
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.slithir.operations import InternalCall
 from slither.core.declarations import SolidityVariableComposed, Contract
 from slither.utils.output import Output
 
 
 def detect_msg_value_in_loop(contract: Contract) -> List[Node]:
     results: List[Node] = []
@@ -71,23 +75,23 @@
 
 }
 ```
 """
     # endregion wiki_exploit_scenario
 
     WIKI_RECOMMENDATION = """
-Track msg.value through a local variable and decrease its amount on every iteration/usage.
+Provide an explicit array of amounts alongside the receivers array, and check that the sum of all amounts matches `msg.value`.
 """
 
     def _detect(self) -> List[Output]:
         """"""
         results: List[Output] = []
         for c in self.compilation_unit.contracts_derived:
             values = detect_msg_value_in_loop(c)
             for node in values:
                 func = node.function
 
-                info = [func, " use msg.value in a loop: ", node, "\n"]
+                info: DETECTOR_INFO = [func, " use msg.value in a loop: ", node, "\n"]
                 res = self.generate_result(info)
                 results.append(res)
 
         return results
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/statements/redundant_statements.py` & `slither-analyzer-0.9.4/slither/detectors/statements/redundant_statements.py`

 * *Files 3% similar despite different names*

```diff
@@ -3,15 +3,19 @@
 """
 from typing import List
 
 from slither.core.cfg.node import Node, NodeType
 from slither.core.declarations.contract import Contract
 from slither.core.expressions.elementary_type_name_expression import ElementaryTypeNameExpression
 from slither.core.expressions.identifier import Identifier
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.utils.output import Output
 
 
 class RedundantStatements(AbstractDetector):
     """
     Use of Redundant Statements
     """
@@ -83,12 +87,18 @@
         """
         results = []
         for contract in self.contracts:
             redundant_statements = self.detect_redundant_statements_contract(contract)
             if redundant_statements:
 
                 for redundant_statement in redundant_statements:
-                    info = ['Redundant expression "', redundant_statement, '" in', contract, "\n"]
+                    info: DETECTOR_INFO = [
+                        'Redundant expression "',
+                        redundant_statement,
+                        '" in',
+                        contract,
+                        "\n",
+                    ]
                     json = self.generate_result(info)
                     results.append(json)
 
         return results
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/statements/too_many_digits.py` & `slither-analyzer-0.9.4/slither/detectors/statements/too_many_digits.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,15 +3,19 @@
 """
 
 import re
 from typing import List
 
 from slither.core.cfg.node import Node
 from slither.core.declarations.function_contract import FunctionContract
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.slithir.variables import Constant
 from slither.utils.output import Output
 
 _HEX_ADDRESS_REGEXP = re.compile("(0[xX])?[0-9a-fA-F]{40}")
 
 
 def is_hex_address(value: str) -> bool:
@@ -84,16 +88,16 @@
         # iterate over all contracts
         for contract in self.compilation_unit.contracts_derived:
             # iterate over all functions
             for f in contract.functions:
                 # iterate over all the nodes
                 ret = self._detect_too_many_digits(f)
                 if ret:
-                    func_info = [f, " uses literals with too many digits:"]
+                    func_info: DETECTOR_INFO = [f, " uses literals with too many digits:"]
                     for node in ret:
-                        node_info = func_info + ["\n\t- ", node, "\n"]
+                        node_info: DETECTOR_INFO = func_info + ["\n\t- ", node, "\n"]
 
                         # Add the result in result
                         res = self.generate_result(node_info)
                         results.append(res)
 
         return results
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/statements/tx_origin.py` & `slither-analyzer-0.9.4/slither/detectors/statements/tx_origin.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,19 @@
 Module detecting usage of `tx.origin` in a conditional node
 """
 from typing import List, Tuple
 
 from slither.core.cfg.node import Node
 from slither.core.declarations.contract import Contract
 from slither.core.declarations.function_contract import FunctionContract
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.utils.output import Output
 
 
 class TxOrigin(AbstractDetector):
     """
     Detect usage of tx.origin in a conditional node
     """
@@ -76,12 +80,12 @@
         """Detect the functions that use tx.origin in a conditional node"""
         results = []
         for c in self.contracts:
             values = self.detect_tx_origin(c)
             for func, nodes in values:
 
                 for node in nodes:
-                    info = [func, " uses tx.origin for authorization: ", node, "\n"]
+                    info: DETECTOR_INFO = [func, " uses tx.origin for authorization: ", node, "\n"]
                     res = self.generate_result(info)
                     results.append(res)
 
         return results
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/statements/type_based_tautology.py` & `slither-analyzer-0.9.4/slither/detectors/statements/type_based_tautology.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,18 +13,17 @@
 from slither.utils.output import Output
 
 
 def typeRange(t: str) -> Tuple[int, int]:
     bits = int(t.split("int")[1])
     if t in Uint:
         return 0, (2**bits) - 1
-    if t in Int:
-        v = (2 ** (bits - 1)) - 1
-        return -v, v
-    return None
+    assert t in Int
+    v = (2 ** (bits - 1)) - 1
+    return -v, v
 
 
 def _detect_tautology_or_contradiction(low: int, high: int, cval: int, op: BinaryType) -> bool:
     """
     Return true if "[low high] op cval " is always true or always false
     :param low:
     :param high:
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/statements/unary.py` & `slither-analyzer-0.9.4/slither/detectors/statements/unary.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,36 +1,50 @@
 """
 Module detecting the incorrect use of unary expressions
 """
 from typing import List
 
 from slither.core.expressions.assignment_operation import AssignmentOperation
+from slither.core.expressions.expression import Expression
 from slither.core.expressions.unary_operation import UnaryOperationType, UnaryOperation
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.utils.output import Output
 from slither.visitors.expression.expression import ExpressionVisitor
 
-
+# pylint: disable=too-few-public-methods
 class InvalidUnaryExpressionDetector(ExpressionVisitor):
+    def __init__(self, expression: Expression) -> None:
+        self.result: bool = False
+        super().__init__(expression)
+
     def _post_assignement_operation(self, expression: AssignmentOperation) -> None:
         if isinstance(expression.expression_right, UnaryOperation):
             if expression.expression_right.type == UnaryOperationType.PLUS_PRE:
                 # This is defined in ExpressionVisitor but pylint
                 # Seems to think its not
                 # pylint: disable=attribute-defined-outside-init
-                self._result = True
+                self.result = True
 
 
+# pylint: disable=too-few-public-methods
 class InvalidUnaryStateVariableDetector(ExpressionVisitor):
+    def __init__(self, expression: Expression) -> None:
+        self.result: bool = False
+        super().__init__(expression)
+
     def _post_unary_operation(self, expression: UnaryOperation) -> None:
         if expression.type == UnaryOperationType.PLUS_PRE:
             # This is defined in ExpressionVisitor but pylint
             # Seems to think its not
             # pylint: disable=attribute-defined-outside-init
-            self._result = True
+            self.result = True
 
 
 class IncorrectUnaryExpressionDetection(AbstractDetector):
     """
     Incorrect Unary Expression detector
     """
 
@@ -68,21 +82,24 @@
         Detect the incorrect use of unary expressions
         """
         results = []
         for c in self.contracts:
             for variable in c.state_variables:
                 if (
                     variable.expression
-                    and InvalidUnaryStateVariableDetector(variable.expression).result()
+                    and InvalidUnaryStateVariableDetector(variable.expression).result
                 ):
-                    info = [variable, f" uses an dangerous unary operator: {variable.expression}\n"]
+                    info: DETECTOR_INFO = [
+                        variable,
+                        f" uses an dangerous unary operator: {variable.expression}\n",
+                    ]
                     json = self.generate_result(info)
                     results.append(json)
 
             for f in c.functions_and_modifiers_declared:
                 for node in f.nodes:
-                    if node.expression and InvalidUnaryExpressionDetector(node.expression).result():
+                    if node.expression and InvalidUnaryExpressionDetector(node.expression).result:
                         info = [node.function, " uses an dangerous unary operator: ", node, "\n"]
                         res = self.generate_result(info)
                         results.append(res)
 
         return results
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/statements/write_after_write.py` & `slither-analyzer-0.9.4/slither/detectors/statements/write_after_write.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,14 +1,18 @@
 from typing import List, Set, Tuple, Dict
 
 from slither.core.cfg.node import Node, NodeType
 from slither.core.solidity_types import ElementaryType
 from slither.core.variables.state_variable import StateVariable
 from slither.core.variables.variable import Variable
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.slithir.operations import (
     OperationWithLValue,
     HighLevelCall,
     InternalDynamicCall,
     InternalCall,
     LowLevelCall,
     Operation,
@@ -29,14 +33,16 @@
     written: Dict[Variable, Node],
     ret: List[Tuple[Variable, Node, Node]],
 ) -> None:
     if isinstance(ir, (HighLevelCall, InternalDynamicCall, LowLevelCall)):
         _remove_states(written)
 
     if isinstance(ir, InternalCall):
+        if not ir.function:
+            return
         if ir.function.all_high_level_calls() or ir.function.all_library_calls():
             _remove_states(written)
 
         all_read = ir.function.all_state_variables_read()
         for read in all_read:
             if (
                 isinstance(read, Variable)
@@ -124,16 +130,23 @@
 
     def _detect(self) -> List[Output]:
         results = []
 
         for contract in self.compilation_unit.contracts_derived:
             for function in contract.functions:
                 if function.entry_point:
-                    ret = []
+                    ret: List[Tuple[Variable, Node, Node]] = []
                     _detect_write_after_write(function.entry_point, set(), {}, ret)
                     for var, node1, node2 in ret:
-                        info = [var, " is written in both\n\t", node1, "\n\t", node2, "\n"]
+                        info: DETECTOR_INFO = [
+                            var,
+                            " is written in both\n\t",
+                            node1,
+                            "\n\t",
+                            node2,
+                            "\n",
+                        ]
 
                         res = self.generate_result(info)
                         results.append(res)
 
         return results
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/variables/could_be_constant.py` & `slither-analyzer-0.9.4/slither/detectors/variables/could_be_constant.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/detectors/variables/could_be_immutable.py` & `slither-analyzer-0.9.4/slither/detectors/variables/could_be_immutable.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/detectors/variables/function_init_state_variables.py` & `slither-analyzer-0.9.4/slither/detectors/variables/function_init_state_variables.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,19 @@
 Module detecting state variables initializing from an immediate function call (prior to constructor run).
 """
 from typing import List
 
 from slither.core.declarations.contract import Contract
 from slither.core.declarations.function import Function
 from slither.core.variables.state_variable import StateVariable
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.utils.output import Output
 from slither.visitors.expression.export_values import ExportValues
 
 
 def detect_function_init_state_vars(contract: Contract) -> List[StateVariable]:
     """
     Detect any state variables that are initialized from an immediate function call (prior to constructor run).
@@ -100,15 +104,15 @@
 
         """
         results = []
         for contract in self.contracts:
             state_variables = detect_function_init_state_vars(contract)
             if state_variables:
                 for state_variable in state_variables:
-                    info = [
+                    info: DETECTOR_INFO = [
                         state_variable,
                         " is set pre-construction with a non-constant function or state variable:\n",
                     ]
                     info += [f"\t- {state_variable.expression}\n"]
                     json = self.generate_result(info)
                     results.append(json)
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/variables/predeclaration_usage_local.py` & `slither-analyzer-0.9.4/slither/detectors/variables/predeclaration_usage_local.py`

 * *Files 2% similar despite different names*

```diff
@@ -7,14 +7,15 @@
 from slither.core.declarations import Function
 from slither.core.declarations.contract import Contract
 from slither.core.variables.local_variable import LocalVariable
 from slither.detectors.abstract_detector import (
     AbstractDetector,
     DetectorClassification,
     ALL_SOLC_VERSIONS_04,
+    DETECTOR_INFO,
 )
 from slither.utils.output import Output
 
 
 class PredeclarationUsageLocal(AbstractDetector):
     """
     Pre-declaration usage of local variable
@@ -150,15 +151,15 @@
             predeclared_usages = self.detect_predeclared_in_contract(contract)
             if predeclared_usages:
                 for (predeclared_usage_function, predeclared_usage_nodes) in predeclared_usages:
                     for (
                         predeclared_usage_node,
                         predeclared_usage_local_variable,
                     ) in predeclared_usage_nodes:
-                        info = [
+                        info: DETECTOR_INFO = [
                             "Variable '",
                             predeclared_usage_local_variable,
                             "' in ",
                             predeclared_usage_function,
                             " potentially used before declaration: ",
                             predeclared_usage_node,
                             "\n",
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/variables/similar_variables.py` & `slither-analyzer-0.9.4/slither/detectors/variables/similar_variables.py`

 * *Files 14% similar despite different names*

```diff
@@ -3,15 +3,19 @@
 Do not check contract inheritance
 """
 import difflib
 from typing import List, Set, Tuple
 
 from slither.core.declarations.contract import Contract
 from slither.core.variables.local_variable import LocalVariable
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.utils.output import Output
 
 
 class SimilarVarsDetection(AbstractDetector):
     """
     Variable similar detector
     """
@@ -39,17 +43,15 @@
         See: https://docs.python.org/2/library/difflib.html
         Args:
             seq1 (str): first name
             seq2 (str): second name
         Returns:
             bool: true if names are similar
         """
-        if len(seq1) != len(seq2):
-            return False
-        val = difflib.SequenceMatcher(a=seq1.lower(), b=seq2.lower()).ratio()
+        val = difflib.SequenceMatcher(a=seq1, b=seq2).ratio()
         ret = val > 0.90
         return ret
 
     @staticmethod
     def detect_sim(contract: Contract) -> Set[Tuple[LocalVariable, LocalVariable]]:
         """Detect variables with similar name
 
@@ -57,36 +59,48 @@
             bool: true if variables have similar name
         """
         all_var = [x.variables for x in contract.functions]
         all_var = [x for l in all_var for x in l]
 
         contract_var = contract.variables
 
-        all_var = set(all_var + contract_var)
+        all_var = list(set(all_var + contract_var))
 
-        ret = []
-        for v1 in all_var:
-            for v2 in all_var:
-                if v1.name.lower() != v2.name.lower():
-                    if SimilarVarsDetection.similar(v1.name, v2.name):
-                        if (v2, v1) not in ret:
-                            ret.append((v1, v2))
+        ret = set()
+        # pylint: disable=consider-using-enumerate
+        for i in range(len(all_var)):
+            v1 = all_var[i]
+            _v1_name_lower = v1.name.lower()
+            for j in range(i, len(all_var)):
+                v2 = all_var[j]
+                if len(v1.name) != len(v2.name):
+                    continue
+                _v2_name_lower = v2.name.lower()
+                if _v1_name_lower != _v2_name_lower:
+                    if SimilarVarsDetection.similar(_v1_name_lower, _v2_name_lower):
+                        ret.add((v1, v2))
 
-        return set(ret)
+        return ret
 
     def _detect(self) -> List[Output]:
         """Detect similar variables name
 
         Returns:
             list: {'vuln', 'filename,'contract','vars'}
         """
         results = []
         for c in self.contracts:
             allVars = self.detect_sim(c)
             if allVars:
                 for (v1, v2) in sorted(allVars, key=lambda x: (x[0].name, x[1].name)):
                     v_left = v1 if v1.name < v2.name else v2
                     v_right = v2 if v_left == v1 else v1
-                    info = ["Variable ", v_left, " is too similar to ", v_right, "\n"]
+                    info: DETECTOR_INFO = [
+                        "Variable ",
+                        v_left,
+                        " is too similar to ",
+                        v_right,
+                        "\n",
+                    ]
                     json = self.generate_result(info)
                     results.append(json)
         return results
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/variables/unchanged_state_variables.py` & `slither-analyzer-0.9.4/slither/detectors/variables/unchanged_state_variables.py`

 * *Files 2% similar despite different names*

```diff
@@ -83,14 +83,16 @@
     def constant_candidates(self) -> List[StateVariable]:
         """Return the constant candidates"""
         return self._constant_candidates
 
     def detect(self) -> None:
         """Detect state variables that could be constant or immutable"""
         for c in self.compilation_unit.contracts_derived:
+            if c.is_signature_only():
+                continue
             variables = []
             functions = []
 
             variables.append(c.state_variables)
             functions.append(c.all_functions_called)
 
             valid_candidates: Set[StateVariable] = {
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/variables/uninitialized_local_variables.py` & `slither-analyzer-0.9.4/slither/detectors/variables/uninitialized_local_variables.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,15 @@
     Module detecting uninitialized local variables
 
     Recursively explore the CFG to only report uninitialized local variables that are
     read before being written
 """
 from typing import List
 
-from slither.core.cfg.node import Node
+from slither.core.cfg.node import Node, NodeType
 from slither.core.declarations.function_contract import FunctionContract
 from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
 from slither.utils.output import Output
 
 
 class UninitializedLocalVars(AbstractDetector):
 
@@ -60,14 +60,23 @@
             if all(f_c in self.visited_all_paths[node] for f_c in fathers_context):
                 return
         else:
             self.visited_all_paths[node] = []
 
         self.visited_all_paths[node] = list(set(self.visited_all_paths[node] + fathers_context))
 
+        # Remove a local variable declared in a for loop header
+        if (
+            node.type == NodeType.VARIABLE
+            and len(node.sons) == 1  # Should always be true for a node that has a STARTLOOP son
+            and node.sons[0].type == NodeType.STARTLOOP
+        ):
+            if node.variable_declaration in fathers_context:
+                fathers_context.remove(node.variable_declaration)
+
         if self.key in node.context:
             fathers_context += node.context[self.key]
 
         variables_read = node.variables_read
         for uninitialized_local_variable in fathers_context:
             if uninitialized_local_variable in variables_read:
                 self.results.append((function, uninitialized_local_variable))
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/variables/uninitialized_state_variables.py` & `slither-analyzer-0.9.4/slither/detectors/variables/uninitialized_state_variables.py`

 * *Files 1% similar despite different names*

```diff
@@ -10,15 +10,19 @@
 """
 from typing import List, Tuple
 
 from slither.core.declarations import Function
 from slither.core.declarations.contract import Contract
 from slither.core.variables import Variable
 from slither.core.variables.state_variable import StateVariable
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.slithir.operations import InternalCall, LibraryCall
 from slither.slithir.variables import ReferenceVariable
 from slither.utils.output import Output
 
 
 class UninitializedStateVarsDetection(AbstractDetector):
     """
@@ -136,15 +140,15 @@
             dict: [contract name] = set(state variable uninitialized)
         """
         results = []
         for c in self.compilation_unit.contracts_derived:
             ret = self._detect_uninitialized(c)
             for variable, functions in ret:
 
-                info = [variable, " is never initialized. It is used in:\n"]
+                info: DETECTOR_INFO = [variable, " is never initialized. It is used in:\n"]
 
                 for f in functions:
                     info += ["\t- ", f, "\n"]
 
                 json = self.generate_result(info)
                 results.append(json)
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/variables/uninitialized_storage_variables.py` & `slither-analyzer-0.9.4/slither/detectors/variables/uninitialized_storage_variables.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/detectors/variables/unused_state_variables.py` & `slither-analyzer-0.9.4/slither/detectors/variables/unused_state_variables.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,35 +1,44 @@
 """
 Module detecting unused state variables
 """
-from typing import List, Optional
+from typing import List, Optional, Dict
 
 from slither.core.compilation_unit import SlitherCompilationUnit
+from slither.core.declarations import Function
 from slither.core.declarations.contract import Contract
 from slither.core.solidity_types import ArrayType
+from slither.core.variables import Variable
 from slither.core.variables.state_variable import StateVariable
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.formatters.variables.unused_state_variables import custom_format
 from slither.utils.output import Output
 from slither.visitors.expression.export_values import ExportValues
 
 
 def detect_unused(contract: Contract) -> Optional[List[StateVariable]]:
-    if contract.is_signature_only():
-        return None
     # Get all the variables read in all the functions and modifiers
 
-    all_functions = contract.all_functions_called + contract.modifiers
+    all_functions = [
+        f
+        for f in contract.all_functions_called + list(contract.modifiers)
+        if isinstance(f, Function)
+    ]
     variables_used = [x.state_variables_read for x in all_functions]
     variables_used += [
         x.state_variables_written for x in all_functions if not x.is_constructor_variables
     ]
 
-    array_candidates = [x.variables for x in all_functions]
-    array_candidates = [i for sl in array_candidates for i in sl] + contract.state_variables
+    array_candidates_ = [x.variables for x in all_functions]
+    array_candidates: List[Variable] = [i for sl in array_candidates_ for i in sl]
+    array_candidates += contract.state_variables
     array_candidates = [
         x.type.length for x in array_candidates if isinstance(x.type, ArrayType) and x.type.length
     ]
     array_candidates = [ExportValues(x).result() for x in array_candidates]
     array_candidates = [i for sl in array_candidates for i in sl]
     array_candidates = [v for v in array_candidates if isinstance(v, StateVariable)]
 
@@ -58,19 +67,21 @@
     WIKI_EXPLOIT_SCENARIO = ""
     WIKI_RECOMMENDATION = "Remove unused state variables."
 
     def _detect(self) -> List[Output]:
         """Detect unused state variables"""
         results = []
         for c in self.compilation_unit.contracts_derived:
+            if c.is_signature_only():
+                continue
             unusedVars = detect_unused(c)
             if unusedVars:
                 for var in unusedVars:
-                    info = [var, " is never used in ", c, "\n"]
+                    info: DETECTOR_INFO = [var, " is never used in ", c, "\n"]
                     json = self.generate_result(info)
                     results.append(json)
 
         return results
 
     @staticmethod
-    def _format(compilation_unit: SlitherCompilationUnit, result):
+    def _format(compilation_unit: SlitherCompilationUnit, result: Dict) -> None:
         custom_format(compilation_unit, result)
```

### Comparing `slither-analyzer-0.9.3/slither/detectors/variables/var_read_using_this.py` & `slither-analyzer-0.9.4/slither/detectors/variables/var_read_using_this.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,23 +1,27 @@
 from typing import List
 
 from slither.core.cfg.node import Node
 from slither.core.declarations import Function, SolidityVariable
-from slither.detectors.abstract_detector import AbstractDetector, DetectorClassification
+from slither.detectors.abstract_detector import (
+    AbstractDetector,
+    DetectorClassification,
+    DETECTOR_INFO,
+)
 from slither.slithir.operations.high_level_call import HighLevelCall
 from slither.utils.output import Output
 
 
 class VarReadUsingThis(AbstractDetector):
     ARGUMENT = "var-read-using-this"
     HELP = "Contract reads its own variable using `this`"
     IMPACT = DetectorClassification.OPTIMIZATION
     CONFIDENCE = DetectorClassification.HIGH
 
-    WIKI = "https://github.com/crytic/slither/wiki/Vulnerabilities-Description#public-variable-read-in-external-context"
+    WIKI = "https://github.com/crytic/slither/wiki/Detector-Documentation#public-variable-read-in-external-context"
 
     WIKI_TITLE = "Public variable read in external context"
     WIKI_DESCRIPTION = "The contract reads its own variable using `this`, adding overhead of an unnecessary STATICCALL."
     WIKI_EXPLOIT_SCENARIO = """
 ```solidity
 contract C {
     mapping(uint => address) public myMap;
@@ -31,15 +35,15 @@
     WIKI_RECOMMENDATION = "Read the variable directly from storage instead of calling the contract."
 
     def _detect(self) -> List[Output]:
         results = []
         for c in self.contracts:
             for func in c.functions:
                 for node in self._detect_var_read_using_this(func):
-                    info = [
+                    info: DETECTOR_INFO = [
                         "The function ",
                         func,
                         " reads ",
                         node,
                         " with `this` which adds an extra STATICCALL.\n",
                     ]
                     json = self.generate_result(info)
```

### Comparing `slither-analyzer-0.9.3/slither/formatters/attributes/const_functions.py` & `slither-analyzer-0.9.4/slither/formatters/attributes/const_functions.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,15 +1,16 @@
 import re
+from typing import Dict
 
 from slither.core.compilation_unit import SlitherCompilationUnit
 from slither.formatters.exceptions import FormatError
 from slither.formatters.utils.patches import create_patch
 
 
-def custom_format(compilation_unit: SlitherCompilationUnit, result):
+def custom_format(compilation_unit: SlitherCompilationUnit, result: Dict) -> None:
     for file_scope in compilation_unit.scopes.values():
         elements = result["elements"]
         for element in elements:
             if element["type"] != "function":
                 # Skip variable elements
                 continue
             target_contract = file_scope.get_contract_from_name(
@@ -29,16 +30,20 @@
                             + function.parameters_src().source_mapping.length
                         ),
                         int(function.returns_src().source_mapping.start),
                     )
 
 
 def _patch(
-    compilation_unit: SlitherCompilationUnit, result, in_file, modify_loc_start, modify_loc_end
-):
+    compilation_unit: SlitherCompilationUnit,
+    result: Dict,
+    in_file: str,
+    modify_loc_start: int,
+    modify_loc_end: int,
+) -> None:
     in_file_str = compilation_unit.core.source_code[in_file].encode("utf8")
     old_str_of_interest = in_file_str[modify_loc_start:modify_loc_end]
     # Find the keywords view|pure|constant and remove them
     m = re.search("(view|pure|constant)", old_str_of_interest.decode("utf-8"))
     if m:
         create_patch(
             result,
```

### Comparing `slither-analyzer-0.9.3/slither/formatters/attributes/constant_pragma.py` & `slither-analyzer-0.9.4/slither/formatters/attributes/constant_pragma.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,8 +1,11 @@
 import re
+from typing import Dict, List, Union
+
+from slither.core.compilation_unit import SlitherCompilationUnit
 from slither.formatters.exceptions import FormatImpossible
 from slither.formatters.utils.patches import create_patch
 
 # Indicates the recommended versions for replacement
 REPLACEMENT_VERSIONS = ["^0.4.25", "^0.5.3"]
 
 # pylint: disable=anomalous-backslash-in-string
@@ -12,41 +15,41 @@
 # 1: ' ' (optional)
 # 2: version number
 # 3: version number
 # 4: version number
 PATTERN = re.compile(r"(\^|>|>=|<|<=)?([ ]+)?(\d+)\.(\d+)\.(\d+)")
 
 
-def custom_format(slither, result):
+def custom_format(slither: SlitherCompilationUnit, result: Dict) -> None:
     elements = result["elements"]
-    versions_used = []
+    versions_used: List[str] = []
     for element in elements:
         versions_used.append("".join(element["type_specific_fields"]["directive"][1:]))
     solc_version_replace = _analyse_versions(versions_used)
     for element in elements:
         _patch(
             slither,
             result,
             element["source_mapping"]["filename_absolute"],
             solc_version_replace,
             element["source_mapping"]["start"],
             element["source_mapping"]["start"] + element["source_mapping"]["length"],
         )
 
 
-def _analyse_versions(used_solc_versions):
+def _analyse_versions(used_solc_versions: List[str]) -> str:
     replace_solc_versions = []
     for version in used_solc_versions:
         replace_solc_versions.append(_determine_solc_version_replacement(version))
     if not all(version == replace_solc_versions[0] for version in replace_solc_versions):
         raise FormatImpossible("Multiple incompatible versions!")
     return replace_solc_versions[0]
 
 
-def _determine_solc_version_replacement(used_solc_version):
+def _determine_solc_version_replacement(used_solc_version: str) -> str:
     versions = PATTERN.findall(used_solc_version)
     if len(versions) == 1:
         version = versions[0]
         minor_version = ".".join(version[2:])[2]
         if minor_version == "4":
             return "pragma solidity " + REPLACEMENT_VERSIONS[0] + ";"
         if minor_version == "5":
@@ -60,18 +63,24 @@
             return "pragma solidity " + REPLACEMENT_VERSIONS[0] + ";"
         if minor_version_right in ["5", "6"]:
             # Replace with 0.5.3
             return "pragma solidity " + REPLACEMENT_VERSIONS[1] + ";"
     raise FormatImpossible("Unknown version!")
 
 
+# pylint: disable=too-many-arguments
 def _patch(
-    slither, result, in_file, pragma, modify_loc_start, modify_loc_end
-):  # pylint: disable=too-many-arguments
-    in_file_str = slither.source_code[in_file].encode("utf8")
+    slither: SlitherCompilationUnit,
+    result: Dict,
+    in_file: str,
+    pragma: Union[str, bytes],
+    modify_loc_start: int,
+    modify_loc_end: int,
+) -> None:
+    in_file_str = slither.core.source_code[in_file].encode("utf8")
     old_str_of_interest = in_file_str[modify_loc_start:modify_loc_end]
     create_patch(
         result,
         in_file,
         int(modify_loc_start),
         int(modify_loc_end),
         old_str_of_interest,
```

### Comparing `slither-analyzer-0.9.3/slither/formatters/attributes/incorrect_solc.py` & `slither-analyzer-0.9.4/slither/formatters/attributes/incorrect_solc.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/formatters/functions/external_function.py` & `slither-analyzer-0.9.4/slither/formatters/functions/external_function.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/formatters/naming_convention/naming_convention.py` & `slither-analyzer-0.9.4/slither/formatters/naming_convention/naming_convention.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 import re
 import logging
 
-from typing import List
+from typing import List, Set, Dict, Union, Optional, Callable, Type, Sequence
 
 from slither.core.compilation_unit import SlitherCompilationUnit
+from slither.core.variables import Variable
 from slither.slithir.operations import (
     Send,
     Transfer,
     OperationWithLValue,
     HighLevelCall,
     LowLevelCall,
     InternalCall,
     InternalDynamicCall,
     Operation,
 )
-from slither.core.declarations import Modifier
+from slither.core.declarations import Modifier, Event
 from slither.core.solidity_types import UserDefinedType, MappingType
 from slither.core.declarations import Enum, Contract, Structure, Function
 from slither.core.solidity_types.elementary_type import ElementaryTypeName
 from slither.core.variables.local_variable import LocalVariable
 from slither.formatters.exceptions import FormatError, FormatImpossible
 from slither.formatters.utils.patches import create_patch
 
 logging.basicConfig(level=logging.INFO)
 logger = logging.getLogger("Slither.Format")
 
 
 # pylint: disable=anomalous-backslash-in-string
 
 
-def custom_format(compilation_unit: SlitherCompilationUnit, result):
+def custom_format(compilation_unit: SlitherCompilationUnit, result: Dict) -> None:
     elements = result["elements"]
     for element in elements:
         target = element["additional_fields"]["target"]
 
         convention = element["additional_fields"]["convention"]
 
         if convention == "l_O_I_should_not_be_used":
@@ -125,32 +126,32 @@
     "else",
     "type",
 ]
 
 SOLIDITY_KEYWORDS += ElementaryTypeName
 
 
-def _name_already_use(slither, name):
+def _name_already_use(slither: SlitherCompilationUnit, name: str) -> bool:
     # Do not convert to a name used somewhere else
     if not KEY in slither.context:
-        all_names = set()
+        all_names: Set[str] = set()
         for contract in slither.contracts_derived:
             all_names = all_names.union({st.name for st in contract.structures})
             all_names = all_names.union({f.name for f in contract.functions_and_modifiers})
             all_names = all_names.union({e.name for e in contract.enums})
-            all_names = all_names.union({s.name for s in contract.state_variables})
+            all_names = all_names.union({s.name for s in contract.state_variables if s.name})
 
             for function in contract.functions:
-                all_names = all_names.union({v.name for v in function.variables})
+                all_names = all_names.union({v.name for v in function.variables if v.name})
 
         slither.context[KEY] = all_names
     return name in slither.context[KEY]
 
 
-def _convert_CapWords(original_name, slither):
+def _convert_CapWords(original_name: str, slither: SlitherCompilationUnit) -> str:
     name = original_name.capitalize()
 
     while "_" in name:
         offset = name.find("_")
         if len(name) > offset:
             name = name[0:offset] + name[offset + 1].upper() + name[offset + 1 :]
 
@@ -158,73 +159,87 @@
         raise FormatImpossible(f"{original_name} cannot be converted to {name} (already used)")
 
     if name in SOLIDITY_KEYWORDS:
         raise FormatImpossible(f"{original_name} cannot be converted to {name} (Solidity keyword)")
     return name
 
 
-def _convert_mixedCase(original_name, compilation_unit: SlitherCompilationUnit):
-    name = original_name
-    if isinstance(name, bytes):
-        name = name.decode("utf8")
+def _convert_mixedCase(
+    original_name: Union[str, bytes], compilation_unit: SlitherCompilationUnit
+) -> str:
+    if isinstance(original_name, bytes):
+        name = original_name.decode("utf8")
+    else:
+        name = original_name
 
     while "_" in name:
         offset = name.find("_")
         if len(name) > offset:
             name = name[0:offset] + name[offset + 1].upper() + name[offset + 2 :]
 
     name = name[0].lower() + name[1:]
     if _name_already_use(compilation_unit, name):
-        raise FormatImpossible(f"{original_name} cannot be converted to {name} (already used)")
+        raise FormatImpossible(f"{original_name} cannot be converted to {name} (already used)")  # type: ignore
     if name in SOLIDITY_KEYWORDS:
-        raise FormatImpossible(f"{original_name} cannot be converted to {name} (Solidity keyword)")
+        raise FormatImpossible(f"{original_name} cannot be converted to {name} (Solidity keyword)")  # type: ignore
     return name
 
 
-def _convert_UPPER_CASE_WITH_UNDERSCORES(name, compilation_unit: SlitherCompilationUnit):
+def _convert_UPPER_CASE_WITH_UNDERSCORES(
+    name: str, compilation_unit: SlitherCompilationUnit
+) -> str:
     if _name_already_use(compilation_unit, name.upper()):
         raise FormatImpossible(f"{name} cannot be converted to {name.upper()} (already used)")
     if name.upper() in SOLIDITY_KEYWORDS:
         raise FormatImpossible(f"{name} cannot be converted to {name.upper()} (Solidity keyword)")
     return name.upper()
 
 
-conventions = {
+TARGET_TYPE = Union[Contract, Variable, Function]
+CONVENTION_F_TYPE = Callable[[str, SlitherCompilationUnit], str]
+
+conventions: Dict[str, CONVENTION_F_TYPE] = {
     "CapWords": _convert_CapWords,
     "mixedCase": _convert_mixedCase,
     "UPPER_CASE_WITH_UNDERSCORES": _convert_UPPER_CASE_WITH_UNDERSCORES,
 }
 
 
 # endregion
 ###################################################################################
 ###################################################################################
 # region Helpers
 ###################################################################################
 ###################################################################################
 
 
-def _get_from_contract(compilation_unit: SlitherCompilationUnit, element, name, getter):
+def _get_from_contract(
+    compilation_unit: SlitherCompilationUnit, element: Dict, name: str, getter: str
+) -> TARGET_TYPE:
     scope = compilation_unit.get_scope(element["source_mapping"]["filename_absolute"])
     contract_name = element["type_specific_fields"]["parent"]["name"]
     contract = scope.get_contract_from_name(contract_name)
     return getattr(contract, getter)(name)
 
 
 # endregion
 ###################################################################################
 ###################################################################################
 # region Patch dispatcher
 ###################################################################################
 ###################################################################################
 
 
-def _patch(compilation_unit: SlitherCompilationUnit, result, element, _target):
+def _patch(
+    compilation_unit: SlitherCompilationUnit, result: Dict, element: Dict, _target: str
+) -> None:
     scope = compilation_unit.get_scope(element["source_mapping"]["filename_absolute"])
 
+    target: Optional[TARGET_TYPE] = None
+
     if _target == "contract":
         target = scope.get_contract_from_name(element["name"])
 
     elif _target == "structure":
         target = _get_from_contract(
             compilation_unit, element, element["name"], "get_structure_from_name"
         )
@@ -253,29 +268,33 @@
             "name"
         ]
         function_sig = element["type_specific_fields"]["parent"]["type_specific_fields"][
             "signature"
         ]
         param_name = element["name"]
         contract = scope.get_contract_from_name(contract_name)
+        assert contract
         function = contract.get_function_from_full_name(function_sig)
+        assert function
         target = function.get_local_variable_from_name(param_name)
 
     elif _target in ["variable", "variable_constant"]:
         # Local variable
         if element["type_specific_fields"]["parent"] == "function":
             contract_name = element["type_specific_fields"]["parent"]["type_specific_fields"][
                 "parent"
             ]["name"]
             function_sig = element["type_specific_fields"]["parent"]["type_specific_fields"][
                 "signature"
             ]
             var_name = element["name"]
             contract = scope.get_contract_from_name(contract_name)
+            assert contract
             function = contract.get_function_from_full_name(function_sig)
+            assert function
             target = function.get_local_variable_from_name(var_name)
         # State variable
         else:
             target = _get_from_contract(
                 compilation_unit, element, element["name"], "get_state_variable_from_name"
             )
 
@@ -283,14 +302,15 @@
         target = _get_from_contract(
             compilation_unit, element, element["name"], "get_enum_from_canonical_name"
         )
 
     else:
         raise FormatError("Unknown naming convention! " + _target)
 
+    assert target
     _explore(
         compilation_unit, result, target, conventions[element["additional_fields"]["convention"]]
     )
 
 
 # endregion
 ###################################################################################
@@ -306,29 +326,36 @@
 RE_MAPPING_FROM = rb"([a-zA-Z0-9\._\[\]]*)"
 RE_MAPPING_TO = rb"([\=\>\(\) a-zA-Z0-9\._\[\]\   ]*)"
 RE_MAPPING = (
     rb"[ ]*mapping[ ]*\([ ]*" + RE_MAPPING_FROM + b"[ ]*" + b"=>" + b"[ ]*" + RE_MAPPING_TO + rb"\)"
 )
 
 
-def _is_var_declaration(slither, filename, start):
+def _is_var_declaration(slither: SlitherCompilationUnit, filename: str, start: int) -> bool:
     """
     Detect usage of 'var ' for Solidity < 0.5
     :param slither:
     :param filename:
     :param start:
     :return:
     """
     v = "var "
-    return slither.source_code[filename][start : start + len(v)] == v
+    return slither.core.source_code[filename][start : start + len(v)] == v
 
 
 def _explore_type(  # pylint: disable=too-many-arguments,too-many-locals,too-many-branches
-    slither, result, target, convert, custom_type, filename_source_code, start, end
-):
+    slither: SlitherCompilationUnit,
+    result: Dict,
+    target: TARGET_TYPE,
+    convert: CONVENTION_F_TYPE,
+    custom_type: Optional[Union[Type, List[Type]]],
+    filename_source_code: str,
+    start: int,
+    end: int,
+) -> None:
     if isinstance(custom_type, UserDefinedType):
         # Patch type based on contract/enum
         if isinstance(custom_type.type, (Enum, Contract)):
             if custom_type.type == target:
                 old_str = custom_type.type.name
                 new_str = convert(old_str, slither)
 
@@ -354,15 +381,15 @@
                     loc_end = loc_start + len(old_str)
 
                 create_patch(result, filename_source_code, loc_start, loc_end, old_str, new_str)
 
             # Structure contain a list of elements, that might need patching
             # .elems return a list of VariableStructure
             _explore_variables_declaration(
-                slither, custom_type.type.elems.values(), result, target, convert
+                slither, list(custom_type.type.elems.values()), result, target, convert
             )
 
     if isinstance(custom_type, MappingType):
         # Mapping has three steps:
         # Convert the "from" type
         # Convert the "to" type
         # Convert nested type in the "to"
@@ -373,15 +400,15 @@
         if isinstance(custom_type.type_to, (UserDefinedType, MappingType)) or target in [
             custom_type.type_from,
             custom_type.type_to,
         ]:
 
             full_txt_start = start
             full_txt_end = end
-            full_txt = slither.source_code[filename_source_code].encode("utf8")[
+            full_txt = slither.core.source_code[filename_source_code].encode("utf8")[
                 full_txt_start:full_txt_end
             ]
             re_match = re.match(RE_MAPPING, full_txt)
             assert re_match
 
             if custom_type.type_from == target:
                 old_str = custom_type.type_from.name
@@ -413,22 +440,27 @@
                     filename_source_code,
                     loc_start,
                     loc_end,
                 )
 
 
 def _explore_variables_declaration(  # pylint: disable=too-many-arguments,too-many-locals,too-many-nested-blocks
-    slither, variables, result, target, convert, patch_comment=False
-):
+    slither: SlitherCompilationUnit,
+    variables: Sequence[Variable],
+    result: Dict,
+    target: TARGET_TYPE,
+    convert: CONVENTION_F_TYPE,
+    patch_comment: bool = False,
+) -> None:
     for variable in variables:
         # First explore the type of the variable
         filename_source_code = variable.source_mapping.filename.absolute
         full_txt_start = variable.source_mapping.start
         full_txt_end = full_txt_start + variable.source_mapping.length
-        full_txt = slither.source_code[filename_source_code].encode("utf8")[
+        full_txt = slither.core.source_code[filename_source_code].encode("utf8")[
             full_txt_start:full_txt_end
         ]
 
         _explore_type(
             slither,
             result,
             target,
@@ -438,14 +470,16 @@
             full_txt_start,
             variable.source_mapping.start + variable.source_mapping.length,
         )
 
         # If the variable is the target
         if variable == target:
             old_str = variable.name
+            if old_str is None:
+                old_str = ""
             new_str = convert(old_str, slither)
 
             loc_start = full_txt_start + full_txt.find(old_str.encode("utf8"))
             loc_end = loc_start + len(old_str)
 
             create_patch(result, filename_source_code, loc_start, loc_end, old_str, new_str)
 
@@ -454,18 +488,18 @@
                 if variable.source_mapping.lines:
                     func = variable.function
                     end_line = func.source_mapping.lines[0]
                     if variable in func.parameters:
                         idx = len(func.parameters) - func.parameters.index(variable) + 1
                         first_line = end_line - idx - 2
 
-                        potential_comments = slither.source_code[filename_source_code].encode(
+                        potential_comments_ = slither.core.source_code[filename_source_code].encode(
                             "utf8"
                         )
-                        potential_comments = potential_comments.splitlines(keepends=True)[
+                        potential_comments = potential_comments_.splitlines(keepends=True)[
                             first_line : end_line - 1
                         ]
 
                         idx_beginning = func.source_mapping.start
                         idx_beginning += -func.source_mapping.starting_column + 1
                         idx_beginning += -sum([len(c) for c in potential_comments])
 
@@ -487,41 +521,53 @@
                                     new_comment,
                                 )
 
                                 break
                             idx_beginning += len(line)
 
 
-def _explore_structures_declaration(slither, structures, result, target, convert):
+def _explore_structures_declaration(
+    slither: SlitherCompilationUnit,
+    structures: Sequence[Structure],
+    result: Dict,
+    target: TARGET_TYPE,
+    convert: CONVENTION_F_TYPE,
+) -> None:
     for st in structures:
         # Explore the variable declared within the structure (VariableStructure)
-        _explore_variables_declaration(slither, st.elems.values(), result, target, convert)
+        _explore_variables_declaration(slither, list(st.elems.values()), result, target, convert)
 
         # If the structure is the target
         if st == target:
             old_str = st.name
             new_str = convert(old_str, slither)
 
             filename_source_code = st.source_mapping.filename.absolute
             full_txt_start = st.source_mapping.start
             full_txt_end = full_txt_start + st.source_mapping.length
-            full_txt = slither.source_code[filename_source_code].encode("utf8")[
+            full_txt = slither.core.source_code[filename_source_code].encode("utf8")[
                 full_txt_start:full_txt_end
             ]
 
             # The name is after the space
             matches = re.finditer(b"struct[ ]*", full_txt)
             # Look for the end offset of the largest list of ' '
             loc_start = full_txt_start + max(matches, key=lambda x: len(x.group())).end()
             loc_end = loc_start + len(old_str)
 
             create_patch(result, filename_source_code, loc_start, loc_end, old_str, new_str)
 
 
-def _explore_events_declaration(slither, events, result, target, convert):
+def _explore_events_declaration(
+    slither: SlitherCompilationUnit,
+    events: Sequence[Event],
+    result: Dict,
+    target: TARGET_TYPE,
+    convert: CONVENTION_F_TYPE,
+) -> None:
     for event in events:
         # Explore the parameters
         _explore_variables_declaration(slither, event.elems, result, target, convert)
 
         # If the event is the target
         if event == target:
             filename_source_code = event.source_mapping.filename.absolute
@@ -531,15 +577,15 @@
 
             loc_start = event.source_mapping.start
             loc_end = loc_start + len(old_str)
 
             create_patch(result, filename_source_code, loc_start, loc_end, old_str, new_str)
 
 
-def get_ir_variables(ir):
+def get_ir_variables(ir: Operation) -> List[Union[Variable, Function]]:
     all_vars = ir.read
 
     if isinstance(ir, (InternalCall, InternalDynamicCall, HighLevelCall)):
         all_vars += [ir.function]
 
     if isinstance(ir, (HighLevelCall, Send, LowLevelCall, Transfer)):
         all_vars += [ir.call_value]
@@ -549,30 +595,36 @@
 
     if isinstance(ir, OperationWithLValue):
         all_vars += [ir.lvalue]
 
     return [v for v in all_vars if v]
 
 
-def _explore_irs(slither, irs: List[Operation], result, target, convert):
+def _explore_irs(
+    slither: SlitherCompilationUnit,
+    irs: List[Operation],
+    result: Dict,
+    target: TARGET_TYPE,
+    convert: CONVENTION_F_TYPE,
+) -> None:
     # pylint: disable=too-many-locals
-    if irs is None:
+    if not irs:
         return
     for ir in irs:
         for v in get_ir_variables(ir):
             if target == v or (
                 isinstance(target, Function)
                 and isinstance(v, Function)
                 and v.canonical_name == target.canonical_name
             ):
                 source_mapping = ir.expression.source_mapping
                 filename_source_code = source_mapping.filename.absolute
                 full_txt_start = source_mapping.start
                 full_txt_end = full_txt_start + source_mapping.length
-                full_txt = slither.source_code[filename_source_code].encode("utf8")[
+                full_txt = slither.core.source_code[filename_source_code].encode("utf8")[
                     full_txt_start:full_txt_end
                 ]
 
                 if not target.name.encode("utf8") in full_txt:
                     raise FormatError(f"{target} not found in {full_txt} ({source_mapping}")
 
                 old_str = target.name.encode("utf8")
@@ -596,27 +648,33 @@
                         loc_start,
                         loc_end,
                         old_str,
                         new_str,
                     )
 
 
-def _explore_functions(slither, functions, result, target, convert):
+def _explore_functions(
+    slither: SlitherCompilationUnit,
+    functions: List[Function],
+    result: Dict,
+    target: TARGET_TYPE,
+    convert: CONVENTION_F_TYPE,
+) -> None:
     for function in functions:
         _explore_variables_declaration(slither, function.variables, result, target, convert, True)
         _explore_irs(slither, function.all_slithir_operations(), result, target, convert)
 
         if isinstance(target, Function) and function.canonical_name == target.canonical_name:
             old_str = function.name
             new_str = convert(old_str, slither)
 
             filename_source_code = function.source_mapping.filename.absolute
             full_txt_start = function.source_mapping.start
             full_txt_end = full_txt_start + function.source_mapping.length
-            full_txt = slither.source_code[filename_source_code].encode("utf8")[
+            full_txt = slither.core.source_code[filename_source_code].encode("utf8")[
                 full_txt_start:full_txt_end
             ]
 
             # The name is after the space
             if isinstance(target, Modifier):
                 matches = re.finditer(b"modifier([ ]*)", full_txt)
             else:
@@ -624,47 +682,59 @@
             # Look for the end offset of the largest list of ' '
             loc_start = full_txt_start + max(matches, key=lambda x: len(x.group())).end()
             loc_end = loc_start + len(old_str)
 
             create_patch(result, filename_source_code, loc_start, loc_end, old_str, new_str)
 
 
-def _explore_enums(slither, enums, result, target, convert):
+def _explore_enums(
+    slither: SlitherCompilationUnit,
+    enums: Sequence[Enum],
+    result: Dict,
+    target: TARGET_TYPE,
+    convert: CONVENTION_F_TYPE,
+) -> None:
     for enum in enums:
         if enum == target:
             old_str = enum.name
             new_str = convert(old_str, slither)
 
             filename_source_code = enum.source_mapping.filename.absolute
             full_txt_start = enum.source_mapping.start
             full_txt_end = full_txt_start + enum.source_mapping.length
-            full_txt = slither.source_code[filename_source_code].encode("utf8")[
+            full_txt = slither.core.source_code[filename_source_code].encode("utf8")[
                 full_txt_start:full_txt_end
             ]
 
             # The name is after the space
             matches = re.finditer(b"enum([ ]*)", full_txt)
             # Look for the end offset of the largest list of ' '
             loc_start = full_txt_start + max(matches, key=lambda x: len(x.group())).end()
             loc_end = loc_start + len(old_str)
 
             create_patch(result, filename_source_code, loc_start, loc_end, old_str, new_str)
 
 
-def _explore_contract(slither, contract, result, target, convert):
+def _explore_contract(
+    slither: SlitherCompilationUnit,
+    contract: Contract,
+    result: Dict,
+    target: TARGET_TYPE,
+    convert: CONVENTION_F_TYPE,
+) -> None:
     _explore_variables_declaration(slither, contract.state_variables, result, target, convert)
     _explore_structures_declaration(slither, contract.structures, result, target, convert)
     _explore_functions(slither, contract.functions_and_modifiers, result, target, convert)
     _explore_enums(slither, contract.enums, result, target, convert)
 
     if contract == target:
         filename_source_code = contract.source_mapping.filename.absolute
         full_txt_start = contract.source_mapping.start
         full_txt_end = full_txt_start + contract.source_mapping.length
-        full_txt = slither.source_code[filename_source_code].encode("utf8")[
+        full_txt = slither.core.source_code[filename_source_code].encode("utf8")[
             full_txt_start:full_txt_end
         ]
 
         old_str = contract.name
         new_str = convert(old_str, slither)
 
         # The name is after the space
@@ -673,13 +743,18 @@
         loc_start = full_txt_start + max(matches, key=lambda x: len(x.group())).end()
 
         loc_end = loc_start + len(old_str)
 
         create_patch(result, filename_source_code, loc_start, loc_end, old_str, new_str)
 
 
-def _explore(compilation_unit: SlitherCompilationUnit, result, target, convert):
+def _explore(
+    compilation_unit: SlitherCompilationUnit,
+    result: Dict,
+    target: TARGET_TYPE,
+    convert: CONVENTION_F_TYPE,
+) -> None:
     for contract in compilation_unit.contracts_derived:
         _explore_contract(compilation_unit, contract, result, target, convert)
 
 
 # endregion
```

### Comparing `slither-analyzer-0.9.3/slither/formatters/utils/patches.py` & `slither-analyzer-0.9.4/slither/formatters/utils/patches.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/formatters/variables/unchanged_state_variables.py` & `slither-analyzer-0.9.4/slither/formatters/variables/unchanged_state_variables.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/formatters/variables/unused_state_variables.py` & `slither-analyzer-0.9.4/slither/formatters/variables/unused_state_variables.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,24 +1,28 @@
+from typing import Dict
+
 from slither.core.compilation_unit import SlitherCompilationUnit
 from slither.formatters.utils.patches import create_patch
 
 
-def custom_format(compilation_unit: SlitherCompilationUnit, result):
+def custom_format(compilation_unit: SlitherCompilationUnit, result: Dict) -> None:
     elements = result["elements"]
     for element in elements:
         if element["type"] == "variable":
             _patch(
                 compilation_unit,
                 result,
                 element["source_mapping"]["filename_absolute"],
                 element["source_mapping"]["start"],
             )
 
 
-def _patch(compilation_unit: SlitherCompilationUnit, result, in_file, modify_loc_start):
+def _patch(
+    compilation_unit: SlitherCompilationUnit, result: Dict, in_file: str, modify_loc_start: int
+) -> None:
     in_file_str = compilation_unit.core.source_code[in_file].encode("utf8")
     old_str_of_interest = in_file_str[modify_loc_start:]
     old_str = (
         old_str_of_interest.decode("utf-8").partition(";")[0]
         + old_str_of_interest.decode("utf-8").partition(";")[1]
     )
```

### Comparing `slither-analyzer-0.9.3/slither/printers/abstract_printer.py` & `slither-analyzer-0.9.4/slither/printers/abstract_printer.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/printers/all_printers.py` & `slither-analyzer-0.9.4/slither/printers/all_printers.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,10 +1,11 @@
 # pylint: disable=unused-import,relative-beyond-top-level
 from .summary.function import FunctionSummary
 from .summary.contract import ContractSummary
+from .summary.loc import LocPrinter
 from .inheritance.inheritance import PrinterInheritance
 from .inheritance.inheritance_graph import PrinterInheritanceGraph
 from .call.call_graph import PrinterCallGraph
 from .functions.authorization import PrinterWrittenVariablesAndAuthorization
 from .summary.slithir import PrinterSlithIR
 from .summary.slithir_ssa import PrinterSlithIRSSA
 from .summary.human_summary import PrinterHumanSummary
```

### Comparing `slither-analyzer-0.9.3/slither/printers/call/call_graph.py` & `slither-analyzer-0.9.4/slither/printers/call/call_graph.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,58 +2,62 @@
     Module printing the call graph
 
     The call graph shows for each function,
     what are the contracts/functions called.
     The output is a dot file named filename.dot
 """
 from collections import defaultdict
-from slither.printers.abstract_printer import AbstractPrinter
-from slither.core.declarations.solidity_variables import SolidityFunction
+from typing import Optional, Union, Dict, Set, Tuple, Sequence
+
+from slither.core.declarations import Contract, FunctionContract
 from slither.core.declarations.function import Function
+from slither.core.declarations.solidity_variables import SolidityFunction
 from slither.core.variables.variable import Variable
+from slither.printers.abstract_printer import AbstractPrinter
+from slither.utils.output import Output
 
 
-def _contract_subgraph(contract):
+def _contract_subgraph(contract: Contract) -> str:
     return f"cluster_{contract.id}_{contract.name}"
 
 
 # return unique id for contract function to use as node name
-def _function_node(contract, function):
+def _function_node(contract: Contract, function: Union[Function, Variable]) -> str:
     return f"{contract.id}_{function.name}"
 
 
 # return unique id for solidity function to use as node name
-def _solidity_function_node(solidity_function):
+def _solidity_function_node(solidity_function: SolidityFunction) -> str:
     return f"{solidity_function.name}"
 
 
 # return dot language string to add graph edge
-def _edge(from_node, to_node):
+def _edge(from_node: str, to_node: str) -> str:
     return f'"{from_node}" -> "{to_node}"'
 
 
 # return dot language string to add graph node (with optional label)
-def _node(node, label=None):
+def _node(node: str, label: Optional[str] = None) -> str:
     return " ".join(
         (
             f'"{node}"',
             f'[label="{label}"]' if label is not None else "",
         )
     )
 
 
 # pylint: disable=too-many-arguments
 def _process_internal_call(
-    contract,
-    function,
-    internal_call,
-    contract_calls,
-    solidity_functions,
-    solidity_calls,
-):
+    contract: Contract,
+    function: Function,
+    internal_call: Union[Function, SolidityFunction],
+    contract_calls: Dict[Contract, Set[str]],
+    solidity_functions: Set[str],
+    solidity_calls: Set[str],
+) -> None:
     if isinstance(internal_call, (Function)):
         contract_calls[contract].add(
             _edge(
                 _function_node(contract, function),
                 _function_node(contract, internal_call),
             )
         )
@@ -65,54 +69,58 @@
             _edge(
                 _function_node(contract, function),
                 _solidity_function_node(internal_call),
             )
         )
 
 
-def _render_external_calls(external_calls):
+def _render_external_calls(external_calls: Set[str]) -> str:
     return "\n".join(external_calls)
 
 
-def _render_internal_calls(contract, contract_functions, contract_calls):
+def _render_internal_calls(
+    contract: Contract,
+    contract_functions: Dict[Contract, Set[str]],
+    contract_calls: Dict[Contract, Set[str]],
+) -> str:
     lines = []
 
     lines.append(f"subgraph {_contract_subgraph(contract)} {{")
     lines.append(f'label = "{contract.name}"')
 
     lines.extend(contract_functions[contract])
     lines.extend(contract_calls[contract])
 
     lines.append("}")
 
     return "\n".join(lines)
 
 
-def _render_solidity_calls(solidity_functions, solidity_calls):
+def _render_solidity_calls(solidity_functions: Set[str], solidity_calls: Set[str]) -> str:
     lines = []
 
     lines.append("subgraph cluster_solidity {")
     lines.append('label = "[Solidity]"')
 
     lines.extend(solidity_functions)
     lines.extend(solidity_calls)
 
     lines.append("}")
 
     return "\n".join(lines)
 
 
 def _process_external_call(
-    contract,
-    function,
-    external_call,
-    contract_functions,
-    external_calls,
-    all_contracts,
-):
+    contract: Contract,
+    function: Function,
+    external_call: Tuple[Contract, Union[Function, Variable]],
+    contract_functions: Dict[Contract, Set[str]],
+    external_calls: Set[str],
+    all_contracts: Set[Contract],
+) -> None:
     external_contract, external_function = external_call
 
     if not external_contract in all_contracts:
         return
 
     # add variable as node to respective contract
     if isinstance(external_function, (Variable)):
@@ -129,23 +137,23 @@
             _function_node(external_contract, external_function),
         )
     )
 
 
 # pylint: disable=too-many-arguments
 def _process_function(
-    contract,
-    function,
-    contract_functions,
-    contract_calls,
-    solidity_functions,
-    solidity_calls,
-    external_calls,
-    all_contracts,
-):
+    contract: Contract,
+    function: Function,
+    contract_functions: Dict[Contract, Set[str]],
+    contract_calls: Dict[Contract, Set[str]],
+    solidity_functions: Set[str],
+    solidity_calls: Set[str],
+    external_calls: Set[str],
+    all_contracts: Set[Contract],
+) -> None:
     contract_functions[contract].add(
         _node(_function_node(contract, function), function.name),
     )
 
     for internal_call in function.internal_calls:
         _process_internal_call(
             contract,
@@ -162,37 +170,43 @@
             external_call,
             contract_functions,
             external_calls,
             all_contracts,
         )
 
 
-def _process_functions(functions):
-    contract_functions = defaultdict(set)  # contract -> contract functions nodes
-    contract_calls = defaultdict(set)  # contract -> contract calls edges
-
-    solidity_functions = set()  # solidity function nodes
-    solidity_calls = set()  # solidity calls edges
-    external_calls = set()  # external calls edges
+def _process_functions(functions: Sequence[Function]) -> str:
+    # TODO  add support for top level function
+
+    contract_functions: Dict[Contract, Set[str]] = defaultdict(
+        set
+    )  # contract -> contract functions nodes
+    contract_calls: Dict[Contract, Set[str]] = defaultdict(set)  # contract -> contract calls edges
+
+    solidity_functions: Set[str] = set()  # solidity function nodes
+    solidity_calls: Set[str] = set()  # solidity calls edges
+    external_calls: Set[str] = set()  # external calls edges
 
     all_contracts = set()
 
     for function in functions:
-        all_contracts.add(function.contract_declarer)
+        if isinstance(function, FunctionContract):
+            all_contracts.add(function.contract_declarer)
     for function in functions:
-        _process_function(
-            function.contract_declarer,
-            function,
-            contract_functions,
-            contract_calls,
-            solidity_functions,
-            solidity_calls,
-            external_calls,
-            all_contracts,
-        )
+        if isinstance(function, FunctionContract):
+            _process_function(
+                function.contract_declarer,
+                function,
+                contract_functions,
+                contract_calls,
+                solidity_functions,
+                solidity_calls,
+                external_calls,
+                all_contracts,
+            )
 
     render_internal_calls = ""
     for contract in all_contracts:
         render_internal_calls += _render_internal_calls(
             contract, contract_functions, contract_calls
         )
 
@@ -205,15 +219,15 @@
 
 class PrinterCallGraph(AbstractPrinter):
     ARGUMENT = "call-graph"
     HELP = "Export the call-graph of the contracts to a dot file"
 
     WIKI = "https://github.com/trailofbits/slither/wiki/Printer-documentation#call-graph"
 
-    def output(self, filename):
+    def output(self, filename: str) -> Output:
         """
         Output the graph in filename
         Args:
             filename(string)
         """
 
         all_contracts_filename = ""
@@ -237,15 +251,17 @@
                 compilation_unit.functions for compilation_unit in self.slither.compilation_units
             ]
             all_functions = [item for sublist in all_functionss for item in sublist]
             all_functions_as_dict = {
                 function.canonical_name: function for function in all_functions
             }
             content = "\n".join(
-                ["strict digraph {"] + [_process_functions(all_functions_as_dict.values())] + ["}"]
+                ["strict digraph {"]
+                + [_process_functions(list(all_functions_as_dict.values()))]
+                + ["}"]
             )
             f.write(content)
             results.append((all_contracts_filename, content))
 
         for derived_contract in self.slither.contracts_derived:
             derived_output_filename = f"{filename}{derived_contract.name}.call-graph.dot"
             with open(derived_output_filename, "w", encoding="utf8") as f:
```

### Comparing `slither-analyzer-0.9.3/slither/printers/functions/authorization.py` & `slither-analyzer-0.9.4/slither/printers/functions/authorization.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,59 +1,65 @@
 """
     Module printing summary of the contract
 """
+from typing import List
 
 from slither.printers.abstract_printer import AbstractPrinter
 from slither.core.declarations.function import Function
 from slither.utils.myprettytable import MyPrettyTable
+from slither.utils.output import Output
 
 
 class PrinterWrittenVariablesAndAuthorization(AbstractPrinter):
 
     ARGUMENT = "vars-and-auth"
     HELP = "Print the state variables written and the authorization of the functions"
 
     WIKI = "https://github.com/trailofbits/slither/wiki/Printer-documentation#variables-written-and-authorization"
 
     @staticmethod
-    def get_msg_sender_checks(function):
-        all_functions = function.all_internal_calls() + [function] + function.modifiers
+    def get_msg_sender_checks(function: Function) -> List[str]:
+        all_functions = (
+            [f for f in function.all_internal_calls() if isinstance(f, Function)]
+            + [function]
+            + [m for m in function.modifiers if isinstance(m, Function)]
+        )
 
-        all_nodes = [f.nodes for f in all_functions if isinstance(f, Function)]
-        all_nodes = [item for sublist in all_nodes for item in sublist]
+        all_nodes_ = [f.nodes for f in all_functions]
+        all_nodes = [item for sublist in all_nodes_ for item in sublist]
 
         all_conditional_nodes = [
             n for n in all_nodes if n.contains_if() or n.contains_require_or_assert()
         ]
         all_conditional_nodes_on_msg_sender = [
             str(n.expression)
             for n in all_conditional_nodes
             if "msg.sender" in [v.name for v in n.solidity_variables_read]
         ]
         return all_conditional_nodes_on_msg_sender
 
-    def output(self, _filename):
+    def output(self, _filename: str) -> Output:
         """
         _filename is not used
         Args:
             _filename(string)
         """
 
         txt = ""
         all_tables = []
-        for contract in self.contracts:
-            if contract.is_top_level:
-                continue
+        for contract in self.contracts:  # type: ignore
             txt += f"\nContract {contract.name}\n"
             table = MyPrettyTable(
                 ["Function", "State variables written", "Conditions on msg.sender"]
             )
             for function in contract.functions:
 
-                state_variables_written = [v.name for v in function.all_state_variables_written()]
+                state_variables_written = [
+                    v.name for v in function.all_state_variables_written() if v.name
+                ]
                 msg_sender_condition = self.get_msg_sender_checks(function)
                 table.add_row(
                     [
                         function.name,
                         str(sorted(state_variables_written)),
                         str(sorted(msg_sender_condition)),
                     ]
```

### Comparing `slither-analyzer-0.9.3/slither/printers/functions/cfg.py` & `slither-analyzer-0.9.4/slither/printers/functions/cfg.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,30 +1,29 @@
 from slither.printers.abstract_printer import AbstractPrinter
+from slither.utils.output import Output
 
 
 class CFG(AbstractPrinter):
 
     ARGUMENT = "cfg"
     HELP = "Export the CFG of each functions"
 
     WIKI = "https://github.com/trailofbits/slither/wiki/Printer-documentation#cfg"
 
-    def output(self, filename):
+    def output(self, filename: str) -> Output:
         """
         _filename is not used
         Args:
             _filename(string)
         """
 
         info = ""
         all_files = []
-        for contract in self.contracts:
-            if contract.is_top_level:
-                continue
-            for function in contract.functions + contract.modifiers:
+        for contract in self.contracts:  # type: ignore
+            for function in contract.functions + list(contract.modifiers):
                 if filename:
                     new_filename = f"{filename}-{contract.name}-{function.full_name}.dot"
                 else:
                     new_filename = f"{contract.name}-{function.full_name}.dot"
                 info += f"Export {new_filename}\n"
                 content = function.slithir_cfg_to_dot_str()
                 with open(new_filename, "w", encoding="utf8") as f:
```

### Comparing `slither-analyzer-0.9.3/slither/printers/functions/dominator.py` & `slither-analyzer-0.9.4/slither/printers/functions/dominator.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,18 +1,19 @@
 from slither.printers.abstract_printer import AbstractPrinter
+from slither.utils.output import Output
 
 
 class Dominator(AbstractPrinter):
 
     ARGUMENT = "dominator"
     HELP = "Export the dominator tree of each functions"
 
     WIKI = "https://github.com/trailofbits/slither/wiki/Printer-documentation#dominator"
 
-    def output(self, filename):
+    def output(self, filename: str) -> Output:
         """
         _filename is not used
         Args:
             _filename(string)
         """
 
         info = ""
```

### Comparing `slither-analyzer-0.9.3/slither/printers/guidance/echidna.py` & `slither-analyzer-0.9.4/slither/printers/guidance/echidna.py`

 * *Files 1% similar despite different names*

```diff
@@ -28,15 +28,15 @@
     InternalDynamicCall,
     InternalCall,
     TypeConversion,
 )
 from slither.slithir.operations.binary import Binary
 from slither.slithir.variables import Constant
 from slither.utils.output import Output
-from slither.visitors.expression.constants_folding import ConstantFolding
+from slither.visitors.expression.constants_folding import ConstantFolding, NotConstant
 
 
 def _get_name(f: Union[Function, Variable]) -> str:
     # Return the name of the function or variable
     if isinstance(f, Function):
         if f.is_fallback or f.is_receive:
             return "()"
@@ -76,15 +76,15 @@
     - Otherwise check for the rules from
     https://solidity.readthedocs.io/en/v0.5.0/contracts.html?highlight=pure#view-functions
     with an exception: internal dynamic call are not correctly handled, so we consider them as non-constant
     :param f:
     :return:
     """
     if f.view or f.pure:
-        if not f.contract.compilation_unit.solc_version.startswith("0.4"):
+        if not f.compilation_unit.solc_version.startswith("0.4"):
             return True
     if f.payable:
         return False
     if not f.is_implemented:
         return False
     if f.contains_assembly:
         return False
@@ -99,19 +99,19 @@
             SolidityFunction("selfdestruct(address)"),
             SolidityFunction("suicide(address)"),
         ]:
             return False
         if isinstance(ir, HighLevelCall):
             if isinstance(ir.function, Variable) or ir.function.view or ir.function.pure:
                 # External call to constant functions are ensured to be constant only for solidity >= 0.5
-                if f.contract.compilation_unit.solc_version.startswith("0.4"):
+                if f.compilation_unit.solc_version.startswith("0.4"):
                     return False
             else:
                 return False
-        if isinstance(ir, InternalCall):
+        if isinstance(ir, InternalCall) and ir.function:
             # Storage write are not properly handled by all_state_variables_written
             if any(parameter.is_storage for parameter in ir.function.parameters):
                 return False
     return True
 
 
 def _extract_constant_functions(slither: SlitherCore) -> Dict[str, List[str]]:
@@ -174,19 +174,24 @@
     for ir in irs:
         if isinstance(ir, Binary):
             for r in ir.read:
                 if isinstance(r, Constant):
                     all_cst_used_in_binary[str(ir.type)].append(
                         ConstantValue(str(r.value), str(r.type))
                     )
-            if isinstance(ir.variable_left, Constant) and isinstance(ir.variable_right, Constant):
-                if ir.lvalue:
-                    type_ = ir.lvalue.type
-                    cst = ConstantFolding(ir.expression, type_).result()
-                    all_cst_used.append(ConstantValue(str(cst.value), str(type_)))
+                if isinstance(ir.variable_left, Constant) or isinstance(
+                    ir.variable_right, Constant
+                ):
+                    if ir.lvalue:
+                        try:
+                            type_ = ir.lvalue.type
+                            cst = ConstantFolding(ir.expression, type_).result()
+                            all_cst_used.append(ConstantValue(str(cst.value), str(type_)))
+                        except NotConstant:
+                            pass
         if isinstance(ir, TypeConversion):
             if isinstance(ir.variable, Constant):
                 if isinstance(ir.type, TypeAlias):
                     value_type = ir.type.type
                 else:
                     value_type = ir.type
                 all_cst_used.append(ConstantValue(str(ir.variable.value), str(value_type)))
```

### Comparing `slither-analyzer-0.9.3/slither/printers/inheritance/inheritance.py` & `slither-analyzer-0.9.4/slither/printers/inheritance/inheritance.py`

 * *Files 4% similar despite different names*

```diff
@@ -32,16 +32,14 @@
 
         info += blue("Child_Contract -> ") + green("Immediate_Base_Contracts")
         info += green(" [Not_Immediate_Base_Contracts]")
 
         result = {"child_to_base": {}}
 
         for child in self.contracts:
-            if child.is_top_level:
-                continue
             info += blue(f"\n+ {child.name}\n")
             result["child_to_base"][child.name] = {"immediate": [], "not_immediate": []}
             if child.inheritance:
 
                 immediate = child.immediate_inheritance
                 not_immediate = [i for i in child.inheritance if i not in immediate]
 
@@ -54,16 +52,14 @@
                     )
 
         info += green("\n\nBase_Contract -> ") + blue("Immediate_Child_Contracts") + "\n"
         info += blue(" [Not_Immediate_Child_Contracts]") + "\n"
 
         result["base_to_child"] = {}
         for base in self.contracts:
-            if base.is_top_level:
-                continue
             info += green(f"\n+ {base.name}") + "\n"
             children = list(self._get_child_contracts(base))
 
             result["base_to_child"][base.name] = {"immediate": [], "not_immediate": []}
             if children:
                 immediate = [child for child in children if base in child.immediate_inheritance]
                 not_immediate = [child for child in children if not child in immediate]
```

### Comparing `slither-analyzer-0.9.3/slither/printers/inheritance/inheritance_graph.py` & `slither-analyzer-0.9.4/slither/printers/inheritance/inheritance_graph.py`

 * *Files 1% similar despite different names*

```diff
@@ -190,16 +190,14 @@
         if not filename.endswith(".dot"):
             filename += ".inheritance-graph.dot"
         info = "Inheritance Graph: " + filename + "\n"
         self.info(info)
 
         content = 'digraph "" {\n'
         for c in self.contracts:
-            if c.is_top_level:
-                continue
             content += self._summary(c) + "\n"
         content += "}"
 
         with open(filename, "w", encoding="utf8") as f:
             f.write(content)
 
         res = self.generate_output(info)
```

### Comparing `slither-analyzer-0.9.3/slither/printers/summary/constructor_calls.py` & `slither-analyzer-0.9.4/slither/printers/summary/constructor_calls.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,27 +1,28 @@
 """
     Module printing summary of the contract
 """
 from slither.core.declarations import Function
 from slither.core.source_mapping.source_mapping import Source
 from slither.printers.abstract_printer import AbstractPrinter
 from slither.utils import output
+from slither.utils.output import Output
 
 
 def _get_source_code(cst: Function) -> str:
     src_mapping: Source = cst.source_mapping
     return " " * src_mapping.starting_column + src_mapping.content
 
 
 class ConstructorPrinter(AbstractPrinter):
     WIKI = "https://github.com/crytic/slither/wiki/Printer-documentation#constructor-calls"
     ARGUMENT = "constructor-calls"
     HELP = "Print the constructors executed"
 
-    def output(self, _filename):
+    def output(self, _filename: str) -> Output:
         info = ""
         for contract in self.slither.contracts_derived:
             stack_name = []
             stack_definition = []
             cst = contract.constructors_declared
             if cst:
                 stack_name.append(contract.name)
```

### Comparing `slither-analyzer-0.9.3/slither/printers/summary/contract.py` & `slither-analyzer-0.9.4/slither/printers/summary/contract.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,36 +1,37 @@
 """
     Module printing summary of the contract
 """
 import collections
+from typing import Dict, List
+
+from slither.core.declarations import FunctionContract
 from slither.printers.abstract_printer import AbstractPrinter
 from slither.utils import output
 from slither.utils.colors import blue, green, magenta
+from slither.utils.output import Output
 
 
 class ContractSummary(AbstractPrinter):
     ARGUMENT = "contract-summary"
     HELP = "Print a summary of the contracts"
 
     WIKI = "https://github.com/trailofbits/slither/wiki/Printer-documentation#contract-summary"
 
-    def output(self, _filename):  # pylint: disable=too-many-locals
+    def output(self, _filename: str) -> Output:  # pylint: disable=too-many-locals
         """
         _filename is not used
         Args:
             _filename(string)
         """
 
         txt = ""
 
         all_contracts = []
         for c in self.contracts:
-            if c.is_top_level:
-                continue
-
             is_upgradeable_proxy = c.is_upgradeable_proxy
             is_upgradeable = c.is_upgradeable
 
             additional_txt_info = ""
 
             if is_upgradeable_proxy:
                 additional_txt_info += " (Upgradeable Proxy)"
@@ -49,25 +50,24 @@
                     "is_upgradeable": is_upgradeable,
                     "is_most_derived": c in self.slither.contracts_derived,
                 },
             )
 
             # Order the function with
             # contract_declarer -> list_functions
-            public = [
+            public_function = [
                 (f.contract_declarer.name, f)
                 for f in c.functions
                 if (not f.is_shadowed and not f.is_constructor_variables)
             ]
-            collect = collections.defaultdict(list)
-            for a, b in public:
+            collect: Dict[str, List[FunctionContract]] = collections.defaultdict(list)
+            for a, b in public_function:
                 collect[a].append(b)
-            public = list(collect.items())
 
-            for contract, functions in public:
+            for contract, functions in collect.items():
                 txt += blue(f"  - From {contract}\n")
 
                 functions = sorted(functions, key=lambda f: f.full_name)
 
                 for function in functions:
                     if function.visibility in ["external", "public"]:
                         txt += green(f"    - {function.full_name} ({function.visibility})\n")
@@ -86,11 +86,11 @@
                     )
 
             all_contracts.append((c, additional_fields.data))
 
         self.info(txt)
 
         res = self.generate_output(txt)
-        for contract, additional_fields in all_contracts:
-            res.add(contract, additional_fields=additional_fields)
+        for current_contract, current_additional_fields in all_contracts:
+            res.add(current_contract, additional_fields=current_additional_fields)
 
         return res
```

### Comparing `slither-analyzer-0.9.3/slither/printers/summary/data_depenency.py` & `slither-analyzer-0.9.4/slither/printers/summary/data_depenency.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,51 +1,53 @@
 """
     Module printing summary of the contract
 """
+from typing import List
 
+from slither.core.declarations import Contract
 from slither.printers.abstract_printer import AbstractPrinter
-from slither.analyses.data_dependency.data_dependency import get_dependencies
+from slither.analyses.data_dependency.data_dependency import get_dependencies, SUPPORTED_TYPES
 from slither.slithir.variables import TemporaryVariable, ReferenceVariable
 from slither.utils.myprettytable import MyPrettyTable
+from slither.utils.output import Output
 
 
-def _get(v, c):
+def _get(v: SUPPORTED_TYPES, c: Contract) -> List[str]:
     return list(
         {
             d.name
             for d in get_dependencies(v, c)
-            if not isinstance(d, (TemporaryVariable, ReferenceVariable))
+            if not isinstance(d, (TemporaryVariable, ReferenceVariable)) and d.name
         }
     )
 
 
 class DataDependency(AbstractPrinter):
 
     ARGUMENT = "data-dependency"
     HELP = "Print the data dependencies of the variables"
 
     WIKI = "https://github.com/trailofbits/slither/wiki/Printer-documentation#data-dependencies"
 
-    def output(self, _filename):
+    def output(self, _filename: str) -> Output:
         """
         _filename is not used
         Args:
             _filename(string)
         """
 
         all_tables = []
         all_txt = ""
 
         txt = ""
         for c in self.contracts:
-            if c.is_top_level:
-                continue
             txt += f"\nContract {c.name}\n"
             table = MyPrettyTable(["Variable", "Dependencies"])
             for v in c.state_variables:
+                assert v.name
                 table.add_row([v.name, sorted(_get(v, c))])
 
             txt += str(table)
 
             txt += "\n"
             for f in c.functions_and_modifiers_declared:
                 txt += f"\nFunction {f.full_name}\n"
```

### Comparing `slither-analyzer-0.9.3/slither/printers/summary/declaration.py` & `slither-analyzer-0.9.4/slither/printers/summary/declaration.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,18 +1,19 @@
 from slither.printers.abstract_printer import AbstractPrinter
+from slither.utils.output import Output
 from slither.utils.source_mapping import get_definition, get_implementation, get_references
 
 
 class Declaration(AbstractPrinter):
     ARGUMENT = "declaration"
     HELP = "Prototype showing the source code declaration, implementation and references of the contracts objects"
 
     WIKI = "TODO"
 
-    def output(self, _filename):
+    def output(self, _filename: str) -> Output:
         """
         _filename is not used
         Args:
             _filename(string)
         """
 
         txt = ""
```

### Comparing `slither-analyzer-0.9.3/slither/printers/summary/evm.py` & `slither-analyzer-0.9.4/slither/printers/summary/evm.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/printers/summary/function.py` & `slither-analyzer-0.9.4/slither/printers/summary/function.py`

 * *Files 0% similar despite different names*

```diff
@@ -29,16 +29,14 @@
             _filename(string)
         """
 
         all_tables = []
         all_txt = ""
 
         for c in self.contracts:
-            if c.is_top_level:
-                continue
             (name, inheritance, var, func_summaries, modif_summaries) = c.get_summary()
             txt = f"\nContract {name}"
             txt += "\nContract vars: " + str(var)
             txt += "\nInheritance:: " + str(inheritance)
             table = MyPrettyTable(
                 [
                     "Function",
```

### Comparing `slither-analyzer-0.9.3/slither/printers/summary/function_ids.py` & `slither-analyzer-0.9.4/slither/printers/summary/function_ids.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/printers/summary/human_summary.py` & `slither-analyzer-0.9.4/slither/printers/summary/human_summary.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,42 +1,40 @@
 """
 Module printing summary of the contract
 """
 import logging
-from pathlib import Path
 from typing import Tuple, List, Dict
 
 from slither.core.declarations import SolidityFunction, Function
 from slither.core.variables.state_variable import StateVariable
 from slither.printers.abstract_printer import AbstractPrinter
+from slither.printers.summary.loc import compute_loc_metrics
 from slither.slithir.operations import (
     LowLevelCall,
     HighLevelCall,
     Transfer,
     Send,
     SolidityCall,
 )
 from slither.utils import output
 from slither.utils.code_complexity import compute_cyclomatic_complexity
 from slither.utils.colors import green, red, yellow
 from slither.utils.myprettytable import MyPrettyTable
 from slither.utils.standard_libraries import is_standard_library
 from slither.core.cfg.node import NodeType
-from slither.utils.tests_pattern import is_test_file
 
 
 class PrinterHumanSummary(AbstractPrinter):
     ARGUMENT = "human-summary"
     HELP = "Print a human-readable summary of the contracts"
 
     WIKI = "https://github.com/trailofbits/slither/wiki/Printer-documentation#human-summary"
 
     @staticmethod
     def _get_summary_erc20(contract):
-
         functions_name = [f.name for f in contract.functions]
         state_variables = [v.name for v in contract.state_variables]
 
         pause = "pause" in functions_name
 
         if "mint" in functions_name:
             if "mintingFinished" in state_variables:
@@ -161,36 +159,15 @@
         result = red("Yes") if is_complex else green("No")
         return result
 
     @staticmethod
     def _number_functions(contract):
         return len(contract.functions)
 
-    def _lines_number(self):
-        if not self.slither.source_code:
-            return None
-        total_dep_lines = 0
-        total_lines = 0
-        total_tests_lines = 0
-
-        for filename, source_code in self.slither.source_code.items():
-            lines = len(source_code.splitlines())
-            is_dep = False
-            if self.slither.crytic_compile:
-                is_dep = self.slither.crytic_compile.is_dependency(filename)
-            if is_dep:
-                total_dep_lines += lines
-            else:
-                if is_test_file(Path(filename)):
-                    total_tests_lines += lines
-                else:
-                    total_lines += lines
-        return total_lines, total_dep_lines, total_tests_lines
-
-    def _get_number_of_assembly_lines(self):
+    def _get_number_of_assembly_lines(self) -> int:
         total_asm_lines = 0
         for contract in self.contracts:
             for function in contract.functions_declared:
                 for node in function.nodes:
                     if node.type == NodeType.ASSEMBLY:
                         inline_asm = node.inline_asm
                         if inline_asm:
@@ -198,18 +175,16 @@
         return total_asm_lines
 
     def _compilation_type(self):
         if self.slither.crytic_compile is None:
             return "Compilation non standard\n"
         return f"Compiled with {str(self.slither.crytic_compile.type)}\n"
 
-    def _number_contracts(self):
-        if self.slither.crytic_compile is None:
-            return len(self.slither.contracts), 0, 0
-        contracts = [c for c in self.slither.contracts if not c.is_top_level]
+    def _number_contracts(self) -> Tuple[int, int, int]:
+        contracts = self.slither.contracts
         deps = [c for c in contracts if c.is_from_dependency()]
         tests = [c for c in contracts if c.is_test]
         return len(contracts) - len(deps) - len(tests), len(deps), len(tests)
 
     def _standard_libraries(self):
         libraries = []
         for contract in self.contracts:
@@ -222,15 +197,14 @@
     def _ercs(self):
         ercs = []
         for contract in self.contracts:
             ercs += contract.ercs()
         return list(set(ercs))
 
     def _get_features(self, contract):  # pylint: disable=too-many-branches
-
         has_payable = False
         can_send_eth = False
         can_selfdestruct = False
         has_ecrecover = False
         can_delegatecall = False
         has_token_interaction = False
 
@@ -287,14 +261,44 @@
             "Tokens interaction": has_token_interaction,
             "AbiEncoderV2": use_abi_encoder,
             "Assembly": has_assembly,
             "Upgradeable": contract.is_upgradeable,
             "Proxy": contract.is_upgradeable_proxy,
         }
 
+    def _get_contracts(self, txt: str) -> str:
+        (
+            number_contracts,
+            number_contracts_deps,
+            number_contracts_tests,
+        ) = self._number_contracts()
+        txt += f"Total number of contracts in source files: {number_contracts}\n"
+        if number_contracts_deps > 0:
+            txt += f"Number of contracts in dependencies: {number_contracts_deps}\n"
+        if number_contracts_tests > 0:
+            txt += f"Number of contracts in tests       : {number_contracts_tests}\n"
+        return txt
+
+    def _get_number_lines(self, txt: str, results: Dict) -> Tuple[str, Dict]:
+        loc = compute_loc_metrics(self.slither)
+        txt += "Source lines of code (SLOC) in source files: "
+        txt += f"{loc.src.sloc}\n"
+        if loc.dep.sloc > 0:
+            txt += "Source lines of code (SLOC) in dependencies: "
+            txt += f"{loc.dep.sloc}\n"
+        if loc.test.sloc > 0:
+            txt += "Source lines of code (SLOC) in tests       : "
+            txt += f"{loc.test.sloc}\n"
+        results["number_lines"] = loc.src.sloc
+        results["number_lines__dependencies"] = loc.dep.sloc
+        total_asm_lines = self._get_number_of_assembly_lines()
+        txt += f"Number of  assembly lines: {total_asm_lines}\n"
+        results["number_lines_assembly"] = total_asm_lines
+        return txt, results
+
     def output(self, _filename):  # pylint: disable=too-many-locals,too-many-statements
         """
         _filename is not used
             Args:
                 _filename(string)
         """
 
@@ -307,32 +311,16 @@
             "number_lines_in_dependencies": 0,
             "number_lines_assembly": 0,
             "standard_libraries": [],
             "ercs": [],
             "number_findings": {},
             "detectors": [],
         }
-
-        lines_number = self._lines_number()
-        if lines_number:
-            total_lines, total_dep_lines, total_tests_lines = lines_number
-            txt += f"Number of lines: {total_lines} (+ {total_dep_lines} in dependencies, + {total_tests_lines} in tests)\n"
-            results["number_lines"] = total_lines
-            results["number_lines__dependencies"] = total_dep_lines
-            total_asm_lines = self._get_number_of_assembly_lines()
-            txt += f"Number of assembly lines: {total_asm_lines}\n"
-            results["number_lines_assembly"] = total_asm_lines
-
-        (
-            number_contracts,
-            number_contracts_deps,
-            number_contracts_tests,
-        ) = self._number_contracts()
-        txt += f"Number of contracts: {number_contracts} (+ {number_contracts_deps} in dependencies, + {number_contracts_tests} tests) \n\n"
-
+        txt = self._get_contracts(txt)
+        txt, results = self._get_number_lines(txt, results)
         (
             txt_detectors,
             detectors_results,
             optimization,
             info,
             low,
             medium,
@@ -348,26 +336,25 @@
             "high_issues": high,
         }
         results["detectors"] = detectors_results
 
         libs = self._standard_libraries()
         if libs:
             txt += f'\nUse: {", ".join(libs)}\n'
-            results["standard_libraries"] = [str(l) for l in libs]
+            results["standard_libraries"] = [str(lib) for lib in libs]
 
         ercs = self._ercs()
         if ercs:
             txt += f'ERCs: {", ".join(ercs)}\n'
             results["ercs"] = [str(e) for e in ercs]
 
         table = MyPrettyTable(
             ["Name", "# functions", "ERCS", "ERC20 info", "Complex code", "Features"]
         )
         for contract in self.slither.contracts_derived:
-
             if contract.is_from_dependency() or contract.is_test:
                 continue
 
             is_complex = self.is_complex_code(contract)
             number_functions = self._number_functions(contract)
             ercs = ",".join(contract.ercs())
             is_erc20 = contract.is_erc20()
```

### Comparing `slither-analyzer-0.9.3/slither/printers/summary/modifier_calls.py` & `slither-analyzer-0.9.4/slither/printers/summary/modifier_calls.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/printers/summary/require_calls.py` & `slither-analyzer-0.9.4/slither/printers/summary/require_calls.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/printers/summary/slithir.py` & `slither-analyzer-0.9.4/slither/printers/summary/slithir.py`

 * *Files 5% similar despite different names*

```diff
@@ -32,16 +32,14 @@
         Args:
             _filename(string)
         """
 
         txt = ""
         for compilation_unit in self.slither.compilation_units:
             for contract in compilation_unit.contracts:
-                if contract.is_top_level:
-                    continue
                 txt += f"Contract {contract.name}\n"
                 for function in contract.functions:
                     txt += f'\tFunction {function.canonical_name} {"" if function.is_shadowed else "(*)"}\n'
                     txt += _print_function(function)
                 for modifier in contract.modifiers:
                     txt += f"\tModifier {modifier.canonical_name}\n"
                     txt += _print_function(modifier)
```

### Comparing `slither-analyzer-0.9.3/slither/printers/summary/slithir_ssa.py` & `slither-analyzer-0.9.4/slither/printers/summary/slithir_ssa.py`

 * *Files 12% similar despite different names*

```diff
@@ -17,16 +17,14 @@
         _filename is not used
         Args:
             _filename(string)
         """
 
         txt = ""
         for contract in self.contracts:
-            if contract.is_top_level:
-                continue
             txt += f"Contract {contract.name}" + "\n"
             for function in contract.functions:
                 txt += f"\tFunction {function.canonical_name}" + "\n"
                 for node in function.nodes:
                     if node.expression:
                         txt += f"\t\tExpression: {node.expression}" + "\n"
                     if node.irs_ssa:
```

### Comparing `slither-analyzer-0.9.3/slither/printers/summary/variable_order.py` & `slither-analyzer-0.9.4/slither/printers/summary/variable_order.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,23 +1,24 @@
 """
     Module printing summary of the contract
 """
 
 from slither.printers.abstract_printer import AbstractPrinter
 from slither.utils.myprettytable import MyPrettyTable
+from slither.utils.output import Output
 
 
 class VariableOrder(AbstractPrinter):
 
     ARGUMENT = "variable-order"
     HELP = "Print the storage order of the state variables"
 
     WIKI = "https://github.com/trailofbits/slither/wiki/Printer-documentation#variable-order"
 
-    def output(self, _filename):
+    def output(self, _filename: str) -> Output:
         """
         _filename is not used
         Args:
             _filename(string)
         """
 
         txt = ""
```

### Comparing `slither-analyzer-0.9.3/slither/printers/summary/when_not_paused.py` & `slither-analyzer-0.9.4/slither/printers/summary/when_not_paused.py`

 * *Files 6% similar despite different names*

```diff
@@ -6,28 +6,26 @@
 from slither.core.declarations.function import SolidityFunction
 from slither.printers.abstract_printer import AbstractPrinter
 from slither.utils import output
 from slither.utils.myprettytable import MyPrettyTable
 
 
 def _use_modifier(function: Function, modifier_name: str = "whenNotPaused") -> bool:
-    if function.is_constructor or function.view or function.pure:
-        return False
 
     for internal_call in function.all_internal_calls():
         if isinstance(internal_call, SolidityFunction):
             continue
         if any(modifier.name == modifier_name for modifier in function.modifiers):
             return True
     return False
 
 
 class PrinterWhenNotPaused(AbstractPrinter):
 
-    ARGUMENT = "pausable"
+    ARGUMENT = "not-pausable"
     HELP = "Print functions that do not use whenNotPaused"
 
     WIKI = "https://github.com/trailofbits/slither/wiki/Printer-documentation#when-not-paused"
 
     def output(self, _filename: str) -> output.Output:
         """
         _filename is not used
@@ -42,14 +40,16 @@
         all_tables = []
         for contract in self.slither.contracts:
 
             txt += f"\n{contract.name}:\n"
             table = MyPrettyTable(["Name", "Use whenNotPaused"])
 
             for function in contract.functions_entry_points:
+                if function.is_constructor or function.view or function.pure:
+                    continue
                 status = "X" if _use_modifier(function, modifier_name) else ""
                 table.add_row([function.solidity_signature, status])
 
             txt += str(table) + "\n"
             all_tables.append((contract.name, table))
 
         self.info(txt)
```

### Comparing `slither-analyzer-0.9.3/slither/slither.py` & `slither-analyzer-0.9.4/slither/slither.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/slithir/convert.py` & `slither-analyzer-0.9.4/slither/slithir/convert.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,28 +1,30 @@
 import logging
 from pathlib import Path
-from typing import Any, List, TYPE_CHECKING, Union, Optional
+from typing import Any, List, TYPE_CHECKING, Union, Optional, Dict
 
 # pylint: disable= too-many-lines,import-outside-toplevel,too-many-branches,too-many-statements,too-many-nested-blocks
 from slither.core.declarations import (
     Contract,
     Enum,
     Event,
     Function,
     SolidityFunction,
     SolidityVariable,
     SolidityVariableComposed,
     Structure,
 )
+from slither.core.declarations.contract import USING_FOR_KEY, USING_FOR_ITEM
 from slither.core.declarations.custom_error import CustomError
 from slither.core.declarations.function_contract import FunctionContract
 from slither.core.declarations.function_top_level import FunctionTopLevel
 from slither.core.declarations.solidity_import_placeholder import SolidityImportPlaceHolder
 from slither.core.declarations.solidity_variables import SolidityCustomRevert
 from slither.core.expressions import Identifier, Literal
+from slither.core.expressions.expression import Expression
 from slither.core.solidity_types import (
     ArrayType,
     ElementaryType,
     FunctionType,
     MappingType,
     UserDefinedType,
     TypeInformation,
@@ -79,81 +81,59 @@
 from slither.slithir.tmp_operations.tmp_new_elementary_type import TmpNewElementaryType
 from slither.slithir.tmp_operations.tmp_new_structure import TmpNewStructure
 from slither.slithir.variables import Constant, ReferenceVariable, TemporaryVariable
 from slither.slithir.variables import TupleVariable
 from slither.utils.function import get_function_id
 from slither.utils.type import export_nested_types_from_variable
 from slither.visitors.slithir.expression_to_slithir import ExpressionToSlithIR
-import slither.core.declarations.contract
-import slither.core.declarations.function
-import slither.core.solidity_types.elementary_type
-import slither.core.solidity_types.function_type
-import slither.core.solidity_types.user_defined_type
-import slither.slithir.operations.assignment
-import slither.slithir.operations.binary
-import slither.slithir.operations.call
-import slither.slithir.operations.high_level_call
-import slither.slithir.operations.index
-import slither.slithir.operations.init_array
-import slither.slithir.operations.internal_call
-import slither.slithir.operations.length
-import slither.slithir.operations.library_call
-import slither.slithir.operations.low_level_call
-import slither.slithir.operations.member
-import slither.slithir.operations.operation
-import slither.slithir.operations.send
-import slither.slithir.operations.solidity_call
-import slither.slithir.operations.transfer
-import slither.slithir.variables.temporary
-from slither.core.expressions.expression import Expression
 
 if TYPE_CHECKING:
     from slither.core.cfg.node import Node
 
 logger = logging.getLogger("ConvertToIR")
 
 
-def convert_expression(expression: Expression, node: "Node") -> List[Any]:
+def convert_expression(expression: Expression, node: "Node") -> List[Operation]:
     # handle standlone expression
     # such as return true;
     from slither.core.cfg.node import NodeType
 
     if isinstance(expression, Literal) and node.type in [NodeType.IF, NodeType.IFLOOP]:
         cst = Constant(expression.value, expression.type)
         cond = Condition(cst)
         cond.set_expression(expression)
         cond.set_node(node)
-        result = [cond]
-        return result
+        return [cond]
     if isinstance(expression, Identifier) and node.type in [
         NodeType.IF,
         NodeType.IFLOOP,
     ]:
         cond = Condition(expression.value)
         cond.set_expression(expression)
         cond.set_node(node)
-        result = [cond]
-        return result
+        return [cond]
 
     visitor = ExpressionToSlithIR(expression, node)
     result = visitor.result()
 
     result = apply_ir_heuristics(result, node)
 
     if result:
         if node.type in [NodeType.IF, NodeType.IFLOOP]:
-            assert isinstance(result[-1], (OperationWithLValue))
-            cond = Condition(result[-1].lvalue)
+            prev = result[-1]
+            assert isinstance(prev, (OperationWithLValue)) and prev.lvalue
+            cond = Condition(prev.lvalue)
             cond.set_expression(expression)
             cond.set_node(node)
             result.append(cond)
         elif node.type == NodeType.RETURN:
             # May return None
-            if isinstance(result[-1], (OperationWithLValue)):
-                r = Return(result[-1].lvalue)
+            prev = result[-1]
+            if isinstance(prev, (OperationWithLValue)):
+                r = Return(prev.lvalue)
                 r.set_expression(expression)
                 r.set_node(node)
                 result.append(r)
 
     return result
 
 
@@ -269,15 +249,15 @@
                 type_args = ["bytes", "string"]
             else:
                 type_args = _fits_under_byte(value)
                 if arg_type.type == "string":
                     type_args += ["string"]
 
         not_found = True
-        candidates_kept = []
+        candidates_kept: List[Function] = []
         for type_arg in type_args:
             if not not_found:
                 break
             candidates_kept = []
             for candidate in candidates:
                 param = get_type(candidate.parameters[idx].type)
                 if param == type_arg:
@@ -332,42 +312,47 @@
     while was_changed:
         # We loop until we do not find any call to value or gas
         was_changed = False
 
         # Find all the assignments
         assigments = {}
         for i in result:
-            if isinstance(i, OperationWithLValue):
+            if isinstance(i, OperationWithLValue) and i.lvalue:
                 assigments[i.lvalue.name] = i
             if isinstance(i, TmpCall):
                 if isinstance(i.called, Variable) and i.called.name in assigments:
                     ins_ori = assigments[i.called.name]
                     i.set_ori(ins_ori)
 
         to_remove = []
         variable_to_replace = {}
 
         # Replace call to value, gas to an argument of the real call
         for idx, ins in enumerate(result):
             # value can be shadowed, so we check that the prev ins
             # is an Argument
-            if is_value(ins) and isinstance(result[idx - 1], Argument):
+            if idx == 0:
+                continue
+            prev_ins = result[idx - 1]
+            if is_value(ins) and isinstance(prev_ins, Argument):
                 was_changed = True
-                result[idx - 1].set_type(ArgumentType.VALUE)
-                result[idx - 1].call_id = ins.ori.variable_left.name
-                calls.append(ins.ori.variable_left)
+                prev_ins.set_type(ArgumentType.VALUE)
+                # Types checked by is_value
+                prev_ins.call_id = ins.ori.variable_left.name  # type: ignore
+                calls.append(ins.ori.variable_left)  # type: ignore
                 to_remove.append(ins)
-                variable_to_replace[ins.lvalue.name] = ins.ori.variable_left
-            elif is_gas(ins) and isinstance(result[idx - 1], Argument):
+                variable_to_replace[ins.lvalue.name] = ins.ori.variable_left  # type: ignore
+            elif is_gas(ins) and isinstance(prev_ins, Argument):
                 was_changed = True
-                result[idx - 1].set_type(ArgumentType.GAS)
-                result[idx - 1].call_id = ins.ori.variable_left.name
-                calls.append(ins.ori.variable_left)
+                prev_ins.set_type(ArgumentType.GAS)
+                # Types checked by is_gas
+                prev_ins.call_id = ins.ori.variable_left.name  # type: ignore
+                calls.append(ins.ori.variable_left)  # type: ignore
                 to_remove.append(ins)
-                variable_to_replace[ins.lvalue.name] = ins.ori.variable_left
+                variable_to_replace[ins.lvalue.name] = ins.ori.variable_left  # type: ignore
 
         # Remove the call to value/gas instruction
         result = [i for i in result if not i in to_remove]
 
         # update the real call
         for ins in result:
             if isinstance(ins, TmpCall):
@@ -442,15 +427,15 @@
             else:
                 assert ins.get_type() == ArgumentType.CALL
                 call_data.append(ins.argument)
 
         if isinstance(ins, (HighLevelCall, NewContract, InternalDynamicCall)):
             if ins.call_id in calls_value:
                 ins.call_value = calls_value[ins.call_id]
-            if ins.call_id in calls_gas:
+            if ins.call_id in calls_gas and isinstance(ins, (HighLevelCall, InternalDynamicCall)):
                 ins.call_gas = calls_gas[ins.call_id]
 
         if isinstance(ins, (Call, NewContract, NewStructure)):
             # We might have stored some arguments for libraries
             if ins.arguments:
                 call_data = ins.arguments + call_data
             ins.arguments = call_data
@@ -524,20 +509,20 @@
 
     raise SlithIRError(f"type({contract.name}).{ir.variable_right} is unknown")
 
 
 def propagate_types(ir: Operation, node: "Node"):  # pylint: disable=too-many-locals
     # propagate the type
     node_function = node.function
-    using_for = (
+    using_for: Dict[USING_FOR_KEY, USING_FOR_ITEM] = (
         node_function.contract.using_for_complete
         if isinstance(node_function, FunctionContract)
         else {}
     )
-    if isinstance(ir, OperationWithLValue):
+    if isinstance(ir, OperationWithLValue) and ir.lvalue:
         # Force assignment in case of missing previous correct type
         if not ir.lvalue.type:
             if isinstance(ir, Assignment):
                 ir.lvalue.set_type(ir.rvalue.type)
             elif isinstance(ir, Binary):
                 if BinaryType.return_bool(ir.type):
                     ir.lvalue.set_type(ElementaryType("bool"))
@@ -640,19 +625,20 @@
             elif isinstance(ir, Member):
                 # TODO we should convert the reference to a temporary if the member is a length or a balance
                 if (
                     ir.variable_right == "length"
                     and not isinstance(ir.variable_left, Contract)
                     and isinstance(ir.variable_left.type, (ElementaryType, ArrayType))
                 ):
-                    length = Length(ir.variable_left, ir.lvalue)
-                    length.set_expression(ir.expression)
-                    length.lvalue.points_to = ir.variable_left
-                    length.set_node(ir.node)
-                    return length
+                    new_length = Length(ir.variable_left, ir.lvalue)
+                    assert ir.expression
+                    new_length.set_expression(ir.expression)
+                    new_length.lvalue.points_to = ir.variable_left
+                    new_length.set_node(ir.node)
+                    return new_length
                 # This only happen for .balance/code/codehash access on a variable for which we dont know at
                 # early parsing time the type
                 # Like
                 # function return_addr() internal returns(addresss)
                 #
                 # return_addr().balance
                 # Here slithIR will incorrectly create a REF variable instead of a Temp variable
@@ -725,15 +711,15 @@
                     return assignment
                 if isinstance(ir.variable_left, TemporaryVariable) and isinstance(
                     ir.variable_left.type, TypeInformation
                 ):
                     return _convert_type_contract(ir)
                 left = ir.variable_left
                 t = None
-                ir_func = ir.function
+                ir_func = ir.node.function
                 # Handling of this.function_name usage
                 if (
                     left == SolidityVariable("this")
                     and isinstance(ir.variable_right, Constant)
                     and isinstance(ir_func, FunctionContract)
                     and str(ir.variable_right) in [x.name for x in ir_func.contract.functions]
                 ):
@@ -788,14 +774,15 @@
                                 )
                                 if v:
                                     ir.lvalue.set_type(v.type)
             elif isinstance(ir, NewArray):
                 ir.lvalue.set_type(ir.array_type)
             elif isinstance(ir, NewContract):
                 contract = node.file_scope.get_contract_from_name(ir.contract_name)
+                assert contract
                 ir.lvalue.set_type(UserDefinedType(contract))
             elif isinstance(ir, NewElementaryType):
                 ir.lvalue.set_type(ir.type)
             elif isinstance(ir, NewStructure):
                 ir.lvalue.set_type(UserDefinedType(ir.structure))
             elif isinstance(ir, Send):
                 ir.lvalue.set_type(ElementaryType("bool"))
@@ -831,17 +818,15 @@
                 pass
             else:
                 raise SlithIRError(f"Not handling {type(ir)} during type propagation")
     return None
 
 
 # pylint: disable=too-many-locals
-def extract_tmp_call(
-    ins: TmpCall, contract: Optional[Contract]
-) -> slither.slithir.operations.call.Call:
+def extract_tmp_call(ins: TmpCall, contract: Optional[Contract]) -> Union[Call, Nop]:
     assert isinstance(ins, TmpCall)
     if isinstance(ins.called, Variable) and isinstance(ins.called.type, FunctionType):
         # If the call is made to a variable member, where the member is this
         # We need to convert it to a HighLelelCall and not an internal dynamic call
         if isinstance(ins.ori, Member) and ins.ori.variable_left == SolidityVariable("this"):
             pass
         else:
@@ -1088,15 +1073,15 @@
         if ins.call_value:
             op.call_value = ins.call_value
         if ins.call_salt:
             op.call_salt = ins.call_salt
         return op
 
     if isinstance(ins.ori, TmpNewArray):
-        n = NewArray(ins.ori.depth, ins.ori.array_type, ins.lvalue)
+        n = NewArray(ins.ori.array_type, ins.lvalue)
         n.set_expression(ins.expression)
         return n
 
     if isinstance(ins.called, Structure):
         op = NewStructure(ins.called, ins.lvalue)
         op.set_expression(ins.expression)
         op.call_id = ins.call_id
@@ -1293,15 +1278,15 @@
 ) -> None:
     arr = ir.destination
 
     new_type = ir.destination.type.type
 
     element_to_add = ReferenceVariable(node)
     element_to_add.set_type(new_type)
-    ir_assign_element_to_add = Index(element_to_add, arr, length_val, ElementaryType("uint256"))
+    ir_assign_element_to_add = Index(element_to_add, arr, length_val)
     ir_assign_element_to_add.set_expression(ir.expression)
     ir_assign_element_to_add.set_node(ir.node)
     ret.append(ir_assign_element_to_add)
 
     if len(ir.arguments) > 0:
         assign_value = ir.arguments[0]
         if isinstance(assign_value, list):
@@ -1322,24 +1307,16 @@
         ir_assign_value = Assignment(new_element, element_to_add, new_type)
         ir_assign_value.set_expression(ir.expression)
         ir_assign_value.set_node(ir.node)
         ret.append(ir_assign_value)
 
 
 def convert_to_push(
-    ir: slither.slithir.operations.high_level_call.HighLevelCall, node: "Node"
-) -> List[
-    Union[
-        slither.slithir.operations.length.Length,
-        slither.slithir.operations.assignment.Assignment,
-        slither.slithir.operations.binary.Binary,
-        slither.slithir.operations.index.Index,
-        slither.slithir.operations.init_array.InitArray,
-    ]
-]:
+    ir: HighLevelCall, node: "Node"
+) -> List[Union[Length, Assignment, Binary, Index, InitArray,]]:
     """
     Convert a call to a series of operations to push a new value onto the array
 
     The function assume to receive a correct IR
     The checks must be done by the caller
 
     May necessitate to create an intermediate operation (InitArray)
@@ -1351,57 +1328,68 @@
 
     length_val = convert_to_push_expand_arr(ir, node, ret)
     convert_to_push_set_val(ir, node, length_val, ret)
 
     return ret
 
 
-def convert_to_pop(ir, node):
+def convert_to_pop(ir: HighLevelCall, node: "Node") -> List[Operation]:
     """
     Convert pop operators
     Return a list of 6 operations
     """
 
-    ret = []
+    ret: List[Operation] = []
 
     arr = ir.destination
     length = ReferenceVariable(node)
     length.set_type(ElementaryType("uint256"))
 
     ir_length = Length(arr, length)
+    assert ir.expression
     ir_length.set_expression(ir.expression)
     ir_length.set_node(ir.node)
-    ir_length.lvalue.points_to = arr
+    length.points_to = arr
     ret.append(ir_length)
 
     val = TemporaryVariable(node)
 
     ir_sub_1 = Binary(val, length, Constant("1", ElementaryType("uint256")), BinaryType.SUBTRACTION)
     ir_sub_1.set_expression(ir.expression)
     ir_sub_1.set_node(ir.node)
     ret.append(ir_sub_1)
 
     element_to_delete = ReferenceVariable(node)
-    ir_assign_element_to_delete = Index(element_to_delete, arr, val, ElementaryType("uint256"))
+    ir_assign_element_to_delete = Index(element_to_delete, arr, val)
+    # TODO the following is equivalent to length.points_to = arr
+    # Should it be removed?
     ir_length.lvalue.points_to = arr
-    element_to_delete.set_type(ElementaryType("uint256"))
+    # Note bytes is an ElementaryType not ArrayType and bytes1 should be returned
+    # since bytes is bytes1[] without padding between the elements
+    # while in other cases such as uint256[] (ArrayType) we use ir.destination.type.type
+    # in this way we will have the type always set to the corresponding ElementaryType
+    element_to_delete.set_type(
+        ElementaryType("bytes1")
+        if isinstance(ir.destination.type, ElementaryType)
+        else ir.destination.type.type
+    )
     ir_assign_element_to_delete.set_expression(ir.expression)
     ir_assign_element_to_delete.set_node(ir.node)
     ret.append(ir_assign_element_to_delete)
 
     ir_delete = Delete(element_to_delete, element_to_delete)
     ir_delete.set_expression(ir.expression)
     ir_delete.set_node(ir.node)
     ret.append(ir_delete)
 
     length_to_assign = ReferenceVariable(node)
     length_to_assign.set_type(ElementaryType("uint256"))
     ir_length = Length(arr, length_to_assign)
     ir_length.set_expression(ir.expression)
-    ir_length.lvalue.points_to = arr
+    length_to_assign.points_to = arr
     ir_length.set_node(ir.node)
     ret.append(ir_length)
 
     ir_assign_length = Assignment(length_to_assign, val, ElementaryType("uint256"))
     ir_assign_length.set_expression(ir.expression)
     ir_assign_length.set_node(ir.node)
     ret.append(ir_assign_length)
@@ -1592,15 +1580,17 @@
     #
     #     function f(A a) public{
     #         (uint a, uint b) = a.st(0);
     #     }
     # }
     if isinstance(return_type, (MappingType, ArrayType)):
         return []
-    return [return_type.type]
+
+    assert isinstance(return_type, (ElementaryType, UserDefinedType, TypeAlias))
+    return [return_type]
 
 
 def convert_type_of_high_and_internal_level_call(
     ir: Operation, contract: Optional[Contract]
 ) -> Optional[Operation]:
     """
     Convert the IR type based on heuristic
```

### Comparing `slither-analyzer-0.9.3/slither/slithir/operations/__init__.py` & `slither-analyzer-0.9.4/slither/slithir/operations/__init__.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/slithir/operations/assignment.py` & `slither-analyzer-0.9.4/slither/slithir/operations/unary.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,51 +1,64 @@
 import logging
-from typing import List
+from typing import List, Union
+from enum import Enum
 
-from slither.core.declarations.function import Function
 from slither.slithir.operations.lvalue import OperationWithLValue
 from slither.slithir.utils.utils import is_valid_lvalue, is_valid_rvalue
-from slither.slithir.variables import TupleVariable, ReferenceVariable
-from slither.core.source_mapping.source_mapping import SourceMapping
-from slither.core.variables.variable import Variable
+from slither.slithir.exceptions import SlithIRError
+from slither.core.expressions.unary_operation import UnaryOperationType
+from slither.core.variables.local_variable import LocalVariable
+from slither.slithir.variables.constant import Constant
+from slither.slithir.variables.local_variable import LocalIRVariable
+from slither.slithir.variables.temporary import TemporaryVariable
+from slither.slithir.variables.temporary_ssa import TemporaryVariableSSA
 
 
-logger = logging.getLogger("AssignmentOperationIR")
+logger = logging.getLogger("BinaryOperationIR")
 
 
-class Assignment(OperationWithLValue):
+class UnaryType(Enum):
+    BANG = "!"
+    TILD = "~"
+
+    @staticmethod
+    def get_type(operation_type, isprefix):
+        if isprefix:
+            if operation_type == "!":
+                return UnaryType.BANG
+            if operation_type == "~":
+                return UnaryType.TILD
+        raise SlithIRError(f"get_type: Unknown operation type {operation_type}")
+
+
+class Unary(OperationWithLValue):
     def __init__(
-        self, left_variable: Variable, right_variable: SourceMapping, variable_return_type
+        self,
+        result: Union[TemporaryVariableSSA, TemporaryVariable],
+        variable: Union[Constant, LocalIRVariable, LocalVariable],
+        operation_type: UnaryOperationType,
     ) -> None:
-        assert is_valid_lvalue(left_variable)
-        assert is_valid_rvalue(right_variable) or isinstance(
-            right_variable, (Function, TupleVariable)
-        )
+        assert is_valid_rvalue(variable)
+        assert is_valid_lvalue(result)
         super().__init__()
-        self._variables = [left_variable, right_variable]
-        self._lvalue = left_variable
-        self._rvalue = right_variable
-        self._variable_return_type = variable_return_type
+        self._variable = variable
+        self._type = operation_type
+        self._lvalue = result
 
     @property
-    def variables(self):
-        return list(self._variables)
+    def read(self) -> List[Union[Constant, LocalIRVariable, LocalVariable]]:
+        return [self._variable]
 
     @property
-    def read(self) -> List[SourceMapping]:
-        return [self.rvalue]
+    def rvalue(self) -> Union[Constant, LocalVariable]:
+        return self._variable
 
     @property
-    def variable_return_type(self):
-        return self._variable_return_type
+    def type(self) -> UnaryOperationType:
+        return self._type
 
     @property
-    def rvalue(self) -> SourceMapping:
-        return self._rvalue
+    def type_str(self):
+        return str(self._type)
 
     def __str__(self):
-        if isinstance(self.lvalue, ReferenceVariable):
-            points = self.lvalue.points_to
-            while isinstance(points, ReferenceVariable):
-                points = points.points_to
-            return f"{self.lvalue} (->{points}) := {self.rvalue}({self.rvalue.type})"
-        return f"{self.lvalue}({self.lvalue.type}) := {self.rvalue}({self.rvalue.type})"
+        return f"{self.lvalue} = {self.type_str} {self.rvalue} "
```

### Comparing `slither-analyzer-0.9.3/slither/slithir/operations/binary.py` & `slither-analyzer-0.9.4/slither/slithir/operations/binary.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,21 +1,18 @@
 import logging
-from typing import List
-
 from enum import Enum
+from typing import List, Union
 
 from slither.core.declarations import Function
 from slither.core.solidity_types import ElementaryType
+from slither.core.variables.variable import Variable
 from slither.slithir.exceptions import SlithIRError
 from slither.slithir.operations.lvalue import OperationWithLValue
-from slither.slithir.utils.utils import is_valid_lvalue, is_valid_rvalue
+from slither.slithir.utils.utils import is_valid_lvalue, is_valid_rvalue, LVALUE, RVALUE
 from slither.slithir.variables import ReferenceVariable
-from slither.core.source_mapping.source_mapping import SourceMapping
-from slither.core.variables.variable import Variable
-
 
 logger = logging.getLogger("BinaryOperationIR")
 
 
 class BinaryType(Enum):
     POWER = "**"
     MULTIPLICATION = "*"
@@ -47,15 +44,15 @@
             BinaryType.LESS_EQUAL,
             BinaryType.GREATER_EQUAL,
             BinaryType.EQUAL,
             BinaryType.NOT_EQUAL,
         ]
 
     @staticmethod
-    def get_type(operation_type):  # pylint: disable=too-many-branches
+    def get_type(operation_type: str) -> "BinaryType":  # pylint: disable=too-many-branches
         if operation_type == "**":
             return BinaryType.POWER
         if operation_type == "*":
             return BinaryType.MULTIPLICATION
         if operation_type == "/":
             return BinaryType.DIVISION
         if operation_type == "%":
@@ -89,31 +86,30 @@
         if operation_type == "&&":
             return BinaryType.ANDAND
         if operation_type == "||":
             return BinaryType.OROR
 
         raise SlithIRError(f"get_type: Unknown operation type {operation_type})")
 
-    def can_be_checked_for_overflow(self):
+    def can_be_checked_for_overflow(self) -> bool:
         return self in [
             BinaryType.POWER,
             BinaryType.MULTIPLICATION,
-            BinaryType.MODULO,
             BinaryType.ADDITION,
             BinaryType.SUBTRACTION,
             BinaryType.DIVISION,
         ]
 
 
 class Binary(OperationWithLValue):
     def __init__(
         self,
         result: Variable,
-        left_variable: SourceMapping,
-        right_variable: Variable,
+        left_variable: Union[RVALUE, Function],
+        right_variable: Union[RVALUE, Function],
         operation_type: BinaryType,
     ) -> None:
         assert is_valid_rvalue(left_variable) or isinstance(left_variable, Function)
         assert is_valid_rvalue(right_variable) or isinstance(right_variable, Function)
         assert is_valid_lvalue(result)
         assert isinstance(operation_type, BinaryType)
         super().__init__()
@@ -122,40 +118,42 @@
         self._lvalue = result
         if BinaryType.return_bool(operation_type):
             result.set_type(ElementaryType("bool"))
         else:
             result.set_type(left_variable.type)
 
     @property
-    def read(self) -> List[SourceMapping]:
+    def read(self) -> List[Union[RVALUE, LVALUE, Function]]:
         return [self.variable_left, self.variable_right]
 
     @property
-    def get_variable(self):
+    def get_variable(self) -> List[Union[RVALUE, Function]]:
         return self._variables
 
     @property
-    def variable_left(self) -> SourceMapping:
-        return self._variables[0]
+    def variable_left(self) -> Union[RVALUE, Function]:
+        return self._variables[0]  # type: ignore
 
     @property
-    def variable_right(self) -> Variable:
-        return self._variables[1]
+    def variable_right(self) -> Union[RVALUE, Function]:
+        return self._variables[1]  # type: ignore
 
     @property
     def type(self) -> BinaryType:
         return self._type
 
     @property
-    def type_str(self):
+    def type_str(self) -> str:
         if self.node.scope.is_checked and self._type.can_be_checked_for_overflow():
-            return "(c)" + self._type.value
-        return self._type.value
+            return "(c)" + str(self._type.value)
+        return str(self._type.value)
 
-    def __str__(self):
-        if isinstance(self.lvalue, ReferenceVariable):
-            points = self.lvalue.points_to
+    def __str__(self) -> str:
+        lvalue = self.lvalue
+        assert lvalue
+        if isinstance(lvalue, ReferenceVariable):
+            points = lvalue.points_to
             while isinstance(points, ReferenceVariable):
                 points = points.points_to
-            return f"{str(self.lvalue)}(-> {points}) = {self.variable_left} {self.type_str} {self.variable_right}"
+            return f"{str(lvalue)}(-> {points}) = {self.variable_left} {self.type_str} {self.variable_right}"
 
-        return f"{str(self.lvalue)}({self.lvalue.type}) = {self.variable_left} {self.type_str} {self.variable_right}"
+        return f"{str(lvalue)}({lvalue.type}) = {self.variable_left} {self.type_str} {self.variable_right}"
```

### Comparing `slither-analyzer-0.9.3/slither/slithir/operations/codesize.py` & `slither-analyzer-0.9.4/slither/slithir/operations/codesize.py`

 * *Files 1% similar despite different names*

```diff
@@ -25,9 +25,9 @@
     def read(self) -> List[Union[LocalIRVariable, LocalVariable]]:
         return [self._value]
 
     @property
     def value(self) -> LocalVariable:
         return self._value
 
-    def __str__(self):
+    def __str__(self) -> str:
         return f"{self.lvalue} -> CODESIZE {self.value}"
```

### Comparing `slither-analyzer-0.9.3/slither/slithir/operations/condition.py` & `slither-analyzer-0.9.4/slither/slithir/operations/type_conversion.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,42 +1,45 @@
 from typing import List, Union
-from slither.slithir.operations.operation import Operation
 
-from slither.slithir.utils.utils import is_valid_rvalue
-from slither.core.variables.local_variable import LocalVariable
-from slither.slithir.variables.constant import Constant
-from slither.slithir.variables.local_variable import LocalIRVariable
+from slither.core.declarations import Contract
+from slither.core.solidity_types.elementary_type import ElementaryType
+from slither.core.solidity_types.type_alias import TypeAlias
+from slither.core.solidity_types.user_defined_type import UserDefinedType
+from slither.core.source_mapping.source_mapping import SourceMapping
+from slither.slithir.operations.lvalue import OperationWithLValue
+from slither.slithir.utils.utils import is_valid_lvalue, is_valid_rvalue
 from slither.slithir.variables.temporary import TemporaryVariable
 from slither.slithir.variables.temporary_ssa import TemporaryVariableSSA
-from slither.core.variables.variable import Variable
 
 
-class Condition(Operation):
-    """
-    Condition
-    Only present as last operation in conditional node
-    """
-
+class TypeConversion(OperationWithLValue):
     def __init__(
         self,
-        value: Union[
-            LocalVariable, TemporaryVariableSSA, TemporaryVariable, Constant, LocalIRVariable
-        ],
+        result: Union[TemporaryVariableSSA, TemporaryVariable],
+        variable: SourceMapping,
+        variable_type: Union[TypeAlias, UserDefinedType, ElementaryType],
     ) -> None:
-        assert is_valid_rvalue(value)
         super().__init__()
-        self._value = value
+        assert is_valid_rvalue(variable) or isinstance(variable, Contract)
+        assert is_valid_lvalue(result)
+        assert isinstance(variable_type, (TypeAlias, UserDefinedType, ElementaryType))
+
+        self._variable = variable
+        self._type: Union[TypeAlias, UserDefinedType, ElementaryType] = variable_type
+        self._lvalue = result
+
+    @property
+    def variable(self) -> SourceMapping:
+        return self._variable
 
     @property
-    def read(
+    def type(
         self,
-    ) -> List[
-        Union[LocalIRVariable, Constant, LocalVariable, TemporaryVariableSSA, TemporaryVariable]
-    ]:
-        return [self.value]
+    ) -> Union[TypeAlias, UserDefinedType, ElementaryType,]:
+        return self._type
 
     @property
-    def value(self) -> Variable:
-        return self._value
+    def read(self) -> List[SourceMapping]:
+        return [self.variable]
 
-    def __str__(self):
-        return f"CONDITION {self.value}"
+    def __str__(self) -> str:
+        return str(self.lvalue) + f" = CONVERT {self.variable} to {self.type}"
```

### Comparing `slither-analyzer-0.9.3/slither/slithir/operations/delete.py` & `slither-analyzer-0.9.4/slither/slithir/operations/delete.py`

 * *Files 2% similar despite different names*

```diff
@@ -32,9 +32,9 @@
 
     @property
     def variable(
         self,
     ) -> Union[StateIRVariable, StateVariable, ReferenceVariable, ReferenceVariableSSA]:
         return self._variable
 
-    def __str__(self):
+    def __str__(self) -> str:
         return f"{self.lvalue} = delete {self.variable} "
```

### Comparing `slither-analyzer-0.9.3/slither/slithir/operations/event_call.py` & `slither-analyzer-0.9.4/slither/slithir/operations/event_call.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/slithir/operations/high_level_call.py` & `slither-analyzer-0.9.4/slither/slithir/operations/high_level_call.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,9 +1,10 @@
 from typing import List, Optional, Union
 
+from slither.core.declarations import Contract
 from slither.slithir.operations.call import Call
 from slither.slithir.operations.lvalue import OperationWithLValue
 from slither.core.variables.variable import Variable
 from slither.core.declarations.solidity_variables import SolidityVariable
 from slither.core.declarations.function import Function
 
 from slither.slithir.utils.utils import is_valid_lvalue
@@ -28,28 +29,30 @@
         result: Optional[Union[TemporaryVariable, TupleVariable, TemporaryVariableSSA]],
         type_call: str,
     ) -> None:
         assert isinstance(function_name, Constant)
         assert is_valid_lvalue(result) or result is None
         self._check_destination(destination)
         super().__init__()
-        self._destination = destination
+        # Contract is only possible for library call, which inherits from highlevelcall
+        self._destination: Union[Variable, SolidityVariable, Contract] = destination  # type: ignore
         self._function_name = function_name
         self._nbr_arguments = nbr_arguments
         self._type_call = type_call
         self._lvalue = result
         self._callid = None  # only used if gas/value != 0
         self._function_instance = None
 
         self._call_value = None
         self._call_gas = None
 
     # Development function, to be removed once the code is stable
-    # It is ovveride by LbraryCall
-    def _check_destination(self, destination: SourceMapping) -> None:  # pylint: disable=no-self-use
+    # It is overridden by LibraryCall
+    # pylint: disable=no-self-use
+    def _check_destination(self, destination: Union[Variable, SolidityVariable, Contract]) -> None:
         assert isinstance(destination, (Variable, SolidityVariable))
 
     @property
     def call_id(self):
         return self._callid
 
     @call_id.setter
@@ -75,15 +78,22 @@
     @property
     def read(self) -> List[SourceMapping]:
         all_read = [self.destination, self.call_gas, self.call_value] + self._unroll(self.arguments)
         # remove None
         return [x for x in all_read if x]
 
     @property
-    def destination(self) -> SourceMapping:
+    def destination(self) -> Union[Variable, SolidityVariable, Contract]:
+        """
+        Return a variable or a solidityVariable
+        Contract is only possible for LibraryCall
+
+        Returns:
+
+        """
         return self._destination
 
     @property
     def function_name(self) -> Constant:
         return self._function_name
 
     @property
@@ -112,15 +122,15 @@
         if self.compilation_unit.solc_version and self.compilation_unit.solc_version >= "0.5.0":
             if isinstance(self.function, Function) and (self.function.view or self.function.pure):
                 return True
             if isinstance(self.function, Variable):
                 return True
         return False
 
-    def can_reenter(self, callstack: None = None) -> bool:
+    def can_reenter(self, callstack: Optional[List[Union[Function, Variable]]] = None) -> bool:
         """
         Must be called after slithIR analysis pass
         For Solidity > 0.5, filter access to public variables and constant/pure/view
         For call to this. check if the destination can re-enter
         :param callstack: check for recursion
         :return: bool
         """
```

### Comparing `slither-analyzer-0.9.3/slither/slithir/operations/index.py` & `slither-analyzer-0.9.4/slither/slithir/operations/index.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,51 +1,44 @@
 from typing import List, Union
+
 from slither.core.declarations import SolidityVariableComposed
-from slither.slithir.operations.lvalue import OperationWithLValue
-from slither.slithir.utils.utils import is_valid_lvalue, is_valid_rvalue
-from slither.slithir.variables.reference import ReferenceVariable
-from slither.core.solidity_types.elementary_type import ElementaryType
 from slither.core.source_mapping.source_mapping import SourceMapping
 from slither.core.variables.variable import Variable
-from slither.slithir.variables.reference_ssa import ReferenceVariableSSA
+from slither.core.variables.top_level_variable import TopLevelVariable
+from slither.slithir.operations.lvalue import OperationWithLValue
+from slither.slithir.utils.utils import is_valid_lvalue, is_valid_rvalue, RVALUE, LVALUE
+from slither.slithir.variables.reference import ReferenceVariable
 
 
 class Index(OperationWithLValue):
     def __init__(
-        self,
-        result: Union[ReferenceVariable, ReferenceVariableSSA],
-        left_variable: Variable,
-        right_variable: SourceMapping,
-        index_type: Union[ElementaryType, str],
+        self, result: ReferenceVariable, left_variable: Variable, right_variable: RVALUE
     ) -> None:
         super().__init__()
-        assert is_valid_lvalue(left_variable) or left_variable == SolidityVariableComposed(
-            "msg.data"
+        assert (
+            is_valid_lvalue(left_variable)
+            or left_variable == SolidityVariableComposed("msg.data")
+            or isinstance(left_variable, TopLevelVariable)
         )
         assert is_valid_rvalue(right_variable)
         assert isinstance(result, ReferenceVariable)
         self._variables = [left_variable, right_variable]
-        self._type = index_type
-        self._lvalue = result
+        self._lvalue: ReferenceVariable = result
 
     @property
     def read(self) -> List[SourceMapping]:
         return list(self.variables)
 
     @property
-    def variables(self) -> List[SourceMapping]:
-        return self._variables
-
-    @property
-    def variable_left(self) -> Variable:
-        return self._variables[0]
+    def variables(self) -> List[Union[LVALUE, RVALUE, SolidityVariableComposed]]:
+        return self._variables  # type: ignore
 
     @property
-    def variable_right(self) -> SourceMapping:
-        return self._variables[1]
+    def variable_left(self) -> Union[LVALUE, SolidityVariableComposed]:
+        return self._variables[0]  # type: ignore
 
     @property
-    def index_type(self) -> Union[ElementaryType, str]:
-        return self._type
+    def variable_right(self) -> RVALUE:
+        return self._variables[1]  # type: ignore
 
-    def __str__(self):
+    def __str__(self) -> str:
         return f"{self.lvalue}({self.lvalue.type}) -> {self.variable_left}[{self.variable_right}]"
```

### Comparing `slither-analyzer-0.9.3/slither/slithir/operations/init_array.py` & `slither-analyzer-0.9.4/slither/slithir/operations/init_array.py`

 * *Files 5% similar despite different names*

```diff
@@ -37,11 +37,11 @@
     def init_values(self) -> List[Constant]:
         return list(self._init_values)
 
     def __str__(self):
         def convert(elem):
             if isinstance(elem, (list,)):
                 return str([convert(x) for x in elem])
-            return str(elem)
+            return f"{elem}({elem.type})"
 
         init_values = convert(self.init_values)
         return f"{self.lvalue}({self.lvalue.type}) =  {init_values}"
```

### Comparing `slither-analyzer-0.9.3/slither/slithir/operations/internal_call.py` & `slither-analyzer-0.9.4/slither/slithir/operations/internal_call.py`

 * *Files 2% similar despite different names*

```diff
@@ -20,15 +20,15 @@
             Union[TupleVariableSSA, TemporaryVariableSSA, TupleVariable, TemporaryVariable]
         ],
         type_call: str,
     ) -> None:
         super().__init__()
         self._contract_name = ""
         if isinstance(function, Function):
-            self._function = function
+            self._function: Optional[Function] = function
             self._function_name = function.name
             if isinstance(function, FunctionContract):
                 self._contract_name = function.contract_declarer.name
         else:
             self._function = None
             self._function_name, self._contract_name = function
         # self._contract = contract
@@ -41,15 +41,15 @@
         self.function_candidates: Optional[List[Function]] = None
 
     @property
     def read(self) -> List[Any]:
         return list(self._unroll(self.arguments))
 
     @property
-    def function(self):
+    def function(self) -> Optional[Function]:
         return self._function
 
     @function.setter
     def function(self, f):
         self._function = f
 
     @property
```

### Comparing `slither-analyzer-0.9.3/slither/slithir/operations/internal_dynamic_call.py` & `slither-analyzer-0.9.4/slither/slithir/operations/internal_dynamic_call.py`

 * *Files 4% similar despite different names*

```diff
@@ -20,28 +20,28 @@
         function: Union[LocalVariable, LocalIRVariable],
         function_type: FunctionType,
     ) -> None:
         assert isinstance(function_type, FunctionType)
         assert isinstance(function, Variable)
         assert is_valid_lvalue(lvalue) or lvalue is None
         super().__init__()
-        self._function = function
+        self._function: Variable = function
         self._function_type = function_type
         self._lvalue = lvalue
 
         self._callid = None  # only used if gas/value != 0
         self._call_value = None
         self._call_gas = None
 
     @property
     def read(self) -> List[Union[Constant, LocalIRVariable, LocalVariable]]:
         return self._unroll(self.arguments) + [self.function]
 
     @property
-    def function(self) -> Union[LocalVariable, LocalIRVariable]:
+    def function(self) -> Variable:
         return self._function
 
     @property
     def function_type(self) -> FunctionType:
         return self._function_type
 
     @property
```

### Comparing `slither-analyzer-0.9.3/slither/slithir/operations/length.py` & `slither-analyzer-0.9.4/slither/slithir/operations/length.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/slithir/operations/low_level_call.py` & `slither-analyzer-0.9.4/slither/slithir/operations/low_level_call.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,8 +1,10 @@
-from typing import List, Union
+from typing import List, Union, Optional
+
+from slither.core.declarations import Function
 from slither.slithir.operations.call import Call
 from slither.slithir.operations.lvalue import OperationWithLValue
 from slither.core.variables.variable import Variable
 from slither.core.declarations.solidity_variables import SolidityVariable
 
 from slither.slithir.variables.constant import Constant
 from slither.core.variables.local_variable import LocalVariable
@@ -70,15 +72,15 @@
     ) -> List[
         Union[LocalIRVariable, Constant, LocalVariable, TemporaryVariableSSA, TemporaryVariable]
     ]:
         all_read = [self.destination, self.call_gas, self.call_value] + self.arguments
         # remove None
         return self._unroll([x for x in all_read if x])
 
-    def can_reenter(self, _callstack: None = None) -> bool:
+    def can_reenter(self, _callstack: Optional[List[Union[Function, Variable]]] = None) -> bool:
         """
         Must be called after slithIR analysis pass
         :return: bool
         """
         if self.function_name == "staticcall":
             return False
         return True
```

### Comparing `slither-analyzer-0.9.3/slither/slithir/operations/member.py` & `slither-analyzer-0.9.4/slither/slithir/operations/member.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 from typing import List, Union
 from slither.core.declarations import Contract, Function
 from slither.core.declarations.custom_error import CustomError
 from slither.core.declarations.enum import Enum
 from slither.core.declarations.solidity_import_placeholder import SolidityImportPlaceHolder
 from slither.core.solidity_types import ElementaryType
 from slither.slithir.operations.lvalue import OperationWithLValue
-from slither.slithir.utils.utils import is_valid_rvalue
+from slither.slithir.utils.utils import is_valid_rvalue, RVALUE
 from slither.slithir.variables.constant import Constant
 from slither.slithir.variables.reference import ReferenceVariable
 from slither.core.source_mapping.source_mapping import SourceMapping
 from slither.slithir.variables.reference_ssa import ReferenceVariableSSA
 
 
 class Member(OperationWithLValue):
@@ -35,26 +35,32 @@
             variable_left,
             (Contract, Enum, Function, CustomError, SolidityImportPlaceHolder, ElementaryType),
         )
 
         assert isinstance(variable_right, Constant)
         assert isinstance(result, ReferenceVariable)
         super().__init__()
-        self._variable_left = variable_left
+        self._variable_left: Union[
+            RVALUE, Contract, Enum, Function, CustomError, SolidityImportPlaceHolder, ElementaryType
+        ] = variable_left
         self._variable_right = variable_right
         self._lvalue = result
         self._gas = None
         self._value = None
 
     @property
     def read(self) -> List[SourceMapping]:
         return [self.variable_left, self.variable_right]
 
     @property
-    def variable_left(self) -> SourceMapping:
+    def variable_left(
+        self,
+    ) -> Union[
+        RVALUE, Contract, Enum, Function, CustomError, SolidityImportPlaceHolder, ElementaryType
+    ]:
         return self._variable_left
 
     @property
     def variable_right(self) -> Constant:
         return self._variable_right
 
     @property
```

### Comparing `slither-analyzer-0.9.3/slither/slithir/operations/new_array.py` & `slither-analyzer-0.9.4/slither/slithir/operations/new_array.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,41 +1,36 @@
 from typing import List, Union, TYPE_CHECKING
-from slither.slithir.operations.lvalue import OperationWithLValue
+
+from slither.core.solidity_types.array_type import ArrayType
 from slither.slithir.operations.call import Call
-from slither.core.solidity_types.type import Type
+from slither.slithir.operations.lvalue import OperationWithLValue
 
 if TYPE_CHECKING:
-    from slither.core.solidity_types.type_alias import TypeAliasTopLevel
     from slither.slithir.variables.constant import Constant
     from slither.slithir.variables.temporary import TemporaryVariable
     from slither.slithir.variables.temporary_ssa import TemporaryVariableSSA
 
 
 class NewArray(Call, OperationWithLValue):
     def __init__(
         self,
-        depth: int,
-        array_type: "TypeAliasTopLevel",
+        array_type: "ArrayType",
         lvalue: Union["TemporaryVariableSSA", "TemporaryVariable"],
     ) -> None:
         super().__init__()
-        assert isinstance(array_type, Type)
-        self._depth = depth
+        assert isinstance(array_type, ArrayType)
         self._array_type = array_type
 
         self._lvalue = lvalue
 
     @property
-    def array_type(self) -> "TypeAliasTopLevel":
+    def array_type(self) -> "ArrayType":
         return self._array_type
 
     @property
     def read(self) -> List["Constant"]:
         return self._unroll(self.arguments)
 
-    @property
-    def depth(self) -> int:
-        return self._depth
-
     def __str__(self):
         args = [str(a) for a in self.arguments]
-        return f"{self.lvalue} = new {self.array_type}{'[]' * self.depth}({','.join(args)})"
+        lvalue = self.lvalue
+        return f"{lvalue}{lvalue.type})  = new {self.array_type}({','.join(args)})"
```

### Comparing `slither-analyzer-0.9.3/slither/slithir/operations/new_contract.py` & `slither-analyzer-0.9.4/slither/slithir/operations/new_contract.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,15 +1,17 @@
 from typing import Optional, Any, List, Union
+
+from slither.core.declarations import Function
+from slither.core.declarations.contract import Contract
+from slither.core.variables import Variable
 from slither.slithir.operations import Call, OperationWithLValue
 from slither.slithir.utils.utils import is_valid_lvalue
 from slither.slithir.variables.constant import Constant
-from slither.core.declarations.contract import Contract
 from slither.slithir.variables.temporary import TemporaryVariable
 from slither.slithir.variables.temporary_ssa import TemporaryVariableSSA
-from slither.core.declarations.function_contract import FunctionContract
 
 
 class NewContract(Call, OperationWithLValue):  # pylint: disable=too-many-instance-attributes
     def __init__(
         self, contract_name: Constant, lvalue: Union[TemporaryVariableSSA, TemporaryVariable]
     ) -> None:
         assert isinstance(contract_name, Constant)
@@ -56,23 +58,24 @@
         # remove None
         return [x for x in all_read if x]
 
     @property
     def contract_created(self) -> Contract:
         contract_name = self.contract_name
         contract_instance = self.node.file_scope.get_contract_from_name(contract_name)
+        assert contract_instance
         return contract_instance
 
     ###################################################################################
     ###################################################################################
     # region Analyses
     ###################################################################################
     ###################################################################################
 
-    def can_reenter(self, callstack: Optional[List[FunctionContract]] = None) -> bool:
+    def can_reenter(self, callstack: Optional[List[Union[Function, Variable]]] = None) -> bool:
         """
         Must be called after slithIR analysis pass
         For Solidity > 0.5, filter access to public variables and constant/pure/view
         For call to this. check if the destination can re-enter
         :param callstack: check for recursion
         :return: bool
         """
@@ -90,15 +93,16 @@
         Must be called after slithIR analysis pass
         :return: bool
         """
         return self._call_value is not None
 
     # endregion
 
-    def __str__(self):
+    def __str__(self) -> str:
         options = ""
         if self.call_value:
             options = f"value:{self.call_value} "
         if self.call_salt:
             options += f"salt:{self.call_salt} "
         args = [str(a) for a in self.arguments]
-        return f"{self.lvalue} = new {self.contract_name}({','.join(args)}) {options}"
+        lvalue = self.lvalue
+        return f"{lvalue}({lvalue.type}) = new {self.contract_name}({','.join(args)}) {options}"
```

### Comparing `slither-analyzer-0.9.3/slither/slithir/operations/new_elementary_type.py` & `slither-analyzer-0.9.4/slither/slithir/operations/new_elementary_type.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/slithir/operations/new_structure.py` & `slither-analyzer-0.9.4/slither/slithir/operations/new_structure.py`

 * *Files 4% similar despite different names*

```diff
@@ -10,15 +10,17 @@
 from slither.slithir.variables.constant import Constant
 from slither.slithir.variables.temporary import TemporaryVariable
 from slither.slithir.variables.temporary_ssa import TemporaryVariableSSA
 
 
 class NewStructure(Call, OperationWithLValue):
     def __init__(
-        self, structure: StructureContract, lvalue: Union[TemporaryVariableSSA, TemporaryVariable]
+        self,
+        structure: StructureContract,
+        lvalue: Union[TemporaryVariableSSA, TemporaryVariable],
     ) -> None:
         super().__init__()
         assert isinstance(structure, Structure)
         assert is_valid_lvalue(lvalue)
         self._structure = structure
         # todo create analyze to add the contract instance
         self._lvalue = lvalue
@@ -33,8 +35,9 @@
 
     @property
     def structure_name(self):
         return self.structure.name
 
     def __str__(self):
         args = [str(a) for a in self.arguments]
-        return f"{self.lvalue} = new {self.structure_name}({','.join(args)})"
+        lvalue = self.lvalue
+        return f"{lvalue}({lvalue.type}) = new {self.structure_name}({','.join(args)})"
```

### Comparing `slither-analyzer-0.9.3/slither/slithir/operations/phi.py` & `slither-analyzer-0.9.4/slither/slithir/operations/phi.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/slithir/operations/phi_callback.py` & `slither-analyzer-0.9.4/slither/slithir/operations/phi_callback.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/slithir/operations/return_operation.py` & `slither-analyzer-0.9.4/slither/slithir/operations/return_operation.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,57 +1,58 @@
-from typing import List
+from typing import List, Optional, Union, Any
 
 from slither.core.declarations import Function
+from slither.core.variables.variable import Variable
 from slither.slithir.operations.operation import Operation
-
+from slither.slithir.utils.utils import is_valid_rvalue, RVALUE
 from slither.slithir.variables.tuple import TupleVariable
-from slither.slithir.utils.utils import is_valid_rvalue
-from slither.core.variables.variable import Variable
 
 
 class Return(Operation):
     """
     Return
     Only present as last operation in RETURN node
     """
 
-    def __init__(self, values) -> None:
+    def __init__(
+        self, values: Optional[Union[RVALUE, TupleVariable, Function, List[RVALUE]]]
+    ) -> None:
         # Note: Can return None
         # ex: return call()
         # where call() dont return
+        self._values: List[Union[RVALUE, TupleVariable, Function]]
         if not isinstance(values, list):
             assert (
                 is_valid_rvalue(values)
                 or isinstance(values, (TupleVariable, Function))
                 or values is None
             )
             if values is None:
-                values = []
+                self._values = []
             else:
-                values = [values]
+                self._values = [values]
         else:
             # Remove None
             # Prior Solidity 0.5
             # return (0,)
             # was valid for returns(uint)
-            values = [v for v in values if not v is None]
-            self._valid_value(values)
+            self._values = [v for v in values if not v is None]
+            self._valid_value(self._values)
         super().__init__()
-        self._values = values
 
-    def _valid_value(self, value) -> bool:
+    def _valid_value(self, value: Any) -> bool:
         if isinstance(value, list):
             assert all(self._valid_value(v) for v in value)
         else:
             assert is_valid_rvalue(value) or isinstance(value, (TupleVariable, Function))
         return True
 
     @property
     def read(self) -> List[Variable]:
         return self._unroll(self.values)
 
     @property
     def values(self) -> List[Variable]:
         return self._unroll(self._values)
 
-    def __str__(self):
+    def __str__(self) -> str:
         return f"RETURN {','.join([f'{x}' for x in self.values])}"
```

### Comparing `slither-analyzer-0.9.3/slither/slithir/operations/send.py` & `slither-analyzer-0.9.4/slither/slithir/operations/send.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/slithir/operations/solidity_call.py` & `slither-analyzer-0.9.4/slither/slithir/operations/solidity_call.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,36 +1,35 @@
 from typing import Any, List, Union
-from slither.core.declarations.solidity_variables import SolidityCustomRevert, SolidityFunction
+from slither.core.declarations.solidity_variables import SolidityFunction
+from slither.core.solidity_types.elementary_type import ElementaryType
 from slither.slithir.operations.call import Call
 from slither.slithir.operations.lvalue import OperationWithLValue
-from slither.core.children.child_node import ChildNode
-from slither.core.solidity_types.elementary_type import ElementaryType
 
 
 class SolidityCall(Call, OperationWithLValue):
     def __init__(
         self,
-        function: Union[SolidityCustomRevert, SolidityFunction],
+        function: SolidityFunction,
         nbr_arguments: int,
-        result: ChildNode,
+        result,
         type_call: Union[str, List[ElementaryType]],
     ) -> None:
         assert isinstance(function, SolidityFunction)
         super().__init__()
         self._function = function
         self._nbr_arguments = nbr_arguments
         self._type_call = type_call
         self._lvalue = result
 
     @property
     def read(self) -> List[Any]:
         return self._unroll(self.arguments)
 
     @property
-    def function(self) -> Union[SolidityCustomRevert, SolidityFunction]:
+    def function(self) -> SolidityFunction:
         return self._function
 
     @property
     def nbr_arguments(self) -> int:
         return self._nbr_arguments
 
     @property
```

### Comparing `slither-analyzer-0.9.3/slither/slithir/operations/transfer.py` & `slither-analyzer-0.9.4/slither/slithir/operations/transfer.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/slithir/operations/unpack.py` & `slither-analyzer-0.9.4/slither/slithir/operations/unpack.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/slithir/tmp_operations/argument.py` & `slither-analyzer-0.9.4/slither/slithir/tmp_operations/argument.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,46 +1,49 @@
 from enum import Enum
+from typing import Optional, List
+
+from slither.core.expressions.expression import Expression
 from slither.slithir.operations.operation import Operation
 
 
 class ArgumentType(Enum):
     CALL = 0
     VALUE = 1
     GAS = 2
     DATA = 3
 
 
 class Argument(Operation):
-    def __init__(self, argument) -> None:
+    def __init__(self, argument: Expression) -> None:
         super().__init__()
         self._argument = argument
         self._type = ArgumentType.CALL
-        self._callid = None
+        self._callid: Optional[str] = None
 
     @property
-    def argument(self):
+    def argument(self) -> Expression:
         return self._argument
 
     @property
-    def call_id(self):
+    def call_id(self) -> Optional[str]:
         return self._callid
 
     @call_id.setter
-    def call_id(self, c):
+    def call_id(self, c: str) -> None:
         self._callid = c
 
     @property
-    def read(self):
+    def read(self) -> List[Expression]:
         return [self.argument]
 
     def set_type(self, t: ArgumentType) -> None:
         assert isinstance(t, ArgumentType)
         self._type = t
 
     def get_type(self) -> ArgumentType:
         return self._type
 
-    def __str__(self):
+    def __str__(self) -> str:
         call_id = "none"
         if self.call_id:
             call_id = f"(id ({self.call_id}))"
         return f"ARG_{self._type.name} {str(self._argument)} {call_id}"
```

### Comparing `slither-analyzer-0.9.3/slither/slithir/tmp_operations/tmp_call.py` & `slither-analyzer-0.9.4/slither/slithir/tmp_operations/tmp_call.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/slithir/tmp_operations/tmp_new_array.py` & `slither-analyzer-0.9.4/slither/slithir/tmp_operations/tmp_new_array.py`

 * *Files 22% similar despite different names*

```diff
@@ -2,31 +2,25 @@
 from slither.slithir.operations.lvalue import OperationWithLValue
 from slither.slithir.variables.temporary import TemporaryVariable
 
 
 class TmpNewArray(OperationWithLValue):
     def __init__(
         self,
-        depth: int,
         array_type: Type,
         lvalue: TemporaryVariable,
     ) -> None:
         super().__init__()
         assert isinstance(array_type, Type)
-        self._depth = depth
         self._array_type = array_type
         self._lvalue = lvalue
 
     @property
     def array_type(self) -> Type:
         return self._array_type
 
     @property
     def read(self):
         return []
 
-    @property
-    def depth(self) -> int:
-        return self._depth
-
     def __str__(self):
-        return f"{self.lvalue} = new {self.array_type}{'[]' * self._depth}"
+        return f"{self.lvalue} = new {self.array_type}"
```

### Comparing `slither-analyzer-0.9.3/slither/slithir/tmp_operations/tmp_new_contract.py` & `slither-analyzer-0.9.4/slither/slithir/tmp_operations/tmp_new_contract.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/slithir/tmp_operations/tmp_new_elementary_type.py` & `slither-analyzer-0.9.4/slither/slithir/tmp_operations/tmp_new_elementary_type.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/slithir/utils/ssa.py` & `slither-analyzer-0.9.4/slither/slithir/utils/ssa.py`

 * *Files 2% similar despite different names*

```diff
@@ -362,15 +362,15 @@
             candidates.append(init_vars[var.name])
     assert candidates
     return max(candidates, key=lambda v: v.index)
 
 
 def is_used_later(
     initial_node: Node,
-    variable: Union[StateIRVariable, LocalVariable],
+    variable: Union[StateIRVariable, LocalVariable, TemporaryVariableSSA],
 ) -> bool:
     # TODO: does not handle the case where its read and written in the declaration node
     # It can be problematic if this happens in a loop/if structure
     # Ex:
     # for(;true;){
     #   if(true){
     #     uint a = a;
@@ -747,16 +747,15 @@
         new_ir.arguments = get_arguments(ir, *instances)
         new_ir.function = ir.function
         return new_ir
     if isinstance(ir, Index):
         lvalue = get_variable(ir, lambda x: x.lvalue, *instances)
         variable_left = get_variable(ir, lambda x: x.variable_left, *instances)
         variable_right = get_variable(ir, lambda x: x.variable_right, *instances)
-        index_type = ir.index_type
-        return Index(lvalue, variable_left, variable_right, index_type)
+        return Index(lvalue, variable_left, variable_right)
     if isinstance(ir, InitArray):
         lvalue = get_variable(ir, lambda x: x.lvalue, *instances)
         init_values = get_rec_values(ir, lambda x: x.init_values, *instances)
         return InitArray(init_values, lvalue)
     if isinstance(ir, InternalCall):
         function = ir.function
         nbr_arguments = ir.nbr_arguments
@@ -786,18 +785,17 @@
         return new_ir
     if isinstance(ir, Member):
         lvalue = get_variable(ir, lambda x: x.lvalue, *instances)
         variable_left = get_variable(ir, lambda x: x.variable_left, *instances)
         variable_right = get_variable(ir, lambda x: x.variable_right, *instances)
         return Member(variable_left, variable_right, lvalue)
     if isinstance(ir, NewArray):
-        depth = ir.depth
         array_type = ir.array_type
         lvalue = get_variable(ir, lambda x: x.lvalue, *instances)
-        new_ir = NewArray(depth, array_type, lvalue)
+        new_ir = NewArray(array_type, lvalue)
         new_ir.arguments = get_rec_values(ir, lambda x: x.arguments, *instances)
         return new_ir
     if isinstance(ir, NewElementaryType):
         new_type = ir.type
         lvalue = get_variable(ir, lambda x: x.lvalue, *instances)
         new_ir = NewElementaryType(new_type, lvalue)
         new_ir.arguments = get_arguments(ir, *instances)
```

### Comparing `slither-analyzer-0.9.3/slither/slithir/utils/utils.py` & `slither-analyzer-0.9.4/slither/slithir/utils/utils.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,36 +1,56 @@
+from typing import Union, Optional
+
 from slither.core.variables.local_variable import LocalVariable
 from slither.core.variables.state_variable import StateVariable
 
 from slither.core.declarations.solidity_variables import SolidityVariable
 from slither.core.variables.top_level_variable import TopLevelVariable
 
 from slither.slithir.variables.temporary import TemporaryVariable
 from slither.slithir.variables.constant import Constant
 from slither.slithir.variables.reference import ReferenceVariable
 from slither.slithir.variables.tuple import TupleVariable
 from slither.core.source_mapping.source_mapping import SourceMapping
 
+RVALUE = Union[
+    StateVariable,
+    LocalVariable,
+    TopLevelVariable,
+    TemporaryVariable,
+    Constant,
+    SolidityVariable,
+    ReferenceVariable,
+]
+
+LVALUE = Union[
+    StateVariable,
+    LocalVariable,
+    TemporaryVariable,
+    ReferenceVariable,
+    TupleVariable,
+]
+
 
-def is_valid_rvalue(v: SourceMapping) -> bool:
+def is_valid_rvalue(v: Optional[SourceMapping]) -> bool:
     return isinstance(
         v,
         (
             StateVariable,
             LocalVariable,
             TopLevelVariable,
             TemporaryVariable,
             Constant,
             SolidityVariable,
             ReferenceVariable,
         ),
     )
 
 
-def is_valid_lvalue(v) -> bool:
+def is_valid_lvalue(v: Optional[SourceMapping]) -> bool:
     return isinstance(
         v,
         (
             StateVariable,
             LocalVariable,
             TemporaryVariable,
             ReferenceVariable,
```

### Comparing `slither-analyzer-0.9.3/slither/slithir/variables/constant.py` & `slither-analyzer-0.9.4/slither/slithir/variables/constant.py`

 * *Files 4% similar despite different names*

```diff
@@ -24,27 +24,29 @@
         if subdenomination:
             val = str(convert_subdenomination(val, subdenomination))
 
         if constant_type:  # pylint: disable=too-many-nested-blocks
             assert isinstance(constant_type, ElementaryType)
             self._type = constant_type
             if constant_type.type in Int + Uint + ["address"]:
-                self._val = convert_string_to_int(val)
+                self._val: Union[bool, int, str] = convert_string_to_int(val)
             elif constant_type.type == "bool":
                 self._val = (val == "true") | (val == "True")
             else:
                 self._val = val
         else:
             if val.isdigit():
                 self._type = ElementaryType("uint256")
                 self._val = convert_string_to_int(val)
             else:
                 self._type = ElementaryType("string")
                 self._val = val
 
+        self._name = str(self._val)
+
     @property
     def value(self) -> Union[bool, int, str]:
         """
         Return the value.
         If the expression was an hexadecimal delcared as hex'...'
         return a str
         Returns:
@@ -59,25 +61,23 @@
         :return: str
         """
         return self._original_value
 
     def __str__(self) -> str:
         return str(self.value)
 
-    @property
-    def name(self) -> str:
-        return str(self)
-
-    def __eq__(self, other: Union["Constant", str]) -> bool:
+    def __eq__(self, other: object) -> bool:
         return self.value == other
 
-    def __ne__(self, other):
+    def __ne__(self, other: object) -> bool:
         return self.value != other
 
-    def __lt__(self, other):
-        return self.value < other
+    def __lt__(self, other: object) -> bool:
+        if not isinstance(other, (Constant, str)):
+            raise NotImplementedError
+        return self.value < other  # type: ignore
 
-    def __repr__(self):
+    def __repr__(self) -> str:
         return f"{str(self.value)}"
 
     def __hash__(self) -> int:
         return self._val.__hash__()
```

### Comparing `slither-analyzer-0.9.3/slither/slithir/variables/local_variable.py` & `slither-analyzer-0.9.4/slither/slithir/variables/local_variable.py`

 * *Files 3% similar despite different names*

```diff
@@ -37,19 +37,19 @@
         # keep un-ssa version
         if isinstance(local_variable, LocalIRVariable):
             self._non_ssa_version = local_variable.non_ssa_version
         else:
             self._non_ssa_version = local_variable
 
     @property
-    def index(self):
+    def index(self) -> int:
         return self._index
 
     @index.setter
-    def index(self, idx):
+    def index(self, idx: int) -> None:
         self._index = idx
 
     @property
     def refers_to(self):
         if self.is_storage:
             return self._refers_to
         return set()
```

### Comparing `slither-analyzer-0.9.3/slither/slithir/variables/reference.py` & `slither-analyzer-0.9.4/slither/slithir/variables/reference.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,29 +1,33 @@
 from typing import Optional, TYPE_CHECKING
 
-from slither.core.children.child_node import ChildNode
 from slither.core.declarations import Contract, Enum, SolidityVariable, Function
 from slither.core.variables.variable import Variable
+from slither.core.variables.top_level_variable import TopLevelVariable
 
 if TYPE_CHECKING:
     from slither.core.cfg.node import Node
 
 
-class ReferenceVariable(ChildNode, Variable):
+class ReferenceVariable(Variable):
     def __init__(self, node: "Node", index: Optional[int] = None) -> None:
         super().__init__()
         if index is None:
             self._index = node.compilation_unit.counter_slithir_reference
             node.compilation_unit.counter_slithir_reference += 1
         else:
             self._index = index
         self._points_to = None
         self._node = node
 
     @property
+    def node(self) -> "Node":
+        return self._node
+
+    @property
     def index(self):
         return self._index
 
     @index.setter
     def index(self, idx):
         self._index = idx
 
@@ -39,15 +43,15 @@
     def points_to(self, points_to):
         # Can only be a rvalue of
         # Member or Index operator
         # pylint: disable=import-outside-toplevel
         from slither.slithir.utils.utils import is_valid_lvalue
 
         assert is_valid_lvalue(points_to) or isinstance(
-            points_to, (SolidityVariable, Contract, Enum)
+            points_to, (SolidityVariable, Contract, Enum, TopLevelVariable)
         )
 
         self._points_to = points_to
 
     @property
     def points_to_origin(self):
         points = self.points_to
```

### Comparing `slither-analyzer-0.9.3/slither/slithir/variables/reference_ssa.py` & `slither-analyzer-0.9.4/slither/slithir/variables/reference_ssa.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/slithir/variables/state_variable.py` & `slither-analyzer-0.9.4/slither/slithir/variables/state_variable.py`

 * *Files 1% similar despite different names*

```diff
@@ -26,19 +26,19 @@
         # keep un-ssa version
         if isinstance(state_variable, StateIRVariable):
             self._non_ssa_version = state_variable.non_ssa_version
         else:
             self._non_ssa_version = state_variable
 
     @property
-    def index(self):
+    def index(self) -> int:
         return self._index
 
     @index.setter
-    def index(self, idx):
+    def index(self, idx: int) -> None:
         self._index = idx
 
     @property
     def non_ssa_version(self) -> StateVariable:
         return self._non_ssa_version
 
     @property
```

### Comparing `slither-analyzer-0.9.3/slither/slithir/variables/temporary.py` & `slither-analyzer-0.9.4/slither/slithir/variables/tuple.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,33 +1,37 @@
 from typing import Optional, TYPE_CHECKING
 
-from slither.core.children.child_node import ChildNode
-from slither.core.variables.variable import Variable
+from slither.slithir.variables.variable import SlithIRVariable
 
 if TYPE_CHECKING:
     from slither.core.cfg.node import Node
 
 
-class TemporaryVariable(ChildNode, Variable):
+class TupleVariable(SlithIRVariable):
     def __init__(self, node: "Node", index: Optional[int] = None) -> None:
         super().__init__()
         if index is None:
-            self._index = node.compilation_unit.counter_slithir_temporary
-            node.compilation_unit.counter_slithir_temporary += 1
+            self._index = node.compilation_unit.counter_slithir_tuple
+            node.compilation_unit.counter_slithir_tuple += 1
         else:
             self._index = index
+
         self._node = node
 
     @property
+    def node(self) -> "Node":
+        return self._node
+
+    @property
     def index(self):
         return self._index
 
     @index.setter
     def index(self, idx):
         self._index = idx
 
     @property
     def name(self) -> str:
-        return f"TMP_{self.index}"
+        return f"TUPLE_{self.index}"
 
     def __str__(self) -> str:
         return self.name
```

### Comparing `slither-analyzer-0.9.3/slither/slithir/variables/temporary_ssa.py` & `slither-analyzer-0.9.4/slither/slithir/variables/temporary_ssa.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/slithir/variables/tuple_ssa.py` & `slither-analyzer-0.9.4/slither/slithir/variables/tuple_ssa.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/solc_parsing/cfg/node.py` & `slither-analyzer-0.9.4/slither/solc_parsing/cfg/node.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/solc_parsing/declarations/caller_context.py` & `slither-analyzer-0.9.4/slither/solc_parsing/declarations/caller_context.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/solc_parsing/declarations/contract.py` & `slither-analyzer-0.9.4/slither/solc_parsing/declarations/contract.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,22 @@
 import logging
 import re
-from typing import Any, List, Dict, Callable, TYPE_CHECKING, Union, Set
+from typing import Any, List, Dict, Callable, TYPE_CHECKING, Union, Set, Sequence
 
-from slither.core.declarations import Modifier, Event, EnumContract, StructureContract, Function
-from slither.core.declarations.contract import Contract
+from slither.core.declarations import (
+    Modifier,
+    Event,
+    EnumContract,
+    StructureContract,
+    Function,
+)
+from slither.core.declarations.contract import Contract, USING_FOR_KEY
 from slither.core.declarations.custom_error_contract import CustomErrorContract
 from slither.core.declarations.function_contract import FunctionContract
-from slither.core.solidity_types import ElementaryType, TypeAliasContract, Type
+from slither.core.solidity_types import ElementaryType, TypeAliasContract
 from slither.core.variables.state_variable import StateVariable
 from slither.solc_parsing.declarations.caller_context import CallerContextExpression
 from slither.solc_parsing.declarations.custom_error import CustomErrorSolc
 from slither.solc_parsing.declarations.event import EventSolc
 from slither.solc_parsing.declarations.function import FunctionSolc
 from slither.solc_parsing.declarations.modifier import ModifierSolc
 from slither.solc_parsing.declarations.structure_contract import StructureContractSolc
@@ -160,18 +166,17 @@
         self._contract.is_interface = False
         if "contractKind" in attributes:
             if attributes["contractKind"] == "interface":
                 self._contract.is_interface = True
             elif attributes["contractKind"] == "library":
                 self._contract.is_library = True
             self._contract.contract_kind = attributes["contractKind"]
-            self._contract.is_fully_implemented = attributes["fullyImplemented"]
 
+        self._contract.is_fully_implemented = attributes["fullyImplemented"]
         self._linearized_base_contracts = attributes["linearizedBaseContracts"]
-        # self._contract.fullyImplemented = attributes["fullyImplemented"]
 
         # Parse base contract information
         self._parse_base_contract_info()
 
         # trufle does some re-mapping of id
         if "baseContracts" in self._data:
             for elem in self._data["baseContracts"]:
@@ -293,25 +298,25 @@
 
     def _parse_struct(self, struct: Dict) -> None:
 
         st = StructureContract(self._contract.compilation_unit)
         st.set_contract(self._contract)
         st.set_offset(struct["src"], self._contract.compilation_unit)
 
-        st_parser = StructureContractSolc(st, struct, self)
+        st_parser = StructureContractSolc(st, struct, self)  # type: ignore
         self._contract.structures_as_dict[st.name] = st
         self._structures_parser.append(st_parser)
 
     def parse_structs(self) -> None:
         for father in self._contract.inheritance_reverse:
             self._contract.structures_as_dict.update(father.structures_as_dict)
 
         for struct in self._structuresNotParsed:
             self._parse_struct(struct)
-        self._structuresNotParsed = None
+        self._structuresNotParsed = []
 
     def _parse_custom_error(self, custom_error: Dict) -> None:
         ce = CustomErrorContract(self.compilation_unit)
         ce.set_contract(self._contract)
         ce.set_offset(custom_error["src"], self.compilation_unit)
 
         ce_parser = CustomErrorSolc(ce, custom_error, self._slither_parser)
@@ -320,15 +325,15 @@
 
     def parse_custom_errors(self) -> None:
         for father in self._contract.inheritance_reverse:
             self._contract.custom_errors_as_dict.update(father.custom_errors_as_dict)
 
         for custom_error in self._customErrorParsed:
             self._parse_custom_error(custom_error)
-        self._customErrorParsed = None
+        self._customErrorParsed = []
 
     def parse_state_variables(self) -> None:
         for father in self._contract.inheritance_reverse:
             self._contract.variables_as_dict.update(
                 {
                     name: v
                     for name, v in father.variables_as_dict.items()
@@ -347,54 +352,55 @@
             var = StateVariable()
             var.set_offset(varNotParsed["src"], self._contract.compilation_unit)
             var.set_contract(self._contract)
 
             var_parser = StateVariableSolc(var, varNotParsed)
             self._variables_parser.append(var_parser)
 
+            assert var.name
             self._contract.variables_as_dict[var.name] = var
             self._contract.add_variables_ordered([var])
 
     def _parse_modifier(self, modifier_data: Dict) -> None:
         modif = Modifier(self._contract.compilation_unit)
         modif.set_offset(modifier_data["src"], self._contract.compilation_unit)
         modif.set_contract(self._contract)
         modif.set_contract_declarer(self._contract)
 
-        modif_parser = ModifierSolc(modif, modifier_data, self, self.slither_parser)
+        modif_parser = ModifierSolc(modif, modifier_data, self, self.slither_parser)  # type: ignore
         self._contract.compilation_unit.add_modifier(modif)
         self._modifiers_no_params.append(modif_parser)
         self._modifiers_parser.append(modif_parser)
 
         self._slither_parser.add_function_or_modifier_parser(modif_parser)
 
     def parse_modifiers(self) -> None:
         for modifier in self._modifiersNotParsed:
             self._parse_modifier(modifier)
-        self._modifiersNotParsed = None
+        self._modifiersNotParsed = []
 
     def _parse_function(self, function_data: Dict) -> None:
         func = FunctionContract(self._contract.compilation_unit)
         func.set_offset(function_data["src"], self._contract.compilation_unit)
         func.set_contract(self._contract)
         func.set_contract_declarer(self._contract)
 
-        func_parser = FunctionSolc(func, function_data, self, self._slither_parser)
+        func_parser = FunctionSolc(func, function_data, self, self._slither_parser)  # type: ignore
         self._contract.compilation_unit.add_function(func)
         self._functions_no_params.append(func_parser)
         self._functions_parser.append(func_parser)
 
         self._slither_parser.add_function_or_modifier_parser(func_parser)
 
     def parse_functions(self) -> None:
 
         for function in self._functionsNotParsed:
             self._parse_function(function)
 
-        self._functionsNotParsed = None
+        self._functionsNotParsed = []
 
     # endregion
     ###################################################################################
     ###################################################################################
     # region Analyze
     ###################################################################################
     ###################################################################################
@@ -430,15 +436,16 @@
                 elements_no_params,
                 getter,
                 getter_available,
                 Cls,
                 Cls_parser,
                 self._modifiers_parser,
             )
-            self._contract.set_modifiers(modifiers)
+            # modifiers will be using Modifier so we can ignore the next type check
+            self._contract.set_modifiers(modifiers)  # type: ignore
         except (VariableNotFound, KeyError) as e:
             self.log_incorrect_parsing(f"Missing params {e}")
         self._modifiers_no_params = []
 
     def analyze_params_functions(self) -> None:
         try:
             elements_no_params = self._functions_no_params
@@ -450,26 +457,27 @@
                 elements_no_params,
                 getter,
                 getter_available,
                 Cls,
                 Cls_parser,
                 self._functions_parser,
             )
-            self._contract.set_functions(functions)
+            # function will be using FunctionContract so we can ignore the next type check
+            self._contract.set_functions(functions)  # type: ignore
         except (VariableNotFound, KeyError) as e:
             self.log_incorrect_parsing(f"Missing params {e}")
         self._functions_no_params = []
 
     def _analyze_params_element(  # pylint: disable=too-many-arguments
         self,
         Cls: Callable,
         Cls_parser: Callable,
         element_parser: FunctionSolc,
         explored_reference_id: Set[str],
-        parser: List[FunctionSolc],
+        parser: Union[List[FunctionSolc], List[ModifierSolc]],
         all_elements: Dict[str, Function],
     ) -> None:
         elem = Cls(self._contract.compilation_unit)
         elem.set_contract(self._contract)
         underlying_function = element_parser.underlying_function
         # TopLevel function are not analyzed here
         assert isinstance(underlying_function, FunctionContract)
@@ -499,39 +507,39 @@
         self._slither_parser.add_function_or_modifier_parser(elem_parser)
 
         all_elements[elem.canonical_name] = elem
         parser.append(elem_parser)
 
     def _analyze_params_elements(  # pylint: disable=too-many-arguments,too-many-locals
         self,
-        elements_no_params: List[FunctionSolc],
+        elements_no_params: Sequence[FunctionSolc],
         getter: Callable[["ContractSolc"], List[FunctionSolc]],
         getter_available: Callable[[Contract], List[FunctionContract]],
         Cls: Callable,
         Cls_parser: Callable,
-        parser: List[FunctionSolc],
-    ) -> Dict[str, Union[FunctionContract, Modifier]]:
+        parser: Union[List[FunctionSolc], List[ModifierSolc]],
+    ) -> Dict[str, Function]:
         """
         Analyze the parameters of the given elements (Function or Modifier).
         The function iterates over the inheritance to create an instance or inherited elements (Function or Modifier)
         If the element is shadowed, set is_shadowed to True
 
         :param elements_no_params: list of elements to analyzer
         :param getter: fun x
         :param getter_available: fun x
         :param Cls: Class to create for collision
         :return:
         """
-        all_elements = {}
+        all_elements: Dict[str, Function] = {}
 
-        explored_reference_id = set()
+        explored_reference_id: Set[str] = set()
         try:
             for father in self._contract.inheritance:
                 father_parser = self._slither_parser.underlying_contract_to_parser[father]
-                for element_parser in getter(father_parser):
+                for element_parser in getter(father_parser):  # type: ignore
                     self._analyze_params_element(
                         Cls, Cls_parser, element_parser, explored_reference_id, parser, all_elements
                     )
 
             accessible_elements = self._contract.available_elements_from_inheritances(
                 all_elements, getter_available
             )
@@ -588,15 +596,15 @@
     def analyze_using_for(self) -> None:  # pylint: disable=too-many-branches
         try:
             for father in self._contract.inheritance:
                 self._contract.using_for.update(father.using_for)
             if self.is_compact_ast:
                 for using_for in self._usingForNotParsed:
                     if "typeName" in using_for and using_for["typeName"]:
-                        type_name = parse_type(using_for["typeName"], self)
+                        type_name: USING_FOR_KEY = parse_type(using_for["typeName"], self)
                     else:
                         type_name = "*"
                     if type_name not in self._contract.using_for:
                         self._contract.using_for[type_name] = []
 
                     if "libraryName" in using_for:
                         self._contract.using_for[type_name].append(
@@ -607,26 +615,26 @@
                         self._analyze_function_list(using_for["functionList"], type_name)
             else:
                 for using_for in self._usingForNotParsed:
                     children = using_for[self.get_children()]
                     assert children and len(children) <= 2
                     if len(children) == 2:
                         new = parse_type(children[0], self)
-                        old = parse_type(children[1], self)
+                        old: USING_FOR_KEY = parse_type(children[1], self)
                     else:
                         new = parse_type(children[0], self)
                         old = "*"
                     if old not in self._contract.using_for:
                         self._contract.using_for[old] = []
                     self._contract.using_for[old].append(new)
             self._usingForNotParsed = []
         except (VariableNotFound, KeyError) as e:
             self.log_incorrect_parsing(f"Missing using for {e}")
 
-    def _analyze_function_list(self, function_list: List, type_name: Type) -> None:
+    def _analyze_function_list(self, function_list: List, type_name: USING_FOR_KEY) -> None:
         for f in function_list:
             full_name_split = f["function"]["name"].split(".")
             if len(full_name_split) == 1:
                 # Top level function
                 function_name = full_name_split[0]
                 self._analyze_top_level_function(function_name, type_name)
             elif len(full_name_split) == 2:
@@ -637,31 +645,33 @@
                 self._check_aliased_import(first_part, function_name, type_name)
             else:
                 # MyImport.MyLib.a we don't care of the alias
                 library_name = full_name_split[1]
                 function_name = full_name_split[2]
                 self._analyze_library_function(library_name, function_name, type_name)
 
-    def _check_aliased_import(self, first_part: str, function_name: str, type_name: Type) -> None:
+    def _check_aliased_import(
+        self, first_part: str, function_name: str, type_name: USING_FOR_KEY
+    ) -> None:
         # We check if the first part appear as alias for an import
         # if it is then function_name must be a top level function
         # otherwise it's a library function
         for i in self._contract.file_scope.imports:
             if i.alias == first_part:
                 self._analyze_top_level_function(function_name, type_name)
                 return
         self._analyze_library_function(first_part, function_name, type_name)
 
-    def _analyze_top_level_function(self, function_name: str, type_name: Type) -> None:
+    def _analyze_top_level_function(self, function_name: str, type_name: USING_FOR_KEY) -> None:
         for tl_function in self.compilation_unit.functions_top_level:
             if tl_function.name == function_name:
                 self._contract.using_for[type_name].append(tl_function)
 
     def _analyze_library_function(
-        self, library_name: str, function_name: str, type_name: Type
+        self, library_name: str, function_name: str, type_name: USING_FOR_KEY
     ) -> None:
         # Get the library function
         found = False
         for c in self.compilation_unit.contracts:
             if found:
                 break
             if c.name == library_name:
@@ -680,30 +690,21 @@
             for father in self._contract.inheritance:
                 self._contract.enums_as_dict.update(father.enums_as_dict)
 
             for enum in self._enumsNotParsed:
                 # for enum, we can parse and analyze it
                 # at the same time
                 self._analyze_enum(enum)
-            self._enumsNotParsed = None
+            self._enumsNotParsed = []
         except (VariableNotFound, KeyError) as e:
             self.log_incorrect_parsing(f"Missing enum {e}")
 
     def _analyze_enum(
         self,
-        enum: Dict[
-            str,
-            Union[
-                str,
-                int,
-                List[Dict[str, Union[int, str]]],
-                Dict[str, str],
-                List[Dict[str, Union[Dict[str, str], int, str]]],
-            ],
-        ],
+        enum: Dict,
     ) -> None:
         # Enum can be parsed in one pass
         if self.is_compact_ast:
             name = enum["name"]
             canonicalName = enum["canonicalName"]
         else:
             name = enum["attributes"][self.get_key()]
@@ -744,30 +745,30 @@
                 self._contract.events_as_dict.update(father.events_as_dict)
 
             for event_to_parse in self._eventsNotParsed:
                 event = Event()
                 event.set_contract(self._contract)
                 event.set_offset(event_to_parse["src"], self._contract.compilation_unit)
 
-                event_parser = EventSolc(event, event_to_parse, self)
-                event_parser.analyze(self)
+                event_parser = EventSolc(event, event_to_parse, self)  # type: ignore
+                event_parser.analyze(self)  # type: ignore
                 self._contract.events_as_dict[event.full_name] = event
         except (VariableNotFound, KeyError) as e:
             self.log_incorrect_parsing(f"Missing event {e}")
 
-        self._eventsNotParsed = None
+        self._eventsNotParsed = []
 
     # endregion
     ###################################################################################
     ###################################################################################
     # region Internal
     ###################################################################################
     ###################################################################################
 
-    def delete_content(self):
+    def delete_content(self) -> None:
         """
         Remove everything not parsed from the contract
         This is used only if something went wrong with the inheritance parsing
         :return:
         """
         self._functionsNotParsed = []
         self._modifiersNotParsed = []
@@ -824,11 +825,11 @@
     # endregion
     ###################################################################################
     ###################################################################################
     # region Built in definitions
     ###################################################################################
     ###################################################################################
 
-    def __hash__(self):
+    def __hash__(self) -> int:
         return self._contract.id
 
     # endregion
```

### Comparing `slither-analyzer-0.9.3/slither/solc_parsing/declarations/custom_error.py` & `slither-analyzer-0.9.4/slither/solc_parsing/declarations/custom_error.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/solc_parsing/declarations/event.py` & `slither-analyzer-0.9.4/slither/solc_parsing/declarations/event.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/solc_parsing/declarations/function.py` & `slither-analyzer-0.9.4/slither/solc_parsing/declarations/function.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 import logging
-from typing import Dict, Optional, Union, List, TYPE_CHECKING, Tuple
+from typing import Dict, Optional, Union, List, TYPE_CHECKING, Tuple, Set
 
 from slither.core.cfg.node import NodeType, link_nodes, insert_node, Node
 from slither.core.cfg.scope import Scope
 from slither.core.declarations.contract import Contract
 from slither.core.declarations.function import (
     Function,
     ModifierStatements,
@@ -238,15 +238,15 @@
                 self._function.visibility = "private"
         else:
             self._function.visibility = "public"
 
         if "payable" in attributes:
             self._function.payable = attributes["payable"]
 
-    def analyze_params(self):
+    def analyze_params(self) -> None:
         # Can be re-analyzed due to inheritance
         if self._params_was_analyzed:
             return
 
         self._params_was_analyzed = True
 
         self._analyze_attributes()
@@ -268,15 +268,15 @@
             returns = next(child_iter)
 
         if params:
             self._parse_params(params)
         if returns:
             self._parse_returns(returns)
 
-    def analyze_content(self):
+    def analyze_content(self) -> None:
         if self._content_was_analyzed:
             return
 
         self._content_was_analyzed = True
 
         if self.is_compact_ast:
             body = self._functionNotParsed.get("body", None)
@@ -304,16 +304,16 @@
 
         for local_var_parser in self._local_variables_parser:
             local_var_parser.analyze(self)
 
         for node_parser in self._node_to_nodesolc.values():
             node_parser.analyze_expressions(self)
 
-        for node_parser in self._node_to_yulobject.values():
-            node_parser.analyze_expressions()
+        for yul_parser in self._node_to_yulobject.values():
+            yul_parser.analyze_expressions()
 
         self._rewrite_ternary_as_if_else()
 
         self._remove_alone_endif()
 
     # endregion
     ###################################################################################
@@ -350,95 +350,77 @@
     # endregion
     ###################################################################################
     ###################################################################################
     # region Parsing function
     ###################################################################################
     ###################################################################################
 
-    def _parse_if(self, if_statement: Dict, node: NodeSolc) -> NodeSolc:
+    def _parse_if(self, if_statement: Dict, node: NodeSolc, scope: Scope) -> NodeSolc:
         # IfStatement = 'if' '(' Expression ')' Statement ( 'else' Statement )?
         falseStatement = None
 
         if self.is_compact_ast:
             condition = if_statement["condition"]
             # Note: check if the expression could be directly
             # parsed here
-            condition_node = self._new_node(
-                NodeType.IF, condition["src"], node.underlying_node.scope
-            )
+            condition_node = self._new_node(NodeType.IF, condition["src"], scope)
             condition_node.add_unparsed_expression(condition)
             link_underlying_nodes(node, condition_node)
-            true_scope = Scope(
-                node.underlying_node.scope.is_checked, False, node.underlying_node.scope
-            )
+            true_scope = Scope(scope.is_checked, False, scope)
             trueStatement = self._parse_statement(
                 if_statement["trueBody"], condition_node, true_scope
             )
             if "falseBody" in if_statement and if_statement["falseBody"]:
-                false_scope = Scope(
-                    node.underlying_node.scope.is_checked, False, node.underlying_node.scope
-                )
+                false_scope = Scope(scope.is_checked, False, scope)
                 falseStatement = self._parse_statement(
                     if_statement["falseBody"], condition_node, false_scope
                 )
         else:
             children = if_statement[self.get_children("children")]
             condition = children[0]
             # Note: check if the expression could be directly
             # parsed here
-            condition_node = self._new_node(
-                NodeType.IF, condition["src"], node.underlying_node.scope
-            )
+            condition_node = self._new_node(NodeType.IF, condition["src"], scope)
             condition_node.add_unparsed_expression(condition)
             link_underlying_nodes(node, condition_node)
-            true_scope = Scope(
-                node.underlying_node.scope.is_checked, False, node.underlying_node.scope
-            )
+            true_scope = Scope(scope.is_checked, False, scope)
             trueStatement = self._parse_statement(children[1], condition_node, true_scope)
             if len(children) == 3:
-                false_scope = Scope(
-                    node.underlying_node.scope.is_checked, False, node.underlying_node.scope
-                )
+                false_scope = Scope(scope.is_checked, False, scope)
                 falseStatement = self._parse_statement(children[2], condition_node, false_scope)
 
-        endIf_node = self._new_node(NodeType.ENDIF, if_statement["src"], node.underlying_node.scope)
+        endIf_node = self._new_node(NodeType.ENDIF, if_statement["src"], scope)
         link_underlying_nodes(trueStatement, endIf_node)
 
         if falseStatement:
             link_underlying_nodes(falseStatement, endIf_node)
         else:
             link_underlying_nodes(condition_node, endIf_node)
         return endIf_node
 
-    def _parse_while(self, whilte_statement: Dict, node: NodeSolc) -> NodeSolc:
+    def _parse_while(self, whilte_statement: Dict, node: NodeSolc, scope: Scope) -> NodeSolc:
         # WhileStatement = 'while' '(' Expression ')' Statement
 
-        node_startWhile = self._new_node(
-            NodeType.STARTLOOP, whilte_statement["src"], node.underlying_node.scope
-        )
+        node_startWhile = self._new_node(NodeType.STARTLOOP, whilte_statement["src"], scope)
 
-        body_scope = Scope(node.underlying_node.scope.is_checked, False, node.underlying_node.scope)
+        body_scope = Scope(scope.is_checked, False, scope)
         if self.is_compact_ast:
             node_condition = self._new_node(
-                NodeType.IFLOOP, whilte_statement["condition"]["src"], node.underlying_node.scope
+                NodeType.IFLOOP, whilte_statement["condition"]["src"], scope
             )
             node_condition.add_unparsed_expression(whilte_statement["condition"])
             statement = self._parse_statement(whilte_statement["body"], node_condition, body_scope)
         else:
             children = whilte_statement[self.get_children("children")]
             expression = children[0]
-            node_condition = self._new_node(
-                NodeType.IFLOOP, expression["src"], node.underlying_node.scope
-            )
+            node_condition = self._new_node(NodeType.IFLOOP, expression["src"], scope)
             node_condition.add_unparsed_expression(expression)
             statement = self._parse_statement(children[1], node_condition, body_scope)
 
-        node_endWhile = self._new_node(
-            NodeType.ENDLOOP, whilte_statement["src"], node.underlying_node.scope
-        )
+        node_endWhile = self._new_node(NodeType.ENDLOOP, whilte_statement["src"], scope)
 
         link_underlying_nodes(node, node_startWhile)
         link_underlying_nodes(node_startWhile, node_condition)
         link_underlying_nodes(statement, node_condition)
         link_underlying_nodes(node_condition, node_endWhile)
 
         return node_endWhile
@@ -558,52 +540,48 @@
                     if len(children) == 2:
                         pre, cond, post = None, children[0], None
                     else:
                         pre, cond, post = None, children[0], children[1]
 
         return pre, cond, post, body
 
-    def _parse_for(self, statement: Dict, node: NodeSolc) -> NodeSolc:
+    def _parse_for(self, statement: Dict, node: NodeSolc, scope: Scope) -> NodeSolc:
         # ForStatement = 'for' '(' (SimpleStatement)? ';' (Expression)? ';' (ExpressionStatement)? ')' Statement
 
         if self.is_compact_ast:
             pre, cond, post, body = self._parse_for_compact_ast(statement)
         else:
             pre, cond, post, body = self._parse_for_legacy_ast(statement)
 
-        node_startLoop = self._new_node(
-            NodeType.STARTLOOP, statement["src"], node.underlying_node.scope
-        )
-        node_endLoop = self._new_node(
-            NodeType.ENDLOOP, statement["src"], node.underlying_node.scope
-        )
+        node_startLoop = self._new_node(NodeType.STARTLOOP, statement["src"], scope)
+        node_endLoop = self._new_node(NodeType.ENDLOOP, statement["src"], scope)
 
-        last_scope = node.underlying_node.scope
+        last_scope = scope
 
         if pre:
-            pre_scope = Scope(node.underlying_node.scope.is_checked, False, last_scope)
+            pre_scope = Scope(scope.is_checked, False, last_scope)
             last_scope = pre_scope
             node_init_expression = self._parse_statement(pre, node, pre_scope)
             link_underlying_nodes(node_init_expression, node_startLoop)
         else:
             link_underlying_nodes(node, node_startLoop)
 
         if cond:
-            cond_scope = Scope(node.underlying_node.scope.is_checked, False, last_scope)
+            cond_scope = Scope(scope.is_checked, False, last_scope)
             last_scope = cond_scope
             node_condition = self._new_node(NodeType.IFLOOP, cond["src"], cond_scope)
             node_condition.add_unparsed_expression(cond)
             link_underlying_nodes(node_startLoop, node_condition)
 
             node_beforeBody = node_condition
         else:
             node_condition = None
             node_beforeBody = node_startLoop
 
-        body_scope = Scope(node.underlying_node.scope.is_checked, False, last_scope)
+        body_scope = Scope(scope.is_checked, False, last_scope)
         last_scope = body_scope
         node_body = self._parse_statement(body, node_beforeBody, body_scope)
 
         if post:
             node_loopexpression = self._parse_statement(post, node_body, last_scope)
             link_underlying_nodes(node_loopexpression, node_beforeBody)
         else:
@@ -615,22 +593,18 @@
         else:
             link_underlying_nodes(
                 node_startLoop, node_endLoop
             )  # this is an infinite loop but we can't break our cfg
 
         return node_endLoop
 
-    def _parse_dowhile(self, do_while_statement: Dict, node: NodeSolc) -> NodeSolc:
+    def _parse_dowhile(self, do_while_statement: Dict, node: NodeSolc, scope: Scope) -> NodeSolc:
 
-        node_startDoWhile = self._new_node(
-            NodeType.STARTLOOP, do_while_statement["src"], node.underlying_node.scope
-        )
-        condition_scope = Scope(
-            node.underlying_node.scope.is_checked, False, node.underlying_node.scope
-        )
+        node_startDoWhile = self._new_node(NodeType.STARTLOOP, do_while_statement["src"], scope)
+        condition_scope = Scope(scope.is_checked, False, scope)
 
         if self.is_compact_ast:
             node_condition = self._new_node(
                 NodeType.IFLOOP, do_while_statement["condition"]["src"], condition_scope
             )
             node_condition.add_unparsed_expression(do_while_statement["condition"])
             statement = self._parse_statement(
@@ -640,15 +614,15 @@
             children = do_while_statement[self.get_children("children")]
             # same order in the AST as while
             expression = children[0]
             node_condition = self._new_node(NodeType.IFLOOP, expression["src"], condition_scope)
             node_condition.add_unparsed_expression(expression)
             statement = self._parse_statement(children[1], node_condition, condition_scope)
 
-        body_scope = Scope(node.underlying_node.scope.is_checked, False, condition_scope)
+        body_scope = Scope(scope.is_checked, False, condition_scope)
         node_endDoWhile = self._new_node(NodeType.ENDLOOP, do_while_statement["src"], body_scope)
 
         link_underlying_nodes(node, node_startDoWhile)
         # empty block, loop from the start to the condition
         if not node_condition.underlying_node.sons:
             link_underlying_nodes(node_startDoWhile, node_condition)
         else:
@@ -656,66 +630,142 @@
                 node_startDoWhile.underlying_node,
                 node_condition.underlying_node.sons[0],
             )
         link_underlying_nodes(statement, node_condition)
         link_underlying_nodes(node_condition, node_endDoWhile)
         return node_endDoWhile
 
-    def _parse_try_catch(self, statement: Dict, node: NodeSolc) -> NodeSolc:
+    # pylint: disable=no-self-use
+    def _construct_try_expression(self, externalCall: Dict, parameters_list: Dict) -> Dict:
+        # if the parameters are more than 1 we make the leftHandSide of the Assignment node
+        # a TupleExpression otherwise an Identifier
+
+        # case when there isn't returns(...)
+        # e.g. external call that doesn't have any return variable
+        if not parameters_list:
+            return externalCall
+
+        ret: Dict = {"nodeType": "Assignment", "operator": "=", "src": parameters_list["src"]}
+
+        parameters = parameters_list.get("parameters", None)
+
+        # if the name is "" it means the return variable is not used
+        if len(parameters) == 1:
+            if parameters[0]["name"] != "":
+                self._add_param(parameters[0])
+                ret["typeDescriptions"] = {
+                    "typeString": parameters[0]["typeName"]["typeDescriptions"]["typeString"]
+                }
+                leftHandSide = {
+                    "name": parameters[0]["name"],
+                    "nodeType": "Identifier",
+                    "src": parameters[0]["src"],
+                    "referencedDeclaration": parameters[0]["id"],
+                    "typeDescriptions": parameters[0]["typeDescriptions"],
+                }
+            else:
+                # we don't need an Assignment so we return only the external call
+                return externalCall
+        else:
+            ret["typeDescriptions"] = {"typeString": "tuple()"}
+            leftHandSide = {
+                "components": [],
+                "nodeType": "TupleExpression",
+                "src": parameters_list["src"],
+            }
+
+            for i, p in enumerate(parameters):
+                if p["name"] == "":
+                    continue
+
+                new_statement = {
+                    "nodeType": "VariableDefinitionStatement",
+                    "src": p["src"],
+                    "declarations": [p],
+                }
+                self._add_param_init_tuple(new_statement, i)
+
+                ident = {
+                    "name": p["name"],
+                    "nodeType": "Identifier",
+                    "src": p["src"],
+                    "referencedDeclaration": p["id"],
+                    "typeDescriptions": p["typeDescriptions"],
+                }
+                leftHandSide["components"].append(ident)
+
+        ret["leftHandSide"] = leftHandSide
+        ret["rightHandSide"] = externalCall
+
+        return ret
+
+    def _parse_try_catch(self, statement: Dict, node: NodeSolc, scope: Scope) -> NodeSolc:
         externalCall = statement.get("externalCall", None)
 
         if externalCall is None:
             raise ParsingError(f"Try/Catch not correctly parsed by Slither {statement}")
-        catch_scope = Scope(
-            node.underlying_node.scope.is_checked, False, node.underlying_node.scope
-        )
+        catch_scope = Scope(scope.is_checked, False, scope)
         new_node = self._new_node(NodeType.TRY, statement["src"], catch_scope)
-        new_node.add_unparsed_expression(externalCall)
+        clauses = statement.get("clauses", [])
+        # the first clause is the try scope
+        returned_variables = clauses[0].get("parameters", None)
+        constructed_try_expression = self._construct_try_expression(
+            externalCall, returned_variables
+        )
+        new_node.add_unparsed_expression(constructed_try_expression)
         link_underlying_nodes(node, new_node)
         node = new_node
 
-        for clause in statement.get("clauses", []):
-            self._parse_catch(clause, node)
+        for index, clause in enumerate(clauses):
+            # clauses after the first one are related to catch cases
+            # we set the parameters (e.g. data in this case. catch(string memory data) ...)
+            # to be initialized so they are not reported by the uninitialized-local-variables detector
+            if index >= 1:
+                self._parse_catch(clause, node, catch_scope, True)
+            else:
+                # the parameters for the try scope were already added in _construct_try_expression
+                self._parse_catch(clause, node, catch_scope, False)
         return node
 
-    def _parse_catch(self, statement: Dict, node: NodeSolc) -> NodeSolc:
+    def _parse_catch(
+        self, statement: Dict, node: NodeSolc, scope: Scope, add_param: bool
+    ) -> NodeSolc:
         block = statement.get("block", None)
 
         if block is None:
             raise ParsingError(f"Catch not correctly parsed by Slither {statement}")
-        try_scope = Scope(node.underlying_node.scope.is_checked, False, node.underlying_node.scope)
+        try_scope = Scope(scope.is_checked, False, scope)
 
         try_node = self._new_node(NodeType.CATCH, statement["src"], try_scope)
         link_underlying_nodes(node, try_node)
 
-        if self.is_compact_ast:
-            params = statement.get("parameters", None)
-        else:
-            params = statement[self.get_children("children")]
+        if add_param:
+            if self.is_compact_ast:
+                params = statement.get("parameters", None)
+            else:
+                params = statement[self.get_children("children")]
 
-        if params:
-            for param in params.get("parameters", []):
-                assert param[self.get_key()] == "VariableDeclaration"
-                self._add_param(param)
+            if params:
+                for param in params.get("parameters", []):
+                    assert param[self.get_key()] == "VariableDeclaration"
+                    self._add_param(param, True)
 
         return self._parse_statement(block, try_node, try_scope)
 
-    def _parse_variable_definition(self, statement: Dict, node: NodeSolc) -> NodeSolc:
+    def _parse_variable_definition(self, statement: Dict, node: NodeSolc, scope: Scope) -> NodeSolc:
         try:
             local_var = LocalVariable()
             local_var.set_function(self._function)
             local_var.set_offset(statement["src"], self._function.compilation_unit)
 
             local_var_parser = LocalVariableSolc(local_var, statement)
             self._add_local_variable(local_var_parser)
             # local_var.analyze(self)
 
-            new_node = self._new_node(
-                NodeType.VARIABLE, statement["src"], node.underlying_node.scope
-            )
+            new_node = self._new_node(NodeType.VARIABLE, statement["src"], scope)
             new_node.underlying_node.add_variable_declaration(local_var)
             link_underlying_nodes(node, new_node)
             return new_node
         except MultipleVariablesDeclaration:
             # Custom handling of var (a,b) = .. style declaration
             if self.is_compact_ast:
                 variables = statement["declarations"]
@@ -737,15 +787,15 @@
 
                         new_statement = {
                             "nodeType": "VariableDefinitionStatement",
                             "src": src,
                             "declarations": [variable],
                             "initialValue": init,
                         }
-                        new_node = self._parse_variable_definition(new_statement, new_node)
+                        new_node = self._parse_variable_definition(new_statement, new_node, scope)
 
                 else:
                     # If we have
                     # var (a, b) = f()
                     # we can split in multiple declarations, without init
                     # Then we craft one expression that does the assignment
                     variables = []
@@ -759,25 +809,26 @@
                                 "nodeType": "VariableDefinitionStatement",
                                 "src": src,
                                 "declarations": [variable],
                             }
                             variables.append(variable)
 
                             new_node = self._parse_variable_definition_init_tuple(
-                                new_statement, i, new_node
+                                new_statement, i, new_node, scope
                             )
                         i = i + 1
 
                     var_identifiers = []
                     # craft of the expression doing the assignement
                     for v in variables:
                         identifier = {
                             "nodeType": "Identifier",
                             "src": v["src"],
                             "name": v["name"],
+                            "referencedDeclaration": v["id"],
                             "typeDescriptions": {"typeString": v["typeDescriptions"]["typeString"]},
                         }
                         var_identifiers.append(identifier)
 
                     tuple_expression = {
                         "nodeType": "TupleExpression",
                         "src": statement["src"],
@@ -790,17 +841,15 @@
                         "operator": "=",
                         "type": "tuple()",
                         "leftHandSide": tuple_expression,
                         "rightHandSide": statement["initialValue"],
                         "typeDescriptions": {"typeString": "tuple()"},
                     }
                     node = new_node
-                    new_node = self._new_node(
-                        NodeType.EXPRESSION, statement["src"], node.underlying_node.scope
-                    )
+                    new_node = self._new_node(NodeType.EXPRESSION, statement["src"], scope)
                     new_node.add_unparsed_expression(expression)
                     link_underlying_nodes(node, new_node)
 
             else:
                 count = 0
                 children = statement[self.get_children("children")]
                 child = children[0]
@@ -823,15 +872,15 @@
                         # Create a fake statement to be consistent
                         new_statement = {
                             self.get_key(): "VariableDefinitionStatement",
                             "src": src,
                             self.get_children("children"): [variable, init],
                         }
 
-                        new_node = self._parse_variable_definition(new_statement, new_node)
+                        new_node = self._parse_variable_definition(new_statement, new_node, scope)
                 else:
                     # If we have
                     # var (a, b) = f()
                     # we can split in multiple declarations, without init
                     # Then we craft one expression that does the assignment
                     assert tuple_vars[self.get_key()] in ["FunctionCall", "Conditional"]
                     variables = []
@@ -842,15 +891,15 @@
                             self.get_key(): "VariableDefinitionStatement",
                             "src": src,
                             self.get_children("children"): [variable],
                         }
                         variables.append(variable)
 
                         new_node = self._parse_variable_definition_init_tuple(
-                            new_statement, i, new_node
+                            new_statement, i, new_node, scope
                         )
                         i = i + 1
                     var_identifiers = []
                     # craft of the expression doing the assignement
                     for v in variables:
                         identifier = {
                             self.get_key(): "Identifier",
@@ -872,34 +921,32 @@
                                 "src": statement["src"],
                                 self.get_children("children"): var_identifiers,
                             },
                             tuple_vars,
                         ],
                     }
                     node = new_node
-                    new_node = self._new_node(
-                        NodeType.EXPRESSION, statement["src"], node.underlying_node.scope
-                    )
+                    new_node = self._new_node(NodeType.EXPRESSION, statement["src"], scope)
                     new_node.add_unparsed_expression(expression)
                     link_underlying_nodes(node, new_node)
 
             return new_node
 
     def _parse_variable_definition_init_tuple(
-        self, statement: Dict, index: int, node: NodeSolc
+        self, statement: Dict, index: int, node: NodeSolc, scope
     ) -> NodeSolc:
         local_var = LocalVariableInitFromTuple()
         local_var.set_function(self._function)
         local_var.set_offset(statement["src"], self._function.compilation_unit)
 
         local_var_parser = LocalVariableInitFromTupleSolc(local_var, statement, index)
 
         self._add_local_variable(local_var_parser)
 
-        new_node = self._new_node(NodeType.VARIABLE, statement["src"], node.underlying_node.scope)
+        new_node = self._new_node(NodeType.VARIABLE, statement["src"], scope)
         new_node.underlying_node.add_variable_declaration(local_var)
         link_underlying_nodes(node, new_node)
         return new_node
 
     def _parse_statement(
         self, statement: Dict, node: NodeSolc, scope: Union[Scope, Function]
     ) -> NodeSolc:
@@ -912,23 +959,23 @@
         #            ( DoWhileStatement | PlaceholderStatement | Continue | Break | Return |
         #                          Throw | EmitStatement | SimpleStatement ) ';'
         # SimpleStatement = VariableDefinition | ExpressionStatement
 
         name = statement[self.get_key()]
         # SimpleStatement = VariableDefinition | ExpressionStatement
         if name == "IfStatement":
-            node = self._parse_if(statement, node)
+            node = self._parse_if(statement, node, scope)
         elif name == "WhileStatement":
-            node = self._parse_while(statement, node)
+            node = self._parse_while(statement, node, scope)
         elif name == "ForStatement":
-            node = self._parse_for(statement, node)
+            node = self._parse_for(statement, node, scope)
         elif name == "Block":
-            node = self._parse_block(statement, node)
+            node = self._parse_block(statement, node, scope)
         elif name == "UncheckedBlock":
-            node = self._parse_unchecked_block(statement, node)
+            node = self._parse_unchecked_block(statement, node, scope)
         elif name == "InlineAssembly":
             # Added with solc 0.6 - the yul code is an AST
             if "AST" in statement and not self.compilation_unit.core.skip_assembly:
                 self._function.contains_assembly = True
                 yul_object = self._new_yul_block(statement["src"], scope)
                 entrypoint = yul_object.entrypoint
                 exitpoint = yul_object.convert(statement["AST"])
@@ -942,15 +989,15 @@
                 self._function.contains_assembly = True
                 # Added with solc 0.4.12
                 if "operations" in statement:
                     asm_node.underlying_node.add_inline_asm(statement["operations"])
                 link_underlying_nodes(node, asm_node)
                 node = asm_node
         elif name == "DoWhileStatement":
-            node = self._parse_dowhile(statement, node)
+            node = self._parse_dowhile(statement, node, scope)
         # For Continue / Break / Return / Throw
         # The is fixed later
         elif name == "Continue":
             continue_node = self._new_node(NodeType.CONTINUE, statement["src"], scope)
             link_underlying_nodes(node, continue_node)
             node = continue_node
         elif name == "Break":
@@ -983,29 +1030,29 @@
             else:
                 expression = statement[self.get_children("children")][0]
             new_node = self._new_node(NodeType.EXPRESSION, statement["src"], scope)
             new_node.add_unparsed_expression(expression)
             link_underlying_nodes(node, new_node)
             node = new_node
         elif name in ["VariableDefinitionStatement", "VariableDeclarationStatement"]:
-            node = self._parse_variable_definition(statement, node)
+            node = self._parse_variable_definition(statement, node, scope)
         elif name == "ExpressionStatement":
             # assert len(statement[self.get_children('expression')]) == 1
             # assert not 'attributes' in statement
             # expression = parse_expression(statement[self.get_children('children')][0], self)
             if self.is_compact_ast:
                 expression = statement[self.get_children("expression")]
             else:
                 expression = statement[self.get_children("expression")][0]
             new_node = self._new_node(NodeType.EXPRESSION, statement["src"], scope)
             new_node.add_unparsed_expression(expression)
             link_underlying_nodes(node, new_node)
             node = new_node
         elif name == "TryStatement":
-            node = self._parse_try_catch(statement, node)
+            node = self._parse_try_catch(statement, node, scope)
         # elif name == 'TryCatchClause':
         #     self._parse_catch(statement, node)
         elif name == "RevertStatement":
             if self.is_compact_ast:
                 expression = statement[self.get_children("errorCall")]
             else:
                 expression = statement[self.get_children("errorCall")][0]
@@ -1014,45 +1061,45 @@
             link_underlying_nodes(node, new_node)
             node = new_node
         else:
             raise ParsingError(f"Statement not parsed {name}")
 
         return node
 
-    def _parse_block(self, block: Dict, node: NodeSolc, check_arithmetic: bool = False) -> NodeSolc:
+    def _parse_block(self, block: Dict, node: NodeSolc, scope: Scope) -> NodeSolc:
         """
         Return:
             Node
         """
         assert block[self.get_key()] == "Block"
 
         if self.is_compact_ast:
             statements = block["statements"]
         else:
             statements = block[self.get_children("children")]
 
-        check_arithmetic = check_arithmetic | node.underlying_node.scope.is_checked
-        new_scope = Scope(check_arithmetic, False, node.underlying_node.scope)
+        new_scope = Scope(scope.is_checked, False, scope)
         for statement in statements:
             node = self._parse_statement(statement, node, new_scope)
         return node
 
-    def _parse_unchecked_block(self, block: Dict, node: NodeSolc):
+    def _parse_unchecked_block(self, block: Dict, node: NodeSolc, scope):
         """
         Return:
             Node
         """
         assert block[self.get_key()] == "UncheckedBlock"
 
         if self.is_compact_ast:
             statements = block["statements"]
         else:
             statements = block[self.get_children("children")]
 
-        new_scope = Scope(False, False, node.underlying_node.scope)
+        new_scope = Scope(False, False, scope)
+
         for statement in statements:
             node = self._parse_statement(statement, node, new_scope)
         return node
 
     def _parse_cfg(self, cfg: Dict) -> None:
 
         assert cfg[self.get_key()] == "Block"
@@ -1065,16 +1112,15 @@
         else:
             statements = cfg[self.get_children("children")]
 
         if not statements:
             self._function.is_empty = True
         else:
             self._function.is_empty = False
-            check_arithmetic = self.compilation_unit.solc_version >= "0.8.0"
-            self._parse_block(cfg, node, check_arithmetic=check_arithmetic)
+            self._parse_block(cfg, node, self.underlying_function)
             self._remove_incorrect_edges()
             self._remove_alone_endif()
 
     # endregion
     ###################################################################################
     ###################################################################################
     # region Loops
@@ -1146,41 +1192,56 @@
         start_node.add_father(node)
 
     def _fix_try(self, node: Node) -> None:
         end_node = next((son for son in node.sons if son.type != NodeType.CATCH), None)
         if end_node:
             for son in node.sons:
                 if son.type == NodeType.CATCH:
-                    self._fix_catch(son, end_node)
+                    self._fix_catch(son, end_node, set())
 
-    def _fix_catch(self, node: Node, end_node: Node) -> None:
+    def _fix_catch(self, node: Node, end_node: Node, visited: Set[Node]) -> None:
         if not node.sons:
             link_nodes(node, end_node)
         else:
             for son in node.sons:
-                if son != end_node:
-                    self._fix_catch(son, end_node)
+                if son != end_node and son not in visited:
+                    visited.add(son)
+                    self._fix_catch(son, end_node, visited)
 
-    def _add_param(self, param: Dict) -> LocalVariableSolc:
+    def _add_param(self, param: Dict, initialized: bool = False) -> LocalVariableSolc:
 
         local_var = LocalVariable()
         local_var.set_function(self._function)
         local_var.set_offset(param["src"], self._function.compilation_unit)
 
         local_var_parser = LocalVariableSolc(local_var, param)
 
         local_var_parser.analyze(self)
 
+        if initialized:
+            local_var.initialized = True
+
         # see https://solidity.readthedocs.io/en/v0.4.24/types.html?highlight=storage%20location#data-location
         if local_var.location == "default":
             local_var.set_location("memory")
 
         self._add_local_variable(local_var_parser)
         return local_var_parser
 
+    def _add_param_init_tuple(self, statement: Dict, index: int) -> LocalVariableInitFromTupleSolc:
+
+        local_var = LocalVariableInitFromTuple()
+        local_var.set_function(self._function)
+        local_var.set_offset(statement["src"], self._function.compilation_unit)
+
+        local_var_parser = LocalVariableInitFromTupleSolc(local_var, statement, index)
+
+        self._add_local_variable(local_var_parser)
+        return local_var_parser
+
     def _parse_params(self, params: Dict):
         assert params[self.get_key()] == "ParameterList"
 
         self._function.parameters_src().set_offset(params["src"], self._function.compilation_unit)
 
         if self.is_compact_ast:
             params = params["parameters"]
@@ -1293,15 +1354,15 @@
                 for son in node.sons:
                     if son.type != NodeType.ENDLOOP:
                         new_sons.append(son)
                         continue
                     son.remove_father(node)
                 node.set_sons(new_sons)
 
-    def _remove_alone_endif(self):
+    def _remove_alone_endif(self) -> None:
         """
         Can occur on:
         if(..){
             return
         }
         else{
             return
@@ -1391,16 +1452,15 @@
             # false_expr = false_expr.expression_right
         false_node_parser.underlying_node.add_expression(false_expr)
         false_node_parser.analyze_expressions(self)
 
         endif_node = self._new_node(NodeType.ENDIF, node.source_mapping, node.scope)
 
         for father in node.fathers:
-            father.remove_son(node)
-            father.add_son(condition_node.underlying_node)
+            father.replace_son(node, condition_node.underlying_node)
             condition_node.underlying_node.add_father(father)
 
         for son in node.sons:
             son.remove_father(node)
             son.add_father(endif_node.underlying_node)
             endif_node.underlying_node.add_son(son)
```

### Comparing `slither-analyzer-0.9.3/slither/solc_parsing/declarations/modifier.py` & `slither-analyzer-0.9.4/slither/solc_parsing/declarations/modifier.py`

 * *Files 5% similar despite different names*

```diff
@@ -83,14 +83,17 @@
 
         for local_var_parser in self._local_variables_parser:
             local_var_parser.analyze(self)
 
         for node in self._node_to_nodesolc.values():
             node.analyze_expressions(self)
 
+        for yul_parser in self._node_to_yulobject.values():
+            yul_parser.analyze_expressions()
+
         self._rewrite_ternary_as_if_else()
         self._remove_alone_endif()
 
         # self._analyze_read_write()
         # self._analyze_calls()
 
     def _parse_statement(
```

### Comparing `slither-analyzer-0.9.3/slither/solc_parsing/declarations/structure_contract.py` & `slither-analyzer-0.9.4/slither/solc_parsing/declarations/structure_contract.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/solc_parsing/declarations/structure_top_level.py` & `slither-analyzer-0.9.4/slither/solc_parsing/declarations/structure_top_level.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/solc_parsing/declarations/using_for_top_level.py` & `slither-analyzer-0.9.4/slither/solc_parsing/declarations/using_for_top_level.py`

 * *Files 7% similar despite different names*

```diff
@@ -51,30 +51,37 @@
 
         if self._library_name:
             library_name = parse_type(self._library_name, self)
             self._using_for.using_for[type_name].append(library_name)
             self._propagate_global(type_name)
         else:
             for f in self._functions:
-                full_name_split = f["function"]["name"].split(".")
-                if len(full_name_split) == 1:
+                # User defined operator
+                if "operator" in f:
                     # Top level function
-                    function_name: str = full_name_split[0]
-                    self._analyze_top_level_function(function_name, type_name)
-                elif len(full_name_split) == 2:
-                    # It can be a top level function behind an aliased import
-                    # or a library function
-                    first_part = full_name_split[0]
-                    function_name = full_name_split[1]
-                    self._check_aliased_import(first_part, function_name, type_name)
+                    function_name: str = f["definition"]["name"]
+                    operator: str = f["operator"]
+                    self._analyze_operator(operator, function_name, type_name)
                 else:
-                    # MyImport.MyLib.a we don't care of the alias
-                    library_name_str = full_name_split[1]
-                    function_name = full_name_split[2]
-                    self._analyze_library_function(library_name_str, function_name, type_name)
+                    full_name_split = f["function"]["name"].split(".")
+                    if len(full_name_split) == 1:
+                        # Top level function
+                        function_name: str = full_name_split[0]
+                        self._analyze_top_level_function(function_name, type_name)
+                    elif len(full_name_split) == 2:
+                        # It can be a top level function behind an aliased import
+                        # or a library function
+                        first_part = full_name_split[0]
+                        function_name = full_name_split[1]
+                        self._check_aliased_import(first_part, function_name, type_name)
+                    else:
+                        # MyImport.MyLib.a we don't care of the alias
+                        library_name_str = full_name_split[1]
+                        function_name = full_name_split[2]
+                        self._analyze_library_function(library_name_str, function_name, type_name)
 
     def _check_aliased_import(
         self,
         first_part: str,
         function_name: str,
         type_name: Union[TypeAliasTopLevel, UserDefinedType],
     ) -> None:
@@ -97,14 +104,27 @@
                 and tl_function.parameters
                 and type_name == tl_function.parameters[0].type
             ):
                 self._using_for.using_for[type_name].append(tl_function)
                 self._propagate_global(type_name)
                 break
 
+    def _analyze_operator(
+        self, operator: str, function_name: str, type_name: TypeAliasTopLevel
+    ) -> None:
+        for tl_function in self._using_for.file_scope.functions:
+            # The library function is bound to the first parameter's type
+            if (
+                tl_function.name == function_name
+                and tl_function.parameters
+                and type_name == tl_function.parameters[0].type
+            ):
+                type_name.operators[operator] = tl_function
+                break
+
     def _analyze_library_function(
         self,
         library_name: str,
         function_name: str,
         type_name: Union[TypeAliasTopLevel, UserDefinedType],
     ) -> None:
         found = False
```

### Comparing `slither-analyzer-0.9.3/slither/solc_parsing/expressions/expression_parsing.py` & `slither-analyzer-0.9.4/slither/solc_parsing/expressions/expression_parsing.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 import logging
 import re
-from typing import Union, Dict, TYPE_CHECKING
+from typing import Union, Dict, TYPE_CHECKING, List, Any
 
 import slither.core.expressions.type_conversion
 from slither.core.declarations.solidity_variables import (
     SOLIDITY_VARIABLES_COMPOSED,
     SolidityVariableComposed,
 )
 from slither.core.expressions import (
@@ -232,14 +232,32 @@
     return e
 
 
 if TYPE_CHECKING:
     pass
 
 
+def _user_defined_op_call(
+    caller_context: CallerContextExpression, src, function_id: int, args: List[Any], type_call: str
+) -> CallExpression:
+    var, was_created = find_variable(None, caller_context, function_id)
+
+    if was_created:
+        var.set_offset(src, caller_context.compilation_unit)
+
+    identifier = Identifier(var)
+    identifier.set_offset(src, caller_context.compilation_unit)
+
+    var.references.append(identifier.source_mapping)
+
+    call = CallExpression(identifier, args, type_call)
+    call.set_offset(src, caller_context.compilation_unit)
+    return call
+
+
 def parse_expression(expression: Dict, caller_context: CallerContextExpression) -> "Expression":
     # pylint: disable=too-many-nested-blocks,too-many-statements
     """
 
     Returns:
         str: expression
     """
@@ -270,42 +288,58 @@
     name = expression[caller_context.get_key()]
     is_compact_ast = caller_context.is_compact_ast
     src = expression["src"]
 
     if name == "UnaryOperation":
         if is_compact_ast:
             attributes = expression
-        else:
-            attributes = expression["attributes"]
-        assert "prefix" in attributes
-        operation_type = UnaryOperationType.get_type(attributes["operator"], attributes["prefix"])
-
-        if is_compact_ast:
             expression = parse_expression(expression["subExpression"], caller_context)
         else:
+            attributes = expression["attributes"]
             assert len(expression["children"]) == 1
             expression = parse_expression(expression["children"][0], caller_context)
+        assert "prefix" in attributes
+
+        # Use of user defined operation
+        if "function" in attributes:
+            return _user_defined_op_call(
+                caller_context,
+                src,
+                attributes["function"],
+                [expression],
+                attributes["typeDescriptions"]["typeString"],
+            )
+
+        operation_type = UnaryOperationType.get_type(attributes["operator"], attributes["prefix"])
         unary_op = UnaryOperation(expression, operation_type)
         unary_op.set_offset(src, caller_context.compilation_unit)
         return unary_op
 
     if name == "BinaryOperation":
         if is_compact_ast:
             attributes = expression
-        else:
-            attributes = expression["attributes"]
-        operation_type = BinaryOperationType.get_type(attributes["operator"])
-
-        if is_compact_ast:
             left_expression = parse_expression(expression["leftExpression"], caller_context)
             right_expression = parse_expression(expression["rightExpression"], caller_context)
         else:
             assert len(expression["children"]) == 2
+            attributes = expression["attributes"]
             left_expression = parse_expression(expression["children"][0], caller_context)
             right_expression = parse_expression(expression["children"][1], caller_context)
+
+        # Use of user defined operation
+        if "function" in attributes:
+            return _user_defined_op_call(
+                caller_context,
+                src,
+                attributes["function"],
+                [left_expression, right_expression],
+                attributes["typeDescriptions"]["typeString"],
+            )
+
+        operation_type = BinaryOperationType.get_type(attributes["operator"])
         binary_op = BinaryOperation(left_expression, right_expression, operation_type)
         binary_op.set_offset(src, caller_context.compilation_unit)
         return binary_op
 
     if name in "FunctionCall":
         return parse_call(expression, caller_context)
 
@@ -429,14 +463,16 @@
             type_candidate = expression["attributes"]["type"]
 
         if type_candidate is None:
             if value.isdecimal():
                 type_candidate = ElementaryType("uint256")
             else:
                 type_candidate = ElementaryType("string")
+        elif type_candidate.startswith("rational_const "):
+            type_candidate = ElementaryType("uint256")
         elif type_candidate.startswith("int_const "):
             type_candidate = ElementaryType("uint256")
         elif type_candidate.startswith("bool"):
             type_candidate = ElementaryType("bool")
         elif type_candidate.startswith("address"):
             type_candidate = ElementaryType("address")
         else:
@@ -477,19 +513,22 @@
         identifier.set_offset(src, caller_context.compilation_unit)
         var.references.append(identifier.source_mapping)
 
         return identifier
 
     if name == "IndexAccess":
         if is_compact_ast:
-            index_type = expression["typeDescriptions"]["typeString"]
+            # We dont use the index type here, as we recover it later
+            # We could change the paradigm with the current AST parsing
+            # And do the type parsing in advanced for most of the operation
+            # index_type = expression["typeDescriptions"]["typeString"]
             left = expression["baseExpression"]
             right = expression.get("indexExpression", None)
         else:
-            index_type = expression["attributes"]["type"]
+            # index_type = expression["attributes"]["type"]
             children = expression["children"]
             left = children[0]
             right = children[1] if len(children) > 1 else None
         # IndexAccess is used to describe ElementaryTypeNameExpression
         # if abi.decode is used
         # For example, abi.decode(data, ...(uint[]) )
         if right is None:
@@ -498,15 +537,15 @@
             if isinstance(ret, ElementaryTypeNameExpression):
                 old_type = ret.type
                 ret.type = ArrayType(old_type, None)
             return ret
 
         left_expression = parse_expression(left, caller_context)
         right_expression = parse_expression(right, caller_context)
-        index = IndexAccess(left_expression, right_expression, index_type)
+        index = IndexAccess(left_expression, right_expression)
         index.set_offset(src, caller_context.compilation_unit)
         return index
 
     if name == "MemberAccess":
         if caller_context.is_compact_ast:
             member_name = expression["memberName"]
             member_type = expression["typeDescriptions"]["typeString"]
@@ -552,45 +591,17 @@
             type_name = expression["typeName"]
         else:
             children = expression["children"]
             assert len(children) == 1
             type_name = children[0]
 
         if type_name[caller_context.get_key()] == "ArrayTypeName":
-            depth = 0
-            while type_name[caller_context.get_key()] == "ArrayTypeName":
-                # Note: dont conserve the size of the array if provided
-                # We compute it directly
-                if is_compact_ast:
-                    type_name = type_name["baseType"]
-                else:
-                    type_name = type_name["children"][0]
-                depth += 1
-            if type_name[caller_context.get_key()] == "ElementaryTypeName":
-                if is_compact_ast:
-                    array_type = ElementaryType(type_name["name"])
-                else:
-                    array_type = ElementaryType(type_name["attributes"]["name"])
-            elif type_name[caller_context.get_key()] == "UserDefinedTypeName":
-                if is_compact_ast:
-                    if "name" not in type_name:
-                        name_type = type_name["pathNode"]["name"]
-                    else:
-                        name_type = type_name["name"]
-
-                    array_type = parse_type(UnknownType(name_type), caller_context)
-                else:
-                    array_type = parse_type(
-                        UnknownType(type_name["attributes"]["name"]), caller_context
-                    )
-            elif type_name[caller_context.get_key()] == "FunctionTypeName":
-                array_type = parse_type(type_name, caller_context)
-            else:
-                raise ParsingError(f"Incorrect type array {type_name}")
-            array = NewArray(depth, array_type)
+            array_type = parse_type(type_name, caller_context)
+            assert isinstance(array_type, ArrayType)
+            array = NewArray(array_type)
             array.set_offset(src, caller_context.compilation_unit)
             return array
 
         if type_name[caller_context.get_key()] == "ElementaryTypeName":
             if is_compact_ast:
                 elem_type = ElementaryType(type_name["name"])
             else:
```

### Comparing `slither-analyzer-0.9.3/slither/solc_parsing/expressions/find_variable.py` & `slither-analyzer-0.9.4/slither/solc_parsing/expressions/find_variable.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/solc_parsing/slither_compilation_unit_solc.py` & `slither-analyzer-0.9.4/slither/solc_parsing/slither_compilation_unit_solc.py`

 * *Files 2% similar despite different names*

```diff
@@ -29,14 +29,18 @@
 from slither.solc_parsing.variables.top_level_variable import TopLevelVariableSolc
 
 logging.basicConfig()
 logger = logging.getLogger("SlitherSolcParsing")
 logger.setLevel(logging.INFO)
 
 
+class InheritanceResolutionError(SlitherException):
+    pass
+
+
 def _handle_import_aliases(
     symbol_aliases: Dict, import_directive: Import, scope: FileScope
 ) -> None:
     """
     Handle the parsing of import aliases
 
     Args:
@@ -190,14 +194,21 @@
         enum = EnumTopLevel(name, canonicalName, values, scope)
         scope.enums[name] = enum
         enum.set_offset(top_level_data["src"], self._compilation_unit)
         self._compilation_unit.enums_top_level.append(enum)
 
     # pylint: disable=too-many-branches,too-many-statements,too-many-locals
     def parse_top_level_from_loaded_json(self, data_loaded: Dict, filename: str) -> None:
+        if not data_loaded or data_loaded is None:
+            logger.error(
+                "crytic-compile returned an empty AST. "
+                "If you are trying to analyze a contract from etherscan or similar make sure it has source code available."
+            )
+            return
+
         if "nodeType" in data_loaded:
             self._is_compact_ast = True
 
         if "sourcePaths" in data_loaded:
             for sourcePath in data_loaded["sourcePaths"]:
                 if os.path.isfile(sourcePath):
                     self._compilation_unit.core.add_source_code(sourcePath)
@@ -398,18 +409,15 @@
             )
         if self._parsed:
             raise Exception("Contract analysis can be run only once!")
 
         # First we save all the contracts in a dict
         # the key is the contractid
         for contract in self._underlying_contract_to_parser:
-            if (
-                contract.name.startswith("SlitherInternalTopLevelContract")
-                and not contract.is_top_level
-            ):
+            if contract.name.startswith("SlitherInternalTopLevelContract"):
                 raise SlitherException(
                     # region multi-line-string
                     """Your codebase has a contract named 'SlitherInternalTopLevelContract'.
 Please rename it, this name is reserved for Slither's internals"""
                     # endregion multi-line
                 )
             self._contracts_by_id[contract.id] = contract
@@ -431,15 +439,20 @@
                     if contract_name in contract_parser.underlying_contract.file_scope.renaming:
                         contract_name = contract_parser.underlying_contract.file_scope.renaming[
                             contract_name
                         ]
                     target = contract_parser.underlying_contract.file_scope.get_contract_from_name(
                         contract_name
                     )
-                    assert target
+                    if target == contract_parser.underlying_contract:
+                        raise InheritanceResolutionError(
+                            "Could not resolve contract inheritance. This is likely caused by an import renaming that collides with existing names (see https://github.com/crytic/slither/issues/1758)."
+                            f"\n Try changing `contract {target}` ({target.source_mapping}) to a unique name."
+                        )
+                    assert target, f"Contract {contract_name} not found"
                     ancestors.append(target)
                 elif i in self._contracts_by_id:
                     ancestors.append(self._contracts_by_id[i])
                 else:
                     missing_inheritance = i
 
             # Resolve immediate base contracts
@@ -741,19 +754,53 @@
                 except AttributeError as e:
                     # This can happens for example if there is a call to an interface
                     # And the interface is redefined due to contract's name reuse
                     # But the available version misses some functions
                     self._underlying_contract_to_parser[contract].log_incorrect_parsing(
                         f"Impossible to generate IR for {contract.name}.{func.name} ({func.source_mapping}):\n {e}"
                     )
-
-            contract.convert_expression_to_slithir_ssa()
+                except Exception as e:
+                    func_expressions = "\n".join([f"\t{ex}" for ex in func.expressions])
+                    logger.error(
+                        f"\nFailed to generate IR for {contract.name}.{func.name}. Please open an issue https://github.com/crytic/slither/issues.\n{contract.name}.{func.name} ({func.source_mapping}):\n "
+                        f"{func_expressions}"
+                    )
+                    raise e
+            try:
+                contract.convert_expression_to_slithir_ssa()
+            except Exception as e:
+                logger.error(
+                    f"\nFailed to convert IR to SSA for {contract.name} contract. Please open an issue https://github.com/crytic/slither/issues.\n "
+                )
+                raise e
 
         for func in self._compilation_unit.functions_top_level:
-            func.generate_slithir_and_analyze()
-            func.generate_slithir_ssa({})
+            try:
+                func.generate_slithir_and_analyze()
+            except AttributeError as e:
+                logger.error(
+                    f"Impossible to generate IR for top level function {func.name} ({func.source_mapping}):\n {e}"
+                )
+            except Exception as e:
+                func_expressions = "\n".join([f"\t{ex}" for ex in func.expressions])
+                logger.error(
+                    f"\nFailed to generate IR for top level function {func.name}. Please open an issue https://github.com/crytic/slither/issues.\n{func.name} ({func.source_mapping}):\n "
+                    f"{func_expressions}"
+                )
+                raise e
+
+            try:
+                func.generate_slithir_ssa({})
+            except Exception as e:
+                func_expressions = "\n".join([f"\t{ex}" for ex in func.expressions])
+                logger.error(
+                    f"\nFailed to convert IR to SSA for top level function {func.name}. Please open an issue https://github.com/crytic/slither/issues.\n{func.name} ({func.source_mapping}):\n "
+                    f"{func_expressions}"
+                )
+                raise e
+
         self._compilation_unit.propagate_function_calls()
         for contract in self._compilation_unit.contracts:
             contract.fix_phi()
             contract.update_read_write_using_ssa()
 
     # endregion
```

### Comparing `slither-analyzer-0.9.3/slither/solc_parsing/solidity_types/type_parsing.py` & `slither-analyzer-0.9.4/slither/solc_parsing/solidity_types/type_parsing.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/solc_parsing/variables/event_variable.py` & `slither-analyzer-0.9.4/slither/solc_parsing/variables/event_variable.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/solc_parsing/variables/function_type_variable.py` & `slither-analyzer-0.9.4/slither/solc_parsing/variables/function_type_variable.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/solc_parsing/variables/local_variable.py` & `slither-analyzer-0.9.4/slither/solc_parsing/variables/local_variable.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/solc_parsing/variables/state_variable.py` & `slither-analyzer-0.9.4/slither/solc_parsing/variables/state_variable.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/solc_parsing/variables/structure_variable.py` & `slither-analyzer-0.9.4/slither/solc_parsing/variables/structure_variable.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/solc_parsing/variables/top_level_variable.py` & `slither-analyzer-0.9.4/slither/solc_parsing/variables/top_level_variable.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/solc_parsing/variables/variable_declaration.py` & `slither-analyzer-0.9.4/slither/solc_parsing/variables/variable_declaration.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 import logging
 import re
-from typing import Dict, Optional
+from typing import Dict, Optional, Union
 
 from slither.solc_parsing.declarations.caller_context import CallerContextExpression
 from slither.solc_parsing.expressions.expression_parsing import parse_expression
 
 from slither.core.variables.variable import Variable
 
 from slither.solc_parsing.solidity_types.type_parsing import parse_type, UnknownType
@@ -38,20 +38,20 @@
         the init value.
         It may be possible that the variable is declared through a statement,
         but the init value is declared at the VariableDeclaration children level
         """
 
         self._variable = variable
         self._was_analyzed = False
-        self._elem_to_parse = None
-        self._initializedNotParsed = None
+        self._elem_to_parse: Optional[Union[Dict, UnknownType]] = None
+        self._initializedNotParsed: Optional[Dict] = None
 
         self._is_compact_ast = False
 
-        self._reference_id = None
+        self._reference_id: Optional[int] = None
 
         if "nodeType" in variable_data:
             self._is_compact_ast = True
             nodeType = variable_data["nodeType"]
             if nodeType in [
                 "VariableDeclarationStatement",
                 "VariableDefinitionStatement",
@@ -83,28 +83,29 @@
                 else:
                     raise ParsingError(
                         "Variable declaration without children?" + str(variable_data)
                     )
                 declaration = variable_data["children"][0]
                 self._init_from_declaration(declaration, init)
             elif nodeType == "VariableDeclaration":
-                self._init_from_declaration(variable_data, False)
+                self._init_from_declaration(variable_data, None)
             else:
                 raise ParsingError(f"Incorrect variable declaration type {nodeType}")
 
     @property
     def underlying_variable(self) -> Variable:
         return self._variable
 
     @property
     def reference_id(self) -> int:
         """
         Return the solc id. It can be compared with the referencedDeclaration attr
         Returns None if it was not parsed (legacy AST)
         """
+        assert self._reference_id
         return self._reference_id
 
     def _handle_comment(self, attributes: Dict) -> None:
         if "documentation" in attributes and "text" in attributes["documentation"]:
 
             candidates = attributes["documentation"]["text"].split(",")
 
@@ -123,15 +124,15 @@
     def _analyze_variable_attributes(self, attributes: Dict) -> None:
         if "visibility" in attributes:
             self._variable.visibility = attributes["visibility"]
         else:
             self._variable.visibility = "internal"
 
     def _init_from_declaration(
-        self, var: Dict, init: Optional[bool]
+        self, var: Dict, init: Optional[Dict]
     ) -> None:  # pylint: disable=too-many-branches
         if self._is_compact_ast:
             attributes = var
             self._typeName = attributes["typeDescriptions"]["typeString"]
         else:
             assert len(var["children"]) <= 2
             assert var["name"] == "VariableDeclaration"
@@ -191,15 +192,15 @@
         else:
             if init:  # there are two way to init a var local in the AST
                 assert len(var["children"]) <= 1
                 self._variable.initialized = True
                 self._initializedNotParsed = init
             elif len(var["children"]) in [0, 1]:
                 self._variable.initialized = False
-                self._initializedNotParsed = []
+                self._initializedNotParsed = None
             else:
                 assert len(var["children"]) == 2
                 self._variable.initialized = True
                 self._initializedNotParsed = var["children"][1]
 
     def analyze(self, caller_context: CallerContextExpression) -> None:
         # Can be re-analyzed due to inheritance
@@ -208,9 +209,10 @@
         self._was_analyzed = True
 
         if self._elem_to_parse:
             self._variable.type = parse_type(self._elem_to_parse, caller_context)
             self._elem_to_parse = None
 
         if self._variable.initialized:
+            assert self._initializedNotParsed
             self._variable.expression = parse_expression(self._initializedNotParsed, caller_context)
             self._initializedNotParsed = None
```

### Comparing `slither-analyzer-0.9.3/slither/solc_parsing/yul/evm_functions.py` & `slither-analyzer-0.9.4/slither/solc_parsing/yul/evm_functions.py`

 * *Files 3% similar despite different names*

```diff
@@ -47,14 +47,15 @@
     "RETURNDATACOPY",
     "EXTCODEHASH",
     "BLOCKHASH",
     "COINBASE",
     "TIMESTAMP",
     "NUMBER",
     "DIFFICULTY",
+    "PREVRANDAO",
     "GASLIMIT",
     "CHAINID",
     "SELFBALANCE",
     "POP",
     "MLOAD",
     "MSTORE",
     "MSTORE8",
@@ -164,14 +165,15 @@
         or x.startswith("DUP")
         or x == "JUMP"
         or x == "JUMPI"
         or x == "JUMPDEST"
     )
 ] + yul_funcs
 
+# "identifier": [input_count, output_count]
 function_args = {
     "byte": [2, 1],
     "addmod": [3, 1],
     "mulmod": [3, 1],
     "signextend": [2, 1],
     "keccak256": [2, 1],
     "pc": [0, 1],
@@ -217,14 +219,15 @@
     "origin": [0, 1],
     "gasprice": [0, 1],
     "blockhash": [1, 1],
     "coinbase": [0, 1],
     "timestamp": [0, 1],
     "number": [0, 1],
     "difficulty": [0, 1],
+    "prevrandao": [0, 1],
     "gaslimit": [0, 1],
 }
 
 
 def format_function_descriptor(name: str) -> str:
     if name not in function_args:
         return name + "()"
```

### Comparing `slither-analyzer-0.9.3/slither/solc_parsing/yul/parse_yul.py` & `slither-analyzer-0.9.4/slither/solc_parsing/yul/parse_yul.py`

 * *Files 2% similar despite different names*

```diff
@@ -177,15 +177,15 @@
             ),
             None,
         )
 
     def add_yul_local_function(self, func: "YulFunction") -> None:
         self._yul_local_functions.append(func)
 
-    def get_yul_local_function_from_name(self, func_name: str) -> Optional["YulLocalVariable"]:
+    def get_yul_local_function_from_name(self, func_name: str) -> Optional["YulFunction"]:
         return next(
             (v for v in self._yul_local_functions if v.underlying.name == func_name),
             None,
         )
 
 
 class YulLocalVariable:  # pylint: disable=too-few-public-methods
@@ -248,14 +248,18 @@
     def underlying(self) -> Function:
         return self._function
 
     @property
     def function(self) -> Function:
         return self._function
 
+    @property
+    def root(self) -> YulScope:
+        return self._root
+
     def convert_body(self) -> None:
         node = self.new_node(NodeType.ENTRYPOINT, self._ast["src"])
         link_underlying_nodes(self._entrypoint, node)
 
         for param in self._ast.get("parameters", []):
             node = convert_yul(self, node, param, self.node_scope)
             self._function.add_parameters(
@@ -267,14 +271,17 @@
             self._function.add_return(self.get_yul_local_variable_from_name(ret["name"]).underlying)
 
         convert_yul(self, node, self._ast["body"], self.node_scope)
 
     def parse_body(self) -> None:
         for node in self._nodes:
             node.analyze_expressions()
+        for f in self._yul_local_functions:
+            if f != self:
+                f.parse_body()
 
     def new_node(self, node_type: NodeType, src: str) -> YulNode:
         if self._function:
             node = self._function.new_node(node_type, src, self.node_scope)
         else:
             raise SlitherException("standalone yul objects are not supported yet")
 
@@ -321,15 +328,18 @@
             raise SlitherException("standalone yul objects are not supported yet")
 
         yul_node = YulNode(node, self)
         self._nodes.append(yul_node)
         return yul_node
 
     def convert(self, ast: Dict) -> YulNode:
-        return convert_yul(self, self._entrypoint, ast, self.node_scope)
+        yul_node = convert_yul(self, self._entrypoint, ast, self.node_scope)
+        for f in self._yul_local_functions:
+            f.parse_body()
+        return yul_node
 
     def analyze_expressions(self) -> None:
         for node in self._nodes:
             node.analyze_expressions()
 
 
 ###################################################################################
@@ -386,15 +396,14 @@
     if root.contract:
         root.contract.add_function(func)
 
     root.compilation_unit.add_function(func)
     root.add_yul_local_function(yul_function)
 
     yul_function.convert_body()
-    yul_function.parse_body()
 
     return parent
 
 
 def convert_yul_variable_declaration(
     root: YulScope, parent: YulNode, ast: Dict, node_scope: Union[Function, Scope]
 ) -> YulNode:
@@ -774,14 +783,15 @@
         potential_name = name[:-7]
         var = root.function.get_local_variable_from_name(potential_name)
         if var and var.location == "calldata":
             return Identifier(var)
     return None
 
 
+# pylint: disable=too-many-branches
 def parse_yul_identifier(root: YulScope, _node: YulNode, ast: Dict) -> Optional[Expression]:
     name = ast["name"]
 
     if name in builtins:
         return Identifier(YulBuiltin(name))
 
     # check function-scoped variables
@@ -805,14 +815,31 @@
 
     # check yul-scoped function
 
     func = root.get_yul_local_function_from_name(name)
     if func:
         return Identifier(func.underlying)
 
+    # check yul-block scoped function
+    if isinstance(root, YulFunction):
+        yul_block = root.root
+
+        # Iterate until we searched in all the scopes until the YulBlock scope
+        while not isinstance(yul_block, YulBlock):
+            func = yul_block.get_yul_local_function_from_name(name)
+            if func:
+                return Identifier(func.underlying)
+
+            if isinstance(yul_block, YulFunction):
+                yul_block = yul_block.root
+
+        func = yul_block.get_yul_local_function_from_name(name)
+        if func:
+            return Identifier(func.underlying)
+
     magic_suffix = _parse_yul_magic_suffixes(name, root)
     if magic_suffix:
         return magic_suffix
 
     ret, _ = find_top_level(name, root.file_scope)
     if ret:
         return Identifier(ret)
```

### Comparing `slither-analyzer-0.9.3/slither/tools/demo/__main__.py` & `slither-analyzer-0.9.4/slither/tools/demo/__main__.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/doctor/__main__.py` & `slither-analyzer-0.9.4/slither/tools/doctor/__main__.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/doctor/checks/__init__.py` & `slither-analyzer-0.9.4/slither/tools/doctor/checks/__init__.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/doctor/checks/paths.py` & `slither-analyzer-0.9.4/slither/tools/doctor/checks/paths.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/doctor/checks/platform.py` & `slither-analyzer-0.9.4/slither/tools/doctor/checks/platform.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/doctor/checks/versions.py` & `slither-analyzer-0.9.4/slither/tools/doctor/checks/versions.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 from importlib import metadata
 import json
-from typing import Optional
+from typing import Optional, Any
 import urllib
 
 from packaging.version import parse, Version
 
 from slither.utils.colors import yellow, green
 
 
@@ -13,25 +13,26 @@
         return parse(metadata.version(name))
     except metadata.PackageNotFoundError:
         return None
 
 
 def get_github_version(name: str) -> Optional[Version]:
     try:
+        # type: ignore
         with urllib.request.urlopen(
             f"https://api.github.com/repos/crytic/{name}/releases/latest"
         ) as response:
             text = response.read()
             data = json.loads(text)
             return parse(data["tag_name"])
     except:  # pylint: disable=bare-except
         return None
 
 
-def show_versions(**_kwargs) -> None:
+def show_versions(**_kwargs: Any) -> None:
     versions = {
         "Slither": (get_installed_version("slither-analyzer"), get_github_version("slither")),
         "crytic-compile": (
             get_installed_version("crytic-compile"),
             get_github_version("crytic-compile"),
         ),
         "solc-select": (get_installed_version("solc-select"), get_github_version("solc-select")),
```

### Comparing `slither-analyzer-0.9.3/slither/tools/doctor/utils.py` & `slither-analyzer-0.9.4/slither/tools/doctor/utils.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/documentation/__main__.py` & `slither-analyzer-0.9.4/slither/tools/documentation/__main__.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/erc_conformance/__main__.py` & `slither-analyzer-0.9.4/slither/tools/erc_conformance/__main__.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/erc_conformance/erc/erc1155.py` & `slither-analyzer-0.9.4/slither/tools/erc_conformance/erc/erc1155.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/erc_conformance/erc/erc20.py` & `slither-analyzer-0.9.4/slither/tools/erc_conformance/erc/erc20.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/erc_conformance/erc/ercs.py` & `slither-analyzer-0.9.4/slither/tools/erc_conformance/erc/ercs.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/flattening/__main__.py` & `slither-analyzer-0.9.4/slither/tools/flattening/__main__.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/flattening/export/export.py` & `slither-analyzer-0.9.4/slither/tools/flattening/export/export.py`

 * *Files 6% similar despite different names*

```diff
@@ -11,15 +11,15 @@
     "stored": zipfile.ZIP_STORED,
     "deflated": zipfile.ZIP_DEFLATED,
     "bzip2": zipfile.ZIP_BZIP2,
 }
 
 Export = namedtuple("Export", ["filename", "content"])
 
-logger = logging.getLogger("Slither")
+logger = logging.getLogger("Slither-flat")
 
 
 def save_to_zip(files: List[Export], zip_filename: str, zip_type: str = "lzma"):
     """
     Save projects to a zip
     """
     logger.info(f"Export {zip_filename}")
```

### Comparing `slither-analyzer-0.9.3/slither/tools/flattening/flattening.py` & `slither-analyzer-0.9.4/slither/tools/flattening/flattening.py`

 * *Files 1% similar despite different names*

```diff
@@ -7,27 +7,29 @@
 from typing import List, Set, Dict, Optional, Sequence
 
 from slither.core.compilation_unit import SlitherCompilationUnit
 from slither.core.declarations import SolidityFunction, EnumContract, StructureContract
 from slither.core.declarations.contract import Contract
 from slither.core.declarations.function_top_level import FunctionTopLevel
 from slither.core.declarations.top_level import TopLevel
+from slither.core.declarations.solidity_variables import SolidityCustomRevert
 from slither.core.solidity_types import MappingType, ArrayType
 from slither.core.solidity_types.type import Type
 from slither.core.solidity_types.user_defined_type import UserDefinedType
 from slither.exceptions import SlitherException
 from slither.slithir.operations import NewContract, TypeConversion, SolidityCall, InternalCall
 from slither.tools.flattening.export.export import (
     Export,
     export_as_json,
     save_to_zip,
     save_to_disk,
 )
 
-logger = logging.getLogger("Slither-flattening")
+logger = logging.getLogger("Slither-flat")
+logger.setLevel(logging.INFO)
 
 # index: where to start
 # patch_type:
 #   - public_to_external: public to external (external-to-public)
 #   - calldata_to_memory: calldata to memory (external-to-public)
 #   - line_removal: remove the line (remove-assert)
 Patch = namedtuple("PatchExternal", ["index", "patch_type"])
@@ -71,14 +73,15 @@
         self._check_abi_encoder_v2()
 
         for contract in compilation_unit.contracts:
             self._get_source_code(contract)
 
         self._get_source_code_top_level(compilation_unit.structures_top_level)
         self._get_source_code_top_level(compilation_unit.enums_top_level)
+        self._get_source_code_top_level(compilation_unit.custom_errors)
         self._get_source_code_top_level(compilation_unit.variables_top_level)
         self._get_source_code_top_level(compilation_unit.functions_top_level)
 
     def _get_source_code_top_level(self, elems: Sequence[TopLevel]) -> None:
         for elem in elems:
             self._source_codes_top_level[elem] = elem.source_mapping.content
 
@@ -245,20 +248,22 @@
         return ret
 
     def _export_from_type(
         self,
         t: Type,
         contract: Contract,
         exported: Set[str],
-        list_contract: List[Contract],
-        list_top_level: List[TopLevel],
+        list_contract: Set[Contract],
+        list_top_level: Set[TopLevel],
     ):
         if isinstance(t, UserDefinedType):
             t_type = t.type
-            if isinstance(t_type, (EnumContract, StructureContract)):
+            if isinstance(t_type, TopLevel):
+                list_top_level.add(t_type)
+            elif isinstance(t_type, (EnumContract, StructureContract)):
                 if t_type.contract != contract and t_type.contract not in exported:
                     self._export_list_used_contracts(
                         t_type.contract, exported, list_contract, list_top_level
                     )
             else:
                 assert isinstance(t.type, Contract)
                 if t.type != contract and t.type not in exported:
@@ -271,16 +276,16 @@
         elif isinstance(t, ArrayType):
             self._export_from_type(t.type, contract, exported, list_contract, list_top_level)
 
     def _export_list_used_contracts(  # pylint: disable=too-many-branches
         self,
         contract: Contract,
         exported: Set[str],
-        list_contract: List[Contract],
-        list_top_level: List[TopLevel],
+        list_contract: Set[Contract],
+        list_top_level: Set[TopLevel],
     ):
         # TODO: investigate why this happen
         if not isinstance(contract, Contract):
             return
         if contract.name in exported:
             return
         exported.add(contract.name)
@@ -328,27 +333,29 @@
                 if isinstance(ir, TypeConversion):
                     self._export_from_type(
                         ir.type, contract, exported, list_contract, list_top_level
                     )
 
                 for read in ir.read:
                     if isinstance(read, TopLevel):
-                        if read not in list_top_level:
-                            list_top_level.append(read)
-                if isinstance(ir, InternalCall):
-                    function_called = ir.function
-                    if isinstance(function_called, FunctionTopLevel):
-                        list_top_level.append(function_called)
+                        list_top_level.add(read)
+                if isinstance(ir, InternalCall) and isinstance(ir.function, FunctionTopLevel):
+                    list_top_level.add(ir.function)
+                if (
+                    isinstance(ir, SolidityCall)
+                    and isinstance(ir.function, SolidityCustomRevert)
+                    and isinstance(ir.function.custom_error, TopLevel)
+                ):
+                    list_top_level.add(ir.function.custom_error)
 
-        if contract not in list_contract:
-            list_contract.append(contract)
+        list_contract.add(contract)
 
     def _export_contract_with_inheritance(self, contract) -> Export:
-        list_contracts: List[Contract] = []  # will contain contract itself
-        list_top_level: List[TopLevel] = []
+        list_contracts: Set[Contract] = set()  # will contain contract itself
+        list_top_level: Set[TopLevel] = set()
         self._export_list_used_contracts(contract, set(), list_contracts, list_top_level)
         path = Path(self._export_path, f"{contract.name}_{uuid.uuid4()}.sol")
 
         content = ""
         content += self._pragmas()
 
         for listed_top_level in list_top_level:
@@ -397,16 +404,16 @@
                 contract_to_explore.append(next_to_explore)
 
         return [Export(filename=path, content=content)]
 
     def _export_with_import(self) -> List[Export]:
         exports: List[Export] = []
         for contract in self._compilation_unit.contracts:
-            list_contracts: List[Contract] = []  # will contain contract itself
-            list_top_level: List[TopLevel] = []
+            list_contracts: Set[Contract] = set()  # will contain contract itself
+            list_top_level: Set[TopLevel] = set()
             self._export_list_used_contracts(contract, set(), list_contracts, list_top_level)
 
             if list_top_level:
                 logger.info(
                     "Top level objects are not yet supported with the local import flattening"
                 )
                 for elem in list_top_level:
```

### Comparing `slither-analyzer-0.9.3/slither/tools/kspec_coverage/__main__.py` & `slither-analyzer-0.9.4/slither/tools/kspec_coverage/__main__.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/kspec_coverage/analysis.py` & `slither-analyzer-0.9.4/slither/tools/kspec_coverage/analysis.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/kspec_coverage/kspec_coverage.py` & `slither-analyzer-0.9.4/slither/tools/kspec_coverage/kspec_coverage.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/mutator/__main__.py` & `slither-analyzer-0.9.4/slither/tools/mutator/__main__.py`

 * *Files 8% similar despite different names*

```diff
@@ -75,13 +75,14 @@
 def main() -> None:
 
     args = parse_args()
 
     print(args.codebase)
     sl = Slither(args.codebase, **vars(args))
 
-    for M in _get_mutators():
-        m = M(sl)
-        m.mutate()
+    for compilation_unit in sl.compilation_units:
+        for M in _get_mutators():
+            m = M(compilation_unit)
+            m.mutate()
 
 
 # endregion
```

### Comparing `slither-analyzer-0.9.3/slither/tools/mutator/mutators/MIA.py` & `slither-analyzer-0.9.4/slither/tools/mutator/mutators/MIA.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/mutator/mutators/MVIE.py` & `slither-analyzer-0.9.4/slither/tools/mutator/mutators/MVIE.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/mutator/mutators/MVIV.py` & `slither-analyzer-0.9.4/slither/tools/mutator/mutators/MVIV.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/mutator/mutators/abstract_mutator.py` & `slither-analyzer-0.9.4/slither/tools/mutator/mutators/abstract_mutator.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 import abc
 import logging
 from enum import Enum
 from typing import Optional, Dict
 
-from slither import Slither
+from slither.core.compilation_unit import SlitherCompilationUnit
 from slither.formatters.utils.patches import apply_patch, create_diff
 
 logger = logging.getLogger("Slither")
 
 
 class IncorrectMutatorInitialization(Exception):
     pass
@@ -30,16 +30,19 @@
 
 class AbstractMutator(metaclass=abc.ABCMeta):  # pylint: disable=too-few-public-methods
     NAME = ""
     HELP = ""
     FAULTCLASS = FaultClass.Undefined
     FAULTNATURE = FaultNature.Undefined
 
-    def __init__(self, slither: Slither, rate: int = 10, seed: Optional[int] = None):
-        self.slither = slither
+    def __init__(
+        self, compilation_unit: SlitherCompilationUnit, rate: int = 10, seed: Optional[int] = None
+    ):
+        self.compilation_unit = compilation_unit
+        self.slither = compilation_unit.core
         self.seed = seed
         self.rate = rate
 
         if not self.NAME:
             raise IncorrectMutatorInitialization(
                 f"NAME is not initialized {self.__class__.__name__}"
             )
@@ -83,11 +86,11 @@
             patches = all_patches["patches"][file]
             patches.sort(key=lambda x: x["start"])
             if not all(patches[i]["end"] <= patches[i + 1]["end"] for i in range(len(patches) - 1)):
                 logger.info(f"Impossible to generate patch; patches collisions: {patches}")
                 continue
             for patch in patches:
                 patched_txt, offset = apply_patch(patched_txt, patch, offset)
-            diff = create_diff(self.slither, original_txt, patched_txt, file)
+            diff = create_diff(self.compilation_unit, original_txt, patched_txt, file)
             if not diff:
                 logger.info(f"Impossible to generate patch; empty {patches}")
             print(diff)
```

### Comparing `slither-analyzer-0.9.3/slither/tools/mutator/utils/command_line.py` & `slither-analyzer-0.9.4/slither/tools/mutator/utils/command_line.py`

 * *Files 1% similar despite different names*

```diff
@@ -14,10 +14,10 @@
         mutators_list.append((argument, help_info, fault_class, fault_nature))
     table = MyPrettyTable(["Num", "Name", "What it Does", "Fault Class", "Fault Nature"])
 
     # Sort by class, nature, name
     mutators_list = sorted(mutators_list, key=lambda element: (element[2], element[3], element[0]))
     idx = 1
     for (argument, help_info, fault_class, fault_nature) in mutators_list:
-        table.add_row([idx, argument, help_info, fault_class, fault_nature])
+        table.add_row([str(idx), argument, help_info, fault_class, fault_nature])
         idx = idx + 1
     print(table)
```

### Comparing `slither-analyzer-0.9.3/slither/tools/mutator/utils/generic_patching.py` & `slither-analyzer-0.9.4/slither/tools/mutator/utils/generic_patching.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/possible_paths/__main__.py` & `slither-analyzer-0.9.4/slither/tools/possible_paths/__main__.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/possible_paths/possible_paths.py` & `slither-analyzer-0.9.4/slither/tools/possible_paths/possible_paths.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/properties/__main__.py` & `slither-analyzer-0.9.4/slither/tools/properties/__main__.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/properties/addresses/address.py` & `slither-analyzer-0.9.4/slither/tools/properties/addresses/address.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/properties/platforms/echidna.py` & `slither-analyzer-0.9.4/slither/tools/properties/platforms/echidna.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/properties/platforms/truffle.py` & `slither-analyzer-0.9.4/slither/tools/properties/platforms/truffle.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/properties/properties/erc20.py` & `slither-analyzer-0.9.4/slither/tools/properties/properties/erc20.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/properties/properties/ercs/erc20/properties/burn.py` & `slither-analyzer-0.9.4/slither/tools/properties/properties/ercs/erc20/properties/burn.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/properties/properties/ercs/erc20/properties/initialization.py` & `slither-analyzer-0.9.4/slither/tools/properties/properties/ercs/erc20/properties/initialization.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/properties/properties/ercs/erc20/properties/mint.py` & `slither-analyzer-0.9.4/slither/tools/properties/properties/ercs/erc20/properties/mint.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/properties/properties/ercs/erc20/properties/mint_and_burn.py` & `slither-analyzer-0.9.4/slither/tools/properties/properties/ercs/erc20/properties/mint_and_burn.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/properties/properties/ercs/erc20/properties/transfer.py` & `slither-analyzer-0.9.4/slither/tools/properties/properties/ercs/erc20/properties/transfer.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/properties/properties/ercs/erc20/unit_tests/truffle.py` & `slither-analyzer-0.9.4/slither/tools/properties/properties/ercs/erc20/unit_tests/truffle.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/properties/properties/properties.py` & `slither-analyzer-0.9.4/slither/tools/properties/properties/properties.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/properties/solidity/generate_properties.py` & `slither-analyzer-0.9.4/slither/tools/properties/solidity/generate_properties.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/properties/utils.py` & `slither-analyzer-0.9.4/slither/tools/properties/utils.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/read_storage/__main__.py` & `slither-analyzer-0.9.4/slither/tools/read_storage/__main__.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 """
 import json
 import argparse
 
 from crytic_compile import cryticparser
 
 from slither import Slither
-from slither.tools.read_storage.read_storage import SlitherReadStorage
+from slither.tools.read_storage.read_storage import SlitherReadStorage, RpcInfo
 
 
 def parse_args() -> argparse.Namespace:
     """Parse the underlying arguments for the program.
     Returns:
         The arguments for the program.
     """
@@ -100,14 +100,20 @@
 
     parser.add_argument(
         "--block",
         help="The block number to read storage from. Requires an archive node to be provided as the RPC url.",
         default="latest",
     )
 
+    parser.add_argument(
+        "--unstructured",
+        action="store_true",
+        help="Include unstructured storage slots",
+    )
+
     cryticparser.init(parser)
 
     return parser.parse_args()
 
 
 def main() -> None:
     args = parse_args()
@@ -122,30 +128,28 @@
         slither = Slither(target, **vars(args))
 
     if args.contract_name:
         contracts = slither.get_contract_from_name(args.contract_name)
     else:
         contracts = slither.contracts
 
-    srs = SlitherReadStorage(contracts, args.max_depth)
-
-    try:
-        srs.block = int(args.block)
-    except ValueError:
-        srs.block = str(args.block or "latest")
-
+    rpc_info = None
     if args.rpc_url:
-        # Remove target prefix e.g. rinkeby:0x0 -> 0x0.
-        address = target[target.find(":") + 1 :]
-        # Default to implementation address unless a storage address is given.
-        if not args.storage_address:
-            args.storage_address = address
-        srs.storage_address = args.storage_address
-
-        srs.rpc = args.rpc_url
+        valid = ["latest", "earliest", "pending", "safe", "finalized"]
+        block = args.block if args.block in valid else int(args.block)
+        rpc_info = RpcInfo(args.rpc_url, block)
+
+    srs = SlitherReadStorage(contracts, args.max_depth, rpc_info)
+    srs.unstructured = bool(args.unstructured)
+    # Remove target prefix e.g. rinkeby:0x0 -> 0x0.
+    address = target[target.find(":") + 1 :]
+    # Default to implementation address unless a storage address is given.
+    if not args.storage_address:
+        args.storage_address = address
+    srs.storage_address = args.storage_address
 
     if args.variable_name:
         # Use a lambda func to only return variables that have same name as target.
         # x is a tuple (`Contract`, `StateVariable`).
         srs.get_all_storage_variables(lambda x: bool(x[1].name == args.variable_name))
         srs.get_target_variables(**vars(args))
     else:
```

### Comparing `slither-analyzer-0.9.3/slither/tools/read_storage/utils/utils.py` & `slither-analyzer-0.9.4/slither/tools/read_storage/utils/utils.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,11 +1,12 @@
 from typing import Union
 
 from eth_typing.evm import ChecksumAddress
-from eth_utils import to_checksum_address, to_int, to_text
+from eth_utils import to_int, to_text, to_checksum_address
+from web3 import Web3
 
 
 def get_offset_value(hex_bytes: bytes, offset: int, size: int) -> bytes:
     """
     Trims slot data to only contain the target variable's.
     Args:
         hex_bytes (HexBytes): String representation of type
@@ -32,35 +33,37 @@
     Args:
         solidity_type (str): String representation of type.
         value (bytes): The value to be converted.
     Returns:
         (Union[int, bool, str, ChecksumAddress, hex]): The type representation of the value.
     """
     if "int" in solidity_type:
+        if str(value).startswith("0x"):
+            return to_int(hexstr=value)
         return to_int(value)
     if "bool" in solidity_type:
         return bool(to_int(value))
     if "string" in solidity_type and isinstance(value, bytes):
         # length * 2 is stored in lower end bits
         # TODO handle bytes and strings greater than 32 bytes
         length = int(int.from_bytes(value[-2:], "big") / 2)
         return to_text(value[:length])
 
     if "address" in solidity_type:
         if not isinstance(value, (str, bytes)):
             raise TypeError
-        return to_checksum_address(value)
+        return to_checksum_address(value)  # type: ignore
 
     if not isinstance(value, bytes):
         raise TypeError
     return value.hex()
 
 
 def get_storage_data(
-    web3, checksum_address: ChecksumAddress, slot: bytes, block: Union[int, str]
+    web3: Web3, checksum_address: ChecksumAddress, slot: bytes, block: Union[int, str]
 ) -> bytes:
     """
     Retrieves the storage data from the blockchain at target address and slot.
     Args:
         web3: Web3 instance provider.
         checksum_address (ChecksumAddress): The address to query.
         slot (bytes): The slot to retrieve data from.
```

### Comparing `slither-analyzer-0.9.3/slither/tools/similarity/__main__.py` & `slither-analyzer-0.9.4/slither/tools/similarity/__main__.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/similarity/encode.py` & `slither-analyzer-0.9.4/slither/tools/similarity/encode.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/similarity/info.py` & `slither-analyzer-0.9.4/slither/tools/similarity/info.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/similarity/plot.py` & `slither-analyzer-0.9.4/slither/tools/similarity/plot.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/similarity/test.py` & `slither-analyzer-0.9.4/slither/tools/similarity/test.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/similarity/train.py` & `slither-analyzer-0.9.4/slither/tools/similarity/train.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/slither_format/__main__.py` & `slither-analyzer-0.9.4/slither/tools/slither_format/__main__.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/slither_format/slither_format.py` & `slither-analyzer-0.9.4/slither/tools/slither_format/slither_format.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/upgradeability/__main__.py` & `slither-analyzer-0.9.4/slither/tools/upgradeability/__main__.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/upgradeability/checks/abstract_checks.py` & `slither-analyzer-0.9.4/slither/tools/upgradeability/checks/abstract_checks.py`

 * *Files 1% similar despite different names*

```diff
@@ -30,14 +30,16 @@
 classification_txt = {
     CheckClassification.INFORMATIONAL: "Informational",
     CheckClassification.LOW: "Low",
     CheckClassification.MEDIUM: "Medium",
     CheckClassification.HIGH: "High",
 }
 
+CHECK_INFO = List[Union[str, SupportedOutput]]
+
 
 class AbstractCheck(metaclass=abc.ABCMeta):
     ARGUMENT = ""
     HELP = ""
     IMPACT: CheckClassification = CheckClassification.UNIMPLEMENTED
 
     WIKI = ""
@@ -136,15 +138,15 @@
                     info += result["description"]
                 info += f"Reference: {self.WIKI}"
                 self._log(info)
         return all_results
 
     def generate_result(
         self,
-        info: Union[str, List[Union[str, SupportedOutput]]],
+        info: CHECK_INFO,
         additional_fields: Optional[Dict] = None,
     ) -> Output:
         output = Output(
             info, additional_fields, markdown_root=self.contract.compilation_unit.core.markdown_root
         )
 
         output.data["check"] = self.ARGUMENT
```

### Comparing `slither-analyzer-0.9.3/slither/tools/upgradeability/checks/all_checks.py` & `slither-analyzer-0.9.4/slither/tools/upgradeability/checks/all_checks.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/upgradeability/checks/constant.py` & `slither-analyzer-0.9.4/slither/tools/upgradeability/checks/constant.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,11 +1,15 @@
+from typing import List
+
 from slither.tools.upgradeability.checks.abstract_checks import (
     AbstractCheck,
     CheckClassification,
+    CHECK_INFO,
 )
+from slither.utils.output import Output
 
 
 class WereConstant(AbstractCheck):
     ARGUMENT = "were-constant"
     IMPACT = CheckClassification.HIGH
 
     HELP = "Variables that should be constant"
@@ -43,18 +47,20 @@
 Do not remove `constant` from a state variables during an update.
 """
     # endregion wiki_recommendation
 
     REQUIRE_CONTRACT = True
     REQUIRE_CONTRACT_V2 = True
 
-    def _check(self):
+    def _check(self) -> List[Output]:
         contract_v1 = self.contract
         contract_v2 = self.contract_v2
 
+        if contract_v2 is None:
+            raise Exception("were-constant requires a V2 contract")
         state_variables_v1 = contract_v1.state_variables
         state_variables_v2 = contract_v2.state_variables
 
         v2_additional_variables = len(state_variables_v2) - len(state_variables_v1)
         v2_additional_variables = max(v2_additional_variables, 0)
 
         # We keep two index, because we need to have them out of sync if v2
@@ -77,15 +83,15 @@
                         # If v2 has additional non constant variables, we need to skip them
                         if (
                             state_v1.name != state_v2.name or state_v1.type != state_v2.type
                         ) and v2_additional_variables > 0:
                             v2_additional_variables -= 1
                             idx_v2 += 1
                             continue
-                        info = [state_v1, " was constant, but ", state_v2, "is not.\n"]
+                        info: CHECK_INFO = [state_v1, " was constant, but ", state_v2, "is not.\n"]
                         json = self.generate_result(info)
                         results.append(json)
 
             idx_v1 += 1
             idx_v2 += 1
 
         return results
@@ -130,18 +136,21 @@
 Do not make an existing state variable `constant`.
 """
     # endregion wiki_recommendation
 
     REQUIRE_CONTRACT = True
     REQUIRE_CONTRACT_V2 = True
 
-    def _check(self):
+    def _check(self) -> List[Output]:
         contract_v1 = self.contract
         contract_v2 = self.contract_v2
 
+        if contract_v2 is None:
+            raise Exception("became-constant requires a V2 contract")
+
         state_variables_v1 = contract_v1.state_variables
         state_variables_v2 = contract_v2.state_variables
 
         v2_additional_variables = len(state_variables_v2) - len(state_variables_v1)
         v2_additional_variables = max(v2_additional_variables, 0)
 
         # We keep two index, because we need to have them out of sync if v2
@@ -165,15 +174,15 @@
                         if (
                             state_v1.name != state_v2.name or state_v1.type != state_v2.type
                         ) and v2_additional_variables > 0:
                             v2_additional_variables -= 1
                             idx_v2 += 1
                             continue
                 elif state_v2.is_constant:
-                    info = [state_v1, " was not constant but ", state_v2, " is.\n"]
+                    info: CHECK_INFO = [state_v1, " was not constant but ", state_v2, " is.\n"]
                     json = self.generate_result(info)
                     results.append(json)
 
             idx_v1 += 1
             idx_v2 += 1
 
         return results
```

### Comparing `slither-analyzer-0.9.3/slither/tools/upgradeability/checks/functions_ids.py` & `slither-analyzer-0.9.4/slither/tools/upgradeability/checks/functions_ids.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/upgradeability/checks/initialization.py` & `slither-analyzer-0.9.4/slither/tools/upgradeability/checks/initialization.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/tools/upgradeability/checks/variable_initialization.py` & `slither-analyzer-0.9.4/slither/tools/upgradeability/checks/variable_initialization.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,11 +1,15 @@
+from typing import List
+
 from slither.tools.upgradeability.checks.abstract_checks import (
     CheckClassification,
     AbstractCheck,
+    CHECK_INFO,
 )
+from slither.utils.output import Output
 
 
 class VariableWithInit(AbstractCheck):
     ARGUMENT = "variables-initialized"
     IMPACT = CheckClassification.HIGH
 
     HELP = "State variables with an initial value"
@@ -33,15 +37,15 @@
     WIKI_RECOMMENDATION = """
 Using initialize functions to write initial values in state variables.
 """
     # endregion wiki_recommendation
 
     REQUIRE_CONTRACT = True
 
-    def _check(self):
+    def _check(self) -> List[Output]:
         results = []
         for s in self.contract.state_variables_ordered:
             if s.initialized and not (s.is_constant or s.is_immutable):
-                info = [s, " is a state variable with an initial value.\n"]
+                info: CHECK_INFO = [s, " is a state variable with an initial value.\n"]
                 json = self.generate_result(info)
                 results.append(json)
         return results
```

### Comparing `slither-analyzer-0.9.3/slither/tools/upgradeability/checks/variables_order.py` & `slither-analyzer-0.9.4/slither/tools/upgradeability/checks/variables_order.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,11 +1,17 @@
+from typing import List
+
+from slither.core.declarations import Contract
 from slither.tools.upgradeability.checks.abstract_checks import (
     CheckClassification,
     AbstractCheck,
+    CHECK_INFO,
 )
+from slither.utils.upgradeability import get_missing_vars
+from slither.utils.output import Output
 
 
 class MissingVariable(AbstractCheck):
     ARGUMENT = "missing-variables"
     IMPACT = CheckClassification.MEDIUM
 
     HELP = "Variable missing in the v2"
@@ -41,35 +47,26 @@
 Do not change the order of the state variables in the updated contract.
 """
     # endregion wiki_recommendation
 
     REQUIRE_CONTRACT = True
     REQUIRE_CONTRACT_V2 = True
 
-    def _check(self):
+    def _check(self) -> List[Output]:
         contract1 = self.contract
         contract2 = self.contract_v2
-        order1 = [
-            variable
-            for variable in contract1.state_variables_ordered
-            if not (variable.is_constant or variable.is_immutable)
-        ]
-        order2 = [
-            variable
-            for variable in contract2.state_variables_ordered
-            if not (variable.is_constant or variable.is_immutable)
-        ]
+
+        assert contract2
+        missing = get_missing_vars(contract1, contract2)
 
         results = []
-        for idx, _ in enumerate(order1):
-            variable1 = order1[idx]
-            if len(order2) <= idx:
-                info = ["Variable missing in ", contract2, ": ", variable1, "\n"]
-                json = self.generate_result(info)
-                results.append(json)
+        for variable1 in missing:
+            info: CHECK_INFO = ["Variable missing in ", contract2, ": ", variable1, "\n"]
+            json = self.generate_result(info)
+            results.append(json)
 
         return results
 
 
 class DifferentVariableContractProxy(AbstractCheck):
     ARGUMENT = "order-vars-proxy"
     IMPACT = CheckClassification.HIGH
@@ -104,44 +101,45 @@
 Avoid variables in the proxy. If a variable is in the proxy, ensure it has the same layout than in the contract.
 """
     # endregion wiki_recommendation
 
     REQUIRE_CONTRACT = True
     REQUIRE_PROXY = True
 
-    def _contract1(self):
+    def _contract1(self) -> Contract:
         return self.contract
 
-    def _contract2(self):
+    def _contract2(self) -> Contract:
+        assert self.proxy
         return self.proxy
 
-    def _check(self):
+    def _check(self) -> List[Output]:
         contract1 = self._contract1()
         contract2 = self._contract2()
         order1 = [
             variable
             for variable in contract1.state_variables_ordered
             if not (variable.is_constant or variable.is_immutable)
         ]
         order2 = [
             variable
             for variable in contract2.state_variables_ordered
             if not (variable.is_constant or variable.is_immutable)
         ]
 
-        results = []
+        results: List[Output] = []
         for idx, _ in enumerate(order1):
             if len(order2) <= idx:
                 # Handle by MissingVariable
                 return results
 
             variable1 = order1[idx]
             variable2 = order2[idx]
             if (variable1.name != variable2.name) or (variable1.type != variable2.type):
-                info = [
+                info: CHECK_INFO = [
                     "Different variables between ",
                     contract1,
                     " and ",
                     contract2,
                     "\n",
                 ]
                 info += ["\t ", variable1, "\n"]
@@ -186,15 +184,16 @@
 """
     # endregion wiki_recommendation
 
     REQUIRE_CONTRACT = True
     REQUIRE_PROXY = False
     REQUIRE_CONTRACT_V2 = True
 
-    def _contract2(self):
+    def _contract2(self) -> Contract:
+        assert self.contract_v2
         return self.contract_v2
 
 
 class ExtraVariablesProxy(AbstractCheck):
     ARGUMENT = "extra-vars-proxy"
     IMPACT = CheckClassification.MEDIUM
 
@@ -231,21 +230,22 @@
 Avoid variables in the proxy. If a variable is in the proxy, ensure it has the same layout than in the contract.
 """
     # endregion wiki_recommendation
 
     REQUIRE_CONTRACT = True
     REQUIRE_PROXY = True
 
-    def _contract1(self):
+    def _contract1(self) -> Contract:
         return self.contract
 
-    def _contract2(self):
+    def _contract2(self) -> Contract:
+        assert self.proxy
         return self.proxy
 
-    def _check(self):
+    def _check(self) -> List[Output]:
         contract1 = self._contract1()
         contract2 = self._contract2()
         order1 = [
             variable
             for variable in contract1.state_variables_ordered
             if not (variable.is_constant or variable.is_immutable)
         ]
@@ -260,15 +260,15 @@
         if len(order2) <= len(order1):
             return []
 
         idx = len(order1)
 
         while idx < len(order2):
             variable2 = order2[idx]
-            info = ["Extra variables in ", contract2, ": ", variable2, "\n"]
+            info: CHECK_INFO = ["Extra variables in ", contract2, ": ", variable2, "\n"]
             json = self.generate_result(info)
             results.append(json)
             idx = idx + 1
 
         return results
 
 
@@ -295,9 +295,10 @@
 
     IMPACT = CheckClassification.INFORMATIONAL
 
     REQUIRE_CONTRACT = True
     REQUIRE_PROXY = False
     REQUIRE_CONTRACT_V2 = True
 
-    def _contract2(self):
+    def _contract2(self) -> Contract:
+        assert self.contract_v2
         return self.contract_v2
```

### Comparing `slither-analyzer-0.9.3/slither/tools/upgradeability/utils/command_line.py` & `slither-analyzer-0.9.4/slither/tools/upgradeability/utils/command_line.py`

 * *Files 0% similar despite different names*

```diff
@@ -59,15 +59,15 @@
             ]
         )
         idx = idx + 1
     print(table)
 
 
 def output_to_markdown(detector_classes: List[Type[AbstractCheck]], _filter_wiki: str) -> None:
-    def extract_help(cls: AbstractCheck) -> str:
+    def extract_help(cls: Type[AbstractCheck]) -> str:
         if cls.WIKI == "":
             return cls.HELP
         return f"[{cls.HELP}]({cls.WIKI})"
 
     detectors_list = []
     for detector in detector_classes:
         argument = detector.ARGUMENT
```

### Comparing `slither-analyzer-0.9.3/slither/utils/arithmetic.py` & `slither-analyzer-0.9.4/slither/utils/arithmetic.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/utils/code_complexity.py` & `slither-analyzer-0.9.4/slither/utils/code_complexity.py`

 * *Files 4% similar despite different names*

```diff
@@ -31,25 +31,25 @@
         list(list(nodes))
     """
     visited = {n: False for n in function.nodes}
     assigned = {n: False for n in function.nodes}
     components = []
     l = []
 
-    def visit(node):
+    def visit(node: "Node") -> None:
         if not visited[node]:
             visited[node] = True
             for son in node.sons:
                 visit(son)
             l.append(node)
 
     for n in function.nodes:
         visit(n)
 
-    def assign(node: "Node", root: List["Node"]):
+    def assign(node: "Node", root: List["Node"]) -> None:
         if not assigned[node]:
             assigned[node] = True
             root.append(node)
             for father in node.fathers:
                 assign(father, root)
 
     for n in reversed(l):
```

### Comparing `slither-analyzer-0.9.3/slither/utils/codex.py` & `slither-analyzer-0.9.4/slither/utils/codex.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/utils/colors.py` & `slither-analyzer-0.9.4/slither/utils/colors.py`

 * *Files 4% similar despite different names*

```diff
@@ -24,15 +24,15 @@
     """
     Sets the appropriate flags to enable virtual terminal sequences in a Windows command prompt.
     Reference: https://docs.microsoft.com/en-us/windows/console/console-virtual-terminal-sequences
     """
 
     try:
         # pylint: disable=import-outside-toplevel
-        from ctypes import windll, byref
+        from ctypes import windll, byref  # type: ignore
         from ctypes.wintypes import DWORD, HANDLE
 
         kernel32 = windll.kernel32
         virtual_terminal_flag = 0x04  # ENABLE_VIRTUAL_TERMINAL_PROCESSING
 
         # Obtain our stdout/stderr handles.
         # Reference: https://docs.microsoft.com/en-us/windows/console/getstdhandle
@@ -61,15 +61,15 @@
         # Any generic failure (possibly from calling these methods on older Windows builds where they do not exist)
         # will fall back onto disabling colorization.
         return False
 
     return True
 
 
-def set_colorization_enabled(enabled: bool):
+def set_colorization_enabled(enabled: bool) -> None:
     """
     Sets the enabled state of output colorization.
     :param enabled: Boolean indicating whether output should be colorized.
     :return: None
     """
     # If color is supposed to be enabled and this is windows, we have to enable console virtual terminal sequences:
     if enabled and platform.system() == "Windows":
```

### Comparing `slither-analyzer-0.9.3/slither/utils/command_line.py` & `slither-analyzer-0.9.4/slither/utils/command_line.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,8 +1,9 @@
 import argparse
+import enum
 import json
 import os
 import re
 import logging
 from collections import defaultdict
 from typing import Dict, List, Type, Union
 
@@ -23,14 +24,23 @@
     "console",
     "detectors",
     "printers",
     "list-detectors",
     "list-printers",
 ]
 
+
+class FailOnLevel(enum.Enum):
+    PEDANTIC = "pedantic"
+    LOW = "low"
+    MEDIUM = "medium"
+    HIGH = "high"
+    NONE = "none"
+
+
 # Those are the flags shared by the command line and the config file
 defaults_flag_in_config = {
     "codex": False,
     "codex_contracts": "all",
     "codex_model": "text-davinci-003",
     "codex_temperature": 0,
     "codex_max_tokens": 300,
@@ -40,18 +50,15 @@
     "detectors_to_exclude": None,
     "exclude_dependencies": False,
     "exclude_informational": False,
     "exclude_optimization": False,
     "exclude_low": False,
     "exclude_medium": False,
     "exclude_high": False,
-    "fail_pedantic": True,
-    "fail_low": False,
-    "fail_medium": False,
-    "fail_high": False,
+    "fail_on": FailOnLevel.PEDANTIC,
     "json": None,
     "sarif": None,
     "json-types": ",".join(DEFAULT_JSON_OUTPUT_TYPES),
     "disable_color": False,
     "filter_paths": None,
     "generate_patches": False,
     # debug command
@@ -60,14 +67,21 @@
     "zip": None,
     "zip_type": "lzma",
     "show_ignored_findings": False,
     "no_fail": False,
     **DEFAULTS_FLAG_IN_CONFIG_CRYTIC_COMPILE,
 }
 
+deprecated_flags = {
+    "fail_pedantic": True,
+    "fail_low": False,
+    "fail_medium": False,
+    "fail_high": False,
+}
+
 
 def read_config_file(args: argparse.Namespace) -> None:
     # No config file was provided as an argument
     if args.config_file is None:
         # Check wether the default config file is present
         if os.path.exists("slither.config.json"):
             # The default file exists, use it
@@ -76,28 +90,56 @@
             return
 
     if os.path.isfile(args.config_file):
         try:
             with open(args.config_file, encoding="utf8") as f:
                 config = json.load(f)
                 for key, elem in config.items():
+                    if key in deprecated_flags:
+                        logger.info(
+                            yellow(f"{args.config_file} has a deprecated key: {key} : {elem}")
+                        )
+                        migrate_config_options(args, key, elem)
+                        continue
                     if key not in defaults_flag_in_config:
                         logger.info(
                             yellow(f"{args.config_file} has an unknown key: {key} : {elem}")
                         )
                         continue
                     if getattr(args, key) == defaults_flag_in_config[key]:
                         setattr(args, key, elem)
         except json.decoder.JSONDecodeError as e:
             logger.error(red(f"Impossible to read {args.config_file}, please check the file {e}"))
     else:
         logger.error(red(f"File {args.config_file} is not a file or does not exist"))
         logger.error(yellow("Falling back to the default settings..."))
 
 
+def migrate_config_options(args: argparse.Namespace, key: str, elem):
+    if key.startswith("fail_") and getattr(args, "fail_on") == defaults_flag_in_config["fail_on"]:
+        if key == "fail_pedantic":
+            pedantic_setting = elem
+            fail_on = FailOnLevel.PEDANTIC if pedantic_setting else FailOnLevel.NONE
+            setattr(args, "fail_on", fail_on)
+            logger.info(f"Migrating fail_pedantic: {pedantic_setting} as fail_on: {fail_on.value}")
+        elif key == "fail_low" and elem is True:
+            logger.info("Migrating fail_low: true -> fail_on: low")
+            setattr(args, "fail_on", FailOnLevel.LOW)
+
+        elif key == "fail_medium" and elem is True:
+            logger.info("Migrating fail_medium: true -> fail_on: medium")
+            setattr(args, "fail_on", FailOnLevel.MEDIUM)
+
+        elif key == "fail_high" and elem is True:
+            logger.info("Migrating fail_high: true -> fail_on: high")
+            setattr(args, "fail_on", FailOnLevel.HIGH)
+        else:
+            logger.warning(yellow(f"Key {key} was deprecated but no migration was provided"))
+
+
 def output_to_markdown(
     detector_classes: List[Type[AbstractDetector]],
     printer_classes: List[Type[AbstractPrinter]],
     filter_wiki: str,
 ) -> None:
     def extract_help(cls: Union[Type[AbstractDetector], Type[AbstractPrinter]]) -> str:
         if cls.WIKI == "":
```

### Comparing `slither-analyzer-0.9.3/slither/utils/comparable_enum.py` & `slither-analyzer-0.9.4/slither/utils/comparable_enum.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/utils/erc.py` & `slither-analyzer-0.9.4/slither/utils/erc.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/utils/expression_manipulations.py` & `slither-analyzer-0.9.4/slither/utils/expression_manipulations.py`

 * *Files 4% similar despite different names*

```diff
@@ -17,15 +17,15 @@
 from slither.core.expressions.index_access import IndexAccess
 from slither.core.expressions.literal import Literal
 from slither.core.expressions.member_access import MemberAccess
 from slither.core.expressions.new_array import NewArray
 from slither.core.expressions.new_contract import NewContract
 from slither.core.expressions.tuple_expression import TupleExpression
 from slither.core.expressions.type_conversion import TypeConversion
-
+from slither.core.expressions.new_elementary_type import NewElementaryType
 
 # pylint: disable=protected-access
 def f_expressions(
     e: Union[AssignmentOperation, BinaryOperation, TupleExpression],
     x: Union[Identifier, Literal, MemberAccess, IndexAccess],
 ) -> None:
     e._expressions.append(x)
@@ -96,15 +96,22 @@
             return
 
         if isinstance(expression, ConditionalExpression):
             raise SlitherException("Nested ternary operator not handled")
 
         if isinstance(
             expression,
-            (Literal, Identifier, NewArray, NewContract, ElementaryTypeNameExpression),
+            (
+                Literal,
+                Identifier,
+                NewArray,
+                NewContract,
+                ElementaryTypeNameExpression,
+                NewElementaryType,
+            ),
         ):
             return
 
         if isinstance(
             expression, (AssignmentOperation, BinaryOperation, TupleExpression, IndexAccess)
         ):
             true_expression._expressions = []
```

### Comparing `slither-analyzer-0.9.3/slither/utils/inheritance_analysis.py` & `slither-analyzer-0.9.4/slither/utils/inheritance_analysis.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/utils/integer_conversion.py` & `slither-analyzer-0.9.4/slither/utils/integer_conversion.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,14 +1,16 @@
 from fractions import Fraction
 from typing import Union
 
 from slither.exceptions import SlitherError
 
 
-def convert_string_to_fraction(val: Union[str, int]) -> Fraction:
+def convert_string_to_fraction(val: Union[str, bytes, int]) -> Fraction:
+    if isinstance(val, bytes):
+        return int.from_bytes(val, byteorder="big")
     if isinstance(val, int):
         return Fraction(val)
     if val.startswith(("0x", "0X")):
         return Fraction(int(val, 16))
 
     # Fractions do not support underscore separators (on Python <3.11)
     val = val.replace("_", "")
```

### Comparing `slither-analyzer-0.9.3/slither/utils/output.py` & `slither-analyzer-0.9.4/slither/utils/output.py`

 * *Files 1% similar despite different names*

```diff
@@ -6,16 +6,25 @@
 from collections import OrderedDict
 from typing import Tuple, Optional, Dict, List, Union, Any, TYPE_CHECKING, Type
 from zipfile import ZipFile
 
 from pkg_resources import require
 
 from slither.core.cfg.node import Node
-from slither.core.declarations import Contract, Function, Enum, Event, Structure, Pragma
+from slither.core.declarations import (
+    Contract,
+    Function,
+    Enum,
+    Event,
+    Structure,
+    Pragma,
+    FunctionContract,
+)
 from slither.core.source_mapping.source_mapping import SourceMapping
+from slither.core.variables.local_variable import LocalVariable
 from slither.core.variables.variable import Variable
 from slither.exceptions import SlitherError
 from slither.utils.colors import yellow
 from slither.utils.myprettytable import MyPrettyTable
 
 if TYPE_CHECKING:
     from slither.core.compilation_unit import SlitherCompilationUnit
@@ -347,29 +356,27 @@
     Union[
         str,
         Dict[str, Union[int, str, bool, List[int]]],
         Dict[str, Union[Dict[str, Union[str, Dict[str, Union[int, str, bool, List[int]]]]], str]],
     ],
 ]:
     # pylint: disable=import-outside-toplevel
-    from slither.core.children.child_contract import ChildContract
-    from slither.core.children.child_function import ChildFunction
-    from slither.core.children.child_inheritance import ChildInheritance
+    from slither.core.declarations.contract_level import ContractLevel
 
-    if isinstance(element, ChildInheritance):
+    if isinstance(element, FunctionContract):
         if element.contract_declarer:
             contract = Output("")
             contract.add_contract(element.contract_declarer)
             return contract.data["elements"][0]
-    elif isinstance(element, ChildContract):
+    elif isinstance(element, ContractLevel):
         if element.contract:
             contract = Output("")
             contract.add_contract(element.contract)
             return contract.data["elements"][0]
-    elif isinstance(element, ChildFunction):
+    elif isinstance(element, (LocalVariable, Node)):
         if element.function:
             function = Output("")
             function.add_function(element.function)
             return function.data["elements"][0]
     return None
```

### Comparing `slither-analyzer-0.9.3/slither/utils/output_capture.py` & `slither-analyzer-0.9.4/slither/utils/output_capture.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/utils/oz_hashes.py` & `slither-analyzer-0.9.4/slither/utils/oz_hashes.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/utils/source_mapping.py` & `slither-analyzer-0.9.4/slither/utils/source_mapping.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/utils/standard_libraries.py` & `slither-analyzer-0.9.4/slither/utils/standard_libraries.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/utils/tests_pattern.py` & `slither-analyzer-0.9.4/slither/utils/tests_pattern.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/utils/type.py` & `slither-analyzer-0.9.4/slither/utils/type.py`

 * *Files 8% similar despite different names*

```diff
@@ -193,7 +193,22 @@
     ):
         ret = []
         for r in variable_or_type.type.type.elems_ordered:
             ret += export_return_type_from_variable(r, all_types=False)
         return ret
 
     return [variable_or_type.type]
+
+
+def is_underlying_type_address(t: "Type") -> bool:
+    """
+    Return true if the underlying type is an address
+    i.e. if the type is an address or a contract
+    """
+    # pylint: disable=import-outside-toplevel
+    from slither.core.declarations.contract import Contract
+
+    if t == ElementaryType("address"):
+        return True
+    if isinstance(t, UserDefinedType) and isinstance(t.type, Contract):
+        return True
+    return False
```

### Comparing `slither-analyzer-0.9.3/slither/utils/type_helpers.py` & `slither-analyzer-0.9.4/slither/utils/type_helpers.py`

 * *Files identical despite different names*

### Comparing `slither-analyzer-0.9.3/slither/visitors/expression/constants_folding.py` & `slither-analyzer-0.9.4/slither/visitors/expression/write_var.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,179 +1,154 @@
-from fractions import Fraction
-from typing import Union, TYPE_CHECKING
+from typing import Any, List, Optional
 
-from slither.core.expressions import (
-    BinaryOperationType,
-    Literal,
-    UnaryOperationType,
-    Identifier,
-    BinaryOperation,
-    UnaryOperation,
-    TupleExpression,
-    TypeConversion,
-)
-
-from slither.utils.integer_conversion import convert_string_to_fraction, convert_string_to_int
+from slither.core.expressions import NewElementaryType
 from slither.visitors.expression.expression import ExpressionVisitor
+from slither.core.expressions.assignment_operation import AssignmentOperation
+from slither.core.expressions.binary_operation import BinaryOperation
+from slither.core.expressions.call_expression import CallExpression
+from slither.core.expressions.conditional_expression import ConditionalExpression
+from slither.core.expressions.elementary_type_name_expression import ElementaryTypeNameExpression
+from slither.core.expressions.expression import Expression
+from slither.core.expressions.identifier import Identifier
+from slither.core.expressions.index_access import IndexAccess
+from slither.core.expressions.literal import Literal
+from slither.core.expressions.member_access import MemberAccess
+from slither.core.expressions.new_array import NewArray
+from slither.core.expressions.new_contract import NewContract
+from slither.core.expressions.tuple_expression import TupleExpression
+from slither.core.expressions.type_conversion import TypeConversion
+from slither.core.expressions.unary_operation import UnaryOperation
 
-if TYPE_CHECKING:
-    from slither.core.solidity_types.elementary_type import ElementaryType
-
-
-class NotConstant(Exception):
-    pass
-
-
-KEY = "ConstantFolding"
 
-CONSTANT_TYPES_OPERATIONS = Union[
-    Literal, BinaryOperation, UnaryOperation, Identifier, TupleExpression, TypeConversion
-]
+key = "WriteVar"
 
 
-def get_val(expression: CONSTANT_TYPES_OPERATIONS) -> Union[bool, int, Fraction, str]:
-    val = expression.context[KEY]
+def get(expression: Expression) -> List[Any]:
+    val = expression.context[key]
     # we delete the item to reduce memory use
-    del expression.context[KEY]
+    del expression.context[key]
     return val
 
 
-def set_val(expression: CONSTANT_TYPES_OPERATIONS, val: Union[bool, int, Fraction, str]) -> None:
-    expression.context[KEY] = val
+def set_val(expression: Expression, val: List[Any]) -> None:
+    expression.context[key] = val
 
 
-class ConstantFolding(ExpressionVisitor):
-    def __init__(
-        self, expression: CONSTANT_TYPES_OPERATIONS, custom_type: Union[str, "ElementaryType"]
-    ) -> None:
-        self._type = custom_type
+class WriteVar(ExpressionVisitor):
+    def __init__(self, expression: Expression) -> None:
+        self._result: Optional[List[Expression]] = None
         super().__init__(expression)
 
-    def result(self) -> "Literal":
-        value = get_val(self._expression)
-        if isinstance(value, Fraction):
-            value = int(value)
-            # emulate 256-bit wrapping
-            if str(self._type).startswith("uint"):
-                value = value & (2**256 - 1)
-        return Literal(value, self._type)
-
-    def _post_identifier(self, expression: Identifier) -> None:
-        if not expression.value.is_constant:
-            raise NotConstant
-        expr = expression.value.expression
-        # assumption that we won't have infinite loop
-        if not isinstance(expr, Literal):
-            cf = ConstantFolding(expr, self._type)
-            expr = cf.result()
-        set_val(expression, convert_string_to_int(expr.converted_value))
+    def result(self) -> List[Any]:
+        if self._result is None:
+            self._result = list(set(get(self.expression)))
+        return self._result
 
-    # pylint: disable=too-many-branches
     def _post_binary_operation(self, expression: BinaryOperation) -> None:
-        left = get_val(expression.expression_left)
-        right = get_val(expression.expression_right)
-        if expression.type == BinaryOperationType.POWER:
-            set_val(expression, left**right)
-        elif expression.type == BinaryOperationType.MULTIPLICATION:
-            set_val(expression, left * right)
-        elif expression.type == BinaryOperationType.DIVISION:
-            set_val(expression, left / right)
-        elif expression.type == BinaryOperationType.MODULO:
-            set_val(expression, left % right)
-        elif expression.type == BinaryOperationType.ADDITION:
-            set_val(expression, left + right)
-        elif expression.type == BinaryOperationType.SUBTRACTION:
-            set_val(expression, left - right)
-        # Convert to int for operations not supported by Fraction
-        elif expression.type == BinaryOperationType.LEFT_SHIFT:
-            set_val(expression, int(left) << int(right))
-        elif expression.type == BinaryOperationType.RIGHT_SHIFT:
-            set_val(expression, int(left) >> int(right))
-        elif expression.type == BinaryOperationType.AND:
-            set_val(expression, int(left) & int(right))
-        elif expression.type == BinaryOperationType.CARET:
-            set_val(expression, int(left) ^ int(right))
-        elif expression.type == BinaryOperationType.OR:
-            set_val(expression, int(left) | int(right))
-        elif expression.type == BinaryOperationType.LESS:
-            set_val(expression, int(left) < int(right))
-        elif expression.type == BinaryOperationType.LESS_EQUAL:
-            set_val(expression, int(left) <= int(right))
-        elif expression.type == BinaryOperationType.GREATER:
-            set_val(expression, int(left) > int(right))
-        elif expression.type == BinaryOperationType.GREATER_EQUAL:
-            set_val(expression, int(left) >= int(right))
-        elif expression.type == BinaryOperationType.EQUAL:
-            set_val(expression, int(left) == int(right))
-        elif expression.type == BinaryOperationType.NOT_EQUAL:
-            set_val(expression, int(left) != int(right))
-        # Convert boolean literals from string to bool
-        elif expression.type == BinaryOperationType.ANDAND:
-            set_val(expression, left == "true" and right == "true")
-        elif expression.type == BinaryOperationType.OROR:
-            set_val(expression, left == "true" or right == "true")
-        else:
-            raise NotConstant
+        left = get(expression.expression_left)
+        right = get(expression.expression_right)
+        val = left + right
+        if expression.is_lvalue:
+            val += [expression]
+        set_val(expression, val)
+
+    def _post_call_expression(self, expression: CallExpression) -> None:
+        called = get(expression.called)
+        args = [get(a) for a in expression.arguments if a]
+        args = [item for sublist in args for item in sublist]
+        val = called + args
+        if expression.is_lvalue:
+            val += [expression]
+        set_val(expression, val)
+
+    def _post_conditional_expression(self, expression: ConditionalExpression) -> None:
+        if_expr = get(expression.if_expression)
+        else_expr = get(expression.else_expression)
+        then_expr = get(expression.then_expression)
+        val = if_expr + else_expr + then_expr
+        if expression.is_lvalue:
+            val += [expression]
+        set_val(expression, val)
+
+    def _post_assignement_operation(self, expression: AssignmentOperation) -> None:
+        left = get(expression.expression_left)
+        right = get(expression.expression_right)
+        val = left + right
+        if expression.is_lvalue:
+            val += [expression]
+        set_val(expression, val)
 
-    def _post_unary_operation(self, expression: UnaryOperation) -> None:
-        # Case of uint a = -7; uint[-a] arr;
-        if expression.type == UnaryOperationType.MINUS_PRE:
-            expr = expression.expression
-            if not isinstance(expr, Literal):
-                cf = ConstantFolding(expr, self._type)
-                expr = cf.result()
-            assert isinstance(expr, Literal)
-            set_val(expression, -convert_string_to_fraction(expr.converted_value))
+    def _post_elementary_type_name_expression(
+        self, expression: ElementaryTypeNameExpression
+    ) -> None:
+        set_val(expression, [])
+
+    # save only identifier expression
+    def _post_identifier(self, expression: Identifier) -> None:
+        if expression.is_lvalue:
+            set_val(expression, [expression])
         else:
-            raise NotConstant
+            set_val(expression, [])
+
+    #        if isinstance(expression.value, Variable):
+    #            set_val(expression, [expression.value])
+    #        else:
+    #            set_val(expression, [])
+
+    def _post_index_access(self, expression: IndexAccess) -> None:
+        left = get(expression.expression_left)
+        right = get(expression.expression_right)
+        val = left + right
+        if expression.is_lvalue:
+            #       val += [expression]
+            val += [expression.expression_left]
+        #       n = expression.expression_left
+        # parse all the a.b[..].c[..]
+        #      while isinstance(n, (IndexAccess, MemberAccess)):
+        #          if isinstance(n, IndexAccess):
+        #              val += [n.expression_left]
+        #              n = n.expression_left
+        #          else:
+        #              val += [n.expression]
+        #              n = n.expression
+        set_val(expression, val)
 
     def _post_literal(self, expression: Literal) -> None:
-        if expression.converted_value in ["true", "false"]:
-            set_val(expression, expression.converted_value)
-        else:
-            try:
-                set_val(expression, convert_string_to_fraction(expression.converted_value))
-            except ValueError as e:
-                raise NotConstant from e
-
-    def _post_assignement_operation(self, expression):
-        raise NotConstant
-
-    def _post_call_expression(self, expression):
-        raise NotConstant
-
-    def _post_conditional_expression(self, expression):
-        raise NotConstant
-
-    def _post_elementary_type_name_expression(self, expression):
-        raise NotConstant
-
-    def _post_index_access(self, expression):
-        raise NotConstant
-
-    def _post_member_access(self, expression):
-        raise NotConstant
-
-    def _post_new_array(self, expression):
-        raise NotConstant
-
-    def _post_new_contract(self, expression):
-        raise NotConstant
-
-    def _post_new_elementary_type(self, expression):
-        raise NotConstant
-
-    def _post_tuple_expression(self, expression):
-        if expression.expressions:
-            if len(expression.expressions) == 1:
-                cf = ConstantFolding(expression.expressions[0], self._type)
-                expr = cf.result()
-                assert isinstance(expr, Literal)
-                set_val(expression, convert_string_to_fraction(expr.converted_value))
-                return
-        raise NotConstant
-
-    def _post_type_conversion(self, expression):
-        cf = ConstantFolding(expression.expression, self._type)
-        expr = cf.result()
-        assert isinstance(expr, Literal)
-        set_val(expression, convert_string_to_fraction(expr.converted_value))
+        set_val(expression, [])
+
+    def _post_member_access(self, expression: MemberAccess) -> None:
+        expr = get(expression.expression)
+        val = expr
+        if expression.is_lvalue:
+            val += [expression]
+            val += [expression.expression]
+        set_val(expression, val)
+
+    def _post_new_array(self, expression: NewArray) -> None:
+        set_val(expression, [])
+
+    def _post_new_contract(self, expression: NewContract) -> None:
+        set_val(expression, [])
+
+    def _post_new_elementary_type(self, expression: NewElementaryType) -> None:
+        set_val(expression, [])
+
+    def _post_tuple_expression(self, expression: TupleExpression) -> None:
+        expressions = [get(e) for e in expression.expressions if e]
+        val = [item for sublist in expressions for item in sublist]
+        if expression.is_lvalue:
+            val += [expression]
+        set_val(expression, val)
+
+    def _post_type_conversion(self, expression: TypeConversion) -> None:
+        expr = get(expression.expression)
+        val = expr
+        if expression.is_lvalue:
+            val += [expression]
+        set_val(expression, val)
+
+    def _post_unary_operation(self, expression: UnaryOperation) -> None:
+        expr = get(expression.expression)
+        val = expr
+        if expression.is_lvalue:
+            val += [expression]
+        set_val(expression, val)
```

### Comparing `slither-analyzer-0.9.3/slither/visitors/expression/export_values.py` & `slither-analyzer-0.9.4/slither/visitors/expression/export_values.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,8 +1,19 @@
-from typing import Any, List
+from typing import Any, List, Optional
+
+from slither.core.expressions import (
+    AssignmentOperation,
+    ConditionalExpression,
+    ElementaryTypeNameExpression,
+    IndexAccess,
+    NewArray,
+    NewContract,
+    UnaryOperation,
+    NewElementaryType,
+)
 from slither.visitors.expression.expression import ExpressionVisitor
 from slither.core.expressions.call_expression import CallExpression
 from slither.core.expressions.identifier import Identifier
 from slither.core.expressions.literal import Literal
 from slither.core.expressions.binary_operation import BinaryOperation
 from slither.core.expressions.expression import Expression
 from slither.core.expressions.member_access import MemberAccess
@@ -21,20 +32,24 @@
 
 
 def set_val(expression: Expression, val: List[Any]) -> None:
     expression.context[key] = val
 
 
 class ExportValues(ExpressionVisitor):
-    def result(self) -> List[Any]:
+    def __init__(self, expression: Expression) -> None:
+        self._result: Optional[List[Expression]] = None
+        super().__init__(expression)
+
+    def result(self) -> List[Expression]:
         if self._result is None:
             self._result = list(set(get(self.expression)))
         return self._result
 
-    def _post_assignement_operation(self, expression):
+    def _post_assignement_operation(self, expression: AssignmentOperation) -> None:
         left = get(expression.expression_left)
         right = get(expression.expression_right)
         val = left + right
         set_val(expression, val)
 
     def _post_binary_operation(self, expression: BinaryOperation) -> None:
         left = get(expression.expression_left)
@@ -45,57 +60,59 @@
     def _post_call_expression(self, expression: CallExpression) -> None:
         called = get(expression.called)
         args = [get(a) for a in expression.arguments if a]
         args = [item for sublist in args for item in sublist]
         val = called + args
         set_val(expression, val)
 
-    def _post_conditional_expression(self, expression):
+    def _post_conditional_expression(self, expression: ConditionalExpression) -> None:
         if_expr = get(expression.if_expression)
         else_expr = get(expression.else_expression)
         then_expr = get(expression.then_expression)
         val = if_expr + else_expr + then_expr
         set_val(expression, val)
 
-    def _post_elementary_type_name_expression(self, expression):
+    def _post_elementary_type_name_expression(
+        self, expression: ElementaryTypeNameExpression
+    ) -> None:
         set_val(expression, [])
 
     def _post_identifier(self, expression: Identifier) -> None:
         set_val(expression, [expression.value])
 
-    def _post_index_access(self, expression):
+    def _post_index_access(self, expression: IndexAccess) -> None:
         left = get(expression.expression_left)
         right = get(expression.expression_right)
         val = left + right
         set_val(expression, val)
 
     def _post_literal(self, expression: Literal) -> None:
         set_val(expression, [])
 
     def _post_member_access(self, expression: MemberAccess) -> None:
         expr = get(expression.expression)
         val = expr
         set_val(expression, val)
 
-    def _post_new_array(self, expression):
+    def _post_new_array(self, expression: NewArray) -> None:
         set_val(expression, [])
 
-    def _post_new_contract(self, expression):
+    def _post_new_contract(self, expression: NewContract) -> None:
         set_val(expression, [])
 
-    def _post_new_elementary_type(self, expression):
+    def _post_new_elementary_type(self, expression: NewElementaryType) -> None:
         set_val(expression, [])
 
     def _post_tuple_expression(self, expression: TupleExpression) -> None:
         expressions = [get(e) for e in expression.expressions if e]
         val = [item for sublist in expressions for item in sublist]
         set_val(expression, val)
 
     def _post_type_conversion(self, expression: TypeConversion) -> None:
         expr = get(expression.expression)
         val = expr
         set_val(expression, val)
 
-    def _post_unary_operation(self, expression):
+    def _post_unary_operation(self, expression: UnaryOperation) -> None:
         expr = get(expression.expression)
         val = expr
         set_val(expression, val)
```

### Comparing `slither-analyzer-0.9.3/slither/visitors/expression/expression.py` & `slither-analyzer-0.9.4/slither/visitors/expression/expression.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,9 +1,8 @@
 import logging
-from typing import Optional, Any
 
 from slither.core.expressions.assignment_operation import AssignmentOperation
 from slither.core.expressions.binary_operation import BinaryOperation
 from slither.core.expressions.call_expression import CallExpression
 from slither.core.expressions.conditional_expression import ConditionalExpression
 from slither.core.expressions.elementary_type_name_expression import ElementaryTypeNameExpression
 from slither.core.expressions.expression import Expression
@@ -18,24 +17,22 @@
 from slither.core.expressions.type_conversion import TypeConversion
 from slither.core.expressions.unary_operation import UnaryOperation
 from slither.exceptions import SlitherError
 
 logger = logging.getLogger("ExpressionVisitor")
 
 
+# pylint: disable=too-few-public-methods
 class ExpressionVisitor:
     def __init__(self, expression: Expression) -> None:
-        # Inherited class must declared their variables prior calling super().__init__
+        super().__init__()
+        # Inherited class must declare their variables prior calling super().__init__
         self._expression = expression
-        self._result: Any = None
         self._visit_expression(self.expression)
 
-    def result(self) -> Optional[bool]:
-        return self._result
-
     @property
     def expression(self) -> Expression:
         return self._expression
 
     # visit an expression
     # call pre_visit, visit_expression_name, post_visit
     # pylint: disable=too-many-branches
@@ -142,15 +139,15 @@
 
     def _visit_new_array(self, expression: NewArray) -> None:
         pass
 
     def _visit_new_contract(self, expression: NewContract) -> None:
         pass
 
-    def _visit_new_elementary_type(self, expression):
+    def _visit_new_elementary_type(self, expression: NewElementaryType) -> None:
         pass
 
     def _visit_tuple_expression(self, expression: TupleExpression) -> None:
         for e in expression.expressions:
             if e:
                 self._visit_expression(e)
 
@@ -158,15 +155,15 @@
         self._visit_expression(expression.expression)
 
     def _visit_unary_operation(self, expression: UnaryOperation) -> None:
         self._visit_expression(expression.expression)
 
     # pre visit
 
-    def _pre_visit(self, expression) -> None:  # pylint: disable=too-many-branches
+    def _pre_visit(self, expression: Expression) -> None:  # pylint: disable=too-many-branches
         if isinstance(expression, AssignmentOperation):
             self._pre_assignement_operation(expression)
 
         elif isinstance(expression, BinaryOperation):
             self._pre_binary_operation(expression)
 
         elif isinstance(expression, CallExpression):
@@ -247,29 +244,29 @@
 
     def _pre_new_array(self, expression: NewArray) -> None:
         pass
 
     def _pre_new_contract(self, expression: NewContract) -> None:
         pass
 
-    def _pre_new_elementary_type(self, expression):
+    def _pre_new_elementary_type(self, expression: NewElementaryType) -> None:
         pass
 
     def _pre_tuple_expression(self, expression: TupleExpression) -> None:
         pass
 
     def _pre_type_conversion(self, expression: TypeConversion) -> None:
         pass
 
     def _pre_unary_operation(self, expression: UnaryOperation) -> None:
         pass
 
     # post visit
 
-    def _post_visit(self, expression) -> None:  # pylint: disable=too-many-branches
+    def _post_visit(self, expression: Expression) -> None:  # pylint: disable=too-many-branches
         if isinstance(expression, AssignmentOperation):
             self._post_assignement_operation(expression)
 
         elif isinstance(expression, BinaryOperation):
             self._post_binary_operation(expression)
 
         elif isinstance(expression, CallExpression):
@@ -324,15 +321,15 @@
 
     def _post_binary_operation(self, expression: BinaryOperation) -> None:
         pass
 
     def _post_call_expression(self, expression: CallExpression) -> None:
         pass
 
-    def _post_conditional_expression(self, expression):
+    def _post_conditional_expression(self, expression: ConditionalExpression) -> None:
         pass
 
     def _post_elementary_type_name_expression(
         self, expression: ElementaryTypeNameExpression
     ) -> None:
         pass
 
@@ -350,15 +347,15 @@
 
     def _post_new_array(self, expression: NewArray) -> None:
         pass
 
     def _post_new_contract(self, expression: NewContract) -> None:
         pass
 
-    def _post_new_elementary_type(self, expression):
+    def _post_new_elementary_type(self, expression: NewElementaryType) -> None:
         pass
 
     def _post_tuple_expression(self, expression: TupleExpression) -> None:
         pass
 
     def _post_type_conversion(self, expression: TypeConversion) -> None:
         pass
```

### Comparing `slither-analyzer-0.9.3/slither/visitors/expression/expression_printer.py` & `slither-analyzer-0.9.4/slither/visitors/expression/expression_printer.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,101 +1,110 @@
+from typing import Optional
+
+from slither.core import expressions
+from slither.core.expressions.expression import Expression
 from slither.visitors.expression.expression import ExpressionVisitor
 
 
-def get(expression):
+def get(expression: Expression) -> str:
     val = expression.context["ExpressionPrinter"]
     # we delete the item to reduce memory use
     del expression.context["ExpressionPrinter"]
     return val
 
 
-def set_val(expression, val):
+def set_val(expression: Expression, val: str) -> None:
     expression.context["ExpressionPrinter"] = val
 
 
 class ExpressionPrinter(ExpressionVisitor):
-    def result(self):
+    def __init__(self, expression: Expression) -> None:
+        self._result: Optional[str] = None
+        super().__init__(expression)
+
+    def result(self) -> str:
         if not self._result:
             self._result = get(self.expression)
         return self._result
 
-    def _post_assignement_operation(self, expression):
+    def _post_assignement_operation(self, expression: expressions.AssignmentOperation) -> None:
         left = get(expression.expression_left)
         right = get(expression.expression_right)
         val = f"{left} {expression.type} {right}"
         set_val(expression, val)
 
-    def _post_binary_operation(self, expression):
+    def _post_binary_operation(self, expression: expressions.BinaryOperation) -> None:
         left = get(expression.expression_left)
         right = get(expression.expression_right)
         val = f"{left} {expression.type} {right}"
         set_val(expression, val)
 
-    def _post_call_expression(self, expression):
+    def _post_call_expression(self, expression: expressions.CallExpression) -> None:
         called = get(expression.called)
         arguments = ",".join([get(x) for x in expression.arguments if x])
         val = f"{called}({arguments})"
         set_val(expression, val)
 
-    def _post_conditional_expression(self, expression):
+    def _post_conditional_expression(self, expression: expressions.ConditionalExpression) -> None:
         if_expr = get(expression.if_expression)
         else_expr = get(expression.else_expression)
         then_expr = get(expression.then_expression)
         val = f"if {if_expr} then {else_expr} else {then_expr}"
         set_val(expression, val)
 
-    def _post_elementary_type_name_expression(self, expression):
+    def _post_elementary_type_name_expression(
+        self, expression: expressions.ElementaryTypeNameExpression
+    ) -> None:
         set_val(expression, str(expression.type))
 
-    def _post_identifier(self, expression):
+    def _post_identifier(self, expression: expressions.Identifier) -> None:
         set_val(expression, str(expression.value))
 
-    def _post_index_access(self, expression):
+    def _post_index_access(self, expression: expressions.IndexAccess) -> None:
         left = get(expression.expression_left)
         right = get(expression.expression_right)
         val = f"{left}[{right}]"
         set_val(expression, val)
 
-    def _post_literal(self, expression):
+    def _post_literal(self, expression: expressions.Literal) -> None:
         set_val(expression, str(expression.value))
 
-    def _post_member_access(self, expression):
+    def _post_member_access(self, expression: expressions.MemberAccess) -> None:
         expr = get(expression.expression)
         member_name = str(expression.member_name)
         val = f"{expr}.{member_name}"
         set_val(expression, val)
 
-    def _post_new_array(self, expression):
+    def _post_new_array(self, expression: expressions.NewArray) -> None:
         array = str(expression.array_type)
-        depth = expression.depth
-        val = f"new {array}{'[]' * depth}"
+        val = f"new {array}"
         set_val(expression, val)
 
-    def _post_new_contract(self, expression):
+    def _post_new_contract(self, expression: expressions.NewContract) -> None:
         contract = str(expression.contract_name)
         val = f"new {contract}"
         set_val(expression, val)
 
-    def _post_new_elementary_type(self, expression):
+    def _post_new_elementary_type(self, expression: expressions.NewElementaryType) -> None:
         t = str(expression.type)
         val = f"new {t}"
         set_val(expression, val)
 
-    def _post_tuple_expression(self, expression):
-        expressions = [get(e) for e in expression.expressions if e]
-        val = f"({','.join(expressions)})"
+    def _post_tuple_expression(self, expression: expressions.TupleExpression) -> None:
+        underlying_expressions = [get(e) for e in expression.expressions if e]
+        val = f"({','.join(underlying_expressions)})"
         set_val(expression, val)
 
-    def _post_type_conversion(self, expression):
+    def _post_type_conversion(self, expression: expressions.TypeConversion) -> None:
         t = str(expression.type)
         expr = get(expression.expression)
         val = f"{t}({expr})"
         set_val(expression, val)
 
-    def _post_unary_operation(self, expression):
+    def _post_unary_operation(self, expression: expressions.UnaryOperation) -> None:
         t = str(expression.type)
         expr = get(expression.expression)
         if expression.is_prefix:
             val = f"{t}{expr}"
         else:
             val = f"{expr}{t}"
         set_val(expression, val)
```

### Comparing `slither-analyzer-0.9.3/slither/visitors/expression/find_calls.py` & `slither-analyzer-0.9.4/slither/visitors/expression/find_calls.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,9 +1,10 @@
-from typing import Any, Union, List
+from typing import Any, Union, List, Optional
 
+from slither.core.expressions import NewElementaryType
 from slither.core.expressions.expression import Expression
 from slither.visitors.expression.expression import ExpressionVisitor
 from slither.core.expressions.assignment_operation import AssignmentOperation
 from slither.core.expressions.binary_operation import BinaryOperation
 from slither.core.expressions.call_expression import CallExpression
 from slither.core.expressions.conditional_expression import ConditionalExpression
 from slither.core.expressions.elementary_type_name_expression import ElementaryTypeNameExpression
@@ -28,14 +29,18 @@
 
 
 def set_val(expression: Expression, val: List[Union[Any, CallExpression]]) -> None:
     expression.context[key] = val
 
 
 class FindCalls(ExpressionVisitor):
+    def __init__(self, expression: Expression) -> None:
+        self._result: Optional[List[Expression]] = None
+        super().__init__(expression)
+
     def result(self) -> List[Expression]:
         if self._result is None:
             self._result = list(set(get(self.expression)))
         return self._result
 
     def _post_assignement_operation(self, expression: AssignmentOperation) -> None:
         left = get(expression.expression_left)
@@ -47,16 +52,16 @@
         left = get(expression.expression_left)
         right = get(expression.expression_right)
         val = left + right
         set_val(expression, val)
 
     def _post_call_expression(self, expression: CallExpression) -> None:
         called = get(expression.called)
-        args = [get(a) for a in expression.arguments if a]
-        args = [item for sublist in args for item in sublist]
+        argss = [get(a) for a in expression.arguments if a]
+        args = [item for sublist in argss for item in sublist]
         val = called + args
         val += [expression]
         set_val(expression, val)
 
     def _post_conditional_expression(self, expression: ConditionalExpression) -> None:
         if_expr = get(expression.if_expression)
         else_expr = get(expression.else_expression)
@@ -89,15 +94,15 @@
 
     def _post_new_array(self, expression: NewArray) -> None:
         set_val(expression, [])
 
     def _post_new_contract(self, expression: NewContract) -> None:
         set_val(expression, [])
 
-    def _post_new_elementary_type(self, expression):
+    def _post_new_elementary_type(self, expression: NewElementaryType) -> None:
         set_val(expression, [])
 
     def _post_tuple_expression(self, expression: TupleExpression) -> None:
         expressions = [get(e) for e in expression.expressions if e]
         val = [item for sublist in expressions for item in sublist]
         set_val(expression, val)
```

### Comparing `slither-analyzer-0.9.3/slither/visitors/expression/read_var.py` & `slither-analyzer-0.9.4/slither/visitors/expression/read_var.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,9 +1,10 @@
-from typing import Any, List, Union
+from typing import Any, List, Union, Optional
 
+from slither.core.expressions import NewElementaryType
 from slither.visitors.expression.expression import ExpressionVisitor
 
 from slither.core.expressions.assignment_operation import (
     AssignmentOperation,
     AssignmentOperationType,
 )
 
@@ -36,15 +37,19 @@
 
 
 def set_val(expression: Expression, val: List[Union[Identifier, IndexAccess, Any]]) -> None:
     expression.context[key] = val
 
 
 class ReadVar(ExpressionVisitor):
-    def result(self) -> List[Union[Identifier, IndexAccess, Any]]:
+    def __init__(self, expression: Expression) -> None:
+        self._result: Optional[List[Expression]] = None
+        super().__init__(expression)
+
+    def result(self) -> List[Expression]:
         if self._result is None:
             self._result = list(set(get(self.expression)))
         return self._result
 
     # overide assignement
     # dont explore if its direct assignement (we explore if its +=, -=, ...)
     def _visit_assignement_operation(self, expression: AssignmentOperation) -> None:
@@ -65,16 +70,16 @@
         left = get(expression.expression_left)
         right = get(expression.expression_right)
         val = left + right
         set_val(expression, val)
 
     def _post_call_expression(self, expression: CallExpression) -> None:
         called = get(expression.called)
-        args = [get(a) for a in expression.arguments if a]
-        args = [item for sublist in args for item in sublist]
+        argss = [get(a) for a in expression.arguments if a]
+        args = [item for sublist in argss for item in sublist]
         val = called + args
         set_val(expression, val)
 
     def _post_conditional_expression(self, expression: ConditionalExpression) -> None:
         if_expr = get(expression.if_expression)
         else_expr = get(expression.else_expression)
         then_expr = get(expression.then_expression)
@@ -87,14 +92,15 @@
         set_val(expression, [])
 
     # save only identifier expression
     def _post_identifier(self, expression: Identifier) -> None:
         if isinstance(expression.value, Variable):
             set_val(expression, [expression])
         elif isinstance(expression.value, SolidityVariable):
+            # TODO: investigate if this branch can be reached, and if Identifier.value has the correct type
             set_val(expression, [expression])
         else:
             set_val(expression, [])
 
     def _post_index_access(self, expression: IndexAccess) -> None:
         left = get(expression.expression_left)
         right = get(expression.expression_right)
@@ -111,15 +117,15 @@
 
     def _post_new_array(self, expression: NewArray) -> None:
         set_val(expression, [])
 
     def _post_new_contract(self, expression: NewContract) -> None:
         set_val(expression, [])
 
-    def _post_new_elementary_type(self, expression):
+    def _post_new_elementary_type(self, expression: NewElementaryType) -> None:
         set_val(expression, [])
 
     def _post_tuple_expression(self, expression: TupleExpression) -> None:
         expressions = [get(e) for e in expression.expressions if e]
         val = [item for sublist in expressions for item in sublist]
         set_val(expression, val)
```

### Comparing `slither-analyzer-0.9.3/slither/visitors/slithir/expression_to_slithir.py` & `slither-analyzer-0.9.4/slither/visitors/slithir/expression_to_slithir.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,37 +1,42 @@
 import logging
-from typing import Union, List, TYPE_CHECKING
+from typing import Union, List, TYPE_CHECKING, Any
 
+from slither.core import expressions
 from slither.core.declarations import (
     Function,
     SolidityVariable,
     SolidityVariableComposed,
     SolidityFunction,
     Contract,
+    EnumContract,
+    EnumTopLevel,
+    Enum,
 )
-from slither.core.declarations.enum import Enum
 from slither.core.expressions import (
     AssignmentOperation,
     AssignmentOperationType,
     UnaryOperationType,
     BinaryOperationType,
     ElementaryTypeNameExpression,
     CallExpression,
     Identifier,
     MemberAccess,
+    ConditionalExpression,
+    NewElementaryType,
 )
 from slither.core.expressions.binary_operation import BinaryOperation
 from slither.core.expressions.expression import Expression
 from slither.core.expressions.index_access import IndexAccess
 from slither.core.expressions.literal import Literal
 from slither.core.expressions.new_array import NewArray
 from slither.core.expressions.new_contract import NewContract
 from slither.core.expressions.tuple_expression import TupleExpression
 from slither.core.expressions.unary_operation import UnaryOperation
-from slither.core.solidity_types import ArrayType, ElementaryType, TypeAlias
+from slither.core.solidity_types import ArrayType, ElementaryType, TypeAlias, UserDefinedType
 from slither.core.solidity_types.type import Type
 from slither.core.variables.local_variable import LocalVariable
 from slither.core.variables.local_variable_init_from_tuple import LocalVariableInitFromTuple
 from slither.core.variables.state_variable import StateVariable
 from slither.core.variables.variable import Variable
 from slither.slithir.exceptions import SlithIRError
 from slither.slithir.operations import (
@@ -67,26 +72,22 @@
     from slither.core.cfg.node import Node
 
 logger = logging.getLogger("VISTIOR:ExpressionToSlithIR")
 
 key = "expressionToSlithIR"
 
 
-def get(expression: Union[Expression, Operation]):
+def get(expression: Expression) -> Any:
     val = expression.context[key]
     # we delete the item to reduce memory use
     del expression.context[key]
     return val
 
 
-def get_without_removing(expression):
-    return expression.context[key]
-
-
-def set_val(expression: Union[Expression, Operation], val) -> None:
+def set_val(expression: Expression, val: Any) -> None:
     expression.context[key] = val
 
 
 _binary_to_binary = {
     BinaryOperationType.POWER: BinaryType.POWER,
     BinaryOperationType.MULTIPLICATION: BinaryType.MULTIPLICATION,
     BinaryOperationType.DIVISION: BinaryType.DIVISION,
@@ -117,15 +118,15 @@
 }
 
 
 def convert_assignment(
     left: Union[LocalVariable, StateVariable, ReferenceVariable],
     right: Union[LocalVariable, StateVariable, ReferenceVariable],
     t: AssignmentOperationType,
-    return_type,
+    return_type: Type,
 ) -> Union[Binary, Assignment]:
     if t == AssignmentOperationType.ASSIGN:
         return Assignment(left, right, return_type)
     if t == AssignmentOperationType.ASSIGN_OR:
         return Binary(left, left, right, BinaryType.OR)
     if t == AssignmentOperationType.ASSIGN_CARET:
         return Binary(left, left, right, BinaryType.CARET)
@@ -146,14 +147,15 @@
     if t == AssignmentOperationType.ASSIGN_MODULO:
         return Binary(left, left, right, BinaryType.MODULO)
 
     raise SlithIRError("Missing type during assignment conversion")
 
 
 class ExpressionToSlithIR(ExpressionVisitor):
+
     # pylint: disable=super-init-not-called
     def __init__(self, expression: Expression, node: "Node") -> None:
         from slither.core.cfg.node import NodeType  # pylint: disable=import-outside-toplevel
 
         self._expression = expression
         self._node = node
         self._result: List[Operation] = []
@@ -167,19 +169,24 @@
 
     def result(self) -> List[Operation]:
         return self._result
 
     def _post_assignement_operation(self, expression: AssignmentOperation) -> None:
         left = get(expression.expression_left)
         right = get(expression.expression_right)
+        operation: Operation
         if isinstance(left, list):  # tuple expression:
             if isinstance(right, list):  # unbox assigment
                 assert len(left) == len(right)
                 for idx, _ in enumerate(left):
-                    if not left[idx] is None:
+                    if (
+                        not left[idx] is None
+                        and expression.type
+                        and expression.expression_return_type
+                    ):
                         operation = convert_assignment(
                             left[idx],
                             right[idx],
                             expression.type,
                             expression.expression_return_type,
                         )
                         operation.set_expression(expression)
@@ -278,22 +285,25 @@
 
         assert isinstance(expression, CallExpression)
 
         expression_called = expression.called
         called = get(expression_called)
 
         args = [get(a) for a in expression.arguments if a]
+        val: Union[TupleVariable, TemporaryVariable]
+        var: Operation
         for arg in args:
             arg_ = Argument(arg)
             arg_.set_expression(expression)
             self._result.append(arg_)
         if isinstance(called, Function):
             # internal call
 
             # If tuple
+
             if expression.type_call.startswith("tuple(") and expression.type_call != "tuple()":
                 val = TupleVariable(self._node)
             else:
                 val = TemporaryVariable(self._node)
             internal_call = InternalCall(called, len(args), val, expression.type_call)
             internal_call.set_expression(expression)
             self._result.append(internal_call)
@@ -304,40 +314,40 @@
             isinstance(called, TypeAlias)
             and isinstance(expression_called, MemberAccess)
             and expression_called.member_name in ["wrap", "unwrap"]
             and len(args) == 1
         ):
             # wrap: underlying_type -> alias
             # unwrap: alias -> underlying_type
-            dest_type = (
+            dest_type: Union[TypeAlias, ElementaryType] = (
                 called if expression_called.member_name == "wrap" else called.underlying_type
             )
             val = TemporaryVariable(self._node)
             var = TypeConversion(val, args[0], dest_type)
             var.set_expression(expression)
             val.set_type(dest_type)
             self._result.append(var)
             set_val(expression, val)
 
         # yul things
         elif called.name == "caller()":
             val = TemporaryVariable(self._node)
-            var = Assignment(val, SolidityVariableComposed("msg.sender"), "uint256")
+            var = Assignment(val, SolidityVariableComposed("msg.sender"), ElementaryType("uint256"))
             self._result.append(var)
             set_val(expression, val)
         elif called.name == "origin()":
             val = TemporaryVariable(self._node)
-            var = Assignment(val, SolidityVariableComposed("tx.origin"), "uint256")
+            var = Assignment(val, SolidityVariableComposed("tx.origin"), ElementaryType("uint256"))
             self._result.append(var)
             set_val(expression, val)
         elif called.name == "extcodesize(uint256)":
-            val = ReferenceVariable(self._node)
-            var = Member(args[0], Constant("codesize"), val)
+            val_ref = ReferenceVariable(self._node)
+            var = Member(args[0], Constant("codesize"), val_ref)
             self._result.append(var)
-            set_val(expression, val)
+            set_val(expression, val_ref)
         elif called.name == "selfbalance()":
             val = TemporaryVariable(self._node)
             var = TypeConversion(val, SolidityVariable("this"), ElementaryType("address"))
             val.set_type(ElementaryType("address"))
             self._result.append(var)
 
             val1 = ReferenceVariable(self._node)
@@ -348,15 +358,15 @@
             val = TemporaryVariable(self._node)
             var = TypeConversion(val, SolidityVariable("this"), ElementaryType("address"))
             val.set_type(ElementaryType("address"))
             self._result.append(var)
             set_val(expression, val)
         elif called.name == "callvalue()":
             val = TemporaryVariable(self._node)
-            var = Assignment(val, SolidityVariableComposed("msg.value"), "uint256")
+            var = Assignment(val, SolidityVariableComposed("msg.value"), ElementaryType("uint256"))
             self._result.append(var)
             set_val(expression, val)
 
         else:
             # If tuple
             if expression.type_call.startswith("tuple(") and expression.type_call != "tuple()":
                 val = TupleVariable(self._node)
@@ -375,54 +385,60 @@
                 message_call.call_value = call_value
             if expression.call_salt:
                 call_salt = get(expression.call_salt)
                 message_call.call_salt = call_salt
             self._result.append(message_call)
             set_val(expression, val)
 
-    def _post_conditional_expression(self, expression):
+    def _post_conditional_expression(self, expression: ConditionalExpression) -> None:
         raise Exception(f"Ternary operator are not convertible to SlithIR {expression}")
 
     def _post_elementary_type_name_expression(
         self,
         expression: ElementaryTypeNameExpression,
     ) -> None:
         set_val(expression, expression.type)
 
     def _post_identifier(self, expression: Identifier) -> None:
         set_val(expression, expression.value)
 
     def _post_index_access(self, expression: IndexAccess) -> None:
         left = get(expression.expression_left)
         right = get(expression.expression_right)
+        operation: Operation
         # Left can be a type for abi.decode(var, uint[2])
-        if isinstance(left, Type):
+        if isinstance(left, (Type, Contract, Enum)):
             # Nested type are not yet supported by abi.decode, so the assumption
             # Is that the right variable must be a constant
             assert isinstance(right, Constant)
-            t = ArrayType(left, right.value)
+            # Case for abi.decode(var, I[2]) where I is an interface/contract or an enum
+            if isinstance(left, (Contract, Enum)):
+                left = UserDefinedType(left)
+            t = ArrayType(left, int(right.value))
             set_val(expression, t)
             return
         val = ReferenceVariable(self._node)
         # access to anonymous array
         # such as [0,1][x]
         if isinstance(left, list):
             init_array_val = TemporaryVariable(self._node)
             init_array_right = left
             left = init_array_val
             operation = InitArray(init_array_right, init_array_val)
             operation.set_expression(expression)
             self._result.append(operation)
-        operation = Index(val, left, right, expression.type)
+        operation = Index(val, left, right)
         operation.set_expression(expression)
         self._result.append(operation)
         set_val(expression, val)
 
     def _post_literal(self, expression: Literal) -> None:
-        cst = Constant(expression.value, expression.type, expression.subdenomination)
+        expression_type = expression.type
+        assert isinstance(expression_type, ElementaryType)
+        cst = Constant(expression.value, expression_type, expression.subdenomination)
         set_val(expression, cst)
 
     def _post_member_access(self, expression: MemberAccess) -> None:
         expr = get(expression.expression)
 
         # Look for type(X).max / min
         # Because we looked at the AST structure, we need to look into the nested expression
@@ -432,33 +448,41 @@
             "max",
         ]:
             if isinstance(expression.expression.called, Identifier):
                 if expression.expression.called.value == SolidityFunction("type()"):
                     assert len(expression.expression.arguments) == 1
                     val = TemporaryVariable(self._node)
                     type_expression_found = expression.expression.arguments[0]
+                    type_found: Union[ElementaryType, UserDefinedType]
                     if isinstance(type_expression_found, ElementaryTypeNameExpression):
-                        type_found = type_expression_found.type
+                        type_expression_found_type = type_expression_found.type
+                        assert isinstance(type_expression_found_type, ElementaryType)
+                        type_found = type_expression_found_type
+                        min_value = type_found.min
+                        max_value = type_found.max
                         constant_type = type_found
                     else:
                         # type(enum).max/min
                         assert isinstance(type_expression_found, Identifier)
-                        type_found = type_expression_found.value
-                        assert isinstance(type_found, Enum)
+                        type_found_in_expression = type_expression_found.value
+                        assert isinstance(type_found_in_expression, (EnumContract, EnumTopLevel))
+                        type_found = UserDefinedType(type_found_in_expression)
                         constant_type = None
+                        min_value = type_found_in_expression.min
+                        max_value = type_found_in_expression.max
                     if expression.member_name == "min":
                         op = Assignment(
                             val,
-                            Constant(str(type_found.min), constant_type),
+                            Constant(str(min_value), constant_type),
                             type_found,
                         )
                     else:
                         op = Assignment(
                             val,
-                            Constant(str(type_found.max), constant_type),
+                            Constant(str(max_value), constant_type),
                             type_found,
                         )
                     self._result.append(op)
                     set_val(expression, val)
                     return
 
         # This does not support solidity 0.4 contract_name.balance
@@ -496,23 +520,23 @@
                 set_val(expression, expr.file_scope.user_defined_types[expression.member_name])
                 return
             # Lookup errors referred to as member of contract e.g. Test.myError.selector
             if expression.member_name in expr.custom_errors_as_dict:
                 set_val(expression, expr.custom_errors_as_dict[expression.member_name])
                 return
 
-        val = ReferenceVariable(self._node)
-        member = Member(expr, Constant(expression.member_name), val)
+        val_ref = ReferenceVariable(self._node)
+        member = Member(expr, Constant(expression.member_name), val_ref)
         member.set_expression(expression)
         self._result.append(member)
-        set_val(expression, val)
+        set_val(expression, val_ref)
 
     def _post_new_array(self, expression: NewArray) -> None:
         val = TemporaryVariable(self._node)
-        operation = TmpNewArray(expression.depth, expression.array_type, val)
+        operation = TmpNewArray(expression.array_type, val)
         operation.set_expression(expression)
         self._result.append(operation)
         set_val(expression, val)
 
     def _post_new_contract(self, expression: NewContract) -> None:
         val = TemporaryVariable(self._node)
         operation = TmpNewContract(expression.contract_name, val)
@@ -523,42 +547,46 @@
         if expression.call_salt:
             call_salt = get(expression.call_salt)
             operation.call_salt = call_salt
 
         self._result.append(operation)
         set_val(expression, val)
 
-    def _post_new_elementary_type(self, expression):
+    def _post_new_elementary_type(self, expression: NewElementaryType) -> None:
         # TODO unclear if this is ever used?
         val = TemporaryVariable(self._node)
         operation = TmpNewElementaryType(expression.type, val)
         operation.set_expression(expression)
         self._result.append(operation)
         set_val(expression, val)
 
     def _post_tuple_expression(self, expression: TupleExpression) -> None:
-        expressions = [get(e) if e else None for e in expression.expressions]
-        if len(expressions) == 1:
-            val = expressions[0]
+        all_expressions = [get(e) if e else None for e in expression.expressions]
+        if len(all_expressions) == 1:
+            val = all_expressions[0]
         else:
-            val = expressions
+            val = all_expressions
         set_val(expression, val)
 
-    def _post_type_conversion(self, expression: TypeConversion) -> None:
+    def _post_type_conversion(self, expression: expressions.TypeConversion) -> None:
+        assert expression.expression
         expr = get(expression.expression)
         val = TemporaryVariable(self._node)
-        operation = TypeConversion(val, expr, expression.type)
+        expression_type = expression.type
+        assert isinstance(expression_type, (TypeAlias, UserDefinedType, ElementaryType))
+        operation = TypeConversion(val, expr, expression_type)
         val.set_type(expression.type)
         operation.set_expression(expression)
         self._result.append(operation)
         set_val(expression, val)
 
     # pylint: disable=too-many-statements
     def _post_unary_operation(self, expression: UnaryOperation) -> None:
         value = get(expression.expression)
+        operation: Operation
         if expression.type in [UnaryOperationType.BANG, UnaryOperationType.TILD]:
             lvalue = TemporaryVariable(self._node)
             operation = Unary(lvalue, value, expression.type)
             operation.set_expression(expression)
             self._result.append(operation)
             set_val(expression, lvalue)
         elif expression.type in [UnaryOperationType.DELETE]:
```

### Comparing `slither-analyzer-0.9.3/slither_analyzer.egg-info/PKG-INFO` & `slither-analyzer-0.9.4/slither_analyzer.egg-info/PKG-INFO`

 * *Files 2% similar despite different names*

```diff
@@ -1,21 +1,25 @@
 Metadata-Version: 2.1
 Name: slither-analyzer
-Version: 0.9.3
+Version: 0.9.4
 Summary: Slither is a Solidity static analysis framework written in Python 3.
 Home-page: https://github.com/crytic/slither
 Author: Trail of Bits
 License: AGPL-3.0
 Requires-Python: >=3.8
 Description-Content-Type: text/markdown
+Provides-Extra: lint
+Provides-Extra: test
+Provides-Extra: doc
 Provides-Extra: dev
 License-File: LICENSE
 
 # Slither, the Solidity source analyzer
-<img src="./logo.png" alt="Logo" width="500"/>
+
+<img src="https://raw.githubusercontent.com/crytic/slither/master/logo.png" alt="Logo" width="500"/>
 
 [![Build Status](https://img.shields.io/github/actions/workflow/status/crytic/slither/ci.yml?branch=master)](https://github.com/crytic/slither/actions?query=workflow%3ACI)
 [![Slack Status](https://empireslacking.herokuapp.com/badge.svg)](https://empireslacking.herokuapp.com)
 [![PyPI version](https://badge.fury.io/py/slither-analyzer.svg)](https://badge.fury.io/py/slither-analyzer)
 
 Slither is a Solidity static analysis framework written in Python3. It runs a suite of vulnerability detectors, prints visual information about contract details, and provides an API to easily write custom analyses. Slither enables developers to find vulnerabilities, enhance their code comprehension, and quickly prototype custom analyses.
 
@@ -28,34 +32,37 @@
 - [API Documentation](#api-documentation)
 - [Getting Help](#getting-help)
 - [FAQ](#faq)
 - [Publications](#publications)
 
 ## Features
 
-* Detects vulnerable Solidity code with low false positives (see the list of [trophies](./trophies.md))
-* Identifies where the error condition occurs in the source code
-* Easily integrates into continuous integration and Hardhat/Foundry builds
-* Built-in 'printers' quickly report crucial contract information
-* Detector API to write custom analyses in Python
-* Ability to analyze contracts written with Solidity >= 0.4
-* Intermediate representation ([SlithIR](https://github.com/trailofbits/slither/wiki/SlithIR)) enables simple, high-precision analyses
-* Correctly parses 99.9% of all public Solidity code
-* Average execution time of less than 1 second per contract
-* Integrates with Github's code scanning in [CI](https://github.com/marketplace/actions/slither-action)
+- Detects vulnerable Solidity code with low false positives (see the list of [trophies](./trophies.md))
+- Identifies where the error condition occurs in the source code
+- Easily integrates into continuous integration and Hardhat/Foundry builds
+- Built-in 'printers' quickly report crucial contract information
+- Detector API to write custom analyses in Python
+- Ability to analyze contracts written with Solidity >= 0.4
+- Intermediate representation ([SlithIR](https://github.com/trailofbits/slither/wiki/SlithIR)) enables simple, high-precision analyses
+- Correctly parses 99.9% of all public Solidity code
+- Average execution time of less than 1 second per contract
+- Integrates with Github's code scanning in [CI](https://github.com/marketplace/actions/slither-action)
 
 ## Usage
 
 Run Slither on a Hardhat/Foundry/Dapp/Brownie application:
+
 ```bash
 slither .
 ```
+
 This is the preferred option if your project has dependencies as Slither relies on the underlying compilation framework to compile source code.
 
 However, you can run Slither on a single file that does not import dependencies:
+
 ```bash
 slither tests/uninitialized.sol
 ```
 
 ## How to install
 
 Slither requires Python 3.8+.
@@ -87,182 +94,192 @@
 To share a directory in the container:
 
 ```bash
 docker run -it -v /home/share:/share trailofbits/eth-security-toolbox
 ```
 
 ### Integration
+
 - For GitHub action integration, use [slither-action](https://github.com/marketplace/actions/slither-action).
 - To generate a Markdown report, use `slither [target] --checklist`.
 - To generate a Markdown with GitHub source code highlighting, use `slither [target] --checklist --markdown-root https://github.com/ORG/REPO/blob/COMMIT/` (replace `ORG`, `REPO`, `COMMIT`)
 
 ## Detectors
 
-
 Num | Detector | What it Detects | Impact | Confidence
 --- | --- | --- | --- | ---
 1 | `abiencoderv2-array` | [Storage abiencoderv2 array](https://github.com/crytic/slither/wiki/Detector-Documentation#storage-abiencoderv2-array) | High | High
 2 | `arbitrary-send-erc20` | [transferFrom uses arbitrary `from`](https://github.com/crytic/slither/wiki/Detector-Documentation#arbitrary-from-in-transferfrom) | High | High
 3 | `array-by-reference` | [Modifying storage array by value](https://github.com/crytic/slither/wiki/Detector-Documentation#modifying-storage-array-by-value) | High | High
-4 | `incorrect-shift` | [The order of parameters in a shift instruction is incorrect.](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-shift-in-assembly) | High | High
-5 | `multiple-constructors` | [Multiple constructor schemes](https://github.com/crytic/slither/wiki/Detector-Documentation#multiple-constructor-schemes) | High | High
-6 | `name-reused` | [Contract's name reused](https://github.com/crytic/slither/wiki/Detector-Documentation#name-reused) | High | High
-7 | `protected-vars` | [Detected unprotected variables](https://github.com/crytic/slither/wiki/Detector-Documentation#protected-variables) | High | High
-8 | `public-mappings-nested` | [Public mappings with nested variables](https://github.com/crytic/slither/wiki/Detector-Documentation#public-mappings-with-nested-variables) | High | High
-9 | `rtlo` | [Right-To-Left-Override control character is used](https://github.com/crytic/slither/wiki/Detector-Documentation#right-to-left-override-character) | High | High
-10 | `shadowing-state` | [State variables shadowing](https://github.com/crytic/slither/wiki/Detector-Documentation#state-variable-shadowing) | High | High
-11 | `suicidal` | [Functions allowing anyone to destruct the contract](https://github.com/crytic/slither/wiki/Detector-Documentation#suicidal) | High | High
-12 | `uninitialized-state` | [Uninitialized state variables](https://github.com/crytic/slither/wiki/Detector-Documentation#uninitialized-state-variables) | High | High
-13 | `uninitialized-storage` | [Uninitialized storage variables](https://github.com/crytic/slither/wiki/Detector-Documentation#uninitialized-storage-variables) | High | High
-14 | `unprotected-upgrade` | [Unprotected upgradeable contract](https://github.com/crytic/slither/wiki/Detector-Documentation#unprotected-upgradeable-contract) | High | High
-15 | `codex` | [Use Codex to find vulnerabilities.](https://github.com/crytic/slither/wiki/Detector-Documentation#codex) | High | Low
-16 | `arbitrary-send-erc20-permit` | [transferFrom uses arbitrary from with permit](https://github.com/crytic/slither/wiki/Detector-Documentation#arbitrary-from-in-transferfrom-used-with-permit) | High | Medium
-17 | `arbitrary-send-eth` | [Functions that send Ether to arbitrary destinations](https://github.com/crytic/slither/wiki/Detector-Documentation#functions-that-send-ether-to-arbitrary-destinations) | High | Medium
-18 | `controlled-array-length` | [Tainted array length assignment](https://github.com/crytic/slither/wiki/Detector-Documentation#array-length-assignment) | High | Medium
-19 | `controlled-delegatecall` | [Controlled delegatecall destination](https://github.com/crytic/slither/wiki/Detector-Documentation#controlled-delegatecall) | High | Medium
-20 | `delegatecall-loop` | [Payable functions using `delegatecall` inside a loop](https://github.com/crytic/slither/wiki/Detector-Documentation/#payable-functions-using-delegatecall-inside-a-loop) | High | Medium
-21 | `msg-value-loop` | [msg.value inside a loop](https://github.com/crytic/slither/wiki/Detector-Documentation/#msgvalue-inside-a-loop) | High | Medium
-22 | `reentrancy-eth` | [Reentrancy vulnerabilities (theft of ethers)](https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities) | High | Medium
-23 | `storage-array` | [Signed storage integer array compiler bug](https://github.com/crytic/slither/wiki/Detector-Documentation#storage-signed-integer-array) | High | Medium
-24 | `unchecked-transfer` | [Unchecked tokens transfer](https://github.com/crytic/slither/wiki/Detector-Documentation#unchecked-transfer) | High | Medium
-25 | `weak-prng` | [Weak PRNG](https://github.com/crytic/slither/wiki/Detector-Documentation#weak-PRNG) | High | Medium
-26 | `domain-separator-collision` | [Detects ERC20 tokens that have a function whose signature collides with EIP-2612's DOMAIN_SEPARATOR()](https://github.com/crytic/slither/wiki/Detector-Documentation#domain-separator-collision) | Medium | High
-27 | `enum-conversion` | [Detect dangerous enum conversion](https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-enum-conversion) | Medium | High
-28 | `erc20-interface` | [Incorrect ERC20 interfaces](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-erc20-interface) | Medium | High
-29 | `erc721-interface` | [Incorrect ERC721 interfaces](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-erc721-interface) | Medium | High
-30 | `incorrect-equality` | [Dangerous strict equalities](https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-strict-equalities) | Medium | High
-31 | `locked-ether` | [Contracts that lock ether](https://github.com/crytic/slither/wiki/Detector-Documentation#contracts-that-lock-ether) | Medium | High
-32 | `mapping-deletion` | [Deletion on mapping containing a structure](https://github.com/crytic/slither/wiki/Detector-Documentation#deletion-on-mapping-containing-a-structure) | Medium | High
-33 | `shadowing-abstract` | [State variables shadowing from abstract contracts](https://github.com/crytic/slither/wiki/Detector-Documentation#state-variable-shadowing-from-abstract-contracts) | Medium | High
-34 | `tautology` | [Tautology or contradiction](https://github.com/crytic/slither/wiki/Detector-Documentation#tautology-or-contradiction) | Medium | High
-35 | `write-after-write` | [Unused write](https://github.com/crytic/slither/wiki/Detector-Documentation#write-after-write) | Medium | High
-36 | `boolean-cst` | [Misuse of Boolean constant](https://github.com/crytic/slither/wiki/Detector-Documentation#misuse-of-a-boolean-constant) | Medium | Medium
-37 | `constant-function-asm` | [Constant functions using assembly code](https://github.com/crytic/slither/wiki/Detector-Documentation#constant-functions-using-assembly-code) | Medium | Medium
-38 | `constant-function-state` | [Constant functions changing the state](https://github.com/crytic/slither/wiki/Detector-Documentation#constant-functions-changing-the-state) | Medium | Medium
-39 | `divide-before-multiply` | [Imprecise arithmetic operations order](https://github.com/crytic/slither/wiki/Detector-Documentation#divide-before-multiply) | Medium | Medium
-40 | `reentrancy-no-eth` | [Reentrancy vulnerabilities (no theft of ethers)](https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-1) | Medium | Medium
-41 | `reused-constructor` | [Reused base constructor](https://github.com/crytic/slither/wiki/Detector-Documentation#reused-base-constructors) | Medium | Medium
-42 | `tx-origin` | [Dangerous usage of `tx.origin`](https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-usage-of-txorigin) | Medium | Medium
-43 | `unchecked-lowlevel` | [Unchecked low-level calls](https://github.com/crytic/slither/wiki/Detector-Documentation#unchecked-low-level-calls) | Medium | Medium
-44 | `unchecked-send` | [Unchecked send](https://github.com/crytic/slither/wiki/Detector-Documentation#unchecked-send) | Medium | Medium
-45 | `uninitialized-local` | [Uninitialized local variables](https://github.com/crytic/slither/wiki/Detector-Documentation#uninitialized-local-variables) | Medium | Medium
-46 | `unused-return` | [Unused return values](https://github.com/crytic/slither/wiki/Detector-Documentation#unused-return) | Medium | Medium
-47 | `incorrect-modifier` | [Modifiers that can return the default value](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-modifier) | Low | High
-48 | `shadowing-builtin` | [Built-in symbol shadowing](https://github.com/crytic/slither/wiki/Detector-Documentation#builtin-symbol-shadowing) | Low | High
-49 | `shadowing-local` | [Local variables shadowing](https://github.com/crytic/slither/wiki/Detector-Documentation#local-variable-shadowing) | Low | High
-50 | `uninitialized-fptr-cst` | [Uninitialized function pointer calls in constructors](https://github.com/crytic/slither/wiki/Detector-Documentation#uninitialized-function-pointers-in-constructors) | Low | High
-51 | `variable-scope` | [Local variables used prior their declaration](https://github.com/crytic/slither/wiki/Detector-Documentation#pre-declaration-usage-of-local-variables) | Low | High
-52 | `void-cst` | [Constructor called not implemented](https://github.com/crytic/slither/wiki/Detector-Documentation#void-constructor) | Low | High
-53 | `calls-loop` | [Multiple calls in a loop](https://github.com/crytic/slither/wiki/Detector-Documentation/#calls-inside-a-loop) | Low | Medium
-54 | `events-access` | [Missing Events Access Control](https://github.com/crytic/slither/wiki/Detector-Documentation#missing-events-access-control) | Low | Medium
-55 | `events-maths` | [Missing Events Arithmetic](https://github.com/crytic/slither/wiki/Detector-Documentation#missing-events-arithmetic) | Low | Medium
-56 | `incorrect-unary` | [Dangerous unary expressions](https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-unary-expressions) | Low | Medium
-57 | `missing-zero-check` | [Missing Zero Address Validation](https://github.com/crytic/slither/wiki/Detector-Documentation#missing-zero-address-validation) | Low | Medium
-58 | `reentrancy-benign` | [Benign reentrancy vulnerabilities](https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-2) | Low | Medium
-59 | `reentrancy-events` | [Reentrancy vulnerabilities leading to out-of-order Events](https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-3) | Low | Medium
-60 | `timestamp` | [Dangerous usage of `block.timestamp`](https://github.com/crytic/slither/wiki/Detector-Documentation#block-timestamp) | Low | Medium
-61 | `assembly` | [Assembly usage](https://github.com/crytic/slither/wiki/Detector-Documentation#assembly-usage) | Informational | High
-62 | `assert-state-change` | [Assert state change](https://github.com/crytic/slither/wiki/Detector-Documentation#assert-state-change) | Informational | High
-63 | `boolean-equal` | [Comparison to boolean constant](https://github.com/crytic/slither/wiki/Detector-Documentation#boolean-equality) | Informational | High
-64 | `cyclomatic-complexity` | [Detects functions with high (> 11) cyclomatic complexity](https://github.com/crytic/slither/wiki/Detector-Documentation#cyclomatic-complexity) | Informational | High
-65 | `deprecated-standards` | [Deprecated Solidity Standards](https://github.com/crytic/slither/wiki/Detector-Documentation#deprecated-standards) | Informational | High
-66 | `erc20-indexed` | [Un-indexed ERC20 event parameters](https://github.com/crytic/slither/wiki/Detector-Documentation#unindexed-erc20-event-parameters) | Informational | High
-67 | `function-init-state` | [Function initializing state variables](https://github.com/crytic/slither/wiki/Detector-Documentation#function-initializing-state) | Informational | High
-68 | `low-level-calls` | [Low level calls](https://github.com/crytic/slither/wiki/Detector-Documentation#low-level-calls) | Informational | High
-69 | `missing-inheritance` | [Missing inheritance](https://github.com/crytic/slither/wiki/Detector-Documentation#missing-inheritance) | Informational | High
-70 | `naming-convention` | [Conformity to Solidity naming conventions](https://github.com/crytic/slither/wiki/Detector-Documentation#conformance-to-solidity-naming-conventions) | Informational | High
-71 | `pragma` | [If different pragma directives are used](https://github.com/crytic/slither/wiki/Detector-Documentation#different-pragma-directives-are-used) | Informational | High
-72 | `redundant-statements` | [Redundant statements](https://github.com/crytic/slither/wiki/Detector-Documentation#redundant-statements) | Informational | High
-73 | `solc-version` | [Incorrect Solidity version](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-versions-of-solidity) | Informational | High
-74 | `unimplemented-functions` | [Unimplemented functions](https://github.com/crytic/slither/wiki/Detector-Documentation#unimplemented-functions) | Informational | High
-75 | `unused-state` | [Unused state variables](https://github.com/crytic/slither/wiki/Detector-Documentation#unused-state-variable) | Informational | High
-76 | `costly-loop` | [Costly operations in a loop](https://github.com/crytic/slither/wiki/Detector-Documentation#costly-operations-inside-a-loop) | Informational | Medium
-77 | `dead-code` | [Functions that are not used](https://github.com/crytic/slither/wiki/Detector-Documentation#dead-code) | Informational | Medium
-78 | `reentrancy-unlimited-gas` | [Reentrancy vulnerabilities through send and transfer](https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-4) | Informational | Medium
-79 | `similar-names` | [Variable names are too similar](https://github.com/crytic/slither/wiki/Detector-Documentation#variable-names-too-similar) | Informational | Medium
-80 | `too-many-digits` | [Conformance to numeric notation best practices](https://github.com/crytic/slither/wiki/Detector-Documentation#too-many-digits) | Informational | Medium
-81 | `constable-states` | [State variables that could be declared constant](https://github.com/crytic/slither/wiki/Detector-Documentation#state-variables-that-could-be-declared-constant) | Optimization | High
-82 | `external-function` | [Public function that could be declared external](https://github.com/crytic/slither/wiki/Detector-Documentation#public-function-that-could-be-declared-external) | Optimization | High
-83 | `immutable-states` | [State variables that could be declared immutable](https://github.com/crytic/slither/wiki/Detector-Documentation#state-variables-that-could-be-declared-immutable) | Optimization | High
-84 | `var-read-using-this` | [Contract reads its own variable using `this`](https://github.com/crytic/slither/wiki/Vulnerabilities-Description#public-variable-read-in-external-context) | Optimization | High
+4 | `encode-packed-collision` | [ABI encodePacked Collision](https://github.com/crytic/slither/wiki/Detector-Documentation#abi-encodePacked-collision) | High | High
+5 | `incorrect-shift` | [The order of parameters in a shift instruction is incorrect.](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-shift-in-assembly) | High | High
+6 | `multiple-constructors` | [Multiple constructor schemes](https://github.com/crytic/slither/wiki/Detector-Documentation#multiple-constructor-schemes) | High | High
+7 | `name-reused` | [Contract's name reused](https://github.com/crytic/slither/wiki/Detector-Documentation#name-reused) | High | High
+8 | `protected-vars` | [Detected unprotected variables](https://github.com/crytic/slither/wiki/Detector-Documentation#protected-variables) | High | High
+9 | `public-mappings-nested` | [Public mappings with nested variables](https://github.com/crytic/slither/wiki/Detector-Documentation#public-mappings-with-nested-variables) | High | High
+10 | `rtlo` | [Right-To-Left-Override control character is used](https://github.com/crytic/slither/wiki/Detector-Documentation#right-to-left-override-character) | High | High
+11 | `shadowing-state` | [State variables shadowing](https://github.com/crytic/slither/wiki/Detector-Documentation#state-variable-shadowing) | High | High
+12 | `suicidal` | [Functions allowing anyone to destruct the contract](https://github.com/crytic/slither/wiki/Detector-Documentation#suicidal) | High | High
+13 | `uninitialized-state` | [Uninitialized state variables](https://github.com/crytic/slither/wiki/Detector-Documentation#uninitialized-state-variables) | High | High
+14 | `uninitialized-storage` | [Uninitialized storage variables](https://github.com/crytic/slither/wiki/Detector-Documentation#uninitialized-storage-variables) | High | High
+15 | `unprotected-upgrade` | [Unprotected upgradeable contract](https://github.com/crytic/slither/wiki/Detector-Documentation#unprotected-upgradeable-contract) | High | High
+16 | `codex` | [Use Codex to find vulnerabilities.](https://github.com/crytic/slither/wiki/Detector-Documentation#codex) | High | Low
+17 | `arbitrary-send-erc20-permit` | [transferFrom uses arbitrary from with permit](https://github.com/crytic/slither/wiki/Detector-Documentation#arbitrary-from-in-transferfrom-used-with-permit) | High | Medium
+18 | `arbitrary-send-eth` | [Functions that send Ether to arbitrary destinations](https://github.com/crytic/slither/wiki/Detector-Documentation#functions-that-send-ether-to-arbitrary-destinations) | High | Medium
+19 | `controlled-array-length` | [Tainted array length assignment](https://github.com/crytic/slither/wiki/Detector-Documentation#array-length-assignment) | High | Medium
+20 | `controlled-delegatecall` | [Controlled delegatecall destination](https://github.com/crytic/slither/wiki/Detector-Documentation#controlled-delegatecall) | High | Medium
+21 | `delegatecall-loop` | [Payable functions using `delegatecall` inside a loop](https://github.com/crytic/slither/wiki/Detector-Documentation/#payable-functions-using-delegatecall-inside-a-loop) | High | Medium
+22 | `msg-value-loop` | [msg.value inside a loop](https://github.com/crytic/slither/wiki/Detector-Documentation/#msgvalue-inside-a-loop) | High | Medium
+23 | `reentrancy-eth` | [Reentrancy vulnerabilities (theft of ethers)](https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities) | High | Medium
+24 | `storage-array` | [Signed storage integer array compiler bug](https://github.com/crytic/slither/wiki/Detector-Documentation#storage-signed-integer-array) | High | Medium
+25 | `unchecked-transfer` | [Unchecked tokens transfer](https://github.com/crytic/slither/wiki/Detector-Documentation#unchecked-transfer) | High | Medium
+26 | `weak-prng` | [Weak PRNG](https://github.com/crytic/slither/wiki/Detector-Documentation#weak-PRNG) | High | Medium
+27 | `domain-separator-collision` | [Detects ERC20 tokens that have a function whose signature collides with EIP-2612's DOMAIN_SEPARATOR()](https://github.com/crytic/slither/wiki/Detector-Documentation#domain-separator-collision) | Medium | High
+28 | `enum-conversion` | [Detect dangerous enum conversion](https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-enum-conversion) | Medium | High
+29 | `erc20-interface` | [Incorrect ERC20 interfaces](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-erc20-interface) | Medium | High
+30 | `erc721-interface` | [Incorrect ERC721 interfaces](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-erc721-interface) | Medium | High
+31 | `incorrect-equality` | [Dangerous strict equalities](https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-strict-equalities) | Medium | High
+32 | `locked-ether` | [Contracts that lock ether](https://github.com/crytic/slither/wiki/Detector-Documentation#contracts-that-lock-ether) | Medium | High
+33 | `mapping-deletion` | [Deletion on mapping containing a structure](https://github.com/crytic/slither/wiki/Detector-Documentation#deletion-on-mapping-containing-a-structure) | Medium | High
+34 | `shadowing-abstract` | [State variables shadowing from abstract contracts](https://github.com/crytic/slither/wiki/Detector-Documentation#state-variable-shadowing-from-abstract-contracts) | Medium | High
+35 | `tautology` | [Tautology or contradiction](https://github.com/crytic/slither/wiki/Detector-Documentation#tautology-or-contradiction) | Medium | High
+36 | `write-after-write` | [Unused write](https://github.com/crytic/slither/wiki/Detector-Documentation#write-after-write) | Medium | High
+37 | `boolean-cst` | [Misuse of Boolean constant](https://github.com/crytic/slither/wiki/Detector-Documentation#misuse-of-a-boolean-constant) | Medium | Medium
+38 | `constant-function-asm` | [Constant functions using assembly code](https://github.com/crytic/slither/wiki/Detector-Documentation#constant-functions-using-assembly-code) | Medium | Medium
+39 | `constant-function-state` | [Constant functions changing the state](https://github.com/crytic/slither/wiki/Detector-Documentation#constant-functions-changing-the-state) | Medium | Medium
+40 | `divide-before-multiply` | [Imprecise arithmetic operations order](https://github.com/crytic/slither/wiki/Detector-Documentation#divide-before-multiply) | Medium | Medium
+41 | `reentrancy-no-eth` | [Reentrancy vulnerabilities (no theft of ethers)](https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-1) | Medium | Medium
+42 | `reused-constructor` | [Reused base constructor](https://github.com/crytic/slither/wiki/Detector-Documentation#reused-base-constructors) | Medium | Medium
+43 | `tx-origin` | [Dangerous usage of `tx.origin`](https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-usage-of-txorigin) | Medium | Medium
+44 | `unchecked-lowlevel` | [Unchecked low-level calls](https://github.com/crytic/slither/wiki/Detector-Documentation#unchecked-low-level-calls) | Medium | Medium
+45 | `unchecked-send` | [Unchecked send](https://github.com/crytic/slither/wiki/Detector-Documentation#unchecked-send) | Medium | Medium
+46 | `uninitialized-local` | [Uninitialized local variables](https://github.com/crytic/slither/wiki/Detector-Documentation#uninitialized-local-variables) | Medium | Medium
+47 | `unused-return` | [Unused return values](https://github.com/crytic/slither/wiki/Detector-Documentation#unused-return) | Medium | Medium
+48 | `incorrect-modifier` | [Modifiers that can return the default value](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-modifier) | Low | High
+49 | `shadowing-builtin` | [Built-in symbol shadowing](https://github.com/crytic/slither/wiki/Detector-Documentation#builtin-symbol-shadowing) | Low | High
+50 | `shadowing-local` | [Local variables shadowing](https://github.com/crytic/slither/wiki/Detector-Documentation#local-variable-shadowing) | Low | High
+51 | `uninitialized-fptr-cst` | [Uninitialized function pointer calls in constructors](https://github.com/crytic/slither/wiki/Detector-Documentation#uninitialized-function-pointers-in-constructors) | Low | High
+52 | `variable-scope` | [Local variables used prior their declaration](https://github.com/crytic/slither/wiki/Detector-Documentation#pre-declaration-usage-of-local-variables) | Low | High
+53 | `void-cst` | [Constructor called not implemented](https://github.com/crytic/slither/wiki/Detector-Documentation#void-constructor) | Low | High
+54 | `calls-loop` | [Multiple calls in a loop](https://github.com/crytic/slither/wiki/Detector-Documentation/#calls-inside-a-loop) | Low | Medium
+55 | `events-access` | [Missing Events Access Control](https://github.com/crytic/slither/wiki/Detector-Documentation#missing-events-access-control) | Low | Medium
+56 | `events-maths` | [Missing Events Arithmetic](https://github.com/crytic/slither/wiki/Detector-Documentation#missing-events-arithmetic) | Low | Medium
+57 | `incorrect-unary` | [Dangerous unary expressions](https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-unary-expressions) | Low | Medium
+58 | `missing-zero-check` | [Missing Zero Address Validation](https://github.com/crytic/slither/wiki/Detector-Documentation#missing-zero-address-validation) | Low | Medium
+59 | `reentrancy-benign` | [Benign reentrancy vulnerabilities](https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-2) | Low | Medium
+60 | `reentrancy-events` | [Reentrancy vulnerabilities leading to out-of-order Events](https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-3) | Low | Medium
+61 | `timestamp` | [Dangerous usage of `block.timestamp`](https://github.com/crytic/slither/wiki/Detector-Documentation#block-timestamp) | Low | Medium
+62 | `assembly` | [Assembly usage](https://github.com/crytic/slither/wiki/Detector-Documentation#assembly-usage) | Informational | High
+63 | `assert-state-change` | [Assert state change](https://github.com/crytic/slither/wiki/Detector-Documentation#assert-state-change) | Informational | High
+64 | `boolean-equal` | [Comparison to boolean constant](https://github.com/crytic/slither/wiki/Detector-Documentation#boolean-equality) | Informational | High
+65 | `cyclomatic-complexity` | [Detects functions with high (> 11) cyclomatic complexity](https://github.com/crytic/slither/wiki/Detector-Documentation#cyclomatic-complexity) | Informational | High
+66 | `deprecated-standards` | [Deprecated Solidity Standards](https://github.com/crytic/slither/wiki/Detector-Documentation#deprecated-standards) | Informational | High
+67 | `erc20-indexed` | [Un-indexed ERC20 event parameters](https://github.com/crytic/slither/wiki/Detector-Documentation#unindexed-erc20-event-parameters) | Informational | High
+68 | `function-init-state` | [Function initializing state variables](https://github.com/crytic/slither/wiki/Detector-Documentation#function-initializing-state) | Informational | High
+69 | `incorrect-using-for` | [Detects using-for statement usage when no function from a given library matches a given type](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-using-for-usage) | Informational | High
+70 | `low-level-calls` | [Low level calls](https://github.com/crytic/slither/wiki/Detector-Documentation#low-level-calls) | Informational | High
+71 | `missing-inheritance` | [Missing inheritance](https://github.com/crytic/slither/wiki/Detector-Documentation#missing-inheritance) | Informational | High
+72 | `naming-convention` | [Conformity to Solidity naming conventions](https://github.com/crytic/slither/wiki/Detector-Documentation#conformance-to-solidity-naming-conventions) | Informational | High
+73 | `pragma` | [If different pragma directives are used](https://github.com/crytic/slither/wiki/Detector-Documentation#different-pragma-directives-are-used) | Informational | High
+74 | `redundant-statements` | [Redundant statements](https://github.com/crytic/slither/wiki/Detector-Documentation#redundant-statements) | Informational | High
+75 | `solc-version` | [Incorrect Solidity version](https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-versions-of-solidity) | Informational | High
+76 | `unimplemented-functions` | [Unimplemented functions](https://github.com/crytic/slither/wiki/Detector-Documentation#unimplemented-functions) | Informational | High
+77 | `unused-state` | [Unused state variables](https://github.com/crytic/slither/wiki/Detector-Documentation#unused-state-variable) | Informational | High
+78 | `costly-loop` | [Costly operations in a loop](https://github.com/crytic/slither/wiki/Detector-Documentation#costly-operations-inside-a-loop) | Informational | Medium
+79 | `dead-code` | [Functions that are not used](https://github.com/crytic/slither/wiki/Detector-Documentation#dead-code) | Informational | Medium
+80 | `reentrancy-unlimited-gas` | [Reentrancy vulnerabilities through send and transfer](https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-4) | Informational | Medium
+81 | `similar-names` | [Variable names are too similar](https://github.com/crytic/slither/wiki/Detector-Documentation#variable-names-too-similar) | Informational | Medium
+82 | `too-many-digits` | [Conformance to numeric notation best practices](https://github.com/crytic/slither/wiki/Detector-Documentation#too-many-digits) | Informational | Medium
+83 | `cache-array-length` | [Detects `for` loops that use `length` member of some storage array in their loop condition and don't modify it.](https://github.com/crytic/slither/wiki/Detector-Documentation#cache-array-length) | Optimization | High
+84 | `constable-states` | [State variables that could be declared constant](https://github.com/crytic/slither/wiki/Detector-Documentation#state-variables-that-could-be-declared-constant) | Optimization | High
+85 | `external-function` | [Public function that could be declared external](https://github.com/crytic/slither/wiki/Detector-Documentation#public-function-that-could-be-declared-external) | Optimization | High
+86 | `immutable-states` | [State variables that could be declared immutable](https://github.com/crytic/slither/wiki/Detector-Documentation#state-variables-that-could-be-declared-immutable) | Optimization | High
+87 | `var-read-using-this` | [Contract reads its own variable using `this`](https://github.com/crytic/slither/wiki/Detector-Documentation#public-variable-read-in-external-context) | Optimization | High
 
 For more information, see
+
 - The [Detector Documentation](https://github.com/crytic/slither/wiki/Detector-Documentation) for details on each detector
 - The [Detection Selection](https://github.com/crytic/slither/wiki/Usage#detector-selection) to run only selected detectors. By default, all the detectors are run.
 - The [Triage Mode](https://github.com/crytic/slither/wiki/Usage#triage-mode) to filter individual results
 
 ## Printers
-
 ### Quick Review Printers
 - `human-summary`: [Print a human-readable summary of the contracts](https://github.com/trailofbits/slither/wiki/Printer-documentation#human-summary)
 - `inheritance-graph`: [Export the inheritance graph of each contract to a dot file](https://github.com/trailofbits/slither/wiki/Printer-documentation#inheritance-graph)
 - `contract-summary`: [Print a summary of the contracts](https://github.com/trailofbits/slither/wiki/Printer-documentation#contract-summary)
+- `loc`: [Count the total number lines of code (LOC), source lines of code (SLOC), and comment lines of code (CLOC) found in source files (SRC), dependencies (DEP), and test files (TEST).](https://github.com/trailofbits/slither/wiki/Printer-documentation#loc)
 
 ### In-Depth Review Printers
 - `call-graph`: [Export the call-graph of the contracts to a dot file](https://github.com/trailofbits/slither/wiki/Printer-documentation#call-graph)
 - `cfg`: [Export the CFG of each functions](https://github.com/trailofbits/slither/wiki/Printer-documentation#cfg)
 - `function-summary`: [Print a summary of the functions](https://github.com/trailofbits/slither/wiki/Printer-documentation#function-summary)
 - `vars-and-auth`: [Print the state variables written and the authorization of the functions](https://github.com/crytic/slither/wiki/Printer-documentation#variables-written-and-authorization)
-- `when-not-paused`: [Print functions that do not use `whenNotPaused` modifier](https://github.com/trailofbits/slither/wiki/Printer-documentation#when-not-paused).
+- `not-pausable`: [Print functions that do not use `whenNotPaused` modifier](https://github.com/trailofbits/slither/wiki/Printer-documentation#when-not-paused).
 
 To run a printer, use `--print` and a comma-separated list of printers.
 
 See the [Printer documentation](https://github.com/crytic/slither/wiki/Printer-documentation) for the complete lists.
 
 ## Tools
 
 - `slither-check-upgradeability`: [Review `delegatecall`-based upgradeability](https://github.com/crytic/slither/wiki/Upgradeability-Checks)
 - `slither-prop`: [Automatic unit test and property generation](https://github.com/crytic/slither/wiki/Property-generation)
 - `slither-flat`: [Flatten a codebase](https://github.com/crytic/slither/wiki/Contract-Flattening)
 - `slither-check-erc`: [Check the ERC's conformance](https://github.com/crytic/slither/wiki/ERC-Conformance)
 - `slither-format`: [Automatic patch generation](https://github.com/crytic/slither/wiki/Slither-format)
 - `slither-read-storage`: [Read storage values from contracts](./slither/tools/read_storage/README.md)
+- `slither-interface`: [Generate an interface for a contract](./slither/tools/interface/README.md)
 
 See the [Tool documentation](https://github.com/crytic/slither/wiki/Tool-Documentation) for additional tools.
 
 [Contact us](https://www.trailofbits.com/contact/) to get help on building custom tools.
 
 ## API Documentation
+
 Documentation on Slither's internals is available [here](https://crytic.github.io/slither/slither.html).
 
 ## Getting Help
 
 Feel free to stop by our [Slack channel](https://empireslacking.herokuapp.com) (#ethereum) for help using or extending Slither.
 
-* The [Printer documentation](https://github.com/trailofbits/slither/wiki/Printer-documentation) describes the information Slither is capable of visualizing for each contract.
+- The [Printer documentation](https://github.com/trailofbits/slither/wiki/Printer-documentation) describes the information Slither is capable of visualizing for each contract.
 
-* The [Detector documentation](https://github.com/trailofbits/slither/wiki/Adding-a-new-detector) describes how to write a new vulnerability analyses.
+- The [Detector documentation](https://github.com/trailofbits/slither/wiki/Adding-a-new-detector) describes how to write a new vulnerability analyses.
 
-* The [API documentation](https://github.com/crytic/slither/wiki/Python-API) describes the methods and objects available for custom analyses.
+- The [API documentation](https://github.com/crytic/slither/wiki/Python-API) describes the methods and objects available for custom analyses.
 
-* The [SlithIR documentation](https://github.com/trailofbits/slither/wiki/SlithIR) describes the SlithIR intermediate representation.
+- The [SlithIR documentation](https://github.com/trailofbits/slither/wiki/SlithIR) describes the SlithIR intermediate representation.
 
 ## FAQ
 
 How do I exclude mocks or tests?
+
 - View our documentation on [path filtering](https://github.com/crytic/slither/wiki/Usage#path-filtering).
 
 How do I fix "unknown file" or compilation issues?
+
 - Because slither requires the solc AST, it must have all dependencies available.
 If a contract has dependencies, `slither contract.sol` will fail.
 Instead, use `slither .` in the parent directory of `contracts/` (you should see `contracts/` when you run `ls`).
 If you have a `node_modules/` folder, it must be in the same directory as `contracts/`. To verify that this issue is related to slither,
 run the compilation command for the framework you are using e.g `npx hardhat compile`. That must work successfully;
 otherwise, slither's compilation engine, crytic-compile, cannot generate the AST.
 
 ## License
 
 Slither is licensed and distributed under the AGPLv3 license. [Contact us](mailto:opensource@trailofbits.com) if you're looking for an exception to the terms.
 
 ## Publications
 
 ### Trail of Bits publication
+
 - [Slither: A Static Analysis Framework For Smart Contracts](https://arxiv.org/abs/1908.09878), Josselin Feist, Gustavo Grieco, Alex Groce - WETSEB '19
 
 ### External publications
+
 Title | Usage | Authors | Venue | Code
 --- | --- | --- | --- | ---
 [ReJection: A AST-Based Reentrancy Vulnerability Detection Method](https://www.researchgate.net/publication/339354823_ReJection_A_AST-Based_Reentrancy_Vulnerability_Detection_Method) | AST-based analysis built on top of Slither | Rui Ma, Zefeng Jian, Guangyuan Chen, Ke Ma, Yujia Chen | CTCIS 19
 [MPro: Combining Static and Symbolic Analysis forScalable Testing of Smart Contract](https://arxiv.org/pdf/1911.00570.pdf) | Leverage data dependency through Slither | William Zhang, Sebastian Banescu, Leodardo Pasos, Steven Stewart, Vijay Ganesh | ISSRE 2019 | [MPro](https://github.com/QuanZhang-William/M-Pro)
 [ETHPLOIT: From Fuzzing to Efficient Exploit Generation against Smart Contracts](https://wcventure.github.io/FuzzingPaper/Paper/SANER20_ETHPLOIT.pdf) | Leverage data dependency through Slither | Qingzhao Zhang, Yizhuo Wang, Juanru Li, Siqi Ma | SANER 20
 [Verification of Ethereum Smart Contracts: A Model Checking Approach](http://www.ijmlc.org/vol10/977-AM0059.pdf) | Symbolic execution built on top of Slithers CFG | Tam Bang, Hoang H Nguyen, Dung Nguyen, Toan Trieu, Tho Quan | IJMLC 20
 [Smart Contract Repair](https://arxiv.org/pdf/1912.05823.pdf) | Rely on Slithers vulnerabilities detectors | Xiao Liang Yu, Omar Al-Bataineh, David Lo, Abhik Roychoudhury | TOSEM 20 | [SCRepair](https://github.com/xiaoly8/SCRepair/)
```

### Comparing `slither-analyzer-0.9.3/slither_analyzer.egg-info/SOURCES.txt` & `slither-analyzer-0.9.4/slither_analyzer.egg-info/SOURCES.txt`

 * *Files 3% similar despite different names*

```diff
@@ -19,25 +19,20 @@
 slither/core/compilation_unit.py
 slither/core/exceptions.py
 slither/core/slither_core.py
 slither/core/cfg/__init__.py
 slither/core/cfg/node.py
 slither/core/cfg/scope.py
 slither/core/children/__init__.py
-slither/core/children/child_contract.py
 slither/core/children/child_event.py
-slither/core/children/child_expression.py
-slither/core/children/child_function.py
-slither/core/children/child_inheritance.py
-slither/core/children/child_node.py
-slither/core/children/child_structure.py
 slither/core/context/__init__.py
 slither/core/context/context.py
 slither/core/declarations/__init__.py
 slither/core/declarations/contract.py
+slither/core/declarations/contract_level.py
 slither/core/declarations/custom_error.py
 slither/core/declarations/custom_error_contract.py
 slither/core/declarations/custom_error_top_level.py
 slither/core/declarations/enum.py
 slither/core/declarations/enum_contract.py
 slither/core/declarations/enum_top_level.py
 slither/core/declarations/event.py
@@ -60,15 +55,14 @@
 slither/core/expressions/__init__.py
 slither/core/expressions/assignment_operation.py
 slither/core/expressions/binary_operation.py
 slither/core/expressions/call_expression.py
 slither/core/expressions/conditional_expression.py
 slither/core/expressions/elementary_type_name_expression.py
 slither/core/expressions/expression.py
-slither/core/expressions/expression_typed.py
 slither/core/expressions/identifier.py
 slither/core/expressions/index_access.py
 slither/core/expressions/literal.py
 slither/core/expressions/member_access.py
 slither/core/expressions/new_array.py
 slither/core/expressions/new_contract.py
 slither/core/expressions/new_elementary_type.py
@@ -142,14 +136,16 @@
 slither/detectors/functions/suicidal.py
 slither/detectors/functions/unimplemented.py
 slither/detectors/naming_convention/__init__.py
 slither/detectors/naming_convention/naming_convention.py
 slither/detectors/operations/__init__.py
 slither/detectors/operations/bad_prng.py
 slither/detectors/operations/block_timestamp.py
+slither/detectors/operations/cache_array_length.py
+slither/detectors/operations/encode_packed.py
 slither/detectors/operations/low_level_calls.py
 slither/detectors/operations/missing_events_access_control.py
 slither/detectors/operations/missing_events_arithmetic.py
 slither/detectors/operations/missing_zero_address_validation.py
 slither/detectors/operations/unchecked_low_level_return_values.py
 slither/detectors/operations/unchecked_send_return_value.py
 slither/detectors/operations/unchecked_transfer.py
@@ -182,14 +178,15 @@
 slither/detectors/statements/calls_in_loop.py
 slither/detectors/statements/controlled_delegatecall.py
 slither/detectors/statements/costly_operations_in_loop.py
 slither/detectors/statements/delegatecall_in_loop.py
 slither/detectors/statements/deprecated_calls.py
 slither/detectors/statements/divide_before_multiply.py
 slither/detectors/statements/incorrect_strict_equality.py
+slither/detectors/statements/incorrect_using_for.py
 slither/detectors/statements/mapping_deletion.py
 slither/detectors/statements/msg_value_in_loop.py
 slither/detectors/statements/redundant_statements.py
 slither/detectors/statements/too_many_digits.py
 slither/detectors/statements/tx_origin.py
 slither/detectors/statements/type_based_tautology.py
 slither/detectors/statements/unary.py
@@ -241,14 +238,15 @@
 slither/printers/summary/contract.py
 slither/printers/summary/data_depenency.py
 slither/printers/summary/declaration.py
 slither/printers/summary/evm.py
 slither/printers/summary/function.py
 slither/printers/summary/function_ids.py
 slither/printers/summary/human_summary.py
+slither/printers/summary/loc.py
 slither/printers/summary/modifier_calls.py
 slither/printers/summary/require_calls.py
 slither/printers/summary/slithir.py
 slither/printers/summary/slithir_ssa.py
 slither/printers/summary/variable_order.py
 slither/printers/summary/when_not_paused.py
 slither/slithir/__init__.py
@@ -359,14 +357,16 @@
 slither/tools/erc_conformance/erc/erc20.py
 slither/tools/erc_conformance/erc/ercs.py
 slither/tools/flattening/__init__.py
 slither/tools/flattening/__main__.py
 slither/tools/flattening/flattening.py
 slither/tools/flattening/export/__init__.py
 slither/tools/flattening/export/export.py
+slither/tools/interface/__init__.py
+slither/tools/interface/__main__.py
 slither/tools/kspec_coverage/__init__.py
 slither/tools/kspec_coverage/__main__.py
 slither/tools/kspec_coverage/analysis.py
 slither/tools/kspec_coverage/kspec_coverage.py
 slither/tools/mutator/__init__.py
 slither/tools/mutator/__main__.py
 slither/tools/mutator/mutators/MIA.py
@@ -434,59 +434,83 @@
 slither/tools/upgradeability/checks/variables_order.py
 slither/tools/upgradeability/utils/__init__.py
 slither/tools/upgradeability/utils/command_line.py
 slither/tools/utils/__init__.py
 slither/utils/__init__.py
 slither/utils/arithmetic.py
 slither/utils/code_complexity.py
+slither/utils/code_generation.py
 slither/utils/codex.py
 slither/utils/colors.py
 slither/utils/command_line.py
 slither/utils/comparable_enum.py
 slither/utils/erc.py
 slither/utils/expression_manipulations.py
 slither/utils/function.py
 slither/utils/inheritance_analysis.py
 slither/utils/integer_conversion.py
+slither/utils/loc.py
 slither/utils/myprettytable.py
 slither/utils/output.py
 slither/utils/output_capture.py
 slither/utils/oz_hashes.py
 slither/utils/source_mapping.py
 slither/utils/standard_libraries.py
 slither/utils/tests_pattern.py
 slither/utils/type.py
 slither/utils/type_helpers.py
+slither/utils/upgradeability.py
 slither/utils/utils.py
 slither/visitors/__init__.py
 slither/visitors/expression/__init__.py
 slither/visitors/expression/constants_folding.py
 slither/visitors/expression/export_values.py
 slither/visitors/expression/expression.py
 slither/visitors/expression/expression_printer.py
 slither/visitors/expression/find_calls.py
-slither/visitors/expression/find_push.py
 slither/visitors/expression/has_conditional.py
-slither/visitors/expression/left_value.py
 slither/visitors/expression/read_var.py
-slither/visitors/expression/right_value.py
 slither/visitors/expression/write_var.py
 slither/visitors/slithir/__init__.py
 slither/visitors/slithir/expression_to_slithir.py
 slither_analyzer.egg-info/PKG-INFO
 slither_analyzer.egg-info/SOURCES.txt
 slither_analyzer.egg-info/dependency_links.txt
 slither_analyzer.egg-info/entry_points.txt
 slither_analyzer.egg-info/requires.txt
 slither_analyzer.egg-info/top_level.txt
 tests/__init__.py
-tests/test_ast_parsing.py
-tests/test_constant_folding.py
-tests/test_detectors.py
-tests/test_features.py
-tests/test_function.py
-tests/test_functions_ids.py
-tests/test_read_storage.py
-tests/test_source_mapping.py
-tests/test_source_unit.py
-tests/test_ssa_generation.py
-tests/test_storage_layout.py
+tests/conftest.py
+tests/utils.py
+tests/e2e/__init__.py
+tests/e2e/compilation/__init__.py
+tests/e2e/compilation/test_resolution.py
+tests/e2e/compilation/test_source_unit.py
+tests/e2e/detectors/__init__.py
+tests/e2e/detectors/test_detectors.py
+tests/e2e/solc_parsing/__init__.py
+tests/e2e/solc_parsing/test_ast_parsing.py
+tests/tools/__init__.py
+tests/tools/read-storage/__init__.py
+tests/tools/read-storage/conftest.py
+tests/tools/read-storage/test_read_storage.py
+tests/unit/__init__.py
+tests/unit/core/__init__.py
+tests/unit/core/test_arithmetic.py
+tests/unit/core/test_code_comments.py
+tests/unit/core/test_constant_folding.py
+tests/unit/core/test_contract_declaration.py
+tests/unit/core/test_error_messages.py
+tests/unit/core/test_fallback_receive.py
+tests/unit/core/test_function_declaration.py
+tests/unit/core/test_source_mapping.py
+tests/unit/core/test_storage_layout.py
+tests/unit/core/test_using_for.py
+tests/unit/slithir/__init__.py
+tests/unit/slithir/test_operation_reads.py
+tests/unit/slithir/test_ssa_generation.py
+tests/unit/slithir/test_ternary_expressions.py
+tests/unit/utils/__init__.py
+tests/unit/utils/test_code_generation.py
+tests/unit/utils/test_functions_ids.py
+tests/unit/utils/test_type_helpers.py
+tests/unit/utils/test_upgradeability_util.py
```

### Comparing `slither-analyzer-0.9.3/slither_analyzer.egg-info/entry_points.txt` & `slither-analyzer-0.9.4/slither_analyzer.egg-info/entry_points.txt`

 * *Files 5% similar despite different names*

```diff
@@ -4,11 +4,12 @@
 slither-check-kspec = slither.tools.kspec_coverage.__main__:main
 slither-check-upgradeability = slither.tools.upgradeability.__main__:main
 slither-doctor = slither.tools.doctor.__main__:main
 slither-documentation = slither.tools.documentation.__main__:main
 slither-find-paths = slither.tools.possible_paths.__main__:main
 slither-flat = slither.tools.flattening.__main__:main
 slither-format = slither.tools.slither_format.__main__:main
+slither-interface = slither.tools.interface.__main__:main
 slither-mutate = slither.tools.mutator.__main__:main
 slither-prop = slither.tools.properties.__main__:main
 slither-read-storage = slither.tools.read_storage.__main__:main
 slither-simil = slither.tools.similarity.__main__:main
```

### Comparing `slither-analyzer-0.9.3/tests/test_ast_parsing.py` & `slither-analyzer-0.9.4/tests/e2e/solc_parsing/test_ast_parsing.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 import json
 import os
 import re
 import sys
 from pathlib import Path
 from typing import List, Dict, Tuple
-
+from packaging.version import parse as parse_version
 import pytest
 from deepdiff import DeepDiff
 from solc_select.solc_select import install_artifacts as install_solc_versions
 from solc_select.solc_select import installed_versions as get_installed_solc_versions
 from crytic_compile import CryticCompile, save_to_zip
 from crytic_compile.utils.zip import load_from_zip
 
 from slither import Slither
 from slither.printers.guidance.echidna import Echidna
 
-SLITHER_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
-TEST_ROOT = os.path.join(SLITHER_ROOT, "tests", "ast-parsing")
+E2E_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
+TEST_ROOT = os.path.join(E2E_ROOT, "solc_parsing", "test_data")
 
 
 # pylint: disable=too-few-public-methods
 class Test:
     def __init__(self, test_file: str, solc_versions: List[str], disable_legacy: bool = False):
         self.solc_versions = solc_versions
         self.test_file = test_file
@@ -28,16 +28,23 @@
 
         versions_with_flavors: List[Tuple[str, str]] = []
         flavors = ["compact"]
         if not self.disable_legacy:
             flavors += ["legacy"]
         for version in solc_versions:
             for flavor in flavors:
-                if flavor == "legacy" and version > "0.8":
-                    # No legacy for >0.8
+                # No legacy AST format for >0.8
+                legacy_unavailable = flavor == "legacy" and parse_version(version) >= parse_version(
+                    "0.8"
+                )
+                # No compact AST format for <0.4.12
+                compact_unavailable = flavor == "compact" and parse_version(
+                    version
+                ) < parse_version("0.4.12")
+                if legacy_unavailable or compact_unavailable:
                     continue
                 versions_with_flavors.append((version, flavor))
         self.versions_with_flavors = versions_with_flavors
 
 
 def generate_output(sl: Slither) -> Dict[str, Dict[str, str]]:
     output = {}
@@ -297,14 +304,15 @@
     Test("units_and_global_variables-0.5.0.sol", make_version(5, 0, 3)),
     Test("units_and_global_variables-0.5.4.sol", make_version(5, 4, 17)),
     Test("units_and_global_variables-0.6.0.sol", VERSIONS_06),
     Test("units_and_global_variables-0.7.0.sol", VERSIONS_07),
     Test("units_and_global_variables-0.8.0.sol", VERSIONS_08),
     Test("units_and_global_variables-0.8.4.sol", make_version(8, 4, 6)),
     Test("units_and_global_variables-0.8.7.sol", make_version(8, 7, 9)),
+    Test("global_variables-0.8.18.sol", make_version(8, 18, 18)),
     Test(
         "push-all.sol",
         ALL_VERSIONS,
     ),
     Test(
         "indexaccess-all.sol",
         ALL_VERSIONS,
@@ -417,14 +425,15 @@
     Test("user_defined_value_type/argument-0.8.8.sol", ["0.8.8"] + make_version(8, 10, 15)),
     Test("user_defined_value_type/calldata-0.8.8.sol", ["0.8.8"] + make_version(8, 10, 15)),
     Test("user_defined_value_type/constant-0.8.8.sol", ["0.8.8"] + make_version(8, 10, 15)),
     Test("user_defined_value_type/erc20-0.8.8.sol", ["0.8.8"] + make_version(8, 10, 15)),
     Test("user_defined_value_type/in_parenthesis-0.8.8.sol", ["0.8.8"] + make_version(8, 10, 15)),
     Test("user_defined_value_type/top-level-0.8.8.sol", ["0.8.8"] + make_version(8, 10, 15)),
     Test("user_defined_value_type/using-for-0.8.8.sol", ["0.8.8"] + make_version(8, 10, 15)),
+    Test("user_defined_value_type/abi-decode-fixed-array.sol", ["0.8.8"] + make_version(8, 10, 15)),
     Test("bytes_call.sol", ["0.8.12"]),
     Test("modifier_identifier_path.sol", VERSIONS_08),
     Test("free_functions/libraries_from_free.sol", ["0.8.12"]),
     Test("free_functions/new_operator.sol", ["0.8.12"]),
     Test("free_functions/library_constant_function_collision.sol", ["0.8.12"]),
     Test("ternary-with-max.sol", ["0.8.15"]),
     Test("using-for-1-0.8.0.sol", ["0.8.15"]),
@@ -440,14 +449,20 @@
     Test("using-for-functions-list-4-0.8.0.sol", ["0.8.15"]),
     Test("using-for-global-0.8.0.sol", ["0.8.15"]),
     Test("library_event-0.8.16.sol", ["0.8.16"]),
     Test("top-level-struct-0.8.0.sol", ["0.8.0"]),
     Test("yul-top-level-0.8.0.sol", ["0.8.0"]),
     Test("complex_imports/import_aliases_issue_1319/test.sol", ["0.5.12"]),
     Test("yul-state-constant-access.sol", ["0.8.16"]),
+    Test("negate-unary-element.sol", ["0.8.16"]),
+    Test(
+        "assembly-functions.sol",
+        ["0.6.9", "0.7.6", "0.8.16"],
+    ),
+    Test("user_defined_operators-0.8.19.sol", ["0.8.19"]),
 ]
 # create the output folder if needed
 try:
     os.mkdir("test_artifacts")
 except OSError:
     pass
 
@@ -464,29 +479,35 @@
     # pylint: disable=no-self-use
     def test_parsing(self, test_file, version, flavor):
         actual = os.path.join(TEST_ROOT, "compile", f"{test_file}-{version}-{flavor}.zip")
         expected = os.path.join(TEST_ROOT, "expected", f"{test_file}-{version}-{flavor}.json")
 
         cc = load_from_zip(actual)[0]
 
+        # Validate that the AST is in the expected format
+        for compiled in cc.compilation_units.values():
+            for source in compiled.source_units.values():
+                if source.ast:
+                    if flavor == "compact":
+                        assert "nodeType" in source.ast, "AST is not compact"
+                    else:
+                        assert "nodeType" not in source.ast, "AST is not legacy"
+
         sl = Slither(
             cc,
             solc_force_legacy_json=flavor == "legacy",
             disallow_partial=True,
             skip_analyze=True,
         )
 
         actual = generate_output(sl)
 
-        try:
-            with open(expected, "r", encoding="utf8") as f:
-                expected = json.load(f)
-        except OSError:
-            pytest.xfail("the file for this test was not generated")
-            raise
+        assert os.path.isfile(expected), f"Expected file {expected} does not exist"
+        with open(expected, "r", encoding="utf8") as f:
+            expected = json.load(f)
 
         diff = DeepDiff(expected, actual, ignore_order=True, verbose_level=2, view="tree")
         if diff:
             for change in diff.get("values_changed", []):
                 path_list = re.findall(r"\['(.*?)'\]", change.path())
                 path = "_".join(path_list)
                 with open(
```

### Comparing `slither-analyzer-0.9.3/tests/test_detectors.py` & `slither-analyzer-0.9.4/tests/e2e/detectors/test_detectors.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,19 +1,17 @@
-import json
 import os
-import pathlib
+from pathlib import Path
 import sys
-from pprint import pprint
 from typing import Type, Optional, List
 
 import pytest
-from deepdiff import DeepDiff  # pip install deepdiff
+from crytic_compile import CryticCompile, save_to_zip
+from crytic_compile.utils.zip import load_from_zip
 
-from solc_select.solc_select import install_artifacts as install_solc_versions
-from solc_select.solc_select import installed_versions as get_installed_solc_versions
+from solc_select import solc_select
 
 from slither import Slither
 from slither.detectors.abstract_detector import AbstractDetector
 from slither.detectors import all_detectors
 
 
 class Test:  # pylint: disable=too-few-public-methods
@@ -31,35 +29,38 @@
         :param test_file:
         :param solc_ver:
         :param additional_files: If the test changes additional files, list them here to allow the
         test to update the source mapping
         """
         self.detector = detector
         self.test_file = test_file
-        self.expected_result = test_file + "." + solc_ver + "." + detector.__name__ + ".json"
         self.solc_ver = solc_ver
         if additional_files is None:
             self.additional_files = []
         else:
             self.additional_files = additional_files
 
 
 def set_solc(test_item: Test):  # pylint: disable=too-many-lines
     # hacky hack hack to pick the solc version we want
     env = dict(os.environ)
+
+    if not solc_select.artifact_path(test_item.solc_ver).exists():
+        print("Installing solc version", test_item.solc_ver)
+        solc_select.install_artifacts([test_item.solc_ver])
     env["SOLC_VERSION"] = test_item.solc_ver
     os.environ.clear()
     os.environ.update(env)
 
 
 def id_test(test_item: Test):
     return f"{test_item.detector.__name__}-{test_item.solc_ver}-{test_item.test_file}"
 
 
-ALL_TEST_OBJECTS = [
+ALL_TESTS = [
     Test(
         all_detectors.UninitializedFunctionPtrsConstructor,
         "uninitialized_function_ptr_constructor.sol",
         "0.4.25",
     ),
     Test(
         all_detectors.UninitializedFunctionPtrsConstructor,
@@ -1634,114 +1635,79 @@
         "0.8.16",
     ),
     Test(
         all_detectors.CyclomaticComplexity,
         "LowCyclomaticComplexity.sol",
         "0.8.16",
     ),
+    Test(
+        all_detectors.CacheArrayLength,
+        "CacheArrayLength.sol",
+        "0.8.17",
+    ),
+    Test(
+        all_detectors.IncorrectUsingFor,
+        "IncorrectUsingForTopLevel.sol",
+        "0.8.17",
+    ),
+    Test(
+        all_detectors.EncodePackedCollision,
+        "encode_packed_collision.sol",
+        "0.7.6",
+    ),
 ]
 
-
-def get_all_tests() -> List[Test]:
-    installed_solcs = set(get_installed_solc_versions())
-    required_solcs = {test.solc_ver for test in ALL_TEST_OBJECTS}
-    missing_solcs = list(required_solcs - installed_solcs)
-    if missing_solcs:
-        install_solc_versions(missing_solcs)
-
-    return ALL_TEST_OBJECTS
-
-
-ALL_TESTS = get_all_tests()
-
 GENERIC_PATH = "/GENERIC_PATH"
 
+TEST_DATA_DIR = Path(__file__).resolve().parent / "test_data"
 
+# pylint: disable=too-many-locals
 @pytest.mark.parametrize("test_item", ALL_TESTS, ids=id_test)
-def test_detector(test_item: Test):
-    test_dir_path = pathlib.Path(
-        pathlib.Path().absolute(),
-        "tests",
-        "detectors",
+def test_detector(test_item: Test, snapshot):
+    test_dir_path = Path(
+        TEST_DATA_DIR,
         test_item.detector.ARGUMENT,
         test_item.solc_ver,
-    )
-    test_file_path = str(pathlib.Path(test_dir_path, test_item.test_file))
-    expected_result_path = str(pathlib.Path(test_dir_path, test_item.expected_result).absolute())
+    ).as_posix()
+    test_file_path = Path(test_dir_path, test_item.test_file).as_posix()
 
-    set_solc(test_item)
-    sl = Slither(test_file_path)
+    zip_artifact_path = Path(f"{test_file_path}-{test_item.solc_ver}.zip").as_posix()
+    crytic_compile = load_from_zip(zip_artifact_path)[0]
+
+    sl = Slither(crytic_compile)
     sl.register_detector(test_item.detector)
     results = sl.run_detectors()
 
-    with open(expected_result_path, encoding="utf8") as f:
-        expected_result = json.load(f)
+    actual_output = ""
+    for detector_result in results:
+        for result in detector_result:
+            actual_output += result["description"]
+            actual_output += "\n"
+    assert snapshot() == actual_output
 
-    results_as_string = json.dumps(results)
 
-    for additional_file in test_item.additional_files:
-        additional_path = str(pathlib.Path(test_dir_path, additional_file).absolute())
-        additional_path = additional_path.replace("\\", "\\\\")
-        results_as_string = results_as_string.replace(additional_path, GENERIC_PATH)
-    test_file_path = test_file_path.replace("\\", "\\\\")
-    results_as_string = results_as_string.replace(test_file_path, GENERIC_PATH)
-    results = json.loads(results_as_string)
-
-    diff = DeepDiff(results, expected_result, ignore_order=True, verbose_level=2)
-    if diff:
-        pprint(diff)
-        diff_as_dict = diff.to_dict()
-
-        if "iterable_item_added" in diff_as_dict:
-            print("#### Findings added")
-            for finding_added in diff_as_dict["iterable_item_added"].values():
-                print(finding_added["description"])
-        if "iterable_item_removed" in diff_as_dict:
-            print("#### Findings removed")
-            for finding_added in diff_as_dict["iterable_item_removed"].values():
-                print(finding_added["description"])
-        assert False
-
-
-def _generate_test(test_item: Test, skip_existing=False):
-    test_dir_path = pathlib.Path(
-        pathlib.Path().absolute(),
-        "tests",
-        "detectors",
+def _generate_compile(test_item: Test, skip_existing=False):
+    test_dir_path = Path(
+        TEST_DATA_DIR,
         test_item.detector.ARGUMENT,
         test_item.solc_ver,
-    )
-    test_file_path = str(pathlib.Path(test_dir_path, test_item.test_file))
-    expected_result_path = str(pathlib.Path(test_dir_path, test_item.expected_result).absolute())
+    ).as_posix()
+    test_file_path = Path(test_dir_path, test_item.test_file).as_posix()
+    zip_artifact_path = Path(f"{test_file_path}-{test_item.solc_ver}.zip").as_posix()
 
     if skip_existing:
-        if os.path.isfile(expected_result_path):
+        if os.path.isfile(zip_artifact_path):
             return
 
     set_solc(test_item)
-    sl = Slither(test_file_path)
-    sl.register_detector(test_item.detector)
-    results = sl.run_detectors()
-
-    results_as_string = json.dumps(results)
-    test_file_path = test_file_path.replace("\\", "\\\\")
-    results_as_string = results_as_string.replace(test_file_path, GENERIC_PATH)
-
-    for additional_file in test_item.additional_files:
-        additional_path = str(pathlib.Path(test_dir_path, additional_file).absolute())
-        additional_path = additional_path.replace("\\", "\\\\")
-        results_as_string = results_as_string.replace(additional_path, GENERIC_PATH)
-
-    results = json.loads(results_as_string)
-    with open(expected_result_path, "w", encoding="utf8") as f:
-        f.write(json.dumps(results, indent=4))
+    crytic_compile = CryticCompile(test_file_path)
+    save_to_zip([crytic_compile], zip_artifact_path)
 
 
 if __name__ == "__main__":
     if len(sys.argv) != 2:
-        print("To generate the json artifacts run\n\tpython tests/test_detectors.py --generate")
-    elif sys.argv[1] == "--generate":
-        for next_test in ALL_TESTS:
-            _generate_test(next_test, skip_existing=True)
-    elif sys.argv[1] == "--overwrite":
+        print(
+            "To generate the zip artifacts run\n\tpython tests/e2e/tests/test_detectors.py --compile"
+        )
+    elif sys.argv[1] == "--compile":
         for next_test in ALL_TESTS:
-            _generate_test(next_test)
+            _generate_compile(next_test, skip_existing=True)
```

### Comparing `slither-analyzer-0.9.3/tests/test_function.py` & `slither-analyzer-0.9.4/tests/unit/core/test_function_declaration.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,24 +1,28 @@
 """
 tests for `slither.core.declarations.Function`.
 tests that `tests/test_function.sol` gets translated into correct
 `slither.core.declarations.Function` objects or its subclasses
 and that these objects behave correctly.
 """
-from solc_select import solc_select
+from pathlib import Path
 
 from slither import Slither
 from slither.core.declarations.function import FunctionType
 from slither.core.solidity_types.elementary_type import ElementaryType
 
+TEST_DATA_DIR = Path(__file__).resolve().parent / "test_data"
+FUNC_DELC_TEST_ROOT = Path(TEST_DATA_DIR, "function_declaration")
 
-def test_functions():
+
+def test_functions(solc_binary_path):
     # pylint: disable=too-many-statements
-    solc_select.switch_global_version("0.6.12", always_install=True)
-    slither = Slither("tests/test_function.sol")
+    solc_path = solc_binary_path("0.6.12")
+    file = Path(FUNC_DELC_TEST_ROOT, "test_function.sol").as_posix()
+    slither = Slither(file, solc=solc_path)
     functions = slither.get_contract_from_name("TestFunction")[0].available_functions_as_dict()
 
     f = functions["external_payable(uint256)"]
     assert f.name == "external_payable"
     assert f.full_name == "external_payable(uint256)"
     assert f.canonical_name == "TestFunction.external_payable(uint256)"
     assert f.solidity_signature == "external_payable(uint256)"
@@ -239,17 +243,18 @@
     assert f.pure is True
     assert f.is_implemented is True
     assert f.is_empty is False
     assert f.parameters == []
     assert f.return_type[0] == ElementaryType("bool")
 
 
-def test_function_can_send_eth():
-    solc_select.switch_global_version("0.6.12", always_install=True)
-    slither = Slither("tests/test_function.sol")
+def test_function_can_send_eth(solc_binary_path):
+    solc_path = solc_binary_path("0.6.12")
+    file = Path(FUNC_DELC_TEST_ROOT, "test_function.sol").as_posix()
+    slither = Slither(file, solc=solc_path)
     compilation_unit = slither.compilation_units[0]
     functions = compilation_unit.get_contract_from_name("TestFunctionCanSendEth")[
         0
     ].available_functions_as_dict()
 
     assert functions["send_direct()"].can_send_eth() is True
     assert functions["transfer_direct()"].can_send_eth() is True
@@ -263,33 +268,35 @@
 
     assert functions["send_via_external()"].can_send_eth() is False
     assert functions["transfer_via_external()"].can_send_eth() is False
     assert functions["call_via_external()"].can_send_eth() is False
     assert functions["highlevel_call_via_external()"].can_send_eth() is False
 
 
-def test_reentrant():
-    solc_select.switch_global_version("0.8.10", always_install=True)
-    slither = Slither("tests/test_function_reentrant.sol")
+def test_reentrant(solc_binary_path):
+    solc_path = solc_binary_path("0.8.10")
+    file = Path(FUNC_DELC_TEST_ROOT, "test_function_reentrant.sol").as_posix()
+    slither = Slither(file, solc=solc_path)
     compilation_unit = slither.compilation_units[0]
     functions = compilation_unit.get_contract_from_name("TestReentrant")[
         0
     ].available_functions_as_dict()
 
     assert functions["is_reentrant()"].is_reentrant
     assert not functions["is_non_reentrant()"].is_reentrant
     assert not functions["internal_and_not_reentrant()"].is_reentrant
     assert not functions["internal_and_not_reentrant2()"].is_reentrant
     assert functions["internal_and_could_be_reentrant()"].is_reentrant
     assert functions["internal_and_reentrant()"].is_reentrant
 
 
-def test_public_variable() -> None:
-    solc_select.switch_global_version("0.6.12", always_install=True)
-    slither = Slither("tests/test_function.sol")
+def test_public_variable(solc_binary_path) -> None:
+    solc_path = solc_binary_path("0.6.12")
+    file = Path(FUNC_DELC_TEST_ROOT, "test_function.sol").as_posix()
+    slither = Slither(file, solc=solc_path)
     contracts = slither.get_contract_from_name("TestFunction")
     assert len(contracts) == 1
     contract = contracts[0]
     var = contract.get_state_variable_from_name("info")
     assert var
     assert var.solidity_signature == "info()"
     assert var.signature_str == "info() returns(bytes32)"
```

### Comparing `slither-analyzer-0.9.3/tests/test_functions_ids.py` & `slither-analyzer-0.9.4/tests/unit/utils/test_functions_ids.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-from solc_select import solc_select
+from pathlib import Path
 from slither import Slither
 
 # % solc functions_ids.sol --hashes
 # ======= functions_ids.sol:C =======
 # Function signatures:
 # 0dbe671f: a()
 # 4a1f689d: a_array(uint256)
@@ -33,28 +33,27 @@
     "multiDimensionalArray(uint256,uint256)": "f29872a8",
     "normalMappingArrayField(uint256,uint256)": "9539e3c8",
     "outer()": "87c3dbb6",
     "simple()": "df201a46",
     "stateMap(uint16)": "5a20851f",
 }
 
+TEST_DATA_DIR = Path(__file__).resolve().parent / "test_data"
 
-def test_functions_ids() -> None:
-    solc_select.switch_global_version("0.7.0", always_install=True)
-    sl = Slither("tests/printers/functions_ids.sol")
+
+def test_functions_ids(solc_binary_path) -> None:
+    solc_path = solc_binary_path("0.7.0")
+    file = Path(TEST_DATA_DIR, "functions_ids.sol").as_posix()
+    sl = Slither(file, solc=solc_path)
     contracts_c = sl.get_contract_from_name("C")
     assert len(contracts_c) == 1
     contract_c = contracts_c[0]
 
     for sig, hashes in signatures.items():
         func = contract_c.get_function_from_signature(sig)
         if not func:
             var_name = sig[: sig.find("(")]
             var = contract_c.get_state_variable_from_name(var_name)
             assert var
             assert get_function_id(var.solidity_signature) == int(hashes, 16)
         else:
             assert get_function_id(func.solidity_signature) == int(hashes, 16)
-
-
-if __name__ == "__main__":
-    test_functions_ids()
```

### Comparing `slither-analyzer-0.9.3/tests/test_source_mapping.py` & `slither-analyzer-0.9.4/tests/unit/core/test_source_mapping.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,102 +1,93 @@
-from solc_select import solc_select
+from pathlib import Path
 
 from slither import Slither
 from slither.core.declarations import Function
 
+TEST_DATA_DIR = Path(__file__).resolve().parent / "test_data"
+SRC_MAPPING_TEST_ROOT = Path(TEST_DATA_DIR, "src_mapping")
 
-def test_source_mapping():
-    solc_select.switch_global_version("0.6.12", always_install=True)
-    slither = Slither("tests/src_mapping/inheritance.sol")
+
+def test_source_mapping(solc_binary_path):
+    solc_path = solc_binary_path("0.6.12")
+    file = Path(SRC_MAPPING_TEST_ROOT, "inheritance.sol").as_posix()
+    slither = Slither(file, solc=solc_path)
 
     # Check if A.f() is at the offset 27
-    functions = slither.offset_to_objects("tests/src_mapping/inheritance.sol", 27)
-    print(functions)
+    functions = slither.offset_to_objects(file, 27)
     assert len(functions) == 1
     function = functions.pop()
     assert isinstance(function, Function)
     assert function.canonical_name == "A.f()"
 
     # Only one definition for A.f()
-    assert {
-        (x.start, x.end)
-        for x in slither.offset_to_definitions("tests/src_mapping/inheritance.sol", 27)
-    } == {(26, 28)}
+    assert {(x.start, x.end) for x in slither.offset_to_definitions(file, 27)} == {(26, 28)}
     # Only one reference for A.f(), in A.test()
-    assert {
-        (x.start, x.end)
-        for x in slither.offset_to_references("tests/src_mapping/inheritance.sol", 27)
-    } == {(92, 93)}
+    assert {(x.start, x.end) for x in slither.offset_to_references(file, 27)} == {(92, 93)}
     # Only one implementation for A.f(), in A.test()
-    assert {
-        (x.start, x.end)
-        for x in slither.offset_to_implementations("tests/src_mapping/inheritance.sol", 27)
-    } == {(17, 53)}
+    assert {(x.start, x.end) for x in slither.offset_to_implementations(file, 27)} == {(17, 53)}
 
     # Check if C.f() is at the offset 203
-    functions = slither.offset_to_objects("tests/src_mapping/inheritance.sol", 203)
+    functions = slither.offset_to_objects(file, 203)
     assert len(functions) == 1
     function = functions.pop()
     assert isinstance(function, Function)
     assert function.canonical_name == "C.f()"
 
     # Only one definition for C.f()
-    assert {
-        (x.start, x.end)
-        for x in slither.offset_to_definitions("tests/src_mapping/inheritance.sol", 203)
-    } == {(202, 204)}
+    assert {(x.start, x.end) for x in slither.offset_to_definitions(file, 203)} == {(202, 204)}
     # Two references for C.f(), in A.test() and C.test2()
-    assert {
-        (x.start, x.end)
-        for x in slither.offset_to_references("tests/src_mapping/inheritance.sol", 203)
-    } == {(270, 271), (92, 93)}
+    assert {(x.start, x.end) for x in slither.offset_to_references(file, 203)} == {
+        (270, 271),
+        (92, 93),
+    }
     # Only one implementation for A.f(), in A.test()
-    assert {
-        (x.start, x.end)
-        for x in slither.offset_to_implementations("tests/src_mapping/inheritance.sol", 203)
-    } == {(193, 230)}
+    assert {(x.start, x.end) for x in slither.offset_to_implementations(file, 203)} == {(193, 230)}
 
     # Offset 93 is the call to f() in A.test()
     # This can lead to three differents functions, depending on the current contract's context
-    functions = slither.offset_to_objects("tests/src_mapping/inheritance.sol", 93)
+    functions = slither.offset_to_objects(file, 93)
     print(functions)
     assert len(functions) == 3
     for function in functions:
         assert isinstance(function, Function)
         assert function.canonical_name in ["A.f()", "B.f()", "C.f()"]
 
     # There are three definitions possible (in A, B or C)
-    assert {
-        (x.start, x.end)
-        for x in slither.offset_to_definitions("tests/src_mapping/inheritance.sol", 93)
-    } == {(26, 28), (202, 204), (138, 140)}
+    assert {(x.start, x.end) for x in slither.offset_to_definitions(file, 93)} == {
+        (26, 28),
+        (202, 204),
+        (138, 140),
+    }
 
     # There are two references possible (in A.test() or C.test2() )
-    assert {
-        (x.start, x.end)
-        for x in slither.offset_to_references("tests/src_mapping/inheritance.sol", 93)
-    } == {(92, 93), (270, 271)}
+    assert {(x.start, x.end) for x in slither.offset_to_references(file, 93)} == {
+        (92, 93),
+        (270, 271),
+    }
 
     # There are three implementations possible (in A, B or C)
-    assert {
-        (x.start, x.end)
-        for x in slither.offset_to_implementations("tests/src_mapping/inheritance.sol", 93)
-    } == {(17, 53), (193, 230), (129, 166)}
+    assert {(x.start, x.end) for x in slither.offset_to_implementations(file, 93)} == {
+        (17, 53),
+        (193, 230),
+        (129, 166),
+    }
 
 
 def _sort_references_lines(refs: list) -> list:
     return sorted([ref.lines[0] for ref in refs])
 
 
-def _test_references_user_defined_aliases():
+def test_references_user_defined_aliases(solc_binary_path):
     """
     Tests if references are filled correctly for user defined aliases (declared using "type [...] is [...]" statement).
     """
-    solc_select.switch_global_version("0.8.16", always_install=True)
-    slither = Slither("tests/src_mapping/ReferencesUserDefinedAliases.sol")
+    solc_path = solc_binary_path("0.8.16")
+    file = Path(SRC_MAPPING_TEST_ROOT, "ReferencesUserDefinedAliases.sol").as_posix()
+    slither = Slither(file, solc=solc_path)
 
     alias_top_level = slither.compilation_units[0].user_defined_value_types["aliasTopLevel"]
     assert len(alias_top_level.references) == 2
     lines = _sort_references_lines(alias_top_level.references)
     assert lines == [12, 16]
 
     alias_contract_level = (
@@ -105,29 +96,20 @@
         .file_scope.user_defined_types["C.aliasContractLevel"]
     )
     assert len(alias_contract_level.references) == 2
     lines = _sort_references_lines(alias_contract_level.references)
     assert lines == [13, 16]
 
 
-def _test_references_user_defined_types_when_casting():
+def test_references_user_defined_types_when_casting(solc_binary_path):
     """
     Tests if references are filled correctly for user defined types in case of casting.
     """
-    solc_select.switch_global_version("0.8.16", always_install=True)
-    slither = Slither("tests/src_mapping/ReferencesUserDefinedTypesCasting.sol")
+    solc_path = solc_binary_path("0.8.16")
+    file = Path(SRC_MAPPING_TEST_ROOT, "ReferencesUserDefinedTypesCasting.sol").as_posix()
+    slither = Slither(file, solc=solc_path)
 
     contracts = slither.compilation_units[0].contracts
     a = contracts[0] if contracts[0].is_interface else contracts[1]
     assert len(a.references) == 2
     lines = _sort_references_lines(a.references)
     assert lines == [12, 18]
-
-
-def test_references():
-    """
-    Tests if references list is filled correctly in the following cases:
-    - user defined aliases (declared using "type [...] is [...]" statement)
-    - user defined types in case of casting (TypeConversion expressions)
-    """
-    _test_references_user_defined_aliases()
-    _test_references_user_defined_types_when_casting()
```

### Comparing `slither-analyzer-0.9.3/tests/test_source_unit.py` & `slither-analyzer-0.9.4/tests/e2e/compilation/test_source_unit.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,32 +2,35 @@
 import shutil
 
 import pytest
 from slither import Slither
 
 # NB: read tests/source_unit/README.md for setup before using this test
 
+
+TEST_DATA_DIR = Path(__file__).resolve().parent / "test_data"
+
 foundry_available = shutil.which("forge") is not None
-project_ready = Path("./tests/source_unit/lib/forge-std").exists()
+project_ready = Path(TEST_DATA_DIR, "test_source_unit/lib/forge-std").exists()
 
 
 @pytest.mark.skipif(
     not foundry_available or not project_ready, reason="requires Foundry and project setup"
 )
 def test_contract_info() -> None:
-    slither = Slither("./tests/source_unit")
+    slither = Slither(Path(TEST_DATA_DIR, "test_source_unit").as_posix())
 
     assert len(slither.compilation_units) == 1
     compilation_unit = slither.compilation_units[0]
 
     for source_unit in compilation_unit.crytic_compile_compilation_unit.source_units.values():
         source_unit.remove_metadata()
 
     counter_sol = compilation_unit.crytic_compile.filename_lookup(
-        "tests/source_unit/src/Counter.sol"
+        Path(TEST_DATA_DIR, "test_source_unit/src/Counter.sol").as_posix()
     )
     assert (
         compilation_unit.scopes[counter_sol].bytecode_init(
             compilation_unit.crytic_compile_compilation_unit, "Counter"
         )
         == "608060405234801561001057600080fd5b5060f78061001f6000396000f3fe6080604052348015600f57600080fd5b5060043610603c5760003560e01c80633fb5c1cb1460415780638381f58a146053578063d09de08a14606d575b600080fd5b6051604c3660046083565b600055565b005b605b60005481565b60405190815260200160405180910390f35b6051600080549080607c83609b565b9190505550565b600060208284031215609457600080fd5b5035919050565b60006001820160ba57634e487b7160e01b600052601160045260246000fd5b506001019056fe"
     )
```

### Comparing `slither-analyzer-0.9.3/tests/test_ssa_generation.py` & `slither-analyzer-0.9.4/tests/unit/slithir/test_ssa_generation.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,24 +1,22 @@
-# pylint: disable=too-many-lines
-import os
+# # pylint: disable=too-many-lines
 import pathlib
 from argparse import ArgumentTypeError
 from collections import defaultdict
-from contextlib import contextmanager
 from inspect import getsourcefile
-from tempfile import NamedTemporaryFile
-from typing import Union, List, Optional
+from typing import Union, List, Dict, Callable
 
 import pytest
-from solc_select import solc_select
 from solc_select.solc_select import valid_version as solc_valid_version
 
 from slither import Slither
 from slither.core.cfg.node import Node, NodeType
 from slither.core.declarations import Function, Contract
+from slither.core.solidity_types import ArrayType
+from slither.core.variables.local_variable import LocalVariable
 from slither.core.variables.state_variable import StateVariable
 from slither.slithir.operations import (
     OperationWithLValue,
     Phi,
     Assignment,
     HighLevelCall,
     Return,
@@ -31,18 +29,19 @@
 )
 from slither.slithir.utils.ssa import is_used_later
 from slither.slithir.variables import (
     Constant,
     ReferenceVariable,
     LocalIRVariable,
     StateIRVariable,
+    TemporaryVariableSSA,
 )
 
 # Directory of currently executing script. Will be used as basis for temporary file names.
-SCRIPT_DIR = pathlib.Path(getsourcefile(lambda: 0)).parent
+SCRIPT_DIR = pathlib.Path(getsourcefile(lambda: 0)).parent  # type:ignore
 
 
 def valid_version(ver: str) -> bool:
     """Wrapper function to check if the solc-version is valid
 
     The solc_select function raises and exception but for checks below,
     only a bool is needed.
@@ -50,56 +49,59 @@
     try:
         solc_valid_version(ver)
         return True
     except ArgumentTypeError:
         return False
 
 
-def have_ssa_if_ir(function: Function):
+def have_ssa_if_ir(function: Function) -> None:
     """Verifies that all nodes in a function that have IR also have SSA IR"""
     for n in function.nodes:
         if n.irs:
             assert n.irs_ssa
 
 
-# pylint: disable=too-many-branches
-def ssa_basic_properties(function: Function):
+# pylint: disable=too-many-branches, too-many-locals
+def ssa_basic_properties(function: Function) -> None:
     """Verifies that basic properties of ssa holds
 
     1. Every name is defined only once
     2. A l-value is never index zero - there is always a zero-value available for each var
     3. Every r-value is at least defined at some point
     4. The number of ssa defs is >= the number of assignments to var
     5. Function parameters SSA are stored in function.parameters_ssa
        - if function parameter is_storage it refers to a fake variable
     6. Function returns SSA are stored in function.returns_ssa
         - if function return is_storage it refers to a fake variable
     """
     ssa_lvalues = set()
     ssa_rvalues = set()
-    lvalue_assignments = {}
+    lvalue_assignments: Dict[str, int] = {}
 
     for n in function.nodes:
         for ir in n.irs:
-            if isinstance(ir, OperationWithLValue):
+            if isinstance(ir, OperationWithLValue) and ir.lvalue:
                 name = ir.lvalue.name
+                if name is None:
+                    continue
                 if name in lvalue_assignments:
                     lvalue_assignments[name] += 1
                 else:
                     lvalue_assignments[name] = 1
 
         for ssa in n.irs_ssa:
             if isinstance(ssa, OperationWithLValue):
                 # 1
                 assert ssa.lvalue not in ssa_lvalues
                 ssa_lvalues.add(ssa.lvalue)
 
                 # 2 (if Local/State Var)
-                if isinstance(ssa.lvalue, (StateIRVariable, LocalIRVariable)):
-                    assert ssa.lvalue.index > 0
+                ssa_lvalue = ssa.lvalue
+                if isinstance(ssa_lvalue, (StateIRVariable, LocalIRVariable)):
+                    assert ssa_lvalue.index > 0
 
             for rvalue in filter(
                 lambda x: not isinstance(x, (StateIRVariable, Constant)), ssa.read
             ):
                 ssa_rvalues.add(rvalue)
 
     # 3
@@ -108,23 +110,26 @@
     undef_vars = set()
     for rvalue in ssa_rvalues:
         if rvalue not in ssa_lvalues:
             assert rvalue.non_ssa_version not in undef_vars
             undef_vars.add(rvalue.non_ssa_version)
 
     # 4
-    ssa_defs = defaultdict(int)
+    ssa_defs: Dict[str, int] = defaultdict(int)
     for v in ssa_lvalues:
-        ssa_defs[v.name] += 1
+        if v and v.name:
+            ssa_defs[v.name] += 1
 
-    for (k, n) in lvalue_assignments.items():
-        assert ssa_defs[k] >= n
+    for (k, count) in lvalue_assignments.items():
+        assert ssa_defs[k] >= count
 
     # Helper 5/6
-    def check_property_5_and_6(variables, ssavars):
+    def check_property_5_and_6(
+        variables: List[LocalVariable], ssavars: List[LocalIRVariable]
+    ) -> None:
         for var in filter(lambda x: x.name, variables):
             ssa_vars = [x for x in ssavars if x.non_ssa_version == var]
             assert len(ssa_vars) == 1
             ssa_var = ssa_vars[0]
             assert var.is_storage == ssa_var.is_storage
             if ssa_var.is_storage:
                 assert len(ssa_var.refers_to) == 1
@@ -133,15 +138,15 @@
     # 5
     check_property_5_and_6(function.parameters, function.parameters_ssa)
 
     # 6
     check_property_5_and_6(function.returns, function.returns_ssa)
 
 
-def ssa_phi_node_properties(f: Function):
+def ssa_phi_node_properties(f: Function) -> None:
     """Every phi-function should have as many args as predecessors
 
     This does not apply if the phi-node refers to state variables,
     they make use os special phi-nodes for tracking potential values
     a state variable can have
     """
     for node in f.nodes:
@@ -149,15 +154,15 @@
             if isinstance(ssa, Phi):
                 n = len(ssa.read)
                 if not isinstance(ssa.lvalue, StateIRVariable):
                     assert len(node.fathers) == n
 
 
 # TODO (hbrodin): This should probably go into another file, not specific to SSA
-def dominance_properties(f: Function):
+def dominance_properties(f: Function) -> None:
     """Verifies properties related to dominators holds
 
     1. Every node have an immediate dominator except entry_node which have none
     2. From every node immediate dominator there is a path via its successors to the node
     """
 
     def find_path(from_node: Node, to: Node) -> bool:
@@ -177,211 +182,178 @@
         if node is f.entry_point:
             assert node.immediate_dominator is None
         else:
             assert node.immediate_dominator is not None
             assert find_path(node.immediate_dominator, node)
 
 
-def phi_values_inserted(f: Function):
+def phi_values_inserted(f: Function) -> None:
     """Verifies that phi-values are inserted at the right places
 
     For every node that has a dominance frontier, any def (including
     phi) should be a phi function in its dominance frontier
     """
 
-    def have_phi_for_var(node: Node, var):
+    def have_phi_for_var(
+        node: Node, var: Union[StateIRVariable, LocalIRVariable, TemporaryVariableSSA]
+    ) -> bool:
         """Checks if a node has a phi-instruction for var
 
         The ssa version would ideally be checked, but then
         more data flow analysis would be needed, for cases
         where a new def for var is introduced before reaching
         DF
         """
         non_ssa = var.non_ssa_version
         for ssa in node.irs_ssa:
             if isinstance(ssa, Phi):
-                if non_ssa in map(lambda ssa_var: ssa_var.non_ssa_version, ssa.read):
+                if non_ssa in map(
+                    lambda ssa_var: ssa_var.non_ssa_version,
+                    [
+                        r
+                        for r in ssa.read
+                        if isinstance(r, (StateIRVariable, LocalIRVariable, TemporaryVariableSSA))
+                    ],
+                ):
                     return True
         return False
 
     for node in filter(lambda n: n.dominance_frontier, f.nodes):
         for df in node.dominance_frontier:
             for ssa in node.irs_ssa:
                 if isinstance(ssa, OperationWithLValue):
-                    if is_used_later(node, ssa.lvalue):
-                        assert have_phi_for_var(df, ssa.lvalue)
+                    ssa_lvalue = ssa.lvalue
+                    if isinstance(
+                        ssa_lvalue, (StateIRVariable, LocalIRVariable, TemporaryVariableSSA)
+                    ) and is_used_later(node, ssa_lvalue):
+                        assert have_phi_for_var(df, ssa_lvalue)
 
 
-@contextmanager
-def select_solc_version(version: Optional[str]):
-    """Selects solc version to use for running tests.
-
-    If no version is provided, latest is used."""
-    # If no solc_version selected just use the latest avail
-    if not version:
-        # This sorts the versions numerically
-        vers = sorted(
-            map(
-                lambda x: (int(x[0]), int(x[1]), int(x[2])),
-                map(lambda x: x.split(".", 3), solc_select.installed_versions()),
-            )
-        )
-        ver = list(vers)[-1]
-        version = ".".join(map(str, ver))
-    env = dict(os.environ)
-    env_restore = dict(env)
-    env["SOLC_VERSION"] = version
-    os.environ.clear()
-    os.environ.update(env)
-
-    yield version
-
-    os.environ.clear()
-    os.environ.update(env_restore)
-
-
-@contextmanager
-def slither_from_source(source_code: str, solc_version: Optional[str] = None):
-    """Yields a Slither instance using source_code string and solc_version
-
-    Creates a temporary file and changes the solc-version temporary to solc_version.
-    """
-
-    fname = ""
-    try:
-        with NamedTemporaryFile(dir=SCRIPT_DIR, mode="w", suffix=".sol", delete=False) as f:
-            fname = f.name
-            f.write(source_code)
-        with select_solc_version(solc_version):
-            yield Slither(fname)
-    finally:
-        pathlib.Path(fname).unlink()
-
-
-def verify_properties_hold(source_code_or_slither: Union[str, Slither]):
+def verify_properties_hold(slither: Slither) -> None:
     """Ensures that basic properties of SSA hold true"""
 
-    def verify_func(func: Function):
+    def verify_func(func: Function) -> None:
         have_ssa_if_ir(func)
         phi_values_inserted(func)
         ssa_basic_properties(func)
         ssa_phi_node_properties(func)
         dominance_properties(func)
 
-    def verify(slither):
+    def verify(slither: Slither) -> None:
         for cu in slither.compilation_units:
             for func in cu.functions_and_modifiers:
                 _dump_function(func)
                 verify_func(func)
             for contract in cu.contracts:
                 for f in contract.functions:
                     if f.is_constructor or f.is_constructor_variables:
                         _dump_function(f)
                         verify_func(f)
 
-    if isinstance(source_code_or_slither, Slither):
-        verify(source_code_or_slither)
-    else:
-        with slither_from_source(source_code_or_slither) as slither:
-            verify(slither)
+    assert isinstance(slither, Slither)
+    verify(slither)
 
 
-def _dump_function(f: Function):
+def _dump_function(f: Function) -> None:
     """Helper function to print nodes/ssa ir for a function or modifier"""
     print(f"---- {f.name} ----")
     for n in f.nodes:
         print(n)
         for ir in n.irs_ssa:
             print(f"\t{ir}")
     print("")
 
 
-def _dump_functions(c: Contract):
+def _dump_functions(c: Contract) -> None:
     """Helper function to print functions and modifiers of a contract"""
     for f in c.functions_and_modifiers:
         _dump_function(f)
 
 
-def get_filtered_ssa(f: Union[Function, Node], flt) -> List[Operation]:
+def get_filtered_ssa(f: Union[Function, Node], flt: Callable) -> List[Operation]:
     """Returns a list of all ssanodes filtered by filter for all nodes in function f"""
     if isinstance(f, Function):
         return [ssanode for node in f.nodes for ssanode in node.irs_ssa if flt(ssanode)]
 
     assert isinstance(f, Node)
     return [ssanode for ssanode in f.irs_ssa if flt(ssanode)]
 
 
 def get_ssa_of_type(f: Union[Function, Node], ssatype) -> List[Operation]:
     """Returns a list of all ssanodes of a specific type for all nodes in function f"""
     return get_filtered_ssa(f, lambda ssanode: isinstance(ssanode, ssatype))
 
 
-def test_multi_write():
-    contract = """
+def test_multi_write(slither_from_source) -> None:
+    source = """
     pragma solidity ^0.8.11;
     contract Test {
     function multi_write(uint val) external pure returns(uint) {
         val = 1;
         val = 2;
         val = 3;
     }
     }"""
-    verify_properties_hold(contract)
+    with slither_from_source(source) as slither:
+        verify_properties_hold(slither)
 
 
-def test_single_branch_phi():
-    contract = """
+def test_single_branch_phi(slither_from_source) -> None:
+    source = """
         pragma solidity ^0.8.11;
         contract Test {
         function single_branch_phi(uint val) external pure returns(uint) {
             if (val == 3) {
                 val = 9;
             }
             return val;
         }
         }
         """
-    verify_properties_hold(contract)
+    with slither_from_source(source) as slither:
+        verify_properties_hold(slither)
 
 
-def test_basic_phi():
-    contract = """
+def test_basic_phi(slither_from_source) -> None:
+    source = """
     pragma solidity ^0.8.11;
     contract Test {
     function basic_phi(uint val) external pure returns(uint) {
         if (val == 3) {
             val = 9;
         } else {
             val = 1;
         }
         return val;
     }
     }
     """
-    verify_properties_hold(contract)
+    with slither_from_source(source) as slither:
+        verify_properties_hold(slither)
 
 
-def test_basic_loop_phi():
-    contract = """
+def test_basic_loop_phi(slither_from_source) -> None:
+    source = """
     pragma solidity ^0.8.11;
     contract Test {
     function basic_loop_phi(uint val) external pure returns(uint) {
         for (uint i=0;i<128;i++) {
             val = val + 1;
         }
         return val;
     }
     }
     """
-    verify_properties_hold(contract)
+    with slither_from_source(source) as slither:
+        verify_properties_hold(slither)
 
 
-@pytest.mark.skip(reason="Fails in current slither version. Fix in #1102.")
-def test_phi_propagation_loop():
-    contract = """
+@pytest.mark.xfail(strict=True, reason="Fails in current slither version. Fix in #1102.")
+def test_phi_propagation_loop(slither_from_source):
+    source = """
      pragma solidity ^0.8.11;
      contract Test {
      function looping(uint v) external pure returns(uint) {
         uint val = 0;
         for (uint i=0;i<v;i++) {
             if (val > i) {
                 val = i;
@@ -389,20 +361,21 @@
                 val = 3;
             }
         }
         return val;
     }
     }
     """
-    verify_properties_hold(contract)
+    with slither_from_source(source) as slither:
+        verify_properties_hold(slither)
 
 
-@pytest.mark.skip(reason="Fails in current slither version. Fix in #1102.")
-def test_free_function_properties():
-    contract = """
+@pytest.mark.xfail(strict=True, reason="Fails in current slither version. Fix in #1102.")
+def test_free_function_properties(slither_from_source):
+    source = """
         pragma solidity ^0.8.11;
 
         function free_looping(uint v) returns(uint) {
            uint val = 0;
            for (uint i=0;i<v;i++) {
                if (val > i) {
                    val = i;
@@ -411,18 +384,19 @@
                }
            }
            return val;
        }
 
        contract Test {}
        """
-    verify_properties_hold(contract)
+    with slither_from_source(source) as slither:
+        verify_properties_hold(slither)
 
 
-def test_ssa_inter_transactional():
+def test_ssa_inter_transactional(slither_from_source) -> None:
     source = """
     pragma solidity ^0.8.11;
     contract A {
         uint my_var_A;
         uint my_var_B;
 
         function direct_set(uint i) public {
@@ -456,16 +430,16 @@
         # phi rvalues come from 1, initial value of my_var_a and 2, assignment in direct_set
         assert len(phi.rvalues) == 3
         assert all(x.non_ssa_version == variables["my_var_A"] for x in phi.rvalues)
         assert assign1.lvalue in phi.rvalues
         assert assign2.lvalue in phi.rvalues
 
 
-@pytest.mark.skip(reason="Fails in current slither version. Fix in #1102.")
-def test_ssa_phi_callbacks():
+@pytest.mark.xfail(strict=True, reason="Fails in current slither version. Fix in #1102.")
+def test_ssa_phi_callbacks(slither_from_source):
     source = """
     pragma solidity ^0.8.11;
     contract A {
         uint my_var_A;
         uint my_var_B;
 
         function direct_set(uint i) public {
@@ -515,16 +489,16 @@
         # The two sources for this phi node is
         # 1. my_var_A = i;
         # 2. my_var_A = 3;
         assert isinstance(after_call_phi, Phi)
         assert len(after_call_phi.rvalues) == 2
 
 
-@pytest.mark.skip(reason="Fails in current slither version. Fix in #1102.")
-def test_storage_refers_to():
+@pytest.mark.xfail(strict=True, reason="Fails in current slither version. Fix in #1102.")
+def test_storage_refers_to(slither_from_source):
     """Test the storage aspects of the SSA IR
 
     When declaring a var as being storage, start tracking what storage it refers_to.
     When a phi-node is created, ensure refers_to is propagated to the phi-node.
     Assignments also propagate refers_to.
     Whenever a ReferenceVariable is the destination of an assignment (e.g. s.v = 10)
     below, create additional versions of the variables it refers to record that a a
@@ -582,19 +556,18 @@
         assert len(phinodes) == 2
 
         # And they are recorded in one of the entry phis
         assert phinodes[0].lvalue in entryphi[0].rvalues or entryphi[1].rvalues
         assert phinodes[1].lvalue in entryphi[0].rvalues or entryphi[1].rvalues
 
 
-@pytest.mark.skip(reason="Fails in current slither version. Fix in #1102.")
 @pytest.mark.skipif(
     not valid_version("0.4.0"), reason="Solidity version 0.4.0 not available on this platform"
 )
-def test_initial_version_exists_for_locals():
+def test_initial_version_exists_for_locals(slither_from_source):
     """
     In solidity you can write statements such as
     uint a = a + 1, this test ensures that can be handled for local variables.
     """
     src = """
     contract C {
         function func() internal {
@@ -619,19 +592,19 @@
         assert a_1.index == 1
         assert a_1.name == "a"
         assert assignment.rvalue == addition.lvalue
 
         assert a_0.non_ssa_version == a_1.non_ssa_version
 
 
-@pytest.mark.skip(reason="Fails in current slither version. Fix in #1102.")
+@pytest.mark.xfail(strict=True, reason="Fails in current slither version. Fix in #1102.")
 @pytest.mark.skipif(
     not valid_version("0.4.0"), reason="Solidity version 0.4.0 not available on this platform"
 )
-def test_initial_version_exists_for_state_variables():
+def test_initial_version_exists_for_state_variables(slither_from_source):
     """
     In solidity you can write statements such as
     uint a = a + 1, this test ensures that can be handled for state variables.
     """
     src = """
     contract C {
         uint a = a + 1;
@@ -659,16 +632,16 @@
         assert a_0.non_ssa_version == a_1.non_ssa_version
         assert isinstance(a_0.non_ssa_version, StateVariable)
 
         # No conditional/other function interaction so no phis
         assert len(get_ssa_of_type(f, Phi)) == 0
 
 
-@pytest.mark.skip(reason="Fails in current slither version. Fix in #1102.")
-def test_initial_version_exists_for_state_variables_function_assign():
+@pytest.mark.xfail(strict=True, reason="Fails in current slither version. Fix in #1102.")
+def test_initial_version_exists_for_state_variables_function_assign(slither_from_source):
     """
     In solidity you can write statements such as
     uint a = a + 1, this test ensures that can be handled for local variables.
     """
     # TODO (hbrodin): Could be a detector that a is not used in f
     src = """
     contract C {
@@ -686,15 +659,15 @@
         if f.is_constructor_variables:
             f, ctor = ctor, f
 
         # ctor should have a single call to f that assigns to a
         # temporary variable, that is then assigned to a
 
         call = get_ssa_of_type(ctor, InternalCall)[0]
-        assert call.function == f
+        assert call.node.function == f
         assign = get_ssa_of_type(ctor, Assignment)[0]
         assert assign.rvalue == call.lvalue
         assert isinstance(assign.lvalue, StateIRVariable)
         assert assign.lvalue.name == "a"
 
         # f should have a phi node on entry of a0, a1 and should return
         # a2
@@ -702,15 +675,15 @@
         assert len(phi.rvalues) == 2
         assert assign.lvalue in phi.rvalues
 
 
 @pytest.mark.skipif(
     not valid_version("0.4.0"), reason="Solidity version 0.4.0 not available on this platform"
 )
-def test_return_local_before_assign():
+def test_return_local_before_assign(slither_from_source):
     src = """
     // this require solidity < 0.5
     // a variable can be returned before declared. Ensure it can be
     // handled by Slither.
     contract A {
     function local(bool my_bool) internal returns(uint){
         if(my_bool){
@@ -732,15 +705,15 @@
         assert assign.lvalue.index == 1
         assert assign.lvalue.non_ssa_version == ret.values[0].non_ssa_version
 
 
 @pytest.mark.skipif(
     not valid_version("0.5.0"), reason="Solidity version 0.5.0 not available on this platform"
 )
-def test_shadow_local():
+def test_shadow_local(slither_from_source):
     src = """
     contract A {
      // this require solidity 0.5
     function shadowing_local() internal{
         uint local = 0;
         {
             uint local = 1;
@@ -756,16 +729,16 @@
         f = slither.contracts[0].functions[0]
 
         # Ensure all assignments are to a variable of index 1
         # not using the same IR var.
         assert all(map(lambda x: x.lvalue.index == 1, get_ssa_of_type(f, Assignment)))
 
 
-@pytest.mark.skip(reason="Fails in current slither version. Fix in #1102.")
-def test_multiple_named_args_returns():
+@pytest.mark.xfail(strict=True, reason="Fails in current slither version. Fix in #1102.")
+def test_multiple_named_args_returns(slither_from_source):
     """Verifies that named arguments and return values have correct versions
 
     Each arg/ret have an initial version, version 0, and is written once and should
     then have version 1.
     """
     src = """
     contract A {
@@ -785,16 +758,16 @@
             map(
                 lambda x: x.lvalue.index == 1 or not isinstance(x.lvalue, LocalIRVariable),
                 get_ssa_of_type(f, OperationWithLValue),
             )
         )
 
 
-@pytest.mark.xfail(reason="Tests for wanted state of SSA IR, not current.")
-def test_memory_array():
+@pytest.mark.xfail(reason="Tests for wanted state of SSA IR, not current.", strict=True)
+def test_memory_array(slither_from_source):
     src = """
     contract MemArray {
         struct A {
             uint val1;
             uint val2;
         }
 
@@ -851,16 +824,16 @@
         for arg in b_args:
             assert arg in phi_entry_b.rvalues
 
         # NOTE(hbrodin): There should be an additional arg_0 (see comment about phi_entry_accept).
         assert len(phi_entry_b.rvalues) == len(b_args) + 1
 
 
-@pytest.mark.xfail(reason="Tests for wanted state of SSA IR, not current.")
-def test_storage_array():
+@pytest.mark.xfail(reason="Tests for wanted state of SSA IR, not current.", strict=True)
+def test_storage_array(slither_from_source):
     src = """
     contract StorageArray {
         struct A {
             uint val1;
             uint val2;
         }
 
@@ -906,16 +879,16 @@
         [phi_entry_accept] = get_ssa_of_type(faccept.entry_point, Phi)
         assert len(phi_entry_accept.rvalues) == 3  # See comment in b above
 
         [phi_entry_b] = get_ssa_of_type(fb.entry_point, Phi)
         assert len(phi_entry_b.rvalues) == 3  # See comment in b above
 
 
-@pytest.mark.skip(reason="Fails in current slither version. Fix in #1102.")
-def test_issue_468():
+@pytest.mark.xfail(strict=True, reason="Fails in current slither version. Fix in #1102.")
+def test_issue_468(slither_from_source):
     """
     Ensure issue 468 is corrected as per
     https://github.com/crytic/slither/issues/468#issuecomment-620974151
     The one difference is that we allow the phi-function at entry of f to
     hold exit state which contains init state and state from branch, which
     is a bit redundant. This could be further simplified.
     """
@@ -960,16 +933,16 @@
         assert len(ret.values) == 1
         assert phi_endif.lvalue in ret.values
 
         # Ensure that the phi_endif (which is the end-state for function as well) is in the entry_phi
         assert phi_endif.lvalue in phi_entry.rvalues
 
 
-@pytest.mark.skip(reason="Fails in current slither version. Fix in #1102.")
-def test_issue_434():
+@pytest.mark.xfail(strict=True, reason="Fails in current slither version. Fix in #1102.")
+def test_issue_434(slither_from_source):
     source = """
      contract Contract {
         int public a;
         function f() public {
             g();
             a += 1;
         }
@@ -1014,16 +987,16 @@
         aftercall_phi = call.node.irs_ssa[idx + 1]
         assert isinstance(aftercall_phi, Phi)
 
         # Ensure that phi node ^ is used in the addition afterwards
         assert aftercall_phi.lvalue in (add_f.variable_left, add_f.variable_right)
 
 
-@pytest.mark.skip(reason="Fails in current slither version. Fix in #1102.")
-def test_issue_473():
+@pytest.mark.xfail(strict=True, reason="Fails in current slither version. Fix in #1102.")
+def test_issue_473(slither_from_source):
     source = """
     contract Contract {
     function f() public returns (int) {
         int a = 1;
         if (a > 0) {
             a = 2;
         }
@@ -1058,22 +1031,88 @@
         assert len(second_phi.rvalues) == 2
 
         # return is for second phi
         assert len(return_value.values) == 1
         assert second_phi.lvalue in return_value.values
 
 
-def test_issue_1748():
+def test_issue_1748(slither_from_source):
     source = """
     contract Contract {
         uint[] arr;
         function foo(uint i) public {
             arr = [1];
         }
     }
     """
     with slither_from_source(source) as slither:
         c = slither.get_contract_from_name("Contract")[0]
         f = c.functions[0]
         operations = f.slithir_operations
         assign_op = operations[0]
         assert isinstance(assign_op, InitArray)
+
+
+def test_issue_1776(slither_from_source):
+    source = """
+    contract Contract {
+        function foo() public returns (uint) {
+            uint[5][10][] memory arr = new uint[5][10][](2);
+            return 0;
+        }
+    }
+    """
+    with slither_from_source(source) as slither:
+        c = slither.get_contract_from_name("Contract")[0]
+        f = c.functions[0]
+        operations = f.slithir_operations
+        new_op = operations[0]
+        lvalue = new_op.lvalue
+        lvalue_type = lvalue.type
+        assert isinstance(lvalue_type, ArrayType)
+        assert lvalue_type.is_dynamic
+        lvalue_type1 = lvalue_type.type
+        assert isinstance(lvalue_type1, ArrayType)
+        assert not lvalue_type1.is_dynamic
+        assert lvalue_type1.length_value.value == "10"
+        lvalue_type2 = lvalue_type1.type
+        assert isinstance(lvalue_type2, ArrayType)
+        assert not lvalue_type2.is_dynamic
+        assert lvalue_type2.length_value.value == "5"
+
+
+def test_issue_1846_ternary_in_if(slither_from_source):
+    source = """
+    contract Contract {
+        function foo(uint x) public returns (uint y) {
+            if (x > 0) {
+                y = x > 1 ? 2 : 3;
+            } else {
+                y = 4;
+            }
+        }
+    }
+    """
+    with slither_from_source(source) as slither:
+        c = slither.get_contract_from_name("Contract")[0]
+        f = c.functions[0]
+        node = f.nodes[1]
+        assert node.type == NodeType.IF
+        assert node.son_true.type == NodeType.IF
+        assert node.son_false.type == NodeType.EXPRESSION
+
+
+def test_issue_1846_ternary_in_ternary(slither_from_source):
+    source = """
+        contract Contract {
+            function foo(uint x) public returns (uint y) {
+                y = x > 0 ? x > 1 ? 2 : 3 : 4;
+            }
+        }
+        """
+    with slither_from_source(source) as slither:
+        c = slither.get_contract_from_name("Contract")[0]
+        f = c.functions[0]
+        node = f.nodes[1]
+        assert node.type == NodeType.IF
+        assert node.son_true.type == NodeType.IF
+        assert node.son_false.type == NodeType.EXPRESSION
```

### Comparing `slither-analyzer-0.9.3/tests/test_storage_layout.py` & `slither-analyzer-0.9.4/tests/unit/core/test_storage_layout.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,28 +1,24 @@
 import json
-import os
-import subprocess
+from pathlib import Path
 from subprocess import PIPE, Popen
-
 from slither import Slither
 
-SLITHER_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
-STORAGE_TEST_ROOT = os.path.join(SLITHER_ROOT, "tests", "storage-layout")
-
-# the storage layout has not yet changed between solidity versions so we will test with one version of the compiler
-
+TEST_DATA_DIR = Path(__file__).resolve().parent / "test_data"
+STORAGE_TEST_ROOT = Path(TEST_DATA_DIR, "storage_layout")
 
-def test_storage_layout():
-    subprocess.run(["solc-select", "use", "0.8.10"], stdout=subprocess.PIPE, check=True)
 
-    test_item = os.path.join(STORAGE_TEST_ROOT, "storage_layout-0.8.10.sol")
+def test_storage_layout(solc_binary_path):
+    # the storage layout has not yet changed between solidity versions so we will test with one version of the compiler
+    solc_path = solc_binary_path("0.8.10")
+    test_item = Path(STORAGE_TEST_ROOT, "storage_layout-0.8.10.sol").as_posix()
 
-    sl = Slither(test_item, solc_force_legacy_json=False, disallow_partial=True)
+    sl = Slither(test_item, disallow_partial=True, solc=solc_path)
 
-    with Popen(["solc", test_item, "--storage-layout"], stdout=PIPE) as process:
+    with Popen([solc_path, test_item, "--storage-layout"], stdout=PIPE) as process:
         for line in process.stdout:  # parse solc output
             if '{"storage":[{' in line.decode("utf-8"):  # find the storage layout
                 layout = iter(json.loads(line)["storage"])
                 while True:
                     try:
                         for contract in sl.contracts:
                             curr_var = next(layout)
@@ -33,7 +29,9 @@
                             )
                             assert slot == int(curr_var["slot"])
                             assert offset == int(curr_var["offset"])
                     except StopIteration:
                         break
                     except KeyError as e:
                         print(f"not found {e} ")
+        process.communicate()
+        assert process.returncode == 0
```


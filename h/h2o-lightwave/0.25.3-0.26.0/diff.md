# Comparing `tmp/h2o_lightwave-0.25.3-py3-none-any.whl.zip` & `tmp/h2o_lightwave-0.26.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,16 +1,17 @@
-Zip file size: 119329 bytes, number of entries: 14
--rw-r--r--  2.0 unx     1132 b- defN 23-May-12 06:28 h2o_lightwave/__init__.py
--rw-r--r--  2.0 unx    13407 b- defN 23-May-12 06:28 h2o_lightwave/core.py
--rw-r--r--  2.0 unx    25866 b- defN 23-May-12 06:28 h2o_lightwave/graphics.py
--rw-r--r--  2.0 unx     7895 b- defN 23-May-12 06:28 h2o_lightwave/routing.py
--rw-r--r--  2.0 unx     3850 b- defN 23-May-12 06:28 h2o_lightwave/server.py
--rw-r--r--  2.0 unx   629082 b- defN 23-May-12 06:28 h2o_lightwave/types.py
--rw-r--r--  2.0 unx   164224 b- defN 23-May-12 06:28 h2o_lightwave/ui.py
--rw-r--r--  2.0 unx     2325 b- defN 23-May-12 06:28 h2o_lightwave/ui_ext.py
--rw-r--r--  2.0 unx       23 b- defN 23-May-12 06:28 h2o_lightwave/version.py
--rw-r--r--  2.0 unx       53 b- defN 23-May-12 06:52 h2o_lightwave-0.25.3.dist-info/LICENSE
--rw-r--r--  2.0 unx     6187 b- defN 23-May-12 06:52 h2o_lightwave-0.25.3.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-May-12 06:52 h2o_lightwave-0.25.3.dist-info/WHEEL
--rw-r--r--  2.0 unx       14 b- defN 23-May-12 06:52 h2o_lightwave-0.25.3.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     1142 b- defN 23-May-12 06:52 h2o_lightwave-0.25.3.dist-info/RECORD
-14 files, 855292 bytes uncompressed, 117443 bytes compressed:  86.3%
+Zip file size: 121156 bytes, number of entries: 15
+-rw-r--r--  2.0 unx     1132 b- defN 23-Jun-26 13:41 h2o_lightwave/__init__.py
+-rw-r--r--  2.0 unx    14374 b- defN 23-Jun-26 13:41 h2o_lightwave/core.py
+-rw-r--r--  2.0 unx    25866 b- defN 23-Jun-26 13:41 h2o_lightwave/graphics.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jun-26 13:41 h2o_lightwave/py.typed
+-rw-r--r--  2.0 unx     7889 b- defN 23-Jun-26 13:41 h2o_lightwave/routing.py
+-rw-r--r--  2.0 unx     3850 b- defN 23-Jun-26 13:41 h2o_lightwave/server.py
+-rw-r--r--  2.0 unx   635842 b- defN 23-Jun-26 13:41 h2o_lightwave/types.py
+-rw-r--r--  2.0 unx   166206 b- defN 23-Jun-26 13:41 h2o_lightwave/ui.py
+-rw-r--r--  2.0 unx     2325 b- defN 23-Jun-26 13:41 h2o_lightwave/ui_ext.py
+-rw-r--r--  2.0 unx       23 b- defN 23-Jun-26 13:41 h2o_lightwave/version.py
+-rw-r--r--  2.0 unx       53 b- defN 23-Jun-26 13:48 h2o_lightwave-0.26.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     6187 b- defN 23-Jun-26 13:48 h2o_lightwave-0.26.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jun-26 13:48 h2o_lightwave-0.26.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       14 b- defN 23-Jun-26 13:48 h2o_lightwave-0.26.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     1218 b- defN 23-Jun-26 13:48 h2o_lightwave-0.26.0.dist-info/RECORD
+15 files, 865071 bytes uncompressed, 119150 bytes compressed:  86.2%
```

## zipnote {}

```diff
@@ -3,14 +3,17 @@
 
 Filename: h2o_lightwave/core.py
 Comment: 
 
 Filename: h2o_lightwave/graphics.py
 Comment: 
 
+Filename: h2o_lightwave/py.typed
+Comment: 
+
 Filename: h2o_lightwave/routing.py
 Comment: 
 
 Filename: h2o_lightwave/server.py
 Comment: 
 
 Filename: h2o_lightwave/types.py
@@ -21,23 +24,23 @@
 
 Filename: h2o_lightwave/ui_ext.py
 Comment: 
 
 Filename: h2o_lightwave/version.py
 Comment: 
 
-Filename: h2o_lightwave-0.25.3.dist-info/LICENSE
+Filename: h2o_lightwave-0.26.0.dist-info/LICENSE
 Comment: 
 
-Filename: h2o_lightwave-0.25.3.dist-info/METADATA
+Filename: h2o_lightwave-0.26.0.dist-info/METADATA
 Comment: 
 
-Filename: h2o_lightwave-0.25.3.dist-info/WHEEL
+Filename: h2o_lightwave-0.26.0.dist-info/WHEEL
 Comment: 
 
-Filename: h2o_lightwave-0.25.3.dist-info/top_level.txt
+Filename: h2o_lightwave-0.26.0.dist-info/top_level.txt
 Comment: 
 
-Filename: h2o_lightwave-0.25.3.dist-info/RECORD
+Filename: h2o_lightwave-0.26.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## h2o_lightwave/core.py

```diff
@@ -214,74 +214,86 @@
         getattr(self, PAGE)._track(_set_op(self, key, _dump(value)))
 
     def __setitem__(self, key, value):
         if isinstance(value, Data):
             raise ValueError('Data instances cannot be used in assignments.')
         getattr(self, PAGE)._track(_set_op(self, key, _dump(value)))
 
+    def __iadd__(self, value):
+        if not getattr(self, KEY).endswith('data'):
+            raise ValueError('+= can only be used on list data buffers.')
+        page = getattr(self, PAGE)
+        page._track(_set_op(self, '__append__', _dump(value)))
+        page._skip_next_track = True
+
 
 class Data:
     """
     Represents a data placeholder. A data placeholder is used to allocate memory on the Wave server to store data.
 
     Args:
         fields: The names of the fields (columns names) in the data, either a list or tuple or string containing space-separated names.
-        size: The number of rows to allocate memory for. Positive for fixed buffers, negative for circular buffers and zero for variable length buffers.
-        data: Initial data. Must be either a key-row ``dict`` for variable-length buffers OR a row ``list`` for fixed-size and circular buffers.
+        size: The number of rows to allocate memory for. Positive for fixed buffers, negative for cyclic buffers and zero for variable length buffers.
+        data: Initial data. Must be either a key-row ``dict`` for variable-length buffers OR a row ``list`` for fixed-size and cyclic buffers.
+        t: Buffer type. One of 'list', 'map', 'cyclic' or 'fixed'. Overrides the buffer type inferred from the size.
     """
 
-    def __init__(self, fields: Union[str, tuple, list], size: int = 0, data: Optional[Union[dict, list]] = None):
+    def __init__(self, fields: Union[str, tuple, list], size: int = 0, data: Optional[Union[dict, list]] = None, t: Optional[str] = None):
         self.fields = fields
         self.data = data
         self.size = size
+        self.type = t
 
     def dump(self):
         f = self.fields
         d = self.data
         n = self.size
+        t = self.type
         if d:
-            if isinstance(d, dict):
+            if t == 'list':
+                return dict(l=dict(f=f, d=d))
+            if t == 'map' or isinstance(d, dict):
                 return dict(m=dict(f=f, d=d))
-            else:
-                if n < 0:
-                    return dict(c=dict(f=f, d=d))
-                else:
-                    return dict(f=dict(f=f, d=d))
+            if t == 'cyclic' or n < 0:
+                return dict(c=dict(f=f, d=d))
+            return dict(f=dict(f=f, d=d))
         else:
-            if n == 0:
+            if t == 'list':
+                return dict(l=dict(f=f, n=n))
+            if t == 'map' or n == 0:
                 return dict(m=dict(f=f))
-            else:
-                if n < 0:
-                    return dict(c=dict(f=f, n=-n))
-                else:
-                    return dict(f=dict(f=f, n=n))
+            if t == 'cyclic' or n < 0:
+                return dict(c=dict(f=f, n=-n))
+            return dict(f=dict(f=f, n=n))
 
 
 def data(
         fields: Union[str, tuple, list],
         size: int = 0,
         rows: Optional[Union[dict, list]] = None,
         columns: Optional[Union[dict, list]] = None,
         pack=False,
+        t: Optional[str] = None,
 ) -> Union[Data, str]:
     """
     Create a `h2o_wave.core.Data` instance for associating data with cards.
 
     ``data(fields, size)`` creates a placeholder for data and allocates memory on the Wave server.
 
     ``data(fields, size, rows)`` creates a placeholder and initializes it with the provided rows.
 
     If ``pack`` is ``True``, the ``size`` parameter is ignored, and the function returns a packed string representing the data.
 
     Args:
         fields: The names of the fields (columns names) in the data, either a list or tuple or string containing space-separated names.
-        size: The number of rows to allocate memory for. Positive for fixed buffers, negative for circular buffers and zero for variable length buffers.
+        size: The number of rows to allocate memory for. Positive for fixed buffers, negative for cyclic buffers and zero for variable length buffers.
         rows: The rows in this data.
         columns: The columns in this data.
         pack: True to return a packed string representing the data instead of a `h2o_wave.core.Data` placeholder.
+        t: Buffer type. One of 'list', 'map', 'cyclic' or 'fixed'. Overrides the buffer type inferred from the size.
 
     Returns:
         Either a `h2o_wave.core.Data` placeholder or a packed string representing the data.
     """
     if _is_str(fields):
         fields = fields.strip()
         if fields == '':
@@ -319,27 +331,29 @@
         rows = []
         for i in range(n):
             rows.append([c[i] for c in columns])
 
     if not _is_int(size):
         raise ValueError('size must be int')
 
-    return Data(fields, size, rows)
+    return Data(fields, size, rows, t)
 
 
 class PageBase:
     """
     Represents a remote page.
 
     Args:
         url: The URL of the remote page.
     """
 
     def __init__(self):
         self._changes = []
+        # HACK: Overloading += operator makes unnecessary __setattr__ call. Skip it to prevent redundant ops.
+        self._skip_next_track = False
 
     def add(self, key: str, card: Any) -> Ref:
         """
         Add a card to this page.
 
         Args:
             key: The card's key. Must uniquely identify the card on the page. Overwrites any other card with the same key.
@@ -374,14 +388,17 @@
             self._track(dict(k=key, d=props, b=bufs))
         else:
             self._track(dict(k=key, d=props))
 
         return Ref(self, key)
 
     def _track(self, op: dict):
+        if self._skip_next_track:
+            self._skip_next_track = False
+            return
         self._changes.append(op)
 
     def _diff(self):
         if len(self._changes) == 0:
             return None
         d = marshal(dict(d=self._changes))
         self._changes.clear()
```

## h2o_lightwave/routing.py

```diff
@@ -58,15 +58,15 @@
     A function annotated with `@on('foo', lambda x: 42 <= x <= 420)` is invoked whenever `q.args.foo` between 42 and 420.
     A function annotated with `@on('foo.bar')` is invoked whenever `q.events.foo.bar` is found and the value is truthy.
     A function annotated with `@on('foo.bar', lambda x: x is False)` is invoked whenever `q.events.foo.bar` is False.
     A function annotated with `@on('foo.bar', lambda x: isinstance(x, bool)` is invoked whenever `q.events.foo.bar` is True or False.
     A function annotated with `@on('foo.bar', lambda x: 42 <= x <= 420)` is invoked whenever `q.events.foo.bar` between 42 and 420.
     A function annotated with `@on('#foo')` is invoked whenever `q.args['#']` equals 'foo'.
     A function annotated with `@on('#foo/bar')` is invoked whenever `q.args['#']` equals 'foo/bar'.
-    A function annotated with `@on('#foo/&lcub;fruit&rcub;')` is invoked whenever `q.args['#']` matches 'foo/apple', 'foo/orange', etc. The parameter 'fruit' is passed to the function (in this case, 'apple', 'orange', etc.)
+    A function annotated with `@on('#foo/{"{fruit}"}')` is invoked whenever `q.args['#']` matches 'foo/apple', 'foo/orange', etc. The parameter 'fruit' is passed to the function (in this case, 'apple', 'orange', etc.)
 
     Parameters in patterns (indicated within curly braces) can be converted to `str`, `int`, `float` or `uuid.UUID` instances by suffixing the parameters with `str`, `int`, `float` or `uuid`, respectively.
 
     Examples:
     - `user_id:int`: `user_id` is converted to an integer.
     - `amount:float`: `amount` is converted to a float.
     - `id:uuid`: `id` is converted to a `uuid.UUID`.
```

## h2o_lightwave/types.py

```diff
@@ -2599,27 +2599,29 @@
             disabled: Optional[bool] = None,
             link: Optional[bool] = None,
             icon: Optional[str] = None,
             width: Optional[str] = None,
             visible: Optional[bool] = None,
             tooltip: Optional[str] = None,
             path: Optional[str] = None,
+            commands: Optional[List[Command]] = None,
     ):
         _guard_scalar('Button.name', name, (str,), True, False, False)
         _guard_scalar('Button.label', label, (str,), False, True, False)
         _guard_scalar('Button.caption', caption, (str,), False, True, False)
         _guard_scalar('Button.value', value, (str,), False, True, False)
         _guard_scalar('Button.primary', primary, (bool,), False, True, False)
         _guard_scalar('Button.disabled', disabled, (bool,), False, True, False)
         _guard_scalar('Button.link', link, (bool,), False, True, False)
         _guard_scalar('Button.icon', icon, (str,), False, True, False)
         _guard_scalar('Button.width', width, (str,), False, True, False)
         _guard_scalar('Button.visible', visible, (bool,), False, True, False)
         _guard_scalar('Button.tooltip', tooltip, (str,), False, True, False)
         _guard_scalar('Button.path', path, (str,), False, True, False)
+        _guard_vector('Button.commands', commands, (Command,), False, True, False)
         self.name = name
         """An identifying name for this component. If the name is prefixed with a '#', the button sets the location hash to the name when clicked."""
         self.label = label
         """The text displayed on the button."""
         self.caption = caption
         """The caption displayed below the label."""
         self.value = value
@@ -2636,14 +2638,16 @@
         """The width of the button, e.g. '100px'."""
         self.visible = visible
         """True if the component should be visible. Defaults to True."""
         self.tooltip = tooltip
         """An optional tooltip message displayed when a user clicks the help icon to the right of the component."""
         self.path = path
         """The path or URL to link to. If specified, the `name` is ignored. The URL is opened in a new browser window or tab."""
+        self.commands = commands
+        """When specified, a split button is rendered with extra actions tied to it within a context menu. Mutually exclusive with `link` attribute."""
 
     def dump(self) -> Dict:
         """Returns the contents of this object as a dict."""
         _guard_scalar('Button.name', self.name, (str,), True, False, False)
         _guard_scalar('Button.label', self.label, (str,), False, True, False)
         _guard_scalar('Button.caption', self.caption, (str,), False, True, False)
         _guard_scalar('Button.value', self.value, (str,), False, True, False)
@@ -2651,27 +2655,29 @@
         _guard_scalar('Button.disabled', self.disabled, (bool,), False, True, False)
         _guard_scalar('Button.link', self.link, (bool,), False, True, False)
         _guard_scalar('Button.icon', self.icon, (str,), False, True, False)
         _guard_scalar('Button.width', self.width, (str,), False, True, False)
         _guard_scalar('Button.visible', self.visible, (bool,), False, True, False)
         _guard_scalar('Button.tooltip', self.tooltip, (str,), False, True, False)
         _guard_scalar('Button.path', self.path, (str,), False, True, False)
+        _guard_vector('Button.commands', self.commands, (Command,), False, True, False)
         return _dump(
             name=self.name,
             label=self.label,
             caption=self.caption,
             value=self.value,
             primary=self.primary,
             disabled=self.disabled,
             link=self.link,
             icon=self.icon,
             width=self.width,
             visible=self.visible,
             tooltip=self.tooltip,
             path=self.path,
+            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
         )
 
     @staticmethod
     def load(__d: Dict) -> 'Button':
         """Creates an instance of this class using the contents of a dict."""
         __d_name: Any = __d.get('name')
         _guard_scalar('Button.name', __d_name, (str,), True, False, False)
@@ -2693,39 +2699,43 @@
         _guard_scalar('Button.width', __d_width, (str,), False, True, False)
         __d_visible: Any = __d.get('visible')
         _guard_scalar('Button.visible', __d_visible, (bool,), False, True, False)
         __d_tooltip: Any = __d.get('tooltip')
         _guard_scalar('Button.tooltip', __d_tooltip, (str,), False, True, False)
         __d_path: Any = __d.get('path')
         _guard_scalar('Button.path', __d_path, (str,), False, True, False)
+        __d_commands: Any = __d.get('commands')
+        _guard_vector('Button.commands', __d_commands, (dict,), False, True, False)
         name: str = __d_name
         label: Optional[str] = __d_label
         caption: Optional[str] = __d_caption
         value: Optional[str] = __d_value
         primary: Optional[bool] = __d_primary
         disabled: Optional[bool] = __d_disabled
         link: Optional[bool] = __d_link
         icon: Optional[str] = __d_icon
         width: Optional[str] = __d_width
         visible: Optional[bool] = __d_visible
         tooltip: Optional[str] = __d_tooltip
         path: Optional[str] = __d_path
+        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
         return Button(
             name,
             label,
             caption,
             value,
             primary,
             disabled,
             link,
             icon,
             width,
             visible,
             tooltip,
             path,
+            commands,
         )
 
 
 _ButtonsJustify = ['start', 'end', 'center', 'between', 'around']
 
 
 class ButtonsJustify:
@@ -3436,15 +3446,15 @@
         self.data_type = data_type
         """Defines the data type of this column. Time column takes either ISO 8601 date string or unix epoch miliseconds. Defaults to `string`. One of 'string', 'number', 'time'. See enum h2o_wave.ui.TableColumnDataType."""
         self.cell_type = cell_type
         """Defines how to render each cell in this column. Renders as plain text by default."""
         self.cell_overflow = cell_overflow
         """Defines what to do with a cell's contents in case it does not fit inside the cell. One of 'tooltip', 'wrap'. See enum h2o_wave.ui.TableColumnCellOverflow."""
         self.filters = filters
-        """List of values to allow filtering by, needed when pagination is set. Only applicable to filterable columns."""
+        """Explicit list of values to allow filtering by, needed when pagination is set or custom order is needed. Only applicable to filterable columns."""
         self.align = align
         """Defines how to align values in a column. One of 'left', 'center', 'right'. See enum h2o_wave.ui.TableColumnAlign."""
 
     def dump(self) -> Dict:
         """Returns the contents of this object as a dict."""
         _guard_scalar('TableColumn.name', self.name, (str,), True, False, False)
         _guard_scalar('TableColumn.label', self.label, (str,), False, False, False)
@@ -3743,15 +3753,15 @@
         self.groupable = groupable
         """True to allow group by feature."""
         self.downloadable = downloadable
         """Indicates whether the table rows can be downloaded as a CSV file. Defaults to False."""
         self.resettable = resettable
         """Indicates whether a Reset button should be displayed to reset search / filter / group-by values to their defaults. Defaults to False."""
         self.height = height
-        """The height of the table, e.g. '400px', '50%', etc."""
+        """The height of the table in px (e.g. '200px') or '1' to fill the remaining card space."""
         self.width = width
         """The width of the table, e.g. '100px'. Defaults to '100%'."""
         self.values = values
         """The names of the selected rows. If this parameter is set, multiple selections will be allowed (`multiple` is assumed to be `True`)."""
         self.checkbox_visibility = checkbox_visibility
         """Controls visibility of table rows when `multiple` is set to `True`. Defaults to 'on-hover'. One of 'always', 'on-hover', 'hidden'. See enum h2o_wave.ui.TableCheckboxVisibility."""
         self.visible = visible
@@ -3759,15 +3769,15 @@
         self.tooltip = tooltip
         """An optional tooltip message displayed when a user clicks the help icon to the right of the component."""
         self.groups = groups
         """Creates collapsible / expandable groups of data rows. Mutually exclusive with `rows` attr."""
         self.pagination = pagination
         """Display a pagination control at the bottom of the table. Set this value using `ui.table_pagination()`."""
         self.events = events
-        """The events to capture on this table. One of 'search' | 'sort' | 'filter' | 'download' | 'page_change' | 'reset' | 'select'."""
+        """The events to capture on this table when pagination is set. One of 'search' | 'sort' | 'filter' | 'download' | 'page_change' | 'reset' | 'select'."""
         self.single = single
         """True to allow only one row to be selected at time. Mutually exclusive with `multiple` attr."""
         self.value = value
         """The name of the selected row. If this parameter is set, single selection will be allowed (`single` is assumed to be `True`)."""
 
     def dump(self) -> Dict:
         """Returns the contents of this object as a dict."""
@@ -6694,23 +6704,25 @@
             image: str,
             title: str,
             tags: List[ImageAnnotatorTag],
             items: Optional[List[ImageAnnotatorItem]] = None,
             trigger: Optional[bool] = None,
             image_height: Optional[str] = None,
             allowed_shapes: Optional[List[str]] = None,
+            events: Optional[List[str]] = None,
     ):
         _guard_scalar('ImageAnnotator.name', name, (str,), True, False, False)
         _guard_scalar('ImageAnnotator.image', image, (str,), False, False, False)
         _guard_scalar('ImageAnnotator.title', title, (str,), False, False, False)
         _guard_vector('ImageAnnotator.tags', tags, (ImageAnnotatorTag,), False, False, False)
         _guard_vector('ImageAnnotator.items', items, (ImageAnnotatorItem,), False, True, False)
         _guard_scalar('ImageAnnotator.trigger', trigger, (bool,), False, True, False)
         _guard_scalar('ImageAnnotator.image_height', image_height, (str,), False, True, False)
         _guard_vector('ImageAnnotator.allowed_shapes', allowed_shapes, (str,), False, True, False)
+        _guard_vector('ImageAnnotator.events', events, (str,), False, True, False)
         self.name = name
         """An identifying name for this component."""
         self.image = image
         """The path or URL of the image to be presented for annotation."""
         self.title = title
         """The image annotator's title."""
         self.tags = tags
@@ -6719,34 +6731,38 @@
         """Annotations to display on the image, if any."""
         self.trigger = trigger
         """True if the form should be submitted as soon as an annotation is drawn."""
         self.image_height = image_height
         """The card’s image height. The actual image size is used by default."""
         self.allowed_shapes = allowed_shapes
         """List of allowed shapes. Available values are 'rect' and 'polygon'. If not set, all shapes are available by default."""
+        self.events = events
+        """The events to capture on this image annotator. One of `click` or `tool_change`."""
 
     def dump(self) -> Dict:
         """Returns the contents of this object as a dict."""
         _guard_scalar('ImageAnnotator.name', self.name, (str,), True, False, False)
         _guard_scalar('ImageAnnotator.image', self.image, (str,), False, False, False)
         _guard_scalar('ImageAnnotator.title', self.title, (str,), False, False, False)
         _guard_vector('ImageAnnotator.tags', self.tags, (ImageAnnotatorTag,), False, False, False)
         _guard_vector('ImageAnnotator.items', self.items, (ImageAnnotatorItem,), False, True, False)
         _guard_scalar('ImageAnnotator.trigger', self.trigger, (bool,), False, True, False)
         _guard_scalar('ImageAnnotator.image_height', self.image_height, (str,), False, True, False)
         _guard_vector('ImageAnnotator.allowed_shapes', self.allowed_shapes, (str,), False, True, False)
+        _guard_vector('ImageAnnotator.events', self.events, (str,), False, True, False)
         return _dump(
             name=self.name,
             image=self.image,
             title=self.title,
             tags=[__e.dump() for __e in self.tags],
             items=None if self.items is None else [__e.dump() for __e in self.items],
             trigger=self.trigger,
             image_height=self.image_height,
             allowed_shapes=self.allowed_shapes,
+            events=self.events,
         )
 
     @staticmethod
     def load(__d: Dict) -> 'ImageAnnotator':
         """Creates an instance of this class using the contents of a dict."""
         __d_name: Any = __d.get('name')
         _guard_scalar('ImageAnnotator.name', __d_name, (str,), True, False, False)
@@ -6760,31 +6776,35 @@
         _guard_vector('ImageAnnotator.items', __d_items, (dict,), False, True, False)
         __d_trigger: Any = __d.get('trigger')
         _guard_scalar('ImageAnnotator.trigger', __d_trigger, (bool,), False, True, False)
         __d_image_height: Any = __d.get('image_height')
         _guard_scalar('ImageAnnotator.image_height', __d_image_height, (str,), False, True, False)
         __d_allowed_shapes: Any = __d.get('allowed_shapes')
         _guard_vector('ImageAnnotator.allowed_shapes', __d_allowed_shapes, (str,), False, True, False)
+        __d_events: Any = __d.get('events')
+        _guard_vector('ImageAnnotator.events', __d_events, (str,), False, True, False)
         name: str = __d_name
         image: str = __d_image
         title: str = __d_title
         tags: List[ImageAnnotatorTag] = [ImageAnnotatorTag.load(__e) for __e in __d_tags]
         items: Optional[List[ImageAnnotatorItem]] = None if __d_items is None else [ImageAnnotatorItem.load(__e) for __e in __d_items]
         trigger: Optional[bool] = __d_trigger
         image_height: Optional[str] = __d_image_height
         allowed_shapes: Optional[List[str]] = __d_allowed_shapes
+        events: Optional[List[str]] = __d_events
         return ImageAnnotator(
             name,
             image,
             title,
             tags,
             items,
             trigger,
             image_height,
             allowed_shapes,
+            events,
         )
 
 
 class Facepile:
     """A face pile displays a list of personas. Each circle represents a person and contains their image or initials.
     Often this control is used when sharing who has access to a specific view or file.
     """
@@ -6866,15 +6886,15 @@
         self.label = label
         """The text displayed above the textbox."""
         self.name = name
         """An identifying name for this component."""
         self.multiline = multiline
         """True if the component should allow multi-line text entry."""
         self.height = height
-        """Custom height in px, e.g. '200px'. Requires `multiline` to be set."""
+        """Custom height in px (e.g. '200px') or '1' to fill the remaining card space. Requires `multiline` to be set."""
 
     def dump(self) -> Dict:
         """Returns the contents of this object as a dict."""
         _guard_scalar('CopyableText.value', self.value, (str,), False, False, False)
         _guard_scalar('CopyableText.label', self.label, (str,), False, False, False)
         _guard_scalar('CopyableText.name', self.name, (str,), False, True, False)
         _guard_scalar('CopyableText.multiline', self.multiline, (bool,), False, True, False)
@@ -7993,14 +8013,101 @@
             title,
             data,
             capacity,
             commands,
         )
 
 
+class ChatbotCard:
+    """Create a chatbot card to allow getting prompts from users and providing them with LLM generated answers.
+    """
+    def __init__(
+            self,
+            box: str,
+            name: str,
+            data: PackedRecord,
+            placeholder: Optional[str] = None,
+            events: Optional[List[str]] = None,
+            generating: Optional[bool] = None,
+            commands: Optional[List[Command]] = None,
+    ):
+        _guard_scalar('ChatbotCard.box', box, (str,), False, False, False)
+        _guard_scalar('ChatbotCard.name', name, (str,), True, False, False)
+        _guard_scalar('ChatbotCard.placeholder', placeholder, (str,), False, True, False)
+        _guard_vector('ChatbotCard.events', events, (str,), False, True, False)
+        _guard_scalar('ChatbotCard.generating', generating, (bool,), False, True, False)
+        _guard_vector('ChatbotCard.commands', commands, (Command,), False, True, False)
+        self.box = box
+        """A string indicating how to place this component on the page."""
+        self.name = name
+        """An identifying name for this component."""
+        self.data = data
+        """Chat messages data. Requires cyclic buffer."""
+        self.placeholder = placeholder
+        """Chat input box placeholder. Use for prompt examples."""
+        self.events = events
+        """The events to capture on this chatbot. One of 'stop'."""
+        self.generating = generating
+        """True to show a button to stop the text generation. Defaults to False."""
+        self.commands = commands
+        """Contextual menu commands for this component."""
+
+    def dump(self) -> Dict:
+        """Returns the contents of this object as a dict."""
+        _guard_scalar('ChatbotCard.box', self.box, (str,), False, False, False)
+        _guard_scalar('ChatbotCard.name', self.name, (str,), True, False, False)
+        _guard_scalar('ChatbotCard.placeholder', self.placeholder, (str,), False, True, False)
+        _guard_vector('ChatbotCard.events', self.events, (str,), False, True, False)
+        _guard_scalar('ChatbotCard.generating', self.generating, (bool,), False, True, False)
+        _guard_vector('ChatbotCard.commands', self.commands, (Command,), False, True, False)
+        return _dump(
+            view='chatbot',
+            box=self.box,
+            name=self.name,
+            data=self.data,
+            placeholder=self.placeholder,
+            events=self.events,
+            generating=self.generating,
+            commands=None if self.commands is None else [__e.dump() for __e in self.commands],
+        )
+
+    @staticmethod
+    def load(__d: Dict) -> 'ChatbotCard':
+        """Creates an instance of this class using the contents of a dict."""
+        __d_box: Any = __d.get('box')
+        _guard_scalar('ChatbotCard.box', __d_box, (str,), False, False, False)
+        __d_name: Any = __d.get('name')
+        _guard_scalar('ChatbotCard.name', __d_name, (str,), True, False, False)
+        __d_data: Any = __d.get('data')
+        __d_placeholder: Any = __d.get('placeholder')
+        _guard_scalar('ChatbotCard.placeholder', __d_placeholder, (str,), False, True, False)
+        __d_events: Any = __d.get('events')
+        _guard_vector('ChatbotCard.events', __d_events, (str,), False, True, False)
+        __d_generating: Any = __d.get('generating')
+        _guard_scalar('ChatbotCard.generating', __d_generating, (bool,), False, True, False)
+        __d_commands: Any = __d.get('commands')
+        _guard_vector('ChatbotCard.commands', __d_commands, (dict,), False, True, False)
+        box: str = __d_box
+        name: str = __d_name
+        data: PackedRecord = __d_data
+        placeholder: Optional[str] = __d_placeholder
+        events: Optional[List[str]] = __d_events
+        generating: Optional[bool] = __d_generating
+        commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
+        return ChatbotCard(
+            box,
+            name,
+            data,
+            placeholder,
+            events,
+            generating,
+            commands,
+        )
+
+
 _EditorCardMode = ['public', 'private']
 
 
 class EditorCardMode:
     PUBLIC = 'public'
     PRIVATE = 'private'
 
@@ -8563,44 +8670,50 @@
     def __init__(
             self,
             name: str,
             label: str,
             icon: Optional[str] = None,
             disabled: Optional[bool] = None,
             tooltip: Optional[str] = None,
+            path: Optional[str] = None,
     ):
         _guard_scalar('NavItem.name', name, (str,), True, False, False)
         _guard_scalar('NavItem.label', label, (str,), False, False, False)
         _guard_scalar('NavItem.icon', icon, (str,), False, True, False)
         _guard_scalar('NavItem.disabled', disabled, (bool,), False, True, False)
         _guard_scalar('NavItem.tooltip', tooltip, (str,), False, True, False)
+        _guard_scalar('NavItem.path', path, (str,), False, True, False)
         self.name = name
         """The name of this item. Prefix the name with a '#' to trigger hash-change navigation."""
         self.label = label
         """The label to display."""
         self.icon = icon
         """An optional icon to display next to the label."""
         self.disabled = disabled
         """True if this item should be disabled."""
         self.tooltip = tooltip
         """An optional tooltip message displayed when a user hovers over this item."""
+        self.path = path
+        """The path or URL to link to. If specified, the `name` is ignored. The URL is opened in a new browser window or tab. E.g. `/foo.html` or `http://example.com/foo.html`"""
 
     def dump(self) -> Dict:
         """Returns the contents of this object as a dict."""
         _guard_scalar('NavItem.name', self.name, (str,), True, False, False)
         _guard_scalar('NavItem.label', self.label, (str,), False, False, False)
         _guard_scalar('NavItem.icon', self.icon, (str,), False, True, False)
         _guard_scalar('NavItem.disabled', self.disabled, (bool,), False, True, False)
         _guard_scalar('NavItem.tooltip', self.tooltip, (str,), False, True, False)
+        _guard_scalar('NavItem.path', self.path, (str,), False, True, False)
         return _dump(
             name=self.name,
             label=self.label,
             icon=self.icon,
             disabled=self.disabled,
             tooltip=self.tooltip,
+            path=self.path,
         )
 
     @staticmethod
     def load(__d: Dict) -> 'NavItem':
         """Creates an instance of this class using the contents of a dict."""
         __d_name: Any = __d.get('name')
         _guard_scalar('NavItem.name', __d_name, (str,), True, False, False)
@@ -8608,25 +8721,29 @@
         _guard_scalar('NavItem.label', __d_label, (str,), False, False, False)
         __d_icon: Any = __d.get('icon')
         _guard_scalar('NavItem.icon', __d_icon, (str,), False, True, False)
         __d_disabled: Any = __d.get('disabled')
         _guard_scalar('NavItem.disabled', __d_disabled, (bool,), False, True, False)
         __d_tooltip: Any = __d.get('tooltip')
         _guard_scalar('NavItem.tooltip', __d_tooltip, (str,), False, True, False)
+        __d_path: Any = __d.get('path')
+        _guard_scalar('NavItem.path', __d_path, (str,), False, True, False)
         name: str = __d_name
         label: str = __d_label
         icon: Optional[str] = __d_icon
         disabled: Optional[bool] = __d_disabled
         tooltip: Optional[str] = __d_tooltip
+        path: Optional[str] = __d_path
         return NavItem(
             name,
             label,
             icon,
             disabled,
             tooltip,
+            path,
         )
 
 
 class NavGroup:
     """Create a group of navigation items.
     """
     def __init__(
@@ -9364,62 +9481,72 @@
     """Render HTML content.
     """
     def __init__(
             self,
             box: str,
             title: str,
             content: str,
+            compact: Optional[bool] = None,
             commands: Optional[List[Command]] = None,
     ):
         _guard_scalar('MarkupCard.box', box, (str,), False, False, False)
         _guard_scalar('MarkupCard.title', title, (str,), False, False, False)
         _guard_scalar('MarkupCard.content', content, (str,), False, False, False)
+        _guard_scalar('MarkupCard.compact', compact, (bool,), False, True, False)
         _guard_vector('MarkupCard.commands', commands, (Command,), False, True, False)
         self.box = box
         """A string indicating how to place this component on the page."""
         self.title = title
         """The title for this card."""
         self.content = content
         """The HTML content."""
+        self.compact = compact
+        """True if outer spacing should be removed. Defaults to False."""
         self.commands = commands
         """Contextual menu commands for this component."""
 
     def dump(self) -> Dict:
         """Returns the contents of this object as a dict."""
         _guard_scalar('MarkupCard.box', self.box, (str,), False, False, False)
         _guard_scalar('MarkupCard.title', self.title, (str,), False, False, False)
         _guard_scalar('MarkupCard.content', self.content, (str,), False, False, False)
+        _guard_scalar('MarkupCard.compact', self.compact, (bool,), False, True, False)
         _guard_vector('MarkupCard.commands', self.commands, (Command,), False, True, False)
         return _dump(
             view='markup',
             box=self.box,
             title=self.title,
             content=self.content,
+            compact=self.compact,
             commands=None if self.commands is None else [__e.dump() for __e in self.commands],
         )
 
     @staticmethod
     def load(__d: Dict) -> 'MarkupCard':
         """Creates an instance of this class using the contents of a dict."""
         __d_box: Any = __d.get('box')
         _guard_scalar('MarkupCard.box', __d_box, (str,), False, False, False)
         __d_title: Any = __d.get('title')
         _guard_scalar('MarkupCard.title', __d_title, (str,), False, False, False)
         __d_content: Any = __d.get('content')
         _guard_scalar('MarkupCard.content', __d_content, (str,), False, False, False)
+        __d_compact: Any = __d.get('compact')
+        _guard_scalar('MarkupCard.compact', __d_compact, (bool,), False, True, False)
         __d_commands: Any = __d.get('commands')
         _guard_vector('MarkupCard.commands', __d_commands, (dict,), False, True, False)
         box: str = __d_box
         title: str = __d_title
         content: str = __d_content
+        compact: Optional[bool] = __d_compact
         commands: Optional[List[Command]] = None if __d_commands is None else [Command.load(__e) for __e in __d_commands]
         return MarkupCard(
             box,
             title,
             content,
+            compact,
             commands,
         )
 
 
 _NotificationBarType = ['info', 'error', 'warning', 'success', 'danger', 'blocked']
```

## h2o_lightwave/ui.py

```diff
@@ -994,14 +994,15 @@
         disabled: Optional[bool] = None,
         link: Optional[bool] = None,
         icon: Optional[str] = None,
         width: Optional[str] = None,
         visible: Optional[bool] = None,
         tooltip: Optional[str] = None,
         path: Optional[str] = None,
+        commands: Optional[List[Command]] = None,
 ) -> Component:
     """Create a button.
 
     Buttons are best used to enable a user to commit a change or complete steps in a task.
     They are typically found inside forms, dialogs, panels or pages.
     An example of their usage is confirming the deletion of a file in a confirmation dialog.
 
@@ -1025,14 +1026,15 @@
         disabled: True if the button should be disabled.
         link: True if the button should be rendered as link text and not a standard button.
         icon: An optional icon to display next to the button label (not applicable for links).
         width: The width of the button, e.g. '100px'.
         visible: True if the component should be visible. Defaults to True.
         tooltip: An optional tooltip message displayed when a user clicks the help icon to the right of the component.
         path: The path or URL to link to. If specified, the `name` is ignored. The URL is opened in a new browser window or tab.
+        commands: When specified, a split button is rendered with extra actions tied to it within a context menu. Mutually exclusive with `link` attribute.
     Returns:
         A `h2o_wave.types.Button` instance.
     """
     return Component(button=Button(
         name,
         label,
         caption,
@@ -1041,14 +1043,15 @@
         disabled,
         link,
         icon,
         width,
         visible,
         tooltip,
         path,
+        commands,
     ))
 
 
 def buttons(
         items: List[Component],
         justify: Optional[str] = None,
         name: Optional[str] = None,
@@ -1312,15 +1315,15 @@
         sortable: Indicates whether the column is sortable.
         searchable: Indicates whether the contents of this column can be searched through. Enables a search box for the table if true.
         filterable: Indicates whether the contents of this column are displayed as filters in a dropdown.
         link: Indicates whether each cell in this column should be displayed as a clickable link. Applies to exactly one text column in the table.
         data_type: Defines the data type of this column. Time column takes either ISO 8601 date string or unix epoch miliseconds. Defaults to `string`. One of 'string', 'number', 'time'. See enum h2o_wave.ui.TableColumnDataType.
         cell_type: Defines how to render each cell in this column. Renders as plain text by default.
         cell_overflow: Defines what to do with a cell's contents in case it does not fit inside the cell. One of 'tooltip', 'wrap'. See enum h2o_wave.ui.TableColumnCellOverflow.
-        filters: List of values to allow filtering by, needed when pagination is set. Only applicable to filterable columns.
+        filters: Explicit list of values to allow filtering by, needed when pagination is set or custom order is needed. Only applicable to filterable columns.
         align: Defines how to align values in a column. One of 'left', 'center', 'right'. See enum h2o_wave.ui.TableColumnAlign.
     Returns:
         A `h2o_wave.types.TableColumn` instance.
     """
     return TableColumn(
         name,
         label,
@@ -1441,23 +1444,23 @@
         name: An identifying name for this component.
         columns: The columns in this table.
         rows: The rows in this table. Mutually exclusive with `groups` attr.
         multiple: True to allow multiple rows to be selected. Mutually exclusive with `single` attr.
         groupable: True to allow group by feature.
         downloadable: Indicates whether the table rows can be downloaded as a CSV file. Defaults to False.
         resettable: Indicates whether a Reset button should be displayed to reset search / filter / group-by values to their defaults. Defaults to False.
-        height: The height of the table, e.g. '400px', '50%', etc.
+        height: The height of the table in px (e.g. '200px') or '1' to fill the remaining card space.
         width: The width of the table, e.g. '100px'. Defaults to '100%'.
         values: The names of the selected rows. If this parameter is set, multiple selections will be allowed (`multiple` is assumed to be `True`).
         checkbox_visibility: Controls visibility of table rows when `multiple` is set to `True`. Defaults to 'on-hover'. One of 'always', 'on-hover', 'hidden'. See enum h2o_wave.ui.TableCheckboxVisibility.
         visible: True if the component should be visible. Defaults to True.
         tooltip: An optional tooltip message displayed when a user clicks the help icon to the right of the component.
         groups: Creates collapsible / expandable groups of data rows. Mutually exclusive with `rows` attr.
         pagination: Display a pagination control at the bottom of the table. Set this value using `ui.table_pagination()`.
-        events: The events to capture on this table. One of 'search' | 'sort' | 'filter' | 'download' | 'page_change' | 'reset' | 'select'.
+        events: The events to capture on this table when pagination is set. One of 'search' | 'sort' | 'filter' | 'download' | 'page_change' | 'reset' | 'select'.
         single: True to allow only one row to be selected at time. Mutually exclusive with `multiple` attr.
         value: The name of the selected row. If this parameter is set, single selection will be allowed (`single` is assumed to be `True`).
     Returns:
         A `h2o_wave.types.Table` instance.
     """
     return Component(table=Table(
         name,
@@ -2475,40 +2478,43 @@
         image: str,
         title: str,
         tags: List[ImageAnnotatorTag],
         items: Optional[List[ImageAnnotatorItem]] = None,
         trigger: Optional[bool] = None,
         image_height: Optional[str] = None,
         allowed_shapes: Optional[List[str]] = None,
+        events: Optional[List[str]] = None,
 ) -> Component:
     """Create an image annotator component.
 
     This component allows annotating and labeling parts of an image by drawing shapes with a pointing device.
 
     Args:
         name: An identifying name for this component.
         image: The path or URL of the image to be presented for annotation.
         title: The image annotator's title.
         tags: The master list of tags that can be used for annotations.
         items: Annotations to display on the image, if any.
         trigger: True if the form should be submitted as soon as an annotation is drawn.
         image_height: The card’s image height. The actual image size is used by default.
         allowed_shapes: List of allowed shapes. Available values are 'rect' and 'polygon'. If not set, all shapes are available by default.
+        events: The events to capture on this image annotator. One of `click` or `tool_change`.
     Returns:
         A `h2o_wave.types.ImageAnnotator` instance.
     """
     return Component(image_annotator=ImageAnnotator(
         name,
         image,
         title,
         tags,
         items,
         trigger,
         image_height,
         allowed_shapes,
+        events,
     ))
 
 
 def facepile(
         items: List[Component],
         name: Optional[str] = None,
         max: Optional[int] = None,
@@ -2544,15 +2550,15 @@
     Use this component when you want to enable your users to quickly copy paste sections of text.
 
     Args:
         value: Text to be displayed inside the component.
         label: The text displayed above the textbox.
         name: An identifying name for this component.
         multiline: True if the component should allow multi-line text entry.
-        height: Custom height in px, e.g. '200px'. Requires `multiline` to be set.
+        height: Custom height in px (e.g. '200px') or '1' to fill the remaining card space. Requires `multiline` to be set.
     Returns:
         A `h2o_wave.types.CopyableText` instance.
     """
     return Component(copyable_text=CopyableText(
         value,
         label,
         name,
@@ -2787,14 +2793,47 @@
         title,
         data,
         capacity,
         commands,
     )
 
 
+def chatbot_card(
+        box: str,
+        name: str,
+        data: PackedRecord,
+        placeholder: Optional[str] = None,
+        events: Optional[List[str]] = None,
+        generating: Optional[bool] = None,
+        commands: Optional[List[Command]] = None,
+) -> ChatbotCard:
+    """Create a chatbot card to allow getting prompts from users and providing them with LLM generated answers.
+
+    Args:
+        box: A string indicating how to place this component on the page.
+        name: An identifying name for this component.
+        data: Chat messages data. Requires cyclic buffer.
+        placeholder: Chat input box placeholder. Use for prompt examples.
+        events: The events to capture on this chatbot. One of 'stop'.
+        generating: True to show a button to stop the text generation. Defaults to False.
+        commands: Contextual menu commands for this component.
+    Returns:
+        A `h2o_wave.types.ChatbotCard` instance.
+    """
+    return ChatbotCard(
+        box,
+        name,
+        data,
+        placeholder,
+        events,
+        generating,
+        commands,
+    )
+
+
 def editor_card(
         box: str,
         mode: str,
         commands: Optional[List[Command]] = None,
 ) -> EditorCard:
     """WARNING: Experimental and subject to change.
     Do not use in production sites!
@@ -2999,32 +3038,35 @@
 
 def nav_item(
         name: str,
         label: str,
         icon: Optional[str] = None,
         disabled: Optional[bool] = None,
         tooltip: Optional[str] = None,
+        path: Optional[str] = None,
 ) -> NavItem:
     """Create a navigation item.
 
     Args:
         name: The name of this item. Prefix the name with a '#' to trigger hash-change navigation.
         label: The label to display.
         icon: An optional icon to display next to the label.
         disabled: True if this item should be disabled.
         tooltip: An optional tooltip message displayed when a user hovers over this item.
+        path: The path or URL to link to. If specified, the `name` is ignored. The URL is opened in a new browser window or tab. E.g. `/foo.html` or `http://example.com/foo.html`
     Returns:
         A `h2o_wave.types.NavItem` instance.
     """
     return NavItem(
         name,
         label,
         icon,
         disabled,
         tooltip,
+        path,
     )
 
 
 def nav_group(
         label: str,
         items: List[NavItem],
         collapsed: Optional[bool] = None,
@@ -3301,30 +3343,33 @@
     )
 
 
 def markup_card(
         box: str,
         title: str,
         content: str,
+        compact: Optional[bool] = None,
         commands: Optional[List[Command]] = None,
 ) -> MarkupCard:
     """Render HTML content.
 
     Args:
         box: A string indicating how to place this component on the page.
         title: The title for this card.
         content: The HTML content.
+        compact: True if outer spacing should be removed. Defaults to False.
         commands: Contextual menu commands for this component.
     Returns:
         A `h2o_wave.types.MarkupCard` instance.
     """
     return MarkupCard(
         box,
         title,
         content,
+        compact,
         commands,
     )
 
 
 def notification_bar(
         text: str,
         type: Optional[str] = None,
```

## h2o_lightwave/version.py

```diff
@@ -1 +1 @@
-__version__ = '0.25.3'
+__version__ = '0.26.0'
```

## Comparing `h2o_lightwave-0.25.3.dist-info/METADATA` & `h2o_lightwave-0.26.0.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: h2o-lightwave
-Version: 0.25.3
+Version: 0.26.0
 Summary: H2O Wave Python driver for integration with arbitrary python web frameworks.
 Home-page: https://h2o.ai/products/h2o-wave
 Author: Martin Turoci
 Author-email: martin.turoci@h2o.ai
 License: UNKNOWN
 Project-URL: Documentation, https://wave.h2o.ai/
 Project-URL: Source, https://github.com/h2oai/wave
@@ -22,15 +22,15 @@
 Classifier: Topic :: Scientific/Engineering :: Visualization
 Classifier: Topic :: Software Development :: Libraries :: Application Frameworks
 Classifier: Topic :: Software Development :: Widget Sets
 Classifier: Topic :: System :: Distributed Computing
 Requires-Python: >=3.7.1
 Description-Content-Type: text/markdown
 Provides-Extra: web
-Requires-Dist: h2o-lightwave-web (==0.25.3) ; extra == 'web'
+Requires-Dist: h2o-lightwave-web (==0.26.0) ; extra == 'web'
 
 # H2O Lightwave
 
 H2O Lightwave is a lightweight, pure-Python version of [H2O Wave](https://wave.h2o.ai/) that can be embedded in popular async web frameworks like FastAPI, Starlette, etc.
 
 In other words, H2O Lightwave works without the Wave server.
```

## Comparing `h2o_lightwave-0.25.3.dist-info/RECORD` & `h2o_lightwave-0.26.0.dist-info/RECORD`

 * *Files 27% similar despite different names*

```diff
@@ -1,14 +1,15 @@
 h2o_lightwave/__init__.py,sha256=GZK8q1_B993ysEiupE9CbxaPE81r8El--58a50OvUAg,1132
-h2o_lightwave/core.py,sha256=CzBHE8dBQEXgsgc1W4dcMpNaJ_yUBFEQf4NzPPtrAIE,13407
+h2o_lightwave/core.py,sha256=7eWtqhAqoWR6ImIYPX5exzUyvqdsCVa4zLZ-ovDJkuc,14374
 h2o_lightwave/graphics.py,sha256=HLYrX-lwsMKbyLmy2ClG5L46DA2_hSCEPTsv0gPVoyg,25866
-h2o_lightwave/routing.py,sha256=hfxb33dpK5MvIEvxdPyodjTkMLH-anP9FG3Xl1_h4n4,7895
+h2o_lightwave/py.typed,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+h2o_lightwave/routing.py,sha256=5aNgnVjhYU3Yih--rC2THfsNZpVWBHmzY9ju64KtyB4,7889
 h2o_lightwave/server.py,sha256=2Pwq5sZbODSbLyLFA-Q1SmYc7Xo-i2zUCFrS3ywFp34,3850
-h2o_lightwave/types.py,sha256=ZaYdqL60TA1UXnEVBGKUefVPjS2sKiiHXL9Ch9n06mE,629082
-h2o_lightwave/ui.py,sha256=sf7VQAt7G7qqLeDa9MqyVv_PLrhy341b72Sag0TdoCg,164224
+h2o_lightwave/types.py,sha256=D7AN4YwxUoALl0IOGgQnxZr8wFxZw2NaPlNIDeh9sJM,635842
+h2o_lightwave/ui.py,sha256=u41t97teUgPOB3IJ8TxIkd4qp8AW_Y9Dskcaq78iRww,166206
 h2o_lightwave/ui_ext.py,sha256=zx_2Ec2-p_ztm8brfVaVF0fTQWVDrb_YxcGfVb-wA10,2325
-h2o_lightwave/version.py,sha256=_duDn5pwjRE5QtlNYg8tB-1mE-qM0W8f4UeMVqrkU8U,23
-h2o_lightwave-0.25.3.dist-info/LICENSE,sha256=hpuFayniDwysSKD0tHGELH2KJDVyhUrKS29torRIpqY,53
-h2o_lightwave-0.25.3.dist-info/METADATA,sha256=cSKbcLL3BaberPrO1zZSwe_Oo2Cq_TmYBf27TyFBG0Y,6187
-h2o_lightwave-0.25.3.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-h2o_lightwave-0.25.3.dist-info/top_level.txt,sha256=1ZH7jcWsnca5BnX2d9scu4t0ohD50aeA2ceYXY8M2c8,14
-h2o_lightwave-0.25.3.dist-info/RECORD,,
+h2o_lightwave/version.py,sha256=Yk2dE3467PDiOPAi-UY_vFwY2lR6HNd27tFHSJqUVxg,23
+h2o_lightwave-0.26.0.dist-info/LICENSE,sha256=hpuFayniDwysSKD0tHGELH2KJDVyhUrKS29torRIpqY,53
+h2o_lightwave-0.26.0.dist-info/METADATA,sha256=VxCwbSOwWB4ifKu-mijSLtlIc-cQWQdvUojfHOUsCa4,6187
+h2o_lightwave-0.26.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+h2o_lightwave-0.26.0.dist-info/top_level.txt,sha256=1ZH7jcWsnca5BnX2d9scu4t0ohD50aeA2ceYXY8M2c8,14
+h2o_lightwave-0.26.0.dist-info/RECORD,,
```


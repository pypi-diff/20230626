# Comparing `tmp/pymunk-6.5.0.zip` & `tmp/pymunk-6.5.1-cp310-cp310-musllinux_1_1_i686.whl.zip`

## zipinfo {}

```diff
@@ -1,518 +1,99 @@
-Zip file size: 8098941 bytes, number of entries: 516
-drwxrwxrwx  2.0 fat        0 b- stor 23-Jun-24 22:13 pymunk-6.5.0/
-drwxrwxrwx  2.0 fat        0 b- stor 23-Jun-24 22:13 pymunk-6.5.0/additional_examples/
-drwxrwxrwx  2.0 fat        0 b- stor 23-Jun-24 22:13 pymunk-6.5.0/Chipmunk2D/
-drwxrwxrwx  2.0 fat        0 b- stor 23-Jun-24 22:13 pymunk-6.5.0/docs/
-drwxrwxrwx  2.0 fat        0 b- stor 23-Jun-24 22:13 pymunk-6.5.0/pymunk/
-drwxrwxrwx  2.0 fat        0 b- stor 23-Jun-24 22:13 pymunk-6.5.0/pymunk.egg-info/
-drwxrwxrwx  2.0 fat        0 b- stor 23-Jun-24 22:13 pymunk-6.5.0/tools/
--rw-rw-rw-  2.0 fat    28937 b- defN 23-Jun-23 09:06 pymunk-6.5.0/CHANGELOG.rst
--rw-rw-rw-  2.0 fat     1084 b- defN 23-Jan-02 22:24 pymunk-6.5.0/LICENSE.txt
--rw-rw-rw-  2.0 fat      852 b- defN 23-Jan-02 13:02 pymunk-6.5.0/MANIFEST.in
--rw-rw-rw-  2.0 fat     6255 b- defN 23-Jun-24 22:13 pymunk-6.5.0/PKG-INFO
--rw-rw-rw-  2.0 fat      109 b- defN 21-Oct-31 20:56 pymunk-6.5.0/pyproject.toml
--rw-rw-rw-  2.0 fat     5498 b- defN 23-Jun-19 22:17 pymunk-6.5.0/README.rst
--rw-rw-rw-  2.0 fat      824 b- defN 23-Jun-24 22:13 pymunk-6.5.0/setup.cfg
--rw-rw-rw-  2.0 fat     1437 b- defN 23-Jun-19 22:17 pymunk-6.5.0/setup.py
--rw-rw-rw-  2.0 fat      380 b- defN 20-Oct-06 21:48 pymunk-6.5.0/THANKS.txt
-drwxrwxrwx  2.0 fat        0 b- stor 23-Jun-24 22:13 pymunk-6.5.0/additional_examples/kivy_pymunk_demo/
--rw-rw-rw-  2.0 fat   229783 b- defN 23-Jan-29 20:46 pymunk-6.5.0/additional_examples/matplotlib_util_demo.ipynb
--rw-rw-rw-  2.0 fat    68619 b- defN 23-Jan-29 20:46 pymunk-6.5.0/additional_examples/newtons_cradle.ipynb
--rw-rw-rw-  2.0 fat     1503 b- defN 22-Nov-10 21:21 pymunk-6.5.0/additional_examples/no_dependencies.py
--rw-rw-rw-  2.0 fat      226 b- defN 22-Nov-10 21:22 pymunk-6.5.0/additional_examples/py2exe_setup__basic_test.py
--rw-rw-rw-  2.0 fat     1078 b- defN 20-Nov-30 21:49 pymunk-6.5.0/additional_examples/pyinstaller_basic_test.spec
--rw-rw-rw-  2.0 fat    13531 b- defN 22-Sep-05 14:52 pymunk-6.5.0/additional_examples/kivy_pymunk_demo/main.py
--rw-rw-rw-  2.0 fat    32267 b- defN 20-Oct-06 21:48 pymunk-6.5.0/additional_examples/kivy_pymunk_demo/pymunk_demo_icon_512.png
--rw-rw-rw-  2.0 fat    14994 b- defN 20-Oct-06 21:48 pymunk-6.5.0/additional_examples/kivy_pymunk_demo/pymunk_logo.png
-drwxrwxrwx  2.0 fat        0 b- stor 23-Jun-24 22:13 pymunk-6.5.0/Chipmunk2D/include/
-drwxrwxrwx  2.0 fat        0 b- stor 23-Jun-24 22:13 pymunk-6.5.0/Chipmunk2D/src/
--rw-rw-rw-  2.0 fat     2311 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/CMakeLists.txt
--rw-rw-rw-  2.0 fat     1107 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/LICENSE.txt
--rw-rw-rw-  2.0 fat     1960 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/TODO.txt
--rw-rw-rw-  2.0 fat    24434 b- defN 23-Jun-18 22:03 pymunk-6.5.0/Chipmunk2D/VERSION.txt
-drwxrwxrwx  2.0 fat        0 b- stor 23-Jun-24 22:13 pymunk-6.5.0/Chipmunk2D/include/chipmunk/
--rw-rw-rw-  2.0 fat     9638 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/include/chipmunk/chipmunk.h
--rw-rw-rw-  2.0 fat     3211 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/include/chipmunk/chipmunk_ffi.h
--rw-rw-rw-  2.0 fat    10948 b- defN 22-Nov-05 20:42 pymunk-6.5.0/Chipmunk2D/include/chipmunk/chipmunk_private.h
--rw-rw-rw-  2.0 fat     9535 b- defN 23-Jun-18 22:03 pymunk-6.5.0/Chipmunk2D/include/chipmunk/chipmunk_structs.h
--rw-rw-rw-  2.0 fat     6869 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/include/chipmunk/chipmunk_types.h
--rw-rw-rw-  2.0 fat     3000 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/include/chipmunk/chipmunk_unsafe.h
--rw-rw-rw-  2.0 fat     8998 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpArbiter.h
--rw-rw-rw-  2.0 fat     5593 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpBB.h
--rw-rw-rw-  2.0 fat     9720 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpBody.h
--rw-rw-rw-  2.0 fat     4903 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpConstraint.h
--rw-rw-rw-  2.0 fat     3170 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpDampedRotarySpring.h
--rw-rw-rw-  2.0 fat     3667 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpDampedSpring.h
--rw-rw-rw-  2.0 fat     2179 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpGearJoint.h
--rw-rw-rw-  2.0 fat     2670 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpGrooveJoint.h
--rw-rw-rw-  2.0 fat     1454 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpHastySpace.h
--rw-rw-rw-  2.0 fat     1697 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpMarch.h
--rw-rw-rw-  2.0 fat     2572 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpPinJoint.h
--rw-rw-rw-  2.0 fat     2462 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpPivotJoint.h
--rw-rw-rw-  2.0 fat     2784 b- defN 21-Aug-15 12:42 pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpPolyline.h
--rw-rw-rw-  2.0 fat     3264 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpPolyShape.h
--rw-rw-rw-  2.0 fat     2508 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpRatchetJoint.h
--rw-rw-rw-  2.0 fat      543 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpRobust.h
--rw-rw-rw-  2.0 fat     2448 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpRotaryLimitJoint.h
--rw-rw-rw-  2.0 fat     9481 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpShape.h
--rw-rw-rw-  2.0 fat     2019 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpSimpleMotor.h
--rw-rw-rw-  2.0 fat     2982 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpSlideJoint.h
--rw-rw-rw-  2.0 fat    17530 b- defN 21-Aug-17 13:24 pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpSpace.h
--rw-rw-rw-  2.0 fat    10103 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpSpatialIndex.h
--rw-rw-rw-  2.0 fat     5822 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpTransform.h
--rw-rw-rw-  2.0 fat     6815 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpVect.h
--rw-rw-rw-  2.0 fat    10248 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/src/chipmunk.c
--rw-rw-rw-  2.0 fat     2433 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/src/CMakeLists.txt
--rw-rw-rw-  2.0 fat    14430 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/src/cpArbiter.c
--rw-rw-rw-  2.0 fat     2461 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/src/cpArray.c
--rw-rw-rw-  2.0 fat    22358 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/src/cpBBTree.c
--rw-rw-rw-  2.0 fat    15339 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/src/cpBody.c
--rw-rw-rw-  2.0 fat    26295 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/src/cpCollision.c
--rw-rw-rw-  2.0 fat     4434 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/src/cpConstraint.c
--rw-rw-rw-  2.0 fat     6281 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/src/cpDampedRotarySpring.c
--rw-rw-rw-  2.0 fat     7346 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/src/cpDampedSpring.c
--rw-rw-rw-  2.0 fat     4444 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/src/cpGearJoint.c
--rw-rw-rw-  2.0 fat     6239 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/src/cpGrooveJoint.c
--rw-rw-rw-  2.0 fat     6053 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/src/cpHashSet.c
--rw-rw-rw-  2.0 fat    19691 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/src/cpHastySpace.c
--rw-rw-rw-  2.0 fat     6808 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/src/cpMarch.c
--rw-rw-rw-  2.0 fat     5478 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/src/cpPinJoint.c
--rw-rw-rw-  2.0 fat     4841 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/src/cpPivotJoint.c
--rw-rw-rw-  2.0 fat    18095 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/src/cpPolyline.c
--rw-rw-rw-  2.0 fat     9900 b- defN 23-Jun-18 22:03 pymunk-6.5.0/Chipmunk2D/src/cpPolyShape.c
--rw-rw-rw-  2.0 fat     5452 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/src/cpRatchetJoint.c
--rw-rw-rw-  2.0 fat      327 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/src/cpRobust.c
--rw-rw-rw-  2.0 fat     4836 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/src/cpRotaryLimitJoint.c
--rw-rw-rw-  2.0 fat    15813 b- defN 22-Nov-05 20:42 pymunk-6.5.0/Chipmunk2D/src/cpShape.c
--rw-rw-rw-  2.0 fat     3569 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/src/cpSimpleMotor.c
--rw-rw-rw-  2.0 fat     6081 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/src/cpSlideJoint.c
--rw-rw-rw-  2.0 fat    20811 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/src/cpSpace.c
--rw-rw-rw-  2.0 fat    12679 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/src/cpSpaceComponent.c
--rw-rw-rw-  2.0 fat     8218 b- defN 21-Aug-16 22:07 pymunk-6.5.0/Chipmunk2D/src/cpSpaceDebug.c
--rw-rw-rw-  2.0 fat    16395 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/src/cpSpaceHash.c
--rw-rw-rw-  2.0 fat     7608 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/src/cpSpaceQuery.c
--rw-rw-rw-  2.0 fat    14567 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/src/cpSpaceStep.c
--rw-rw-rw-  2.0 fat     2531 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/src/cpSpatialIndex.c
--rw-rw-rw-  2.0 fat     6813 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/src/cpSweep1D.c
--rw-rw-rw-  2.0 fat     1865 b- defN 20-Oct-08 20:19 pymunk-6.5.0/Chipmunk2D/src/prime.h
-drwxrwxrwx  2.0 fat        0 b- stor 23-Jun-24 22:13 pymunk-6.5.0/docs/html/
-drwxrwxrwx  2.0 fat        0 b- stor 23-Jun-24 22:13 pymunk-6.5.0/docs/src/
-drwxrwxrwx  2.0 fat        0 b- stor 23-Jun-24 22:13 pymunk-6.5.0/docs/html/.doctrees/
-drwxrwxrwx  2.0 fat        0 b- stor 23-Jun-24 22:13 pymunk-6.5.0/docs/html/tutorials/
-drwxrwxrwx  2.0 fat        0 b- stor 23-Jun-24 22:13 pymunk-6.5.0/docs/html/_images/
-drwxrwxrwx  2.0 fat        0 b- stor 23-Jun-24 22:13 pymunk-6.5.0/docs/html/_modules/
-drwxrwxrwx  2.0 fat        0 b- stor 23-Jun-24 22:13 pymunk-6.5.0/docs/html/_sources/
-drwxrwxrwx  2.0 fat        0 b- stor 23-Jun-24 22:13 pymunk-6.5.0/docs/html/_static/
--rw-rw-rw-  2.0 fat      234 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/.buildinfo
--rw-rw-rw-  2.0 fat    21672 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/advanced.html
--rw-rw-rw-  2.0 fat    16193 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/benchmarks.html
--rw-rw-rw-  2.0 fat    55666 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/changelog.html
--rw-rw-rw-  2.0 fat    36150 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/examples.html
--rw-rw-rw-  2.0 fat    89776 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/genindex.html
--rw-rw-rw-  2.0 fat    40489 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/index.html
--rw-rw-rw-  2.0 fat    16902 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/installation.html
--rw-rw-rw-  2.0 fat     6298 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/license.html
--rw-rw-rw-  2.0 fat     4884 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/objects.inv
--rw-rw-rw-  2.0 fat    26721 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/overview.html
--rw-rw-rw-  2.0 fat     6888 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/py-modindex.html
--rw-rw-rw-  2.0 fat    46746 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/pymunk.autogeometry.html
--rw-rw-rw-  2.0 fat   222423 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/pymunk.constraints.html
--rw-rw-rw-  2.0 fat    13005 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/pymunk.examples.html
--rw-rw-rw-  2.0 fat   463906 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/pymunk.html
--rw-rw-rw-  2.0 fat    53139 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/pymunk.matplotlib_util.html
--rw-rw-rw-  2.0 fat    61618 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/pymunk.pygame_util.html
--rw-rw-rw-  2.0 fat    53977 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/pymunk.pyglet_util.html
--rw-rw-rw-  2.0 fat    16111 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/pymunk.tests.html
--rw-rw-rw-  2.0 fat    62498 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/pymunk.vec2d.html
--rw-rw-rw-  2.0 fat     4832 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/search.html
--rw-rw-rw-  2.0 fat   149006 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/searchindex.js
--rw-rw-rw-  2.0 fat    36469 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/showcase.html
--rw-rw-rw-  2.0 fat    10057 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/tutorials.html
-drwxrwxrwx  2.0 fat        0 b- stor 23-Jun-24 22:13 pymunk-6.5.0/docs/html/.doctrees/tutorials/
--rw-rw-rw-  2.0 fat    45505 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/.doctrees/advanced.doctree
--rw-rw-rw-  2.0 fat    29556 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/.doctrees/benchmarks.doctree
--rw-rw-rw-  2.0 fat   136779 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/.doctrees/changelog.doctree
--rw-rw-rw-  2.0 fat  4183992 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/.doctrees/environment.pickle
--rw-rw-rw-  2.0 fat    97037 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/.doctrees/examples.doctree
--rw-rw-rw-  2.0 fat    29920 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/.doctrees/index.doctree
--rw-rw-rw-  2.0 fat    22083 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/.doctrees/installation.doctree
--rw-rw-rw-  2.0 fat     4921 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/.doctrees/license.doctree
--rw-rw-rw-  2.0 fat    50748 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/.doctrees/overview.doctree
--rw-rw-rw-  2.0 fat    95720 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/.doctrees/pymunk.autogeometry.doctree
--rw-rw-rw-  2.0 fat   518659 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/.doctrees/pymunk.constraints.doctree
--rw-rw-rw-  2.0 fat  1144338 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/.doctrees/pymunk.doctree
--rw-rw-rw-  2.0 fat     5183 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/.doctrees/pymunk.examples.doctree
--rw-rw-rw-  2.0 fat    73573 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/.doctrees/pymunk.matplotlib_util.doctree
--rw-rw-rw-  2.0 fat    89562 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/.doctrees/pymunk.pygame_util.doctree
--rw-rw-rw-  2.0 fat    74725 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/.doctrees/pymunk.pyglet_util.doctree
--rw-rw-rw-  2.0 fat    12128 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/.doctrees/pymunk.tests.doctree
--rw-rw-rw-  2.0 fat   110460 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/.doctrees/pymunk.vec2d.doctree
--rw-rw-rw-  2.0 fat   108690 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/.doctrees/showcase.doctree
--rw-rw-rw-  2.0 fat    11625 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/.doctrees/tutorials.doctree
--rw-rw-rw-  2.0 fat    58125 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/.doctrees/tutorials/SlideAndPinJoint.doctree
--rw-rw-rw-  2.0 fat    72781 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/tutorials/SlideAndPinJoint.html
--rw-rw-rw-  2.0 fat     1822 b- defN 22-Nov-05 21:06 pymunk-6.5.0/docs/html/_images/aafig-57def8bc9dba711704bbcd5d7ccb99d16f57c3d3.svg
--rw-rw-rw-  2.0 fat       28 b- defN 22-Nov-05 21:06 pymunk-6.5.0/docs/html/_images/aafig-57def8bc9dba711704bbcd5d7ccb99d16f57c3d3.svg.aafig
--rw-rw-rw-  2.0 fat     3051 b- defN 22-Nov-05 21:06 pymunk-6.5.0/docs/html/_images/aafig-6d1244b47ef3cff62251ba8c2119d70a3af0e610.svg
--rw-rw-rw-  2.0 fat       28 b- defN 22-Nov-05 21:06 pymunk-6.5.0/docs/html/_images/aafig-6d1244b47ef3cff62251ba8c2119d70a3af0e610.svg.aafig
--rw-rw-rw-  2.0 fat     6358 b- defN 22-Nov-05 21:06 pymunk-6.5.0/docs/html/_images/aafig-e5bd167514754e94de9bcf68b93e2d7e338b37ee.svg
--rw-rw-rw-  2.0 fat       28 b- defN 22-Nov-05 21:06 pymunk-6.5.0/docs/html/_images/aafig-e5bd167514754e94de9bcf68b93e2d7e338b37ee.svg.aafig
--rw-rw-rw-  2.0 fat    39147 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/aimoveneat.png
--rw-rw-rw-  2.0 fat    26582 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/ambient-chimes.png
--rw-rw-rw-  2.0 fat    75102 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/angry-birds-python.png
--rw-rw-rw-  2.0 fat    29887 b- defN 21-Jun-25 21:52 pymunk-6.5.0/docs/html/_images/ar-physics.jpg
--rw-rw-rw-  2.0 fat    23780 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/arcade-library.png
--rw-rw-rw-  2.0 fat     5855 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/arrows.png
--rw-rw-rw-  2.0 fat     6092 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/balls_and_lines.png
--rw-rw-rw-  2.0 fat     5209 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/beneath-the-ice.png
--rw-rw-rw-  2.0 fat   108346 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/billiARds.png
--rw-rw-rw-  2.0 fat   197630 b- defN 22-Jan-25 21:06 pymunk-6.5.0/docs/html/_images/bouncingballs-beatuifulpatterns.png
--rw-rw-rw-  2.0 fat      866 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/bouncing_balls.png
--rw-rw-rw-  2.0 fat     2571 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/box2d_pyramid.png
--rw-rw-rw-  2.0 fat     2781 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/box2d_vertical_stack.png
--rw-rw-rw-  2.0 fat     4729 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/breakout.png
--rw-rw-rw-  2.0 fat     5388 b- defN 21-Aug-15 12:50 pymunk-6.5.0/docs/html/_images/camera.png
--rw-rw-rw-  2.0 fat    21046 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/carconf.png
--rw-rw-rw-  2.0 fat   156035 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/carrom-rl.png
--rw-rw-rw-  2.0 fat    11676 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/constraints.png
--rw-rw-rw-  2.0 fat     1034 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/contact_and_no_flipy.png
--rw-rw-rw-  2.0 fat     1058 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/contact_with_friction.png
--rw-rw-rw-  2.0 fat     7659 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/copy_and_pickle.png
--rw-rw-rw-  2.0 fat      318 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/damped_rotary_spring_pointer.png
--rw-rw-rw-  2.0 fat    13012 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/deformable.png
--rw-rw-rw-  2.0 fat     3541 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/flipper.png
--rw-rw-rw-  2.0 fat    53763 b- defN 21-May-17 21:45 pymunk-6.5.0/docs/html/_images/galtonBoard.png
--rw-rw-rw-  2.0 fat    16174 b- defN 21-May-17 21:45 pymunk-6.5.0/docs/html/_images/guide-the-ball.png
--rw-rw-rw-  2.0 fat     9714 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/index_video.png
--rw-rw-rw-  2.0 fat    95240 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/invisipin.png
--rw-rw-rw-  2.0 fat    12771 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/kivy_pymunk_demo.png
--rw-rw-rw-  2.0 fat    27657 b- defN 20-Nov-26 20:05 pymunk-6.5.0/docs/html/_images/legged_robot.png
--rw-rw-rw-  2.0 fat    18077 b- defN 21-Jul-05 20:53 pymunk-6.5.0/docs/html/_images/manim-physics.png
--rw-rw-rw-  2.0 fat    26552 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/matplotlib_util_demo.png
--rw-rw-rw-  2.0 fat    36263 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/My_Sincerest_Apologies.png
--rw-rw-rw-  2.0 fat     4363 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/newtons_cradle.png
--rw-rw-rw-  2.0 fat     1247 b- defN 21-Aug-16 14:31 pymunk-6.5.0/docs/html/_images/planet.png
--rw-rw-rw-  2.0 fat     4861 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/platformer.png
--rw-rw-rw-  2.0 fat    10259 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/playground.png
--rw-rw-rw-  2.0 fat     1433 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/point_query.png
--rw-rw-rw-  2.0 fat    15799 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/pygame_util_demo.png
--rw-rw-rw-  2.0 fat     9177 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/pyglet_util_demo.png
--rw-rw-rw-  2.0 fat     3249 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/pyphysicssandbox.png
--rw-rw-rw-  2.0 fat    96999 b- defN 20-Nov-26 20:05 pymunk-6.5.0/docs/html/_images/PySimpleGUI.png
--rw-rw-rw-  2.0 fat    10622 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/reinforcement-learning-car.png
--rw-rw-rw-  2.0 fat     2738 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/slide_and_pinjoint.png
--rw-rw-rw-  2.0 fat      910 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/slide_and_pinjoint1.png
--rw-rw-rw-  2.0 fat     9921 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/spiderweb.png
--rw-rw-rw-  2.0 fat    34357 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/SubTerrex.png
--rw-rw-rw-  2.0 fat     4620 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/tank.png
--rw-rw-rw-  2.0 fat     5708 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/using_sprites.png
--rw-rw-rw-  2.0 fat    15320 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/using_sprites_pyglet.png
--rw-rw-rw-  2.0 fat     7441 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_images/virtuaplant.png
-drwxrwxrwx  2.0 fat        0 b- stor 23-Jun-24 22:13 pymunk-6.5.0/docs/html/_modules/pymunk/
--rw-rw-rw-  2.0 fat     5852 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/_modules/index.html
--rw-rw-rw-  2.0 fat    25183 b- defN 23-Jan-10 19:59 pymunk-6.5.0/docs/html/_modules/pymunk.html
--rw-rw-rw-  2.0 fat    46879 b- defN 23-Jan-02 22:21 pymunk-6.5.0/docs/html/_modules/pymunk/arbiter.html
--rw-rw-rw-  2.0 fat    39491 b- defN 23-Jan-13 20:34 pymunk-6.5.0/docs/html/_modules/pymunk/autogeometry.html
--rw-rw-rw-  2.0 fat    22622 b- defN 23-Jan-13 20:34 pymunk-6.5.0/docs/html/_modules/pymunk/bb.html
--rw-rw-rw-  2.0 fat    94318 b- defN 23-May-30 21:56 pymunk-6.5.0/docs/html/_modules/pymunk/body.html
--rw-rw-rw-  2.0 fat    23435 b- defN 23-Jan-13 20:34 pymunk-6.5.0/docs/html/_modules/pymunk/collision_handler.html
--rw-rw-rw-  2.0 fat   125448 b- defN 23-Jan-13 20:34 pymunk-6.5.0/docs/html/_modules/pymunk/constraints.html
--rw-rw-rw-  2.0 fat    15152 b- defN 23-Jan-13 20:34 pymunk-6.5.0/docs/html/_modules/pymunk/contact_point_set.html
--rw-rw-rw-  2.0 fat    21477 b- defN 23-Jan-13 20:34 pymunk-6.5.0/docs/html/_modules/pymunk/matplotlib_util.html
--rw-rw-rw-  2.0 fat    38380 b- defN 23-May-30 21:56 pymunk-6.5.0/docs/html/_modules/pymunk/pygame_util.html
--rw-rw-rw-  2.0 fat    33839 b- defN 23-Jan-13 20:34 pymunk-6.5.0/docs/html/_modules/pymunk/pyglet_util.html
--rw-rw-rw-  2.0 fat    10592 b- defN 23-Jan-13 20:34 pymunk-6.5.0/docs/html/_modules/pymunk/query_info.html
--rw-rw-rw-  2.0 fat   103338 b- defN 23-Jan-02 22:21 pymunk-6.5.0/docs/html/_modules/pymunk/shapes.html
--rw-rw-rw-  2.0 fat    12918 b- defN 23-Jan-13 20:34 pymunk-6.5.0/docs/html/_modules/pymunk/shape_filter.html
--rw-rw-rw-  2.0 fat   143405 b- defN 23-Jun-18 21:43 pymunk-6.5.0/docs/html/_modules/pymunk/space.html
--rw-rw-rw-  2.0 fat    47541 b- defN 23-Jan-13 20:34 pymunk-6.5.0/docs/html/_modules/pymunk/space_debug_draw_options.html
--rw-rw-rw-  2.0 fat    14515 b- defN 23-Jan-13 21:06 pymunk-6.5.0/docs/html/_modules/pymunk/tests.html
--rw-rw-rw-  2.0 fat    28885 b- defN 23-Jan-13 20:34 pymunk-6.5.0/docs/html/_modules/pymunk/transform.html
--rw-rw-rw-  2.0 fat    62600 b- defN 23-Jan-13 20:34 pymunk-6.5.0/docs/html/_modules/pymunk/vec2d.html
-drwxrwxrwx  2.0 fat        0 b- stor 23-Jun-24 22:13 pymunk-6.5.0/docs/html/_sources/tutorials/
--rw-rw-rw-  2.0 fat    12329 b- defN 22-Sep-04 21:47 pymunk-6.5.0/docs/html/_sources/advanced.rst.txt
--rw-rw-rw-  2.0 fat     5985 b- defN 20-Dec-05 20:43 pymunk-6.5.0/docs/html/_sources/benchmarks.rst.txt
--rw-rw-rw-  2.0 fat       34 b- defN 20-Nov-26 20:05 pymunk-6.5.0/docs/html/_sources/changelog.rst.txt
--rw-rw-rw-  2.0 fat     2981 b- defN 22-Nov-10 21:28 pymunk-6.5.0/docs/html/_sources/examples.rst.txt
--rw-rw-rw-  2.0 fat     2028 b- defN 22-Nov-05 21:09 pymunk-6.5.0/docs/html/_sources/index.rst.txt
--rw-rw-rw-  2.0 fat     5420 b- defN 23-Jan-02 22:21 pymunk-6.5.0/docs/html/_sources/installation.rst.txt
--rw-rw-rw-  2.0 fat       59 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_sources/license.rst.txt
--rw-rw-rw-  2.0 fat    12558 b- defN 21-Aug-24 21:43 pymunk-6.5.0/docs/html/_sources/overview.rst.txt
--rw-rw-rw-  2.0 fat      366 b- defN 20-Nov-26 20:05 pymunk-6.5.0/docs/html/_sources/pymunk.autogeometry.rst.txt
--rw-rw-rw-  2.0 fat      272 b- defN 20-Nov-26 20:05 pymunk-6.5.0/docs/html/_sources/pymunk.constraints.rst.txt
--rw-rw-rw-  2.0 fat      310 b- defN 22-Nov-08 22:02 pymunk-6.5.0/docs/html/_sources/pymunk.examples.rst.txt
--rw-rw-rw-  2.0 fat      288 b- defN 20-Nov-26 20:05 pymunk-6.5.0/docs/html/_sources/pymunk.matplotlib_util.rst.txt
--rw-rw-rw-  2.0 fat      276 b- defN 20-Nov-26 20:05 pymunk-6.5.0/docs/html/_sources/pymunk.pygame_util.rst.txt
--rw-rw-rw-  2.0 fat      276 b- defN 20-Nov-26 20:05 pymunk-6.5.0/docs/html/_sources/pymunk.pyglet_util.rst.txt
--rw-rw-rw-  2.0 fat      652 b- defN 23-Jan-13 20:32 pymunk-6.5.0/docs/html/_sources/pymunk.rst.txt
--rw-rw-rw-  2.0 fat      234 b- defN 22-Aug-29 22:16 pymunk-6.5.0/docs/html/_sources/pymunk.tests.rst.txt
--rw-rw-rw-  2.0 fat      318 b- defN 20-Nov-26 20:05 pymunk-6.5.0/docs/html/_sources/pymunk.vec2d.rst.txt
--rw-rw-rw-  2.0 fat    26492 b- defN 23-May-30 13:10 pymunk-6.5.0/docs/html/_sources/showcase.rst.txt
--rw-rw-rw-  2.0 fat     3088 b- defN 21-May-18 21:18 pymunk-6.5.0/docs/html/_sources/tutorials.rst.txt
--rw-rw-rw-  2.0 fat    21089 b- defN 22-Mar-20 20:45 pymunk-6.5.0/docs/html/_sources/tutorials/SlideAndPinJoint.rst.txt
-drwxrwxrwx  2.0 fat        0 b- stor 23-Jun-24 22:13 pymunk-6.5.0/docs/html/_static/bd-2021/
-drwxrwxrwx  2.0 fat        0 b- stor 23-Jun-24 22:13 pymunk-6.5.0/docs/html/_static/examples/
-drwxrwxrwx  2.0 fat        0 b- stor 23-Jun-24 22:13 pymunk-6.5.0/docs/html/_static/tutorials/
--rw-rw-rw-  2.0 fat    39147 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/aimoveneat.png
--rw-rw-rw-  2.0 fat    11975 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/_static/alabaster.css
--rw-rw-rw-  2.0 fat    26582 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/ambient-chimes.png
--rw-rw-rw-  2.0 fat    75102 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/angry-birds-python.png
--rw-rw-rw-  2.0 fat    29887 b- defN 21-Jun-25 21:52 pymunk-6.5.0/docs/html/_static/ar-physics.jpg
--rw-rw-rw-  2.0 fat    23780 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/arcade-library.png
--rw-rw-rw-  2.0 fat    15715 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/_static/basic.css
--rw-rw-rw-  2.0 fat     5209 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/beneath-the-ice.png
--rw-rw-rw-  2.0 fat   108346 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/billiARds.png
--rw-rw-rw-  2.0 fat   197630 b- defN 22-Jan-25 21:06 pymunk-6.5.0/docs/html/_static/bouncingballs-beatuifulpatterns.png
--rw-rw-rw-  2.0 fat    21046 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/carconf.png
--rw-rw-rw-  2.0 fat   156035 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/carrom-rl.png
--rw-rw-rw-  2.0 fat     1105 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/custom.css
--rw-rw-rw-  2.0 fat     4472 b- defN 23-Jan-10 19:59 pymunk-6.5.0/docs/html/_static/doctools.js
--rw-rw-rw-  2.0 fat      433 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/_static/documentation_options.js
--rw-rw-rw-  2.0 fat      286 b- defN 22-Nov-05 20:58 pymunk-6.5.0/docs/html/_static/file.png
--rw-rw-rw-  2.0 fat    53763 b- defN 21-May-17 21:45 pymunk-6.5.0/docs/html/_static/galtonBoard.png
--rw-rw-rw-  2.0 fat    16174 b- defN 21-May-17 21:45 pymunk-6.5.0/docs/html/_static/guide-the-ball.png
--rw-rw-rw-  2.0 fat    95240 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/invisipin.png
--rw-rw-rw-  2.0 fat   288580 b- defN 22-Nov-05 20:58 pymunk-6.5.0/docs/html/_static/jquery-3.6.0.js
--rw-rw-rw-  2.0 fat    89501 b- defN 22-Nov-05 20:58 pymunk-6.5.0/docs/html/_static/jquery.js
--rw-rw-rw-  2.0 fat     4957 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/_static/language_data.js
--rw-rw-rw-  2.0 fat    27657 b- defN 20-Nov-26 20:05 pymunk-6.5.0/docs/html/_static/legged_robot.png
--rw-rw-rw-  2.0 fat    18077 b- defN 21-Jul-05 20:53 pymunk-6.5.0/docs/html/_static/manim-physics.png
--rw-rw-rw-  2.0 fat       90 b- defN 22-Nov-05 20:58 pymunk-6.5.0/docs/html/_static/minus.png
--rw-rw-rw-  2.0 fat    36263 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/My_Sincerest_Apologies.png
--rw-rw-rw-  2.0 fat       90 b- defN 22-Nov-05 20:58 pymunk-6.5.0/docs/html/_static/plus.png
--rw-rw-rw-  2.0 fat     5409 b- defN 23-Jun-24 22:11 pymunk-6.5.0/docs/html/_static/pygments.css
--rw-rw-rw-  2.0 fat     1758 b- defN 23-Jan-13 21:11 pymunk-6.5.0/docs/html/_static/pymunk.js
--rw-rw-rw-  2.0 fat      318 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/pymunk_favicon.ico
--rw-rw-rw-  2.0 fat  1243833 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/pymunk_logo_animation.gif
--rw-rw-rw-  2.0 fat     1795 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/pymunk_logo_googlecode.png
--rw-rw-rw-  2.0 fat     7029 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/pymunk_logo_sphinx.png
--rw-rw-rw-  2.0 fat     3249 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/pyphysicssandbox.png
--rw-rw-rw-  2.0 fat    96999 b- defN 20-Nov-26 20:05 pymunk-6.5.0/docs/html/_static/PySimpleGUI.png
--rw-rw-rw-  2.0 fat    10622 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/reinforcement-learning-car.png
--rw-rw-rw-  2.0 fat    18215 b- defN 23-Jan-10 19:59 pymunk-6.5.0/docs/html/_static/searchtools.js
--rw-rw-rw-  2.0 fat     4712 b- defN 22-Nov-05 20:58 pymunk-6.5.0/docs/html/_static/sphinx_highlight.js
--rw-rw-rw-  2.0 fat    34357 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/SubTerrex.png
--rw-rw-rw-  2.0 fat    68420 b- defN 22-Nov-05 20:58 pymunk-6.5.0/docs/html/_static/underscore-1.13.1.js
--rw-rw-rw-  2.0 fat    19530 b- defN 22-Nov-05 20:58 pymunk-6.5.0/docs/html/_static/underscore.js
--rw-rw-rw-  2.0 fat     7441 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/virtuaplant.png
--rw-rw-rw-  2.0 fat     4418 b- defN 22-Nov-05 20:58 pymunk-6.5.0/docs/html/_static/_sphinx_javascript_frameworks_compat.js
--rw-rw-rw-  2.0 fat    13724 b- defN 21-Mar-20 21:23 pymunk-6.5.0/docs/html/_static/bd-2021/bd-2021.js
--rw-rw-rw-  2.0 fat     5855 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/examples/arrows.png
--rw-rw-rw-  2.0 fat     6092 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/examples/balls_and_lines.png
--rw-rw-rw-  2.0 fat      866 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/examples/bouncing_balls.png
--rw-rw-rw-  2.0 fat     2571 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/examples/box2d_pyramid.png
--rw-rw-rw-  2.0 fat     2781 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/examples/box2d_vertical_stack.png
--rw-rw-rw-  2.0 fat     4729 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/examples/breakout.png
--rw-rw-rw-  2.0 fat     5388 b- defN 21-Aug-15 12:50 pymunk-6.5.0/docs/html/_static/examples/camera.png
--rw-rw-rw-  2.0 fat    11676 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/examples/constraints.png
--rw-rw-rw-  2.0 fat     1034 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/examples/contact_and_no_flipy.png
--rw-rw-rw-  2.0 fat     1058 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/examples/contact_with_friction.png
--rw-rw-rw-  2.0 fat     7659 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/examples/copy_and_pickle.png
--rw-rw-rw-  2.0 fat      318 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/examples/damped_rotary_spring_pointer.png
--rw-rw-rw-  2.0 fat    13012 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/examples/deformable.png
--rw-rw-rw-  2.0 fat     3541 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/examples/flipper.png
--rw-rw-rw-  2.0 fat     9714 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/examples/index_video.png
--rw-rw-rw-  2.0 fat    12771 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/examples/kivy_pymunk_demo.png
--rw-rw-rw-  2.0 fat    26552 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/examples/matplotlib_util_demo.png
--rw-rw-rw-  2.0 fat    40305 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/examples/newtons_cradle.mp4
--rw-rw-rw-  2.0 fat     4363 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/examples/newtons_cradle.png
--rw-rw-rw-  2.0 fat     1247 b- defN 21-Aug-16 14:31 pymunk-6.5.0/docs/html/_static/examples/planet.png
--rw-rw-rw-  2.0 fat     4861 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/examples/platformer.png
--rw-rw-rw-  2.0 fat    10259 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/examples/playground.png
--rw-rw-rw-  2.0 fat     1433 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/examples/point_query.png
--rw-rw-rw-  2.0 fat    15799 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/examples/pygame_util_demo.png
--rw-rw-rw-  2.0 fat     9177 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/examples/pyglet_util_demo.png
--rw-rw-rw-  2.0 fat     2738 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/examples/slide_and_pinjoint.png
--rw-rw-rw-  2.0 fat     9921 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/examples/spiderweb.png
--rw-rw-rw-  2.0 fat     4620 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/examples/tank.png
--rw-rw-rw-  2.0 fat     5708 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/examples/using_sprites.png
--rw-rw-rw-  2.0 fat    15320 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/examples/using_sprites_pyglet.png
--rw-rw-rw-  2.0 fat    18091 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/tutorials/external_pyboxes.png
--rw-rw-rw-  2.0 fat      910 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/html/_static/tutorials/slide_and_pinjoint.png
-drwxrwxrwx  2.0 fat        0 b- stor 23-Jun-24 22:13 pymunk-6.5.0/docs/src/ext/
-drwxrwxrwx  2.0 fat        0 b- stor 23-Jun-24 22:13 pymunk-6.5.0/docs/src/tutorials/
-drwxrwxrwx  2.0 fat        0 b- stor 23-Jun-24 22:13 pymunk-6.5.0/docs/src/_static/
-drwxrwxrwx  2.0 fat        0 b- stor 23-Jun-24 22:13 pymunk-6.5.0/docs/src/_templates/
--rw-rw-rw-  2.0 fat    12329 b- defN 22-Sep-04 21:47 pymunk-6.5.0/docs/src/advanced.rst
--rw-rw-rw-  2.0 fat     5985 b- defN 20-Dec-05 20:43 pymunk-6.5.0/docs/src/benchmarks.rst
--rw-rw-rw-  2.0 fat       34 b- defN 20-Nov-26 20:05 pymunk-6.5.0/docs/src/changelog.rst
--rw-rw-rw-  2.0 fat     4176 b- defN 23-May-30 21:55 pymunk-6.5.0/docs/src/conf.py
--rw-rw-rw-  2.0 fat     2981 b- defN 22-Nov-10 21:28 pymunk-6.5.0/docs/src/examples.rst
--rw-rw-rw-  2.0 fat     2028 b- defN 22-Nov-05 21:09 pymunk-6.5.0/docs/src/index.rst
--rw-rw-rw-  2.0 fat     5420 b- defN 23-Jan-02 22:23 pymunk-6.5.0/docs/src/installation.rst
--rw-rw-rw-  2.0 fat       59 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/license.rst
--rwx---     2.0 fat      804 b- defN 23-Jan-13 20:32 pymunk-6.5.0/docs/src/make.bat
--rw-rw-rw-  2.0 fat      658 b- defN 23-Jan-13 20:32 pymunk-6.5.0/docs/src/Makefile
--rw-rw-rw-  2.0 fat     4086 b- defN 20-Nov-26 20:05 pymunk-6.5.0/docs/src/news.rst.hidden
--rw-rw-rw-  2.0 fat    12558 b- defN 21-Aug-24 21:43 pymunk-6.5.0/docs/src/overview.rst
--rw-rw-rw-  2.0 fat      366 b- defN 20-Nov-26 20:05 pymunk-6.5.0/docs/src/pymunk.autogeometry.rst
--rw-rw-rw-  2.0 fat      272 b- defN 20-Nov-26 20:05 pymunk-6.5.0/docs/src/pymunk.constraints.rst
--rw-rw-rw-  2.0 fat      310 b- defN 22-Nov-08 22:02 pymunk-6.5.0/docs/src/pymunk.examples.rst
--rw-rw-rw-  2.0 fat      288 b- defN 20-Nov-26 20:05 pymunk-6.5.0/docs/src/pymunk.matplotlib_util.rst
--rw-rw-rw-  2.0 fat      276 b- defN 20-Nov-26 20:05 pymunk-6.5.0/docs/src/pymunk.pygame_util.rst
--rw-rw-rw-  2.0 fat      276 b- defN 20-Nov-26 20:05 pymunk-6.5.0/docs/src/pymunk.pyglet_util.rst
--rw-rw-rw-  2.0 fat      652 b- defN 23-Jan-13 20:32 pymunk-6.5.0/docs/src/pymunk.rst
--rw-rw-rw-  2.0 fat      234 b- defN 22-Aug-29 22:16 pymunk-6.5.0/docs/src/pymunk.tests.rst
--rw-rw-rw-  2.0 fat      318 b- defN 20-Nov-26 20:05 pymunk-6.5.0/docs/src/pymunk.vec2d.rst
--rw-rw-rw-  2.0 fat    26492 b- defN 23-May-30 13:10 pymunk-6.5.0/docs/src/showcase.rst
--rw-rw-rw-  2.0 fat     3088 b- defN 21-May-18 21:18 pymunk-6.5.0/docs/src/tutorials.rst
--rw-rw-rw-  2.0 fat     7423 b- defN 22-Nov-08 22:07 pymunk-6.5.0/docs/src/ext/autoexample.py
--rw-rw-rw-  2.0 fat        0 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/ext/__init__.py
--rw-rw-rw-  2.0 fat     4027 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/tutorials/Arrows.rst.inactive
--rw-rw-rw-  2.0 fat    21089 b- defN 22-Mar-20 20:45 pymunk-6.5.0/docs/src/tutorials/SlideAndPinJoint.rst
--rw-rw-rw-  2.0 fat     1999 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/tutorials/StackingGameKivy.rst.incomplete
-drwxrwxrwx  2.0 fat        0 b- stor 23-Jun-24 22:13 pymunk-6.5.0/docs/src/_static/bd-2021/
-drwxrwxrwx  2.0 fat        0 b- stor 23-Jun-24 22:13 pymunk-6.5.0/docs/src/_static/examples/
-drwxrwxrwx  2.0 fat        0 b- stor 23-Jun-24 22:13 pymunk-6.5.0/docs/src/_static/tutorials/
--rw-rw-rw-  2.0 fat    39147 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/aimoveneat.png
--rw-rw-rw-  2.0 fat    26582 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/ambient-chimes.png
--rw-rw-rw-  2.0 fat    75102 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/angry-birds-python.png
--rw-rw-rw-  2.0 fat    29887 b- defN 21-Jun-25 21:52 pymunk-6.5.0/docs/src/_static/ar-physics.jpg
--rw-rw-rw-  2.0 fat    23780 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/arcade-library.png
--rw-rw-rw-  2.0 fat     5209 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/beneath-the-ice.png
--rw-rw-rw-  2.0 fat   108346 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/billiARds.png
--rw-rw-rw-  2.0 fat   197630 b- defN 22-Jan-25 21:06 pymunk-6.5.0/docs/src/_static/bouncingballs-beatuifulpatterns.png
--rw-rw-rw-  2.0 fat    21046 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/carconf.png
--rw-rw-rw-  2.0 fat   156035 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/carrom-rl.png
--rw-rw-rw-  2.0 fat     1105 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/custom.css
--rw-rw-rw-  2.0 fat    53763 b- defN 21-May-17 21:45 pymunk-6.5.0/docs/src/_static/galtonBoard.png
--rw-rw-rw-  2.0 fat    16174 b- defN 21-May-17 21:45 pymunk-6.5.0/docs/src/_static/guide-the-ball.png
--rw-rw-rw-  2.0 fat    95240 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/invisipin.png
--rw-rw-rw-  2.0 fat    27657 b- defN 20-Nov-26 20:05 pymunk-6.5.0/docs/src/_static/legged_robot.png
--rw-rw-rw-  2.0 fat    18077 b- defN 21-Jul-05 20:53 pymunk-6.5.0/docs/src/_static/manim-physics.png
--rw-rw-rw-  2.0 fat    36263 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/My_Sincerest_Apologies.png
--rw-rw-rw-  2.0 fat     1758 b- defN 23-Jan-13 21:11 pymunk-6.5.0/docs/src/_static/pymunk.js
--rw-rw-rw-  2.0 fat      318 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/pymunk_favicon.ico
--rw-rw-rw-  2.0 fat  1243833 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/pymunk_logo_animation.gif
--rw-rw-rw-  2.0 fat     1795 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/pymunk_logo_googlecode.png
--rw-rw-rw-  2.0 fat     7029 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/pymunk_logo_sphinx.png
--rw-rw-rw-  2.0 fat     3249 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/pyphysicssandbox.png
--rw-rw-rw-  2.0 fat    96999 b- defN 20-Nov-26 20:05 pymunk-6.5.0/docs/src/_static/PySimpleGUI.png
--rw-rw-rw-  2.0 fat    10622 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/reinforcement-learning-car.png
--rw-rw-rw-  2.0 fat    34357 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/SubTerrex.png
--rw-rw-rw-  2.0 fat     7441 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/virtuaplant.png
--rw-rw-rw-  2.0 fat    13724 b- defN 21-Mar-20 21:23 pymunk-6.5.0/docs/src/_static/bd-2021/bd-2021.js
--rw-rw-rw-  2.0 fat     5855 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/examples/arrows.png
--rw-rw-rw-  2.0 fat     6092 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/examples/balls_and_lines.png
--rw-rw-rw-  2.0 fat      866 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/examples/bouncing_balls.png
--rw-rw-rw-  2.0 fat     2571 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/examples/box2d_pyramid.png
--rw-rw-rw-  2.0 fat     2781 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/examples/box2d_vertical_stack.png
--rw-rw-rw-  2.0 fat     4729 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/examples/breakout.png
--rw-rw-rw-  2.0 fat     5388 b- defN 21-Aug-15 12:50 pymunk-6.5.0/docs/src/_static/examples/camera.png
--rw-rw-rw-  2.0 fat    11676 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/examples/constraints.png
--rw-rw-rw-  2.0 fat     1034 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/examples/contact_and_no_flipy.png
--rw-rw-rw-  2.0 fat     1058 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/examples/contact_with_friction.png
--rw-rw-rw-  2.0 fat     7659 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/examples/copy_and_pickle.png
--rw-rw-rw-  2.0 fat      318 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/examples/damped_rotary_spring_pointer.png
--rw-rw-rw-  2.0 fat    13012 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/examples/deformable.png
--rw-rw-rw-  2.0 fat     3541 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/examples/flipper.png
--rw-rw-rw-  2.0 fat     9714 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/examples/index_video.png
--rw-rw-rw-  2.0 fat    12771 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/examples/kivy_pymunk_demo.png
--rw-rw-rw-  2.0 fat    26552 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/examples/matplotlib_util_demo.png
--rw-rw-rw-  2.0 fat    40305 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/examples/newtons_cradle.mp4
--rw-rw-rw-  2.0 fat     4363 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/examples/newtons_cradle.png
--rw-rw-rw-  2.0 fat     1247 b- defN 21-Aug-16 14:31 pymunk-6.5.0/docs/src/_static/examples/planet.png
--rw-rw-rw-  2.0 fat     4861 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/examples/platformer.png
--rw-rw-rw-  2.0 fat    10259 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/examples/playground.png
--rw-rw-rw-  2.0 fat     1433 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/examples/point_query.png
--rw-rw-rw-  2.0 fat    15799 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/examples/pygame_util_demo.png
--rw-rw-rw-  2.0 fat     9177 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/examples/pyglet_util_demo.png
--rw-rw-rw-  2.0 fat     2738 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/examples/slide_and_pinjoint.png
--rw-rw-rw-  2.0 fat     9921 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/examples/spiderweb.png
--rw-rw-rw-  2.0 fat     4620 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/examples/tank.png
--rw-rw-rw-  2.0 fat     5708 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/examples/using_sprites.png
--rw-rw-rw-  2.0 fat    15320 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/examples/using_sprites_pyglet.png
--rw-rw-rw-  2.0 fat    18091 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/tutorials/external_pyboxes.png
--rw-rw-rw-  2.0 fat      910 b- defN 20-Oct-06 21:48 pymunk-6.5.0/docs/src/_static/tutorials/slide_and_pinjoint.png
--rw-rw-rw-  2.0 fat      494 b- defN 21-Jul-05 20:56 pymunk-6.5.0/docs/src/_templates/badges.html
-drwxrwxrwx  2.0 fat        0 b- stor 23-Jun-24 22:13 pymunk-6.5.0/pymunk/examples/
-drwxrwxrwx  2.0 fat        0 b- stor 23-Jun-24 22:13 pymunk-6.5.0/pymunk/tests/
--rw-rw-rw-  2.0 fat    10036 b- defN 23-Jan-02 13:02 pymunk-6.5.0/pymunk/arbiter.py
--rw-rw-rw-  2.0 fat     9593 b- defN 22-Nov-01 21:46 pymunk-6.5.0/pymunk/autogeometry.py
--rw-rw-rw-  2.0 fat     3623 b- defN 20-Nov-26 20:05 pymunk-6.5.0/pymunk/bb.py
--rw-rw-rw-  2.0 fat    27541 b- defN 23-May-30 08:33 pymunk-6.5.0/pymunk/body.py
--rw-rw-rw-  2.0 fat     5875 b- defN 22-Nov-02 21:27 pymunk-6.5.0/pymunk/collision_handler.py
--rw-rw-rw-  2.0 fat    29799 b- defN 22-Nov-02 20:46 pymunk-6.5.0/pymunk/constraints.py
--rw-rw-rw-  2.0 fat     2275 b- defN 22-Nov-18 21:48 pymunk-6.5.0/pymunk/contact_point_set.py
--rw-rw-rw-  2.0 fat     3788 b- defN 22-Sep-14 22:01 pymunk-6.5.0/pymunk/matplotlib_util.py
--rw-rw-rw-  2.0 fat        0 b- defN 20-Nov-26 20:05 pymunk-6.5.0/pymunk/py.typed
--rw-rw-rw-  2.0 fat     8254 b- defN 23-Jan-29 20:46 pymunk-6.5.0/pymunk/pygame_util.py
--rw-rw-rw-  2.0 fat     7092 b- defN 22-Nov-18 21:33 pymunk-6.5.0/pymunk/pyglet_util.py
--rw-rw-rw-  2.0 fat     2738 b- defN 23-Jan-02 13:02 pymunk-6.5.0/pymunk/pymunk_extension_build.py
--rw-rw-rw-  2.0 fat     2293 b- defN 20-Nov-26 20:05 pymunk-6.5.0/pymunk/query_info.py
--rw-rw-rw-  2.0 fat    26457 b- defN 23-Jan-02 13:02 pymunk-6.5.0/pymunk/shapes.py
--rw-rw-rw-  2.0 fat     4573 b- defN 20-Nov-26 20:05 pymunk-6.5.0/pymunk/shape_filter.py
--rw-rw-rw-  2.0 fat    42254 b- defN 23-Jun-18 21:39 pymunk-6.5.0/pymunk/space.py
--rw-rw-rw-  2.0 fat    13378 b- defN 22-Nov-01 21:29 pymunk-6.5.0/pymunk/space_debug_draw_options.py
--rw-rw-rw-  2.0 fat     6525 b- defN 22-Sep-05 14:52 pymunk-6.5.0/pymunk/transform.py
--rw-rw-rw-  2.0 fat    12824 b- defN 22-Sep-05 14:52 pymunk-6.5.0/pymunk/util.py
--rw-rw-rw-  2.0 fat    13336 b- defN 22-Sep-14 21:43 pymunk-6.5.0/pymunk/vec2d.py
--rw-rw-rw-  2.0 fat     9212 b- defN 23-Jan-02 13:02 pymunk-6.5.0/pymunk/_callbacks.py
--rw-rw-rw-  2.0 fat      228 b- defN 22-Sep-14 21:41 pymunk-6.5.0/pymunk/_chipmunk_cffi.py
--rw-rw-rw-  2.0 fat     1917 b- defN 20-Nov-26 20:05 pymunk-6.5.0/pymunk/_pickle.py
--rw-rw-rw-  2.0 fat     7044 b- defN 22-Nov-18 21:32 pymunk-6.5.0/pymunk/_pyglet15_util.py
--rw-rw-rw-  2.0 fat      246 b- defN 20-Nov-26 20:05 pymunk-6.5.0/pymunk/_types.py
--rw-rw-rw-  2.0 fat      478 b- defN 20-Nov-26 20:05 pymunk-6.5.0/pymunk/_typing_attr.py
--rw-rw-rw-  2.0 fat     1660 b- defN 23-Jun-19 22:17 pymunk-6.5.0/pymunk/_version.py
--rw-rw-rw-  2.0 fat     5945 b- defN 23-Jan-02 22:24 pymunk-6.5.0/pymunk/__init__.py
--rw-rw-rw-  2.0 fat     7635 b- defN 22-Nov-09 21:00 pymunk-6.5.0/pymunk/examples/arrows.py
--rw-rw-rw-  2.0 fat     5600 b- defN 22-Sep-05 14:52 pymunk-6.5.0/pymunk/examples/balls_and_lines.py
--rw-rw-rw-  2.0 fat     1503 b- defN 22-Nov-08 20:41 pymunk-6.5.0/pymunk/examples/basic_test.py
--rw-rw-rw-  2.0 fat     4729 b- defN 22-Nov-09 21:00 pymunk-6.5.0/pymunk/examples/bouncing_balls.py
--rw-rw-rw-  2.0 fat     2908 b- defN 22-Sep-05 14:52 pymunk-6.5.0/pymunk/examples/box2d_pyramid.py
--rw-rw-rw-  2.0 fat     3065 b- defN 22-Nov-09 21:01 pymunk-6.5.0/pymunk/examples/box2d_vertical_stack.py
--rw-rw-rw-  2.0 fat     7688 b- defN 22-Sep-11 22:18 pymunk-6.5.0/pymunk/examples/breakout.py
--rw-rw-rw-  2.0 fat     5317 b- defN 22-Sep-05 14:52 pymunk-6.5.0/pymunk/examples/camera.py
--rw-rw-rw-  2.0 fat     8665 b- defN 22-Nov-09 21:02 pymunk-6.5.0/pymunk/examples/constraints.py
--rw-rw-rw-  2.0 fat     3198 b- defN 22-Sep-05 14:52 pymunk-6.5.0/pymunk/examples/contact_and_no_flipy.py
--rw-rw-rw-  2.0 fat     3250 b- defN 22-Sep-05 14:52 pymunk-6.5.0/pymunk/examples/contact_with_friction.py
--rw-rw-rw-  2.0 fat     4510 b- defN 22-Sep-05 14:52 pymunk-6.5.0/pymunk/examples/copy_and_pickle.py
--rw-rw-rw-  2.0 fat     3091 b- defN 22-Sep-05 14:52 pymunk-6.5.0/pymunk/examples/damped_rotary_spring_pointer.py
--rw-rw-rw-  2.0 fat     4909 b- defN 22-Sep-05 14:52 pymunk-6.5.0/pymunk/examples/deformable.py
--rw-rw-rw-  2.0 fat     4934 b- defN 23-Jan-02 22:26 pymunk-6.5.0/pymunk/examples/flipper.py
--rw-rw-rw-  2.0 fat     7109 b- defN 23-Jan-02 13:02 pymunk-6.5.0/pymunk/examples/index_video.py
--rw-rw-rw-  2.0 fat      573 b- defN 20-Dec-03 12:36 pymunk-6.5.0/pymunk/examples/matplotlib_util_demo.py
--rw-rw-rw-  2.0 fat     8120 b- defN 22-Nov-08 22:08 pymunk-6.5.0/pymunk/examples/newtons_cradle.py
--rw-rw-rw-  2.0 fat     2793 b- defN 22-Sep-05 14:52 pymunk-6.5.0/pymunk/examples/planet.py
--rw-rw-rw-  2.0 fat    11485 b- defN 23-Jan-02 13:02 pymunk-6.5.0/pymunk/examples/platformer.py
--rw-rw-rw-  2.0 fat    12802 b- defN 22-Sep-05 14:52 pymunk-6.5.0/pymunk/examples/playground.py
--rw-rw-rw-  2.0 fat     2956 b- defN 22-Sep-05 14:52 pymunk-6.5.0/pymunk/examples/point_query.py
--rw-rw-rw-  2.0 fat     1620 b- defN 22-Nov-17 17:45 pymunk-6.5.0/pymunk/examples/pygame_util_demo.py
--rw-rw-rw-  2.0 fat     1275 b- defN 22-Nov-17 17:45 pymunk-6.5.0/pymunk/examples/pyglet_util_demo.py
--rw-rw-rw-  2.0 fat     2408 b- defN 20-Oct-06 21:48 pymunk-6.5.0/pymunk/examples/pymunk_logo_googlecode.png
--rw-rw-rw-  2.0 fat    14994 b- defN 20-Oct-06 21:48 pymunk-6.5.0/pymunk/examples/pymunk_logo_sphinx.png
--rw-rw-rw-  2.0 fat     6338 b- defN 20-Oct-06 21:48 pymunk-6.5.0/pymunk/examples/sfx.wav
--rw-rw-rw-  2.0 fat     9889 b- defN 22-Nov-18 21:49 pymunk-6.5.0/pymunk/examples/shapes_for_draw_demos.py
--rw-rw-rw-  2.0 fat     3000 b- defN 22-Sep-05 14:52 pymunk-6.5.0/pymunk/examples/slide_and_pinjoint.py
--rw-rw-rw-  2.0 fat     4581 b- defN 22-Nov-07 21:37 pymunk-6.5.0/pymunk/examples/spiderweb.py
--rw-rw-rw-  2.0 fat     4483 b- defN 22-Sep-05 14:52 pymunk-6.5.0/pymunk/examples/tank.py
--rw-rw-rw-  2.0 fat     1712 b- defN 22-Sep-05 14:52 pymunk-6.5.0/pymunk/examples/threaded_space.py
--rw-rw-rw-  2.0 fat     3923 b- defN 23-Jan-02 13:02 pymunk-6.5.0/pymunk/examples/using_sprites.py
--rw-rw-rw-  2.0 fat     3562 b- defN 23-Jan-02 13:02 pymunk-6.5.0/pymunk/examples/using_sprites_pyglet.py
--rw-rw-rw-  2.0 fat     4497 b- defN 20-Oct-06 21:48 pymunk-6.5.0/pymunk/examples/xmasgirl1.png
--rw-rw-rw-  2.0 fat      442 b- defN 22-Nov-08 22:08 pymunk-6.5.0/pymunk/examples/__init__.py
--rw-rw-rw-  2.0 fat     2042 b- defN 22-Nov-09 21:04 pymunk-6.5.0/pymunk/examples/__main__.py
--rw-rw-rw-  2.0 fat     1093 b- defN 22-Nov-19 21:27 pymunk-6.5.0/pymunk/tests/doctests.py
--rw-rw-rw-  2.0 fat     9670 b- defN 22-Nov-02 21:00 pymunk-6.5.0/pymunk/tests/test_arbiter.py
--rw-rw-rw-  2.0 fat     5208 b- defN 22-Sep-05 14:52 pymunk-6.5.0/pymunk/tests/test_autogeometry.py
--rw-rw-rw-  2.0 fat     2492 b- defN 22-Nov-04 22:14 pymunk-6.5.0/pymunk/tests/test_bb.py
--rw-rw-rw-  2.0 fat     9596 b- defN 22-Nov-04 22:15 pymunk-6.5.0/pymunk/tests/test_body.py
--rw-rw-rw-  2.0 fat     3603 b- defN 22-Nov-08 22:15 pymunk-6.5.0/pymunk/tests/test_common.py
--rw-rw-rw-  2.0 fat    16166 b- defN 22-Nov-04 22:15 pymunk-6.5.0/pymunk/tests/test_constraint.py
--rw-rw-rw-  2.0 fat    11953 b- defN 22-Nov-04 22:16 pymunk-6.5.0/pymunk/tests/test_shape.py
--rw-rw-rw-  2.0 fat     1151 b- defN 20-Nov-26 20:05 pymunk-6.5.0/pymunk/tests/test_shape_filter.py
--rw-rw-rw-  2.0 fat    32832 b- defN 23-Jan-02 13:02 pymunk-6.5.0/pymunk/tests/test_space.py
--rw-rw-rw-  2.0 fat     1572 b- defN 22-Nov-04 22:16 pymunk-6.5.0/pymunk/tests/test_space_debug_draw_options.py
--rw-rw-rw-  2.0 fat     1167 b- defN 22-Nov-04 22:16 pymunk-6.5.0/pymunk/tests/test_transform.py
--rw-rw-rw-  2.0 fat     5799 b- defN 22-Nov-04 22:16 pymunk-6.5.0/pymunk/tests/test_vec2d.py
--rw-rw-rw-  2.0 fat     2837 b- defN 23-Jan-13 21:06 pymunk-6.5.0/pymunk/tests/__init__.py
--rw-rw-rw-  2.0 fat     1421 b- defN 22-Nov-04 21:36 pymunk-6.5.0/pymunk/tests/__main__.py
--rw-rw-rw-  2.0 fat        1 b- defN 23-Jun-24 22:13 pymunk-6.5.0/pymunk.egg-info/dependency_links.txt
--rw-rw-rw-  2.0 fat     6255 b- defN 23-Jun-24 22:13 pymunk-6.5.0/pymunk.egg-info/PKG-INFO
--rw-rw-rw-  2.0 fat       73 b- defN 23-Jun-24 22:13 pymunk-6.5.0/pymunk.egg-info/requires.txt
--rw-rw-rw-  2.0 fat    17090 b- defN 23-Jun-24 22:13 pymunk-6.5.0/pymunk.egg-info/SOURCES.txt
--rw-rw-rw-  2.0 fat        7 b- defN 23-Jun-24 22:13 pymunk-6.5.0/pymunk.egg-info/top_level.txt
--rw-rw-rw-  2.0 fat     1361 b- defN 23-Jan-02 13:02 pymunk-6.5.0/tools/create_release_win.py
--rw-rw-rw-  2.0 fat      170 b- defN 20-Nov-26 20:05 pymunk-6.5.0/tools/generate_docs.py
--rw-rw-rw-  2.0 fat      311 b- defN 22-Sep-05 14:52 pymunk-6.5.0/tools/update_chipmunk_src.py
-516 files, 18168119 bytes uncompressed, 8011773 bytes compressed:  55.9%
+Zip file size: 1002988 bytes, number of entries: 97
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-26 19:21 pymunk/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-26 19:21 pymunk-6.5.1.dist-info/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-26 19:21 pymunk.libs/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-26 19:21 pymunk/examples/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-26 19:21 pymunk/cffi/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jun-26 19:21 pymunk/tests/
+-rw-r--r--  2.0 unx     5714 b- defN 23-Jun-26 19:21 pymunk/collision_handler.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jun-26 19:21 pymunk/py.typed
+-rw-r--r--  2.0 unx    13035 b- defN 23-Jun-26 19:21 pymunk/space_debug_draw_options.py
+-rw-r--r--  2.0 unx     8913 b- defN 23-Jun-26 19:21 pymunk/_callbacks.py
+-rw-r--r--  2.0 unx    12824 b- defN 23-Jun-26 19:21 pymunk/util.py
+-rw-r--r--  2.0 unx     5753 b- defN 23-Jun-26 19:21 pymunk/__init__.py
+-rw-r--r--  2.0 unx     2194 b- defN 23-Jun-26 19:21 pymunk/contact_point_set.py
+-rw-r--r--  2.0 unx    28936 b- defN 23-Jun-26 19:21 pymunk/constraints.py
+-rw-r--r--  2.0 unx      218 b- defN 23-Jun-26 19:21 pymunk/_chipmunk_cffi.py
+-rw-r--r--  2.0 unx    26794 b- defN 23-Jun-26 19:21 pymunk/body.py
+-rw-r--r--  2.0 unx    41154 b- defN 23-Jun-26 19:21 pymunk/space.py
+-rw-r--r--  2.0 unx    25696 b- defN 23-Jun-26 19:21 pymunk/shapes.py
+-rw-r--r--  2.0 unx     9293 b- defN 23-Jun-26 19:21 pymunk/autogeometry.py
+-rw-r--r--  2.0 unx     6294 b- defN 23-Jun-26 19:21 pymunk/transform.py
+-rw-r--r--  2.0 unx     3510 b- defN 23-Jun-26 19:21 pymunk/bb.py
+-rw-r--r--  2.0 unx     1620 b- defN 23-Jun-26 19:21 pymunk/_version.py
+-rw-r--r--  2.0 unx     7092 b- defN 23-Jun-26 19:21 pymunk/pyglet_util.py
+-rw-r--r--  2.0 unx    13336 b- defN 23-Jun-26 19:21 pymunk/vec2d.py
+-rw-r--r--  2.0 unx     2653 b- defN 23-Jun-26 19:21 pymunk/pymunk_extension_build.py
+-rw-r--r--  2.0 unx     4464 b- defN 23-Jun-26 19:21 pymunk/shape_filter.py
+-rw-r--r--  2.0 unx     3667 b- defN 23-Jun-26 19:21 pymunk/matplotlib_util.py
+-rw-r--r--  2.0 unx     6842 b- defN 23-Jun-26 19:21 pymunk/_pyglet15_util.py
+-rw-r--r--  2.0 unx     9743 b- defN 23-Jun-26 19:21 pymunk/arbiter.py
+-rw-r--r--  2.0 unx     8018 b- defN 23-Jun-26 19:21 pymunk/pygame_util.py
+-rw-r--r--  2.0 unx      463 b- defN 23-Jun-26 19:21 pymunk/_typing_attr.py
+-rw-r--r--  2.0 unx      239 b- defN 23-Jun-26 19:21 pymunk/_types.py
+-rw-r--r--  2.0 unx     1855 b- defN 23-Jun-26 19:21 pymunk/_pickle.py
+-rwxr-xr-x  2.0 unx  2396176 b- defN 23-Jun-26 19:21 pymunk/_chipmunk.abi3.so
+-rw-r--r--  2.0 unx     2218 b- defN 23-Jun-26 19:21 pymunk/query_info.py
+-rw-r--r--  2.0 unx     6338 b- defN 23-Jun-26 19:21 pymunk/examples/sfx.wav
+-rw-r--r--  2.0 unx    14994 b- defN 23-Jun-26 19:21 pymunk/examples/pymunk_logo_sphinx.png
+-rw-r--r--  2.0 unx     3000 b- defN 23-Jun-26 19:21 pymunk/examples/damped_rotary_spring_pointer.py
+-rw-r--r--  2.0 unx     7410 b- defN 23-Jun-26 19:21 pymunk/examples/arrows.py
+-rw-r--r--  2.0 unx     4497 b- defN 23-Jun-26 19:21 pymunk/examples/xmasgirl1.png
+-rw-r--r--  2.0 unx     1652 b- defN 23-Jun-26 19:21 pymunk/examples/threaded_space.py
+-rw-r--r--  2.0 unx     2856 b- defN 23-Jun-26 19:21 pymunk/examples/point_query.py
+-rw-r--r--  2.0 unx     5430 b- defN 23-Jun-26 19:21 pymunk/examples/balls_and_lines.py
+-rw-r--r--  2.0 unx     2969 b- defN 23-Jun-26 19:21 pymunk/examples/box2d_vertical_stack.py
+-rw-r--r--  2.0 unx     2810 b- defN 23-Jun-26 19:21 pymunk/examples/box2d_pyramid.py
+-rw-r--r--  2.0 unx     4574 b- defN 23-Jun-26 19:21 pymunk/examples/bouncing_balls.py
+-rw-r--r--  2.0 unx     9527 b- defN 23-Jun-26 19:21 pymunk/examples/shapes_for_draw_demos.py
+-rw-r--r--  2.0 unx     5135 b- defN 23-Jun-26 19:21 pymunk/examples/camera.py
+-rw-r--r--  2.0 unx     2701 b- defN 23-Jun-26 19:21 pymunk/examples/planet.py
+-rw-r--r--  2.0 unx     4788 b- defN 23-Jun-26 19:21 pymunk/examples/flipper.py
+-rw-r--r--  2.0 unx     7458 b- defN 23-Jun-26 19:21 pymunk/examples/breakout.py
+-rw-r--r--  2.0 unx      425 b- defN 23-Jun-26 19:21 pymunk/examples/__init__.py
+-rw-r--r--  2.0 unx     8414 b- defN 23-Jun-26 19:21 pymunk/examples/constraints.py
+-rw-r--r--  2.0 unx      553 b- defN 23-Jun-26 19:21 pymunk/examples/matplotlib_util_demo.py
+-rw-r--r--  2.0 unx     1447 b- defN 23-Jun-26 19:21 pymunk/examples/basic_test.py
+-rw-r--r--  2.0 unx     1219 b- defN 23-Jun-26 19:21 pymunk/examples/pyglet_util_demo.py
+-rw-r--r--  2.0 unx     1970 b- defN 23-Jun-26 19:21 pymunk/examples/__main__.py
+-rw-r--r--  2.0 unx    11141 b- defN 23-Jun-26 19:21 pymunk/examples/platformer.py
+-rw-r--r--  2.0 unx    12446 b- defN 23-Jun-26 19:21 pymunk/examples/playground.py
+-rw-r--r--  2.0 unx     1557 b- defN 23-Jun-26 19:21 pymunk/examples/pygame_util_demo.py
+-rw-r--r--  2.0 unx     2895 b- defN 23-Jun-26 19:21 pymunk/examples/slide_and_pinjoint.py
+-rw-r--r--  2.0 unx     6837 b- defN 23-Jun-26 19:21 pymunk/examples/index_video.py
+-rw-r--r--  2.0 unx     4331 b- defN 23-Jun-26 19:21 pymunk/examples/tank.py
+-rw-r--r--  2.0 unx     3794 b- defN 23-Jun-26 19:21 pymunk/examples/using_sprites.py
+-rw-r--r--  2.0 unx     4393 b- defN 23-Jun-26 19:21 pymunk/examples/spiderweb.py
+-rw-r--r--  2.0 unx     7866 b- defN 23-Jun-26 19:21 pymunk/examples/newtons_cradle.py
+-rw-r--r--  2.0 unx     3433 b- defN 23-Jun-26 19:21 pymunk/examples/using_sprites_pyglet.py
+-rw-r--r--  2.0 unx     4755 b- defN 23-Jun-26 19:21 pymunk/examples/deformable.py
+-rw-r--r--  2.0 unx     3141 b- defN 23-Jun-26 19:21 pymunk/examples/contact_with_friction.py
+-rw-r--r--  2.0 unx     3093 b- defN 23-Jun-26 19:21 pymunk/examples/contact_and_no_flipy.py
+-rw-r--r--  2.0 unx     4371 b- defN 23-Jun-26 19:21 pymunk/examples/copy_and_pickle.py
+-rw-r--r--  2.0 unx     2408 b- defN 23-Jun-26 19:21 pymunk/examples/pymunk_logo_googlecode.png
+-rw-r--r--  2.0 unx     2583 b- defN 23-Jun-26 19:21 pymunk/cffi/callbacks_cdef.h
+-rw-r--r--  2.0 unx      418 b- defN 23-Jun-26 19:21 pymunk/cffi/hastyspace_cdef.h
+-rw-r--r--  2.0 unx     1102 b- defN 23-Jun-26 19:21 pymunk/cffi/extensions_cdef.h
+-rw-r--r--  2.0 unx    70553 b- defN 23-Jun-26 19:21 pymunk/cffi/chipmunk_cdef.h
+-rw-r--r--  2.0 unx     4035 b- defN 23-Jun-26 19:21 pymunk/cffi/extensions.c
+-rw-r--r--  2.0 unx     5645 b- defN 23-Jun-26 19:21 pymunk/tests/test_vec2d.py
+-rw-r--r--  2.0 unx     9279 b- defN 23-Jun-26 19:21 pymunk/tests/test_body.py
+-rw-r--r--  2.0 unx    31800 b- defN 23-Jun-26 19:21 pymunk/tests/test_space.py
+-rw-r--r--  2.0 unx     2411 b- defN 23-Jun-26 19:21 pymunk/tests/test_bb.py
+-rw-r--r--  2.0 unx     2740 b- defN 23-Jun-26 19:21 pymunk/tests/__init__.py
+-rw-r--r--  2.0 unx     1375 b- defN 23-Jun-26 19:21 pymunk/tests/__main__.py
+-rw-r--r--  2.0 unx     1127 b- defN 23-Jun-26 19:21 pymunk/tests/test_transform.py
+-rw-r--r--  2.0 unx     1054 b- defN 23-Jun-26 19:21 pymunk/tests/doctests.py
+-rw-r--r--  2.0 unx    15656 b- defN 23-Jun-26 19:21 pymunk/tests/test_constraint.py
+-rw-r--r--  2.0 unx     9331 b- defN 23-Jun-26 19:21 pymunk/tests/test_arbiter.py
+-rw-r--r--  2.0 unx     5040 b- defN 23-Jun-26 19:21 pymunk/tests/test_autogeometry.py
+-rw-r--r--  2.0 unx    11556 b- defN 23-Jun-26 19:21 pymunk/tests/test_shape.py
+-rw-r--r--  2.0 unx     1531 b- defN 23-Jun-26 19:21 pymunk/tests/test_space_debug_draw_options.py
+-rw-r--r--  2.0 unx     1109 b- defN 23-Jun-26 19:21 pymunk/tests/test_shape_filter.py
+-rw-r--r--  2.0 unx     3480 b- defN 23-Jun-26 19:21 pymunk/tests/test_common.py
+-rw-r--r--  2.0 unx     1084 b- defN 23-Jun-26 19:21 pymunk-6.5.1.dist-info/LICENSE.txt
+-rw-r--r--  2.0 unx      111 b- defN 23-Jun-26 19:21 pymunk-6.5.1.dist-info/WHEEL
+-rw-r--r--  2.0 unx        7 b- defN 23-Jun-26 19:21 pymunk-6.5.1.dist-info/top_level.txt
+-rw-r--r--  2.0 unx     6361 b- defN 23-Jun-26 19:21 pymunk-6.5.1.dist-info/METADATA
+-rw-rw-r--  2.0 unx     7732 b- defN 23-Jun-26 19:21 pymunk-6.5.1.dist-info/RECORD
+97 files, 3022462 bytes uncompressed, 990420 bytes compressed:  67.2%
```

## zipnote {}

```diff
@@ -1,1549 +1,292 @@
-Filename: pymunk-6.5.0/
+Filename: pymunk/
 Comment: 
 
-Filename: pymunk-6.5.0/additional_examples/
+Filename: pymunk-6.5.1.dist-info/
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/
+Filename: pymunk.libs/
 Comment: 
 
-Filename: pymunk-6.5.0/docs/
+Filename: pymunk/examples/
 Comment: 
 
-Filename: pymunk-6.5.0/pymunk/
+Filename: pymunk/cffi/
 Comment: 
 
-Filename: pymunk-6.5.0/pymunk.egg-info/
+Filename: pymunk/tests/
 Comment: 
 
-Filename: pymunk-6.5.0/tools/
+Filename: pymunk/collision_handler.py
 Comment: 
 
-Filename: pymunk-6.5.0/CHANGELOG.rst
+Filename: pymunk/py.typed
 Comment: 
 
-Filename: pymunk-6.5.0/LICENSE.txt
+Filename: pymunk/space_debug_draw_options.py
 Comment: 
 
-Filename: pymunk-6.5.0/MANIFEST.in
+Filename: pymunk/_callbacks.py
 Comment: 
 
-Filename: pymunk-6.5.0/PKG-INFO
+Filename: pymunk/util.py
 Comment: 
 
-Filename: pymunk-6.5.0/pyproject.toml
+Filename: pymunk/__init__.py
 Comment: 
 
-Filename: pymunk-6.5.0/README.rst
+Filename: pymunk/contact_point_set.py
 Comment: 
 
-Filename: pymunk-6.5.0/setup.cfg
+Filename: pymunk/constraints.py
 Comment: 
 
-Filename: pymunk-6.5.0/setup.py
+Filename: pymunk/_chipmunk_cffi.py
 Comment: 
 
-Filename: pymunk-6.5.0/THANKS.txt
+Filename: pymunk/body.py
 Comment: 
 
-Filename: pymunk-6.5.0/additional_examples/kivy_pymunk_demo/
+Filename: pymunk/space.py
 Comment: 
 
-Filename: pymunk-6.5.0/additional_examples/matplotlib_util_demo.ipynb
+Filename: pymunk/shapes.py
 Comment: 
 
-Filename: pymunk-6.5.0/additional_examples/newtons_cradle.ipynb
+Filename: pymunk/autogeometry.py
 Comment: 
 
-Filename: pymunk-6.5.0/additional_examples/no_dependencies.py
+Filename: pymunk/transform.py
 Comment: 
 
-Filename: pymunk-6.5.0/additional_examples/py2exe_setup__basic_test.py
+Filename: pymunk/bb.py
 Comment: 
 
-Filename: pymunk-6.5.0/additional_examples/pyinstaller_basic_test.spec
+Filename: pymunk/_version.py
 Comment: 
 
-Filename: pymunk-6.5.0/additional_examples/kivy_pymunk_demo/main.py
+Filename: pymunk/pyglet_util.py
 Comment: 
 
-Filename: pymunk-6.5.0/additional_examples/kivy_pymunk_demo/pymunk_demo_icon_512.png
+Filename: pymunk/vec2d.py
 Comment: 
 
-Filename: pymunk-6.5.0/additional_examples/kivy_pymunk_demo/pymunk_logo.png
+Filename: pymunk/pymunk_extension_build.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/include/
+Filename: pymunk/shape_filter.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/src/
+Filename: pymunk/matplotlib_util.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/CMakeLists.txt
+Filename: pymunk/_pyglet15_util.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/LICENSE.txt
+Filename: pymunk/arbiter.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/TODO.txt
+Filename: pymunk/pygame_util.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/VERSION.txt
+Filename: pymunk/_typing_attr.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/include/chipmunk/
+Filename: pymunk/_types.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/include/chipmunk/chipmunk.h
+Filename: pymunk/_pickle.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/include/chipmunk/chipmunk_ffi.h
+Filename: pymunk/_chipmunk.abi3.so
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/include/chipmunk/chipmunk_private.h
+Filename: pymunk/query_info.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/include/chipmunk/chipmunk_structs.h
+Filename: pymunk/examples/sfx.wav
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/include/chipmunk/chipmunk_types.h
+Filename: pymunk/examples/pymunk_logo_sphinx.png
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/include/chipmunk/chipmunk_unsafe.h
+Filename: pymunk/examples/damped_rotary_spring_pointer.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpArbiter.h
+Filename: pymunk/examples/arrows.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpBB.h
+Filename: pymunk/examples/xmasgirl1.png
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpBody.h
+Filename: pymunk/examples/threaded_space.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpConstraint.h
+Filename: pymunk/examples/point_query.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpDampedRotarySpring.h
+Filename: pymunk/examples/balls_and_lines.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpDampedSpring.h
+Filename: pymunk/examples/box2d_vertical_stack.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpGearJoint.h
+Filename: pymunk/examples/box2d_pyramid.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpGrooveJoint.h
+Filename: pymunk/examples/bouncing_balls.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpHastySpace.h
+Filename: pymunk/examples/shapes_for_draw_demos.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpMarch.h
+Filename: pymunk/examples/camera.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpPinJoint.h
+Filename: pymunk/examples/planet.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpPivotJoint.h
+Filename: pymunk/examples/flipper.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpPolyline.h
+Filename: pymunk/examples/breakout.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpPolyShape.h
+Filename: pymunk/examples/__init__.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpRatchetJoint.h
+Filename: pymunk/examples/constraints.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpRobust.h
+Filename: pymunk/examples/matplotlib_util_demo.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpRotaryLimitJoint.h
+Filename: pymunk/examples/basic_test.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpShape.h
+Filename: pymunk/examples/pyglet_util_demo.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpSimpleMotor.h
+Filename: pymunk/examples/__main__.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpSlideJoint.h
+Filename: pymunk/examples/platformer.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpSpace.h
+Filename: pymunk/examples/playground.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpSpatialIndex.h
+Filename: pymunk/examples/pygame_util_demo.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpTransform.h
+Filename: pymunk/examples/slide_and_pinjoint.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/include/chipmunk/cpVect.h
+Filename: pymunk/examples/index_video.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/src/chipmunk.c
+Filename: pymunk/examples/tank.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/src/CMakeLists.txt
+Filename: pymunk/examples/using_sprites.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/src/cpArbiter.c
+Filename: pymunk/examples/spiderweb.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/src/cpArray.c
+Filename: pymunk/examples/newtons_cradle.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/src/cpBBTree.c
+Filename: pymunk/examples/using_sprites_pyglet.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/src/cpBody.c
+Filename: pymunk/examples/deformable.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/src/cpCollision.c
+Filename: pymunk/examples/contact_with_friction.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/src/cpConstraint.c
+Filename: pymunk/examples/contact_and_no_flipy.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/src/cpDampedRotarySpring.c
+Filename: pymunk/examples/copy_and_pickle.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/src/cpDampedSpring.c
+Filename: pymunk/examples/pymunk_logo_googlecode.png
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/src/cpGearJoint.c
+Filename: pymunk/cffi/callbacks_cdef.h
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/src/cpGrooveJoint.c
+Filename: pymunk/cffi/hastyspace_cdef.h
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/src/cpHashSet.c
+Filename: pymunk/cffi/extensions_cdef.h
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/src/cpHastySpace.c
+Filename: pymunk/cffi/chipmunk_cdef.h
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/src/cpMarch.c
+Filename: pymunk/cffi/extensions.c
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/src/cpPinJoint.c
+Filename: pymunk/tests/test_vec2d.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/src/cpPivotJoint.c
+Filename: pymunk/tests/test_body.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/src/cpPolyline.c
+Filename: pymunk/tests/test_space.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/src/cpPolyShape.c
+Filename: pymunk/tests/test_bb.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/src/cpRatchetJoint.c
+Filename: pymunk/tests/__init__.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/src/cpRobust.c
+Filename: pymunk/tests/__main__.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/src/cpRotaryLimitJoint.c
+Filename: pymunk/tests/test_transform.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/src/cpShape.c
+Filename: pymunk/tests/doctests.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/src/cpSimpleMotor.c
+Filename: pymunk/tests/test_constraint.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/src/cpSlideJoint.c
+Filename: pymunk/tests/test_arbiter.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/src/cpSpace.c
+Filename: pymunk/tests/test_autogeometry.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/src/cpSpaceComponent.c
+Filename: pymunk/tests/test_shape.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/src/cpSpaceDebug.c
+Filename: pymunk/tests/test_space_debug_draw_options.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/src/cpSpaceHash.c
+Filename: pymunk/tests/test_shape_filter.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/src/cpSpaceQuery.c
+Filename: pymunk/tests/test_common.py
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/src/cpSpaceStep.c
+Filename: pymunk-6.5.1.dist-info/LICENSE.txt
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/src/cpSpatialIndex.c
+Filename: pymunk-6.5.1.dist-info/WHEEL
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/src/cpSweep1D.c
+Filename: pymunk-6.5.1.dist-info/top_level.txt
 Comment: 
 
-Filename: pymunk-6.5.0/Chipmunk2D/src/prime.h
+Filename: pymunk-6.5.1.dist-info/METADATA
 Comment: 
 
-Filename: pymunk-6.5.0/docs/html/
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/.doctrees/
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/tutorials/
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_modules/
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_sources/
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/.buildinfo
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/advanced.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/benchmarks.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/changelog.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/examples.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/genindex.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/index.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/installation.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/license.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/objects.inv
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/overview.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/py-modindex.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/pymunk.autogeometry.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/pymunk.constraints.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/pymunk.examples.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/pymunk.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/pymunk.matplotlib_util.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/pymunk.pygame_util.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/pymunk.pyglet_util.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/pymunk.tests.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/pymunk.vec2d.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/search.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/searchindex.js
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/showcase.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/tutorials.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/.doctrees/tutorials/
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/.doctrees/advanced.doctree
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/.doctrees/benchmarks.doctree
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/.doctrees/changelog.doctree
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/.doctrees/environment.pickle
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/.doctrees/examples.doctree
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/.doctrees/index.doctree
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/.doctrees/installation.doctree
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/.doctrees/license.doctree
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/.doctrees/overview.doctree
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/.doctrees/pymunk.autogeometry.doctree
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/.doctrees/pymunk.constraints.doctree
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/.doctrees/pymunk.doctree
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/.doctrees/pymunk.examples.doctree
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/.doctrees/pymunk.matplotlib_util.doctree
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/.doctrees/pymunk.pygame_util.doctree
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/.doctrees/pymunk.pyglet_util.doctree
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/.doctrees/pymunk.tests.doctree
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/.doctrees/pymunk.vec2d.doctree
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/.doctrees/showcase.doctree
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/.doctrees/tutorials.doctree
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/.doctrees/tutorials/SlideAndPinJoint.doctree
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/tutorials/SlideAndPinJoint.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/aafig-57def8bc9dba711704bbcd5d7ccb99d16f57c3d3.svg
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/aafig-57def8bc9dba711704bbcd5d7ccb99d16f57c3d3.svg.aafig
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/aafig-6d1244b47ef3cff62251ba8c2119d70a3af0e610.svg
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/aafig-6d1244b47ef3cff62251ba8c2119d70a3af0e610.svg.aafig
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/aafig-e5bd167514754e94de9bcf68b93e2d7e338b37ee.svg
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/aafig-e5bd167514754e94de9bcf68b93e2d7e338b37ee.svg.aafig
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/aimoveneat.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/ambient-chimes.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/angry-birds-python.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/ar-physics.jpg
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/arcade-library.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/arrows.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/balls_and_lines.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/beneath-the-ice.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/billiARds.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/bouncingballs-beatuifulpatterns.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/bouncing_balls.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/box2d_pyramid.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/box2d_vertical_stack.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/breakout.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/camera.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/carconf.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/carrom-rl.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/constraints.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/contact_and_no_flipy.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/contact_with_friction.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/copy_and_pickle.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/damped_rotary_spring_pointer.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/deformable.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/flipper.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/galtonBoard.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/guide-the-ball.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/index_video.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/invisipin.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/kivy_pymunk_demo.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/legged_robot.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/manim-physics.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/matplotlib_util_demo.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/My_Sincerest_Apologies.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/newtons_cradle.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/planet.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/platformer.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/playground.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/point_query.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/pygame_util_demo.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/pyglet_util_demo.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/pyphysicssandbox.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/PySimpleGUI.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/reinforcement-learning-car.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/slide_and_pinjoint.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/slide_and_pinjoint1.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/spiderweb.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/SubTerrex.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/tank.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/using_sprites.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/using_sprites_pyglet.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_images/virtuaplant.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_modules/pymunk/
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_modules/index.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_modules/pymunk.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_modules/pymunk/arbiter.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_modules/pymunk/autogeometry.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_modules/pymunk/bb.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_modules/pymunk/body.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_modules/pymunk/collision_handler.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_modules/pymunk/constraints.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_modules/pymunk/contact_point_set.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_modules/pymunk/matplotlib_util.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_modules/pymunk/pygame_util.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_modules/pymunk/pyglet_util.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_modules/pymunk/query_info.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_modules/pymunk/shapes.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_modules/pymunk/shape_filter.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_modules/pymunk/space.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_modules/pymunk/space_debug_draw_options.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_modules/pymunk/tests.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_modules/pymunk/transform.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_modules/pymunk/vec2d.html
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_sources/tutorials/
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_sources/advanced.rst.txt
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_sources/benchmarks.rst.txt
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_sources/changelog.rst.txt
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_sources/examples.rst.txt
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_sources/index.rst.txt
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_sources/installation.rst.txt
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_sources/license.rst.txt
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_sources/overview.rst.txt
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_sources/pymunk.autogeometry.rst.txt
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_sources/pymunk.constraints.rst.txt
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_sources/pymunk.examples.rst.txt
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_sources/pymunk.matplotlib_util.rst.txt
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_sources/pymunk.pygame_util.rst.txt
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_sources/pymunk.pyglet_util.rst.txt
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_sources/pymunk.rst.txt
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_sources/pymunk.tests.rst.txt
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_sources/pymunk.vec2d.rst.txt
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_sources/showcase.rst.txt
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_sources/tutorials.rst.txt
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_sources/tutorials/SlideAndPinJoint.rst.txt
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/bd-2021/
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/examples/
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/tutorials/
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/aimoveneat.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/alabaster.css
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/ambient-chimes.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/angry-birds-python.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/ar-physics.jpg
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/arcade-library.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/basic.css
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/beneath-the-ice.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/billiARds.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/bouncingballs-beatuifulpatterns.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/carconf.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/carrom-rl.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/custom.css
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/doctools.js
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/documentation_options.js
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/file.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/galtonBoard.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/guide-the-ball.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/invisipin.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/jquery-3.6.0.js
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/jquery.js
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/language_data.js
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/legged_robot.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/manim-physics.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/minus.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/My_Sincerest_Apologies.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/plus.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/pygments.css
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/pymunk.js
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/pymunk_favicon.ico
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/pymunk_logo_animation.gif
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/pymunk_logo_googlecode.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/pymunk_logo_sphinx.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/pyphysicssandbox.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/PySimpleGUI.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/reinforcement-learning-car.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/searchtools.js
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/sphinx_highlight.js
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/SubTerrex.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/underscore-1.13.1.js
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/underscore.js
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/virtuaplant.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/_sphinx_javascript_frameworks_compat.js
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/bd-2021/bd-2021.js
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/examples/arrows.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/examples/balls_and_lines.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/examples/bouncing_balls.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/examples/box2d_pyramid.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/examples/box2d_vertical_stack.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/examples/breakout.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/examples/camera.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/examples/constraints.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/examples/contact_and_no_flipy.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/examples/contact_with_friction.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/examples/copy_and_pickle.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/examples/damped_rotary_spring_pointer.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/examples/deformable.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/examples/flipper.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/examples/index_video.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/examples/kivy_pymunk_demo.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/examples/matplotlib_util_demo.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/examples/newtons_cradle.mp4
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/examples/newtons_cradle.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/examples/planet.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/examples/platformer.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/examples/playground.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/examples/point_query.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/examples/pygame_util_demo.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/examples/pyglet_util_demo.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/examples/slide_and_pinjoint.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/examples/spiderweb.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/examples/tank.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/examples/using_sprites.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/examples/using_sprites_pyglet.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/tutorials/external_pyboxes.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/html/_static/tutorials/slide_and_pinjoint.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/ext/
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/tutorials/
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_templates/
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/advanced.rst
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/benchmarks.rst
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/changelog.rst
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/conf.py
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/examples.rst
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/index.rst
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/installation.rst
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/license.rst
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/make.bat
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/Makefile
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/news.rst.hidden
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/overview.rst
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/pymunk.autogeometry.rst
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/pymunk.constraints.rst
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/pymunk.examples.rst
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/pymunk.matplotlib_util.rst
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/pymunk.pygame_util.rst
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/pymunk.pyglet_util.rst
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/pymunk.rst
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/pymunk.tests.rst
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/pymunk.vec2d.rst
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/showcase.rst
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/tutorials.rst
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/ext/autoexample.py
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/ext/__init__.py
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/tutorials/Arrows.rst.inactive
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/tutorials/SlideAndPinJoint.rst
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/tutorials/StackingGameKivy.rst.incomplete
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/bd-2021/
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/examples/
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/tutorials/
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/aimoveneat.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/ambient-chimes.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/angry-birds-python.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/ar-physics.jpg
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/arcade-library.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/beneath-the-ice.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/billiARds.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/bouncingballs-beatuifulpatterns.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/carconf.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/carrom-rl.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/custom.css
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/galtonBoard.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/guide-the-ball.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/invisipin.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/legged_robot.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/manim-physics.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/My_Sincerest_Apologies.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/pymunk.js
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/pymunk_favicon.ico
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/pymunk_logo_animation.gif
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/pymunk_logo_googlecode.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/pymunk_logo_sphinx.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/pyphysicssandbox.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/PySimpleGUI.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/reinforcement-learning-car.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/SubTerrex.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/virtuaplant.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/bd-2021/bd-2021.js
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/examples/arrows.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/examples/balls_and_lines.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/examples/bouncing_balls.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/examples/box2d_pyramid.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/examples/box2d_vertical_stack.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/examples/breakout.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/examples/camera.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/examples/constraints.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/examples/contact_and_no_flipy.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/examples/contact_with_friction.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/examples/copy_and_pickle.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/examples/damped_rotary_spring_pointer.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/examples/deformable.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/examples/flipper.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/examples/index_video.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/examples/kivy_pymunk_demo.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/examples/matplotlib_util_demo.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/examples/newtons_cradle.mp4
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/examples/newtons_cradle.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/examples/planet.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/examples/platformer.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/examples/playground.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/examples/point_query.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/examples/pygame_util_demo.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/examples/pyglet_util_demo.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/examples/slide_and_pinjoint.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/examples/spiderweb.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/examples/tank.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/examples/using_sprites.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/examples/using_sprites_pyglet.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/tutorials/external_pyboxes.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_static/tutorials/slide_and_pinjoint.png
-Comment: 
-
-Filename: pymunk-6.5.0/docs/src/_templates/badges.html
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/tests/
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/arbiter.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/autogeometry.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/bb.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/body.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/collision_handler.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/constraints.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/contact_point_set.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/matplotlib_util.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/py.typed
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/pygame_util.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/pyglet_util.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/pymunk_extension_build.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/query_info.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/shapes.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/shape_filter.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/space.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/space_debug_draw_options.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/transform.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/util.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/vec2d.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/_callbacks.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/_chipmunk_cffi.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/_pickle.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/_pyglet15_util.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/_types.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/_typing_attr.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/_version.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/__init__.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/arrows.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/balls_and_lines.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/basic_test.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/bouncing_balls.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/box2d_pyramid.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/box2d_vertical_stack.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/breakout.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/camera.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/constraints.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/contact_and_no_flipy.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/contact_with_friction.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/copy_and_pickle.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/damped_rotary_spring_pointer.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/deformable.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/flipper.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/index_video.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/matplotlib_util_demo.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/newtons_cradle.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/planet.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/platformer.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/playground.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/point_query.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/pygame_util_demo.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/pyglet_util_demo.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/pymunk_logo_googlecode.png
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/pymunk_logo_sphinx.png
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/sfx.wav
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/shapes_for_draw_demos.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/slide_and_pinjoint.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/spiderweb.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/tank.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/threaded_space.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/using_sprites.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/using_sprites_pyglet.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/xmasgirl1.png
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/__init__.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/examples/__main__.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/tests/doctests.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/tests/test_arbiter.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/tests/test_autogeometry.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/tests/test_bb.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/tests/test_body.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/tests/test_common.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/tests/test_constraint.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/tests/test_shape.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/tests/test_shape_filter.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/tests/test_space.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/tests/test_space_debug_draw_options.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/tests/test_transform.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/tests/test_vec2d.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/tests/__init__.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk/tests/__main__.py
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk.egg-info/dependency_links.txt
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk.egg-info/PKG-INFO
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk.egg-info/requires.txt
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk.egg-info/SOURCES.txt
-Comment: 
-
-Filename: pymunk-6.5.0/pymunk.egg-info/top_level.txt
-Comment: 
-
-Filename: pymunk-6.5.0/tools/create_release_win.py
-Comment: 
-
-Filename: pymunk-6.5.0/tools/generate_docs.py
-Comment: 
-
-Filename: pymunk-6.5.0/tools/update_chipmunk_src.py
+Filename: pymunk-6.5.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## Comparing `pymunk-6.5.0/LICENSE.txt` & `pymunk-6.5.1.dist-info/LICENSE.txt`

 * *Files identical despite different names*

## Comparing `pymunk-6.5.0/PKG-INFO` & `pymunk-6.5.1.dist-info/METADATA`

 * *Files 17% similar despite different names*

```diff
@@ -1,173 +1,180 @@
-Metadata-Version: 2.1
-Name: pymunk
-Version: 6.5.0
-Summary: Pymunk is a easy-to-use pythonic 2d physics library
-Home-page: http://www.pymunk.org
-Author: Victor Blomqvist
-Author-email: vb@viblo.se
-License: MIT License
-Classifier: Development Status :: 5 - Production/Stable
-Classifier: Intended Audience :: Developers
-Classifier: License :: OSI Approved :: MIT License
-Classifier: Operating System :: OS Independent
-Classifier: Programming Language :: Python
-Classifier: Topic :: Games/Entertainment
-Classifier: Topic :: Software Development :: Libraries
-Classifier: Topic :: Software Development :: Libraries :: pygame
-Classifier: Programming Language :: Python :: 3
-Requires-Python: >=3.6
-Provides-Extra: dev
-License-File: LICENSE.txt
-
-Pymunk
-======
-
-.. image::  https://raw.githubusercontent.com/viblo/pymunk/master/docs/src/_static/pymunk_logo_animation.gif
-
-Pymunk is an easy-to-use pythonic 2d physics library that can be used whenever 
-you need 2d rigid body physics from Python. Perfect when you need 2d physics 
-in your game, demo or simulation! It is built on top of the very 
-capable 2d physics library `Chipmunk <http://chipmunk-physics.net>`_.
-
-The first version was released in 2007 and Pymunk is still actively developed 
-and maintained today, more than 15 years of active development!
-
-Pymunk has been used with success in many projects, big and small. For example: 
-3 Pyweek game competition winners, dozens of published scientific 
-papers and even in a self-driving car simulation! See the Showcases section on 
-the Pymunk webpage for some examples.
-
-2007 - 2023, Victor Blomqvist - vb@viblo.se, MIT License
-
-This release is based on the latest Pymunk release (6.5.0), 
-using Chipmunk 7 rev 5dd7d774053145fa37f352d7a07d2f75a9bd8039.
-
-
-Installation
-------------
-
-In the normal case pymunk can be installed from PyPI with pip::
-
-    > pip install pymunk
-
-It has one direct dependency, CFFI.
-
-Pymunk can also be installed with conda, from the conda-forge channel::
-
-    > conda install -c conda-forge pymunk
-
-For more detailed installation instructions, please see the complete Pymunk 
-documentation.
-
-Example
--------
-
-Quick code example::
-    
-    import pymunk               # Import pymunk..
-
-    space = pymunk.Space()      # Create a Space which contain the simulation
-    space.gravity = 0,-981      # Set its gravity
-
-    body = pymunk.Body()        # Create a Body
-    body.position = 50,100      # Set the position of the body
-
-    poly = pymunk.Poly.create_box(body) # Create a box shape and attach to body
-    poly.mass = 10              # Set the mass on the shape
-    space.add(body, poly)       # Add both body and shape to the simulation
-
-    print_options = pymunk.SpaceDebugDrawOptions() # For easy printing 
-
-    for _ in range(100):        # Run simulation 100 steps in total
-        space.step(0.02)        # Step the simulation one step forward
-        space.debug_draw(print_options) # Print the state of the simulation
-
-This will print (to console) the state of the simulation. For more visual, 
-detailed and advanced examples, take a look at the included demos.  
-They are included in the pymunk install, in the pymunk.examples subpackage. 
-They can be run directly. To list the examples::
-
-    > python -m pymunk.examples -l
-
-And to run one of them::
-
-    > python -m pymunk.examples.breakout
-
-
-Contact & Support
------------------
-.. _contact-support:
-
-**Homepage**
-    http://www.pymunk.org/
-
-**Stackoverflow**
-    You can ask questions/browse old ones at Stackoverflow, just look for 
-    the Pymunk tag. http://stackoverflow.com/questions/tagged/pymunk
-
-**E-Mail**
-    You can email me directly at vb@viblo.se
-
-**Issue Tracker**
-    Please use the issue tracker at github to report any issues you find. This 
-    is also the place for feature requests:
-    https://github.com/viblo/pymunk/issues
-    
-Regardless of the method you use I will try to answer your questions as soon 
-as I see them. (And if you ask on SO other people might help as well!)
-
-
-Documentation
--------------
-
-The full documentation including API reference, showcase of usages and 
-screenshots of examples is available on the Pymunk homepage, 
-http://www.pymunk.org
-
-
-The Pymunk Vision
------------------
-
-    "*Make 2d physics easy to include in your game*"
-
-It is (or is striving to be):
-
-* **Easy to use** - It should be easy to use, no complicated code should be 
-  needed to add physics to your game or program.
-* **"Pythonic"** - It should not be visible that a c-library (Chipmunk) is in 
-  the bottom, it should feel like a Python library (no strange naming, OO, 
-  no memory handling and more)
-* **Simple to build & install** - You shouldn't need to have a zillion of 
-  libraries installed to make it install, or do a lot of command line tricks.
-* **Multi-platform** - Should work on both Windows, \*nix and OSX.
-* **Non-intrusive** - It should not put restrictions on how you structure 
-  your program and not force you to use a special game loop, it should be 
-  possible to use with other libraries like Pygame and Pyglet. 
-
-  
-Dependencies / Requirements
----------------------------
-
-Basically Pymunk have been made to be as easy to install and distribute as 
-possible, usually `pip install` will take care of everything for you.
-
-- Python (Runs on CPython 3.6 and later and Pypy3)
-- Chipmunk (Prebuilt and included when using binary wheels)
-- CFFI (will be installed automatically by Pip)
-- Setuptools (should be included with Pip)
-
-* GCC and friends (optional, you need it to compile Pymunk from source. On 
-  windows Visual Studio is required to compile)
-* Pygame (optional, you need it to run the Pygame based demos)
-* Pyglet (optional, you need it to run the Pyglet based demos)
-* Matplotlib & Jupyter Notebook (optional, you need it to run the Matplotlib 
-  based demos)
-* Sphinx & aafigure & sphinx_autodoc_typehints (optional, you need it to build 
-  documentation)
-
-
-Python 2 Support
-----------------
-
-Support for Python 2 (and Python 3.0 - 3.5) has been dropped with Pymunk 6.0. 
-If you use these legacy versions of Python, please use Pymunk 5.x.
+Metadata-Version: 2.1
+Name: pymunk
+Version: 6.5.1
+Summary: Pymunk is a easy-to-use pythonic 2d physics library
+Home-page: http://www.pymunk.org
+Author: Victor Blomqvist
+Author-email: vb@viblo.se
+License: MIT License
+Classifier: Development Status :: 5 - Production/Stable
+Classifier: Intended Audience :: Developers
+Classifier: License :: OSI Approved :: MIT License
+Classifier: Operating System :: OS Independent
+Classifier: Programming Language :: Python
+Classifier: Topic :: Games/Entertainment
+Classifier: Topic :: Software Development :: Libraries
+Classifier: Topic :: Software Development :: Libraries :: pygame
+Classifier: Programming Language :: Python :: 3
+Requires-Python: >=3.6
+License-File: LICENSE.txt
+Requires-Dist: cffi (>=1.15.0)
+Provides-Extra: dev
+Requires-Dist: pyglet (<2.0.0) ; extra == 'dev'
+Requires-Dist: pygame ; extra == 'dev'
+Requires-Dist: sphinx ; extra == 'dev'
+Requires-Dist: aafigure ; extra == 'dev'
+Requires-Dist: wheel ; extra == 'dev'
+Requires-Dist: matplotlib ; extra == 'dev'
+
+Pymunk
+======
+
+.. image::  https://raw.githubusercontent.com/viblo/pymunk/master/docs/src/_static/pymunk_logo_animation.gif
+
+Pymunk is an easy-to-use pythonic 2d physics library that can be used whenever 
+you need 2d rigid body physics from Python. Perfect when you need 2d physics 
+in your game, demo or simulation! It is built on top of the very 
+capable 2d physics library `Chipmunk <http://chipmunk-physics.net>`_.
+
+The first version was released in 2007 and Pymunk is still actively developed 
+and maintained today, more than 15 years of active development!
+
+Pymunk has been used with success in many projects, big and small. For example: 
+3 Pyweek game competition winners, dozens of published scientific 
+papers and even in a self-driving car simulation! See the Showcases section on 
+the Pymunk webpage for some examples.
+
+2007 - 2023, Victor Blomqvist - vb@viblo.se, MIT License
+
+This release is based on the latest Pymunk release (6.5.1), 
+using Chipmunk 7 rev 5dd7d774053145fa37f352d7a07d2f75a9bd8039.
+
+
+Installation
+------------
+
+In the normal case pymunk can be installed from PyPI with pip::
+
+    > pip install pymunk
+
+It has one direct dependency, CFFI.
+
+Pymunk can also be installed with conda, from the conda-forge channel::
+
+    > conda install -c conda-forge pymunk
+
+For more detailed installation instructions, please see the complete Pymunk 
+documentation.
+
+Example
+-------
+
+Quick code example::
+    
+    import pymunk               # Import pymunk..
+
+    space = pymunk.Space()      # Create a Space which contain the simulation
+    space.gravity = 0,-981      # Set its gravity
+
+    body = pymunk.Body()        # Create a Body
+    body.position = 50,100      # Set the position of the body
+
+    poly = pymunk.Poly.create_box(body) # Create a box shape and attach to body
+    poly.mass = 10              # Set the mass on the shape
+    space.add(body, poly)       # Add both body and shape to the simulation
+
+    print_options = pymunk.SpaceDebugDrawOptions() # For easy printing 
+
+    for _ in range(100):        # Run simulation 100 steps in total
+        space.step(0.02)        # Step the simulation one step forward
+        space.debug_draw(print_options) # Print the state of the simulation
+
+This will print (to console) the state of the simulation. For more visual, 
+detailed and advanced examples, take a look at the included demos.  
+They are included in the pymunk install, in the pymunk.examples subpackage. 
+They can be run directly. To list the examples::
+
+    > python -m pymunk.examples -l
+
+And to run one of them::
+
+    > python -m pymunk.examples.breakout
+
+
+Contact & Support
+-----------------
+.. _contact-support:
+
+**Homepage**
+    http://www.pymunk.org/
+
+**Stackoverflow**
+    You can ask questions/browse old ones at Stackoverflow, just look for 
+    the Pymunk tag. http://stackoverflow.com/questions/tagged/pymunk
+
+**E-Mail**
+    You can email me directly at vb@viblo.se
+
+**Issue Tracker**
+    Please use the issue tracker at github to report any issues you find. This 
+    is also the place for feature requests:
+    https://github.com/viblo/pymunk/issues
+    
+Regardless of the method you use I will try to answer your questions as soon 
+as I see them. (And if you ask on SO other people might help as well!)
+
+
+Documentation
+-------------
+
+The full documentation including API reference, showcase of usages and 
+screenshots of examples is available on the Pymunk homepage, 
+http://www.pymunk.org
+
+
+The Pymunk Vision
+-----------------
+
+    "*Make 2d physics easy to include in your game*"
+
+It is (or is striving to be):
+
+* **Easy to use** - It should be easy to use, no complicated code should be 
+  needed to add physics to your game or program.
+* **"Pythonic"** - It should not be visible that a c-library (Chipmunk) is in 
+  the bottom, it should feel like a Python library (no strange naming, OO, 
+  no memory handling and more)
+* **Simple to build & install** - You shouldn't need to have a zillion of 
+  libraries installed to make it install, or do a lot of command line tricks.
+* **Multi-platform** - Should work on both Windows, \*nix and OSX.
+* **Non-intrusive** - It should not put restrictions on how you structure 
+  your program and not force you to use a special game loop, it should be 
+  possible to use with other libraries like Pygame and Pyglet. 
+
+  
+Dependencies / Requirements
+---------------------------
+
+Basically Pymunk have been made to be as easy to install and distribute as 
+possible, usually `pip install` will take care of everything for you.
+
+- Python (Runs on CPython 3.6 and later and Pypy3)
+- Chipmunk (Prebuilt and included when using binary wheels)
+- CFFI (will be installed automatically by Pip)
+- Setuptools (should be included with Pip)
+
+* GCC and friends (optional, you need it to compile Pymunk from source. On 
+  windows Visual Studio is required to compile)
+* Pygame (optional, you need it to run the Pygame based demos)
+* Pyglet (optional, you need it to run the Pyglet based demos)
+* Matplotlib & Jupyter Notebook (optional, you need it to run the Matplotlib 
+  based demos)
+* Sphinx & aafigure & sphinx_autodoc_typehints (optional, you need it to build 
+  documentation)
+
+
+Python 2 Support
+----------------
+
+Support for Python 2 (and Python 3.0 - 3.5) has been dropped with Pymunk 6.0. 
+If you use these legacy versions of Python, please use Pymunk 5.x.
```

## Comparing `pymunk-6.5.0/additional_examples/no_dependencies.py` & `pymunk/examples/basic_test.py`

 * *Ordering differences only*

 * *Files 15% similar despite different names*

```diff
@@ -1,56 +1,56 @@
-"""Very simple example that does not depend on any third party library such 
-as pygame or pyglet like the other examples. 
-"""
-
-import random
-import sys
-
-import pymunk
-import pymunk.util
-from pymunk import Vec2d
-
-
-def main():
-    print(f"basic example of pymunk {pymunk.version}")
-    space = pymunk.Space()
-    space.gravity = (0.0, -900.0)
-
-    ## Balls
-    balls = []
-
-    ticks_to_next_ball = 10
-    for x in range(5000):
-        ticks_to_next_ball -= 1
-        if ticks_to_next_ball <= 0:
-            ticks_to_next_ball = 10000
-            mass = 10
-            radius = 25
-            inertia = pymunk.moment_for_circle(mass, 0, radius, (0, 0))
-            body = pymunk.Body(mass, inertia)
-            x = random.randint(115, 350)
-            body.position = x, 400
-            shape = pymunk.Circle(body, radius, Vec2d(0, 0))
-            space.add(body, shape)
-            balls.append(shape)
-
-        balls_to_remove = []
-
-        for ball in balls:
-            if ball.body.position.y < 0:
-                balls_to_remove.append(ball)
-        for ball in balls_to_remove:
-            space.remove(ball, ball.body)
-            balls.remove(ball)
-
-        if len(balls) >= 1:
-            v = balls[0].body.position
-            print("(in on_draw): point = %.2f, %.2f" % (v.x, v.y))
-
-        ### Update physics
-        for x in range(1):
-            space.step(1 / 50.0)
-    print("done!")
-
-
-if __name__ == "__main__":
-    sys.exit(main())
+"""Very simple example that does not depend on any third party library such 
+as pygame or pyglet like the other examples. 
+"""
+
+import random
+import sys
+
+import pymunk
+import pymunk.util
+from pymunk import Vec2d
+
+
+def main():
+    print(f"basic example of pymunk {pymunk.version}")
+    space = pymunk.Space()
+    space.gravity = (0.0, -900.0)
+
+    ## Balls
+    balls = []
+
+    ticks_to_next_ball = 10
+    for x in range(5000):
+        ticks_to_next_ball -= 1
+        if ticks_to_next_ball <= 0:
+            ticks_to_next_ball = 10000
+            mass = 10
+            radius = 25
+            inertia = pymunk.moment_for_circle(mass, 0, radius, (0, 0))
+            body = pymunk.Body(mass, inertia)
+            x = random.randint(115, 350)
+            body.position = x, 400
+            shape = pymunk.Circle(body, radius, Vec2d(0, 0))
+            space.add(body, shape)
+            balls.append(shape)
+
+        balls_to_remove = []
+
+        for ball in balls:
+            if ball.body.position.y < 0:
+                balls_to_remove.append(ball)
+        for ball in balls_to_remove:
+            space.remove(ball, ball.body)
+            balls.remove(ball)
+
+        if len(balls) >= 1:
+            v = balls[0].body.position
+            print("(in on_draw): point = %.2f, %.2f" % (v.x, v.y))
+
+        ### Update physics
+        for x in range(1):
+            space.step(1 / 50.0)
+    print("done!")
+
+
+if __name__ == "__main__":
+    sys.exit(main())
```

## Comparing `pymunk-6.5.0/additional_examples/kivy_pymunk_demo/pymunk_logo.png` & `pymunk/examples/pymunk_logo_sphinx.png`

 * *Files identical despite different names*

## Comparing `pymunk-6.5.0/Chipmunk2D/src/prime.h` & `pymunk/_version.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,68 +1,40 @@
-/* Copyright (c) 2013 Scott Lembcke and Howling Moon Software
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- * 
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
-// Used for resizing hash tables.
-// Values approximately double.
-// http://planetmath.org/encyclopedia/GoodHashTablePrimes.html
-static int primes[] = {
-	5,
-	13,
-	23,
-	47,
-	97,
-	193,
-	389,
-	769,
-	1543,
-	3079,
-	6151,
-	12289,
-	24593,
-	49157,
-	98317,
-	196613,
-	393241,
-	786433,
-	1572869,
-	3145739,
-	6291469,
-	12582917,
-	25165843,
-	50331653,
-	100663319,
-	201326611,
-	402653189,
-	805306457,
-	1610612741,
-	0,
-};
-
-static inline int
-next_prime(int n)
-{
-	int i = 0;
-	while(n > primes[i]){
-		i++;
-		cpAssertHard(primes[i], "Tried to resize a hash table to a size greater than 1610612741 O_o"); // realistically this should never happen
-	}
-	
-	return primes[i];
-}
+# ----------------------------------------------------------------------------
+# pymunk
+# Copyright (c) 2007-2020 Victor Blomqvist
+#
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+#
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+# SOFTWARE.
+# ----------------------------------------------------------------------------
+
+"""
+Internal module used to make it possible to import the pymunk verison number 
+from more places than __init__.
+
+"""
+
+from . import _chipmunk_cffi
+
+cp = _chipmunk_cffi.lib
+ffi = _chipmunk_cffi.ffi
+
+version = "6.5.1"
+
+chipmunk_version = "%s-%s" % (
+    ffi.string(cp.cpVersionString).decode("utf-8"),
+    "5dd7d774053145fa37f352d7a07d2f75a9bd8039",
+)
```

## Comparing `pymunk-6.5.0/pymunk/arbiter.py` & `pymunk/arbiter.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,293 +1,293 @@
-__docformat__ = "reStructuredText"
-
-
-from typing import TYPE_CHECKING, Tuple, Dict, List, Any, Iterable, Sequence
-
-if TYPE_CHECKING:
-    from .space import Space
-    from .shapes import Shape
-
-from ._chipmunk_cffi import ffi, lib
-from .contact_point_set import ContactPointSet
-from .vec2d import Vec2d
-
-
-class Arbiter(object):
-    """The Arbiter object encapsulates a pair of colliding shapes and all of
-        the data about their collision.
-
-        They are created when a collision starts, and persist until those
-        shapes are no longer colliding.
-
-    .. Warning::
-        Because arbiters are handled by the space you should never
-        hold onto a reference to an arbiter as you don't know when it will be
-        destroyed! Use them within the callback where they are given to you
-        and then forget about them or copy out the information you need from
-        them.
-    """
-
-    def __init__(self, _arbiter: ffi.CData, space: "Space") -> None:
-        """Initialize an Arbiter object from the Chipmunk equivalent struct
-        and the Space.
-
-        .. note::
-            You should never need to create an instance of this class directly.
-        """
-
-        self._arbiter = _arbiter
-        self._space = space
-
-    def _get_contact_point_set(self) -> ContactPointSet:
-        _set = lib.cpArbiterGetContactPointSet(self._arbiter)
-        return ContactPointSet._from_cp(_set)
-
-    def _set_contact_point_set(self, point_set: ContactPointSet) -> None:
-        # This has to be done by fetching a new Chipmunk point set, update it
-        # according to whats passed in and the pass that back to chipmunk due
-        # to the fact that ContactPointSet doesnt contain a reference to the
-        # corresponding c struct.
-        _set = lib.cpArbiterGetContactPointSet(self._arbiter)
-        _set.normal = point_set.normal
-
-        if len(point_set.points) == _set.count:
-            for i in range(_set.count):
-                _set.points[i].pointA = point_set.points[0].point_a
-                _set.points[i].pointB = point_set.points[0].point_b
-                _set.points[i].distance = point_set.points[0].distance
-        else:
-            msg = "Expected {} points, got {} points in point_set".format(
-                _set.count, len(point_set.points)
-            )
-            raise Exception(msg)
-
-        lib.cpArbiterSetContactPointSet(self._arbiter, ffi.addressof(_set))
-
-    contact_point_set = property(
-        _get_contact_point_set,
-        _set_contact_point_set,
-        doc="""Contact point sets make getting contact information from the 
-        Arbiter simpler.
-        
-        Return `ContactPointSet`""",
-    )
-
-    @property
-    def shapes(self) -> Tuple["Shape", "Shape"]:
-        """Get the shapes in the order that they were defined in the
-        collision handler associated with this arbiter
-        """
-        shapeA_p = ffi.new("cpShape *[1]")
-        shapeB_p = ffi.new("cpShape *[1]")
-
-        lib.cpArbiterGetShapes(self._arbiter, shapeA_p, shapeB_p)
-
-        a, b = self._space._get_shape(shapeA_p[0]), self._space._get_shape(shapeB_p[0])
-        assert a is not None
-        assert b is not None
-        return a, b
-
-    def _get_restitution(self) -> float:
-        return lib.cpArbiterGetRestitution(self._arbiter)
-
-    def _set_restitution(self, restitution: float) -> None:
-        lib.cpArbiterSetRestitution(self._arbiter, restitution)
-
-    restitution = property(
-        _get_restitution,
-        _set_restitution,
-        doc="""The calculated restitution (elasticity) for this collision 
-        pair. 
-        
-        Setting the value in a pre_solve() callback will override the value 
-        calculated by the space. The default calculation multiplies the 
-        elasticity of the two shapes together.
-        """,
-    )
-
-    def _get_friction(self) -> float:
-        return lib.cpArbiterGetFriction(self._arbiter)
-
-    def _set_friction(self, friction: float) -> None:
-        lib.cpArbiterSetFriction(self._arbiter, friction)
-
-    friction = property(
-        _get_friction,
-        _set_friction,
-        doc="""The calculated friction for this collision pair. 
-        
-        Setting the value in a pre_solve() callback will override the value 
-        calculated by the space. The default calculation multiplies the 
-        friction of the two shapes together.
-        """,
-    )
-
-    def _get_surface_velocity(self) -> Vec2d:
-        v = lib.cpArbiterGetSurfaceVelocity(self._arbiter)
-        return Vec2d(v.x, v.y)
-
-    def _set_surface_velocity(self, velocity: Vec2d) -> None:
-        lib.cpArbiterSetSurfaceVelocity(self._arbiter, velocity)
-
-    surface_velocity = property(
-        _get_surface_velocity,
-        _set_surface_velocity,
-        doc="""The calculated surface velocity for this collision pair. 
-        
-        Setting the value in a pre_solve() callback will override the value 
-        calculated by the space. the default calculation subtracts the 
-        surface velocity of the second shape from the first and then projects 
-        that onto the tangent of the collision. This is so that only 
-        friction is affected by default calculation. Using a custom 
-        calculation, you can make something that responds like a pinball 
-        bumper, or where the surface velocity is dependent on the location 
-        of the contact point.
-        """,
-    )
-
-    @property
-    def total_impulse(self) -> Vec2d:
-        """Returns the impulse that was applied this step to resolve the
-        collision.
-
-        This property should only be called from a post-solve or each_arbiter
-        callback.
-        """
-        v = lib.cpArbiterTotalImpulse(self._arbiter)
-        return Vec2d(v.x, v.y)
-
-    @property
-    def total_ke(self) -> float:
-        """The amount of energy lost in a collision including static, but
-        not dynamic friction.
-
-        This property should only be called from a post-solve or each_arbiter callback.
-        """
-        return lib.cpArbiterTotalKE(self._arbiter)
-
-    @property
-    def is_first_contact(self) -> bool:
-        """Returns true if this is the first step the two shapes started
-        touching.
-
-        This can be useful for sound effects for instance. If its the first
-        frame for a certain collision, check the energy of the collision in a
-        post_step() callback and use that to determine the volume of a sound
-        effect to play.
-        """
-        return bool(lib.cpArbiterIsFirstContact(self._arbiter))
-
-    @property
-    def is_removal(self) -> bool:
-        """Returns True during a separate() callback if the callback was
-        invoked due to an object removal.
-        """
-        return bool(lib.cpArbiterIsRemoval(self._arbiter))
-
-    @property
-    def normal(self) -> Vec2d:
-        """Returns the normal of the collision."""
-        v = lib.cpArbiterGetNormal(self._arbiter)
-        return Vec2d(v.x, v.y)
-
-
-def _contacts_to_dicts(
-    _contacts: Sequence[ffi.CData], count: int
-) -> List[Dict[str, Any]]:
-    res = []
-    for i in range(count):
-        res.append(_contact_to_dict(_contacts[i]))
-    return res
-
-
-def _contact_to_dict(_contact: ffi.CData) -> Dict[str, Any]:
-    d = {}
-    d["r1"] = _contact.r1.x, _contact.r1.y
-    d["r2"] = _contact.r2.x, _contact.r2.y
-    d["nMass"] = _contact.nMass
-    d["tMass"] = _contact.tMass
-    d["bounce"] = _contact.bounce
-    d["jnAcc"] = _contact.jnAcc
-    d["jtAcc"] = _contact.jtAcc
-    d["jBias"] = _contact.jBias
-    d["bias"] = _contact.bias
-    d["hash"] = _contact.hash
-    return d
-
-
-def _contacts_from_dicts(ds: Sequence[Dict[str, Any]]) -> List[ffi.CData]:
-    _contacts = lib.cpContactArrAlloc(len(ds))
-    for i in range(len(ds)):
-        _contact = _contacts[i]
-        d = ds[i]
-        _contact.r1.x = d["r1"][0]
-        _contact.r1.y = d["r1"][1]
-        _contact.r2.x = d["r2"][0]
-        _contact.r2.y = d["r2"][1]
-        _contact.nMass = d["nMass"]
-        _contact.tMass = d["tMass"]
-        _contact.bounce = d["bounce"]
-        _contact.jnAcc = d["jnAcc"]
-        _contact.jtAcc = d["jtAcc"]
-        _contact.jBias = d["jBias"]
-        _contact.bias = d["bias"]
-        _contact.hash = d["hash"]
-    return _contacts
-
-
-def _arbiter_from_dict(d: Dict[str, Any], space: "Space") -> ffi.CData:
-    _arb = lib.cpArbiterNew(
-        d["a"]._shape, d["b"]._shape
-    )  # this will also set the bodies
-
-    _arb.e = d["e"]
-    _arb.u = d["u"]
-    _arb.surface_vr = d["surface_vr"]
-
-    _arb.count = d["count"]
-    _arb.contacts = _contacts_from_dicts(d["contacts"])
-
-    _arb.n = d["n"]
-
-    _arb.swapped = d["swapped"]
-    _arb.stamp = d["stamp"]
-    _arb.state = d["state"]
-    return _arb
-
-
-def _arbiter_to_dict(_arbiter: ffi.CData, space: "Space") -> Dict[str, Any]:
-    d = {}
-    d["e"] = _arbiter.e
-    d["u"] = _arbiter.u
-    d["surface_vr"] = (_arbiter.surface_vr.x, _arbiter.surface_vr.y)
-
-    cp_bodies = {}
-    cp_shapes = {}
-
-    for body in space.bodies:
-        cp_bodies[body._body] = body
-    for shape in space.shapes:
-        cp_shapes[shape._shape] = shape
-
-    # cpDataPointer data;
-
-    d["a"] = cp_shapes[_arbiter.a]
-    d["b"] = cp_shapes[_arbiter.b]
-
-    # these are not needed, since they can be fetched from the shapes
-    # d['body_a'] = cp_bodies[_arbiter.body_a]
-    # d['body_b'] = cp_bodies[_arbiter.body_b]
-
-    # struct cpArbiterThread thread_a, thread_b;
-
-    d["count"] = _arbiter.count
-    d["contacts"] = _contacts_to_dicts(_arbiter.contacts, _arbiter.count)
-    d["n"] = _arbiter.n.x, _arbiter.n.y
-
-    # // Regular, wildcard A and wildcard B collision handlers.
-    # cpCollisionHandler *handler, *handlerA, *handlerB;
-
-    d["swapped"] = _arbiter.swapped
-    d["stamp"] = _arbiter.stamp
-    d["state"] = _arbiter.state
-    return d
+__docformat__ = "reStructuredText"
+
+
+from typing import TYPE_CHECKING, Tuple, Dict, List, Any, Iterable, Sequence
+
+if TYPE_CHECKING:
+    from .space import Space
+    from .shapes import Shape
+
+from ._chipmunk_cffi import ffi, lib
+from .contact_point_set import ContactPointSet
+from .vec2d import Vec2d
+
+
+class Arbiter(object):
+    """The Arbiter object encapsulates a pair of colliding shapes and all of
+        the data about their collision.
+
+        They are created when a collision starts, and persist until those
+        shapes are no longer colliding.
+
+    .. Warning::
+        Because arbiters are handled by the space you should never
+        hold onto a reference to an arbiter as you don't know when it will be
+        destroyed! Use them within the callback where they are given to you
+        and then forget about them or copy out the information you need from
+        them.
+    """
+
+    def __init__(self, _arbiter: ffi.CData, space: "Space") -> None:
+        """Initialize an Arbiter object from the Chipmunk equivalent struct
+        and the Space.
+
+        .. note::
+            You should never need to create an instance of this class directly.
+        """
+
+        self._arbiter = _arbiter
+        self._space = space
+
+    def _get_contact_point_set(self) -> ContactPointSet:
+        _set = lib.cpArbiterGetContactPointSet(self._arbiter)
+        return ContactPointSet._from_cp(_set)
+
+    def _set_contact_point_set(self, point_set: ContactPointSet) -> None:
+        # This has to be done by fetching a new Chipmunk point set, update it
+        # according to whats passed in and the pass that back to chipmunk due
+        # to the fact that ContactPointSet doesnt contain a reference to the
+        # corresponding c struct.
+        _set = lib.cpArbiterGetContactPointSet(self._arbiter)
+        _set.normal = point_set.normal
+
+        if len(point_set.points) == _set.count:
+            for i in range(_set.count):
+                _set.points[i].pointA = point_set.points[0].point_a
+                _set.points[i].pointB = point_set.points[0].point_b
+                _set.points[i].distance = point_set.points[0].distance
+        else:
+            msg = "Expected {} points, got {} points in point_set".format(
+                _set.count, len(point_set.points)
+            )
+            raise Exception(msg)
+
+        lib.cpArbiterSetContactPointSet(self._arbiter, ffi.addressof(_set))
+
+    contact_point_set = property(
+        _get_contact_point_set,
+        _set_contact_point_set,
+        doc="""Contact point sets make getting contact information from the 
+        Arbiter simpler.
+        
+        Return `ContactPointSet`""",
+    )
+
+    @property
+    def shapes(self) -> Tuple["Shape", "Shape"]:
+        """Get the shapes in the order that they were defined in the
+        collision handler associated with this arbiter
+        """
+        shapeA_p = ffi.new("cpShape *[1]")
+        shapeB_p = ffi.new("cpShape *[1]")
+
+        lib.cpArbiterGetShapes(self._arbiter, shapeA_p, shapeB_p)
+
+        a, b = self._space._get_shape(shapeA_p[0]), self._space._get_shape(shapeB_p[0])
+        assert a is not None
+        assert b is not None
+        return a, b
+
+    def _get_restitution(self) -> float:
+        return lib.cpArbiterGetRestitution(self._arbiter)
+
+    def _set_restitution(self, restitution: float) -> None:
+        lib.cpArbiterSetRestitution(self._arbiter, restitution)
+
+    restitution = property(
+        _get_restitution,
+        _set_restitution,
+        doc="""The calculated restitution (elasticity) for this collision 
+        pair. 
+        
+        Setting the value in a pre_solve() callback will override the value 
+        calculated by the space. The default calculation multiplies the 
+        elasticity of the two shapes together.
+        """,
+    )
+
+    def _get_friction(self) -> float:
+        return lib.cpArbiterGetFriction(self._arbiter)
+
+    def _set_friction(self, friction: float) -> None:
+        lib.cpArbiterSetFriction(self._arbiter, friction)
+
+    friction = property(
+        _get_friction,
+        _set_friction,
+        doc="""The calculated friction for this collision pair. 
+        
+        Setting the value in a pre_solve() callback will override the value 
+        calculated by the space. The default calculation multiplies the 
+        friction of the two shapes together.
+        """,
+    )
+
+    def _get_surface_velocity(self) -> Vec2d:
+        v = lib.cpArbiterGetSurfaceVelocity(self._arbiter)
+        return Vec2d(v.x, v.y)
+
+    def _set_surface_velocity(self, velocity: Vec2d) -> None:
+        lib.cpArbiterSetSurfaceVelocity(self._arbiter, velocity)
+
+    surface_velocity = property(
+        _get_surface_velocity,
+        _set_surface_velocity,
+        doc="""The calculated surface velocity for this collision pair. 
+        
+        Setting the value in a pre_solve() callback will override the value 
+        calculated by the space. the default calculation subtracts the 
+        surface velocity of the second shape from the first and then projects 
+        that onto the tangent of the collision. This is so that only 
+        friction is affected by default calculation. Using a custom 
+        calculation, you can make something that responds like a pinball 
+        bumper, or where the surface velocity is dependent on the location 
+        of the contact point.
+        """,
+    )
+
+    @property
+    def total_impulse(self) -> Vec2d:
+        """Returns the impulse that was applied this step to resolve the
+        collision.
+
+        This property should only be called from a post-solve or each_arbiter
+        callback.
+        """
+        v = lib.cpArbiterTotalImpulse(self._arbiter)
+        return Vec2d(v.x, v.y)
+
+    @property
+    def total_ke(self) -> float:
+        """The amount of energy lost in a collision including static, but
+        not dynamic friction.
+
+        This property should only be called from a post-solve or each_arbiter callback.
+        """
+        return lib.cpArbiterTotalKE(self._arbiter)
+
+    @property
+    def is_first_contact(self) -> bool:
+        """Returns true if this is the first step the two shapes started
+        touching.
+
+        This can be useful for sound effects for instance. If its the first
+        frame for a certain collision, check the energy of the collision in a
+        post_step() callback and use that to determine the volume of a sound
+        effect to play.
+        """
+        return bool(lib.cpArbiterIsFirstContact(self._arbiter))
+
+    @property
+    def is_removal(self) -> bool:
+        """Returns True during a separate() callback if the callback was
+        invoked due to an object removal.
+        """
+        return bool(lib.cpArbiterIsRemoval(self._arbiter))
+
+    @property
+    def normal(self) -> Vec2d:
+        """Returns the normal of the collision."""
+        v = lib.cpArbiterGetNormal(self._arbiter)
+        return Vec2d(v.x, v.y)
+
+
+def _contacts_to_dicts(
+    _contacts: Sequence[ffi.CData], count: int
+) -> List[Dict[str, Any]]:
+    res = []
+    for i in range(count):
+        res.append(_contact_to_dict(_contacts[i]))
+    return res
+
+
+def _contact_to_dict(_contact: ffi.CData) -> Dict[str, Any]:
+    d = {}
+    d["r1"] = _contact.r1.x, _contact.r1.y
+    d["r2"] = _contact.r2.x, _contact.r2.y
+    d["nMass"] = _contact.nMass
+    d["tMass"] = _contact.tMass
+    d["bounce"] = _contact.bounce
+    d["jnAcc"] = _contact.jnAcc
+    d["jtAcc"] = _contact.jtAcc
+    d["jBias"] = _contact.jBias
+    d["bias"] = _contact.bias
+    d["hash"] = _contact.hash
+    return d
+
+
+def _contacts_from_dicts(ds: Sequence[Dict[str, Any]]) -> List[ffi.CData]:
+    _contacts = lib.cpContactArrAlloc(len(ds))
+    for i in range(len(ds)):
+        _contact = _contacts[i]
+        d = ds[i]
+        _contact.r1.x = d["r1"][0]
+        _contact.r1.y = d["r1"][1]
+        _contact.r2.x = d["r2"][0]
+        _contact.r2.y = d["r2"][1]
+        _contact.nMass = d["nMass"]
+        _contact.tMass = d["tMass"]
+        _contact.bounce = d["bounce"]
+        _contact.jnAcc = d["jnAcc"]
+        _contact.jtAcc = d["jtAcc"]
+        _contact.jBias = d["jBias"]
+        _contact.bias = d["bias"]
+        _contact.hash = d["hash"]
+    return _contacts
+
+
+def _arbiter_from_dict(d: Dict[str, Any], space: "Space") -> ffi.CData:
+    _arb = lib.cpArbiterNew(
+        d["a"]._shape, d["b"]._shape
+    )  # this will also set the bodies
+
+    _arb.e = d["e"]
+    _arb.u = d["u"]
+    _arb.surface_vr = d["surface_vr"]
+
+    _arb.count = d["count"]
+    _arb.contacts = _contacts_from_dicts(d["contacts"])
+
+    _arb.n = d["n"]
+
+    _arb.swapped = d["swapped"]
+    _arb.stamp = d["stamp"]
+    _arb.state = d["state"]
+    return _arb
+
+
+def _arbiter_to_dict(_arbiter: ffi.CData, space: "Space") -> Dict[str, Any]:
+    d = {}
+    d["e"] = _arbiter.e
+    d["u"] = _arbiter.u
+    d["surface_vr"] = (_arbiter.surface_vr.x, _arbiter.surface_vr.y)
+
+    cp_bodies = {}
+    cp_shapes = {}
+
+    for body in space.bodies:
+        cp_bodies[body._body] = body
+    for shape in space.shapes:
+        cp_shapes[shape._shape] = shape
+
+    # cpDataPointer data;
+
+    d["a"] = cp_shapes[_arbiter.a]
+    d["b"] = cp_shapes[_arbiter.b]
+
+    # these are not needed, since they can be fetched from the shapes
+    # d['body_a'] = cp_bodies[_arbiter.body_a]
+    # d['body_b'] = cp_bodies[_arbiter.body_b]
+
+    # struct cpArbiterThread thread_a, thread_b;
+
+    d["count"] = _arbiter.count
+    d["contacts"] = _contacts_to_dicts(_arbiter.contacts, _arbiter.count)
+    d["n"] = _arbiter.n.x, _arbiter.n.y
+
+    # // Regular, wildcard A and wildcard B collision handlers.
+    # cpCollisionHandler *handler, *handlerA, *handlerB;
+
+    d["swapped"] = _arbiter.swapped
+    d["stamp"] = _arbiter.stamp
+    d["state"] = _arbiter.state
+    return d
```

## Comparing `pymunk-6.5.0/pymunk/autogeometry.py` & `pymunk/autogeometry.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,300 +1,300 @@
-"""This module contain functions for automatic generation of geometry, for 
-example from an image.
-
-Example::
-
-    >>> import pymunk
-    >>> from pymunk.autogeometry import march_soft
-    >>> img = [
-    ...     "  xx   ",
-    ...     "  xx   ",
-    ...     "  xx   ",
-    ...     "  xx   ",
-    ...     "  xx   ",
-    ...     "  xxxxx",
-    ...     "  xxxxx",
-    ... ]
-    >>> def sample_func(point):
-    ...     x = int(point[0])
-    ...     y = int(point[1])
-    ...     return 1 if img[y][x] == "x" else 0
-
-    >>> pl_set = march_soft(pymunk.BB(0,0,6,6), 7, 7, .5, sample_func)
-    >>> print(len(pl_set))
-    2
-
-The information in segments can now be used to create geometry, for example as 
-a Pymunk Poly or Segment::
-
-    >>> s = pymunk.Space()
-    >>> for poly_line in pl_set:
-    ...     for i in range(len(poly_line) - 1):
-    ...         a = poly_line[i]
-    ...         b = poly_line[i + 1]
-    ...         segment = pymunk.Segment(s.static_body, a, b, 1)  
-    ...         s.add(segment)
-
-
-"""
-__docformat__ = "reStructuredText"
-
-from typing import TYPE_CHECKING, Callable, List, Sequence, Tuple, Union, overload
-
-if TYPE_CHECKING:
-    from .bb import BB
-
-from . import area_for_poly
-from ._chipmunk_cffi import ffi, lib
-from .vec2d import Vec2d
-
-_SegmentFunc = Callable[[Tuple[float, float], Tuple[float, float]], None]
-_SampleFunc = Callable[[Tuple[float, float]], float]
-
-_Polyline = Union[List[Tuple[float, float]], List[Vec2d]]
-# Union is needed since List is invariant
-# and Sequence cant be used since CFFI requires a List (or Tuple)
-
-
-def _to_chipmunk(polyline: _Polyline) -> ffi.CData:
-    l = len(polyline)
-    _line = ffi.new("cpPolyline *", {"verts": l})
-    _line.count = l
-    _line.capacity = l
-    _line.verts = polyline
-    return _line
-
-
-def _from_polyline_set(_set: ffi.CData) -> List[List[Vec2d]]:
-    lines = []
-    for i in range(_set.count):
-        line = []
-        l = _set.lines[i]
-        for j in range(l.count):
-            line.append(Vec2d(l.verts[j].x, l.verts[j].y))
-        lines.append(line)
-    return lines
-
-
-def is_closed(polyline: _Polyline) -> bool:
-    """Returns true if the first vertex is equal to the last.
-
-    :param polyline: Polyline to simplify.
-    :type polyline: [(float,float)]
-    :rtype: `bool`
-    """
-    return bool(lib.cpPolylineIsClosed(_to_chipmunk(polyline)))
-
-
-def simplify_curves(polyline: _Polyline, tolerance: float) -> List[Vec2d]:
-    """Returns a copy of a polyline simplified by using the Douglas-Peucker
-    algorithm.
-
-    This works very well on smooth or gently curved shapes, but not well on
-    straight edged or angular shapes.
-
-    :param polyline: Polyline to simplify.
-    :type polyline: [(float,float)]
-    :param float tolerance: A higher value means more error is tolerated.
-    :rtype: [(float,float)]
-    """
-
-    _line = lib.cpPolylineSimplifyCurves(_to_chipmunk(polyline), tolerance)
-    simplified = []
-    for i in range(_line.count):
-        simplified.append(Vec2d(_line.verts[i].x, _line.verts[i].y))
-    return simplified
-
-
-def simplify_vertexes(polyline: _Polyline, tolerance: float) -> List[Vec2d]:
-    """Returns a copy of a polyline simplified by discarding "flat" vertexes.
-
-    This works well on straight edged or angular shapes, not as well on smooth
-    shapes.
-
-    :param polyline: Polyline to simplify.
-    :type polyline: [(float,float)]
-    :param float tolerance: A higher value means more error is tolerated.
-    :rtype: [(float,float)]
-    """
-    _line = lib.cpPolylineSimplifyVertexes(_to_chipmunk(polyline), tolerance)
-    simplified = []
-    for i in range(_line.count):
-        simplified.append(Vec2d(_line.verts[i].x, _line.verts[i].y))
-    return simplified
-
-
-def to_convex_hull(polyline: _Polyline, tolerance: float) -> List[Vec2d]:
-    """Get the convex hull of a polyline as a looped polyline.
-
-    :param polyline: Polyline to simplify.
-    :type polyline: [(float,float)]
-    :param float tolerance: A higher value means more error is tolerated.
-    :rtype: [(float,float)]
-    """
-    _line = lib.cpPolylineToConvexHull(_to_chipmunk(polyline), tolerance)
-    hull = []
-    for i in range(_line.count):
-        hull.append(Vec2d(_line.verts[i].x, _line.verts[i].y))
-    return hull
-
-
-def convex_decomposition(polyline: _Polyline, tolerance: float) -> List[List[Vec2d]]:
-    """Get an approximate convex decomposition from a polyline.
-
-    Returns a list of convex hulls that match the original shape to within
-    tolerance.
-
-    .. note::
-        If the input is a self intersecting polygon, the output might end up
-        overly simplified.
-
-    :param polyline: Polyline to simplify.
-    :type polyline: [(float,float)]
-    :param float tolerance: A higher value means more error is tolerated.
-    :rtype: [(float,float)]
-    """
-
-    assert is_closed(polyline), "Cannot decompose an open polygon."
-    assert (
-        area_for_poly(polyline) >= 0
-    ), "Winding is backwards. Try to reverse the vertices. (Are you passing a hole?)"
-
-    _line = _to_chipmunk(polyline)
-    _set = lib.cpPolylineConvexDecomposition(_line, tolerance)
-    return _from_polyline_set(_set)
-
-
-class PolylineSet(Sequence[List[Vec2d]]):
-    """A set of Polylines.
-
-    Mainly intended to be used for its :py:meth:`collect_segment` function
-    when generating geometry with the :py:func:`march_soft` and
-    :py:func:`march_hard` functions.
-    """
-
-    def __init__(self) -> None:
-        """Initalize a new PolylineSet"""
-
-        def free(_set: ffi.CData) -> None:
-            lib.cpPolylineSetFree(_set, True)
-
-        self._set = ffi.gc(lib.cpPolylineSetNew(), free)
-
-    def collect_segment(self, v0: Tuple[float, float], v1: Tuple[float, float]) -> None:
-        """Add a line segment to a polyline set.
-
-        A segment will either start a new polyline, join two others, or add to
-        or loop an existing polyline. This is mostly intended to be used as a
-        callback directly from :py:func:`march_soft` or :py:func:`march_hard`.
-
-        :param v0: Start of segment
-        :type v0: (float,float)
-        :param v1: End of segment
-        :type v1: (float,float)
-        """
-        assert len(v0) == 2
-        assert len(v1) == 2
-
-        lib.cpPolylineSetCollectSegment(v0, v1, self._set)
-
-    def __len__(self) -> int:
-        return self._set.count
-
-    @overload
-    def __getitem__(self, index: int) -> List[Vec2d]:
-        ...
-
-    @overload
-    def __getitem__(self, index: slice) -> "PolylineSet":
-        ...
-
-    def __getitem__(self, key: Union[int, slice]) -> Union[List[Vec2d], "PolylineSet"]:
-        assert not isinstance(key, slice), "Slice indexing not supported"
-        if key >= self._set.count:
-            raise IndexError
-        line = []
-        l = self._set.lines[key]
-        for i in range(l.count):
-            line.append(Vec2d(l.verts[i].x, l.verts[i].y))
-        return line
-
-
-def march_soft(
-    bb: "BB",
-    x_samples: int,
-    y_samples: int,
-    threshold: float,
-    sample_func: _SampleFunc,
-) -> PolylineSet:
-    """Trace an *anti-aliased* contour of an image along a particular threshold.
-
-    The given number of samples will be taken and spread across the bounding
-    box area using the sampling function and context.
-
-    :param BB bb: Bounding box of the area to sample within
-    :param int x_samples: Number of samples in x
-    :param int y_samples: Number of samples in y
-    :param float threshold: A higher value means more error is tolerated
-    :param sample_func: The sample function will be called for
-        x_samples * y_samples spread across the bounding box area, and should
-        return a float.
-    :type sample_func: ``func(point: Tuple[float, float]) -> float``
-    :return: PolylineSet with the polylines found.
-    """
-    pl_set = PolylineSet()
-
-    segment_data = ffi.new_handle(pl_set)
-    sample_data = ffi.new_handle(sample_func)
-
-    lib.cpMarchSoft(
-        bb,
-        x_samples,
-        y_samples,
-        threshold,
-        lib.ext_cpMarchSegmentFunc,
-        segment_data,
-        lib.ext_cpMarchSampleFunc,
-        sample_data,
-    )
-    return pl_set
-
-
-def march_hard(
-    bb: "BB",
-    x_samples: int,
-    y_samples: int,
-    threshold: float,
-    sample_func: _SampleFunc,
-) -> PolylineSet:
-    """Trace an *aliased* curve of an image along a particular threshold.
-
-    The given number of samples will be taken and spread across the bounding
-    box area using the sampling function and context.
-
-    :param BB bb: Bounding box of the area to sample within
-    :param int x_samples: Number of samples in x
-    :param int y_samples: Number of samples in y
-    :param float threshold: A higher value means more error is tolerated
-    :param sample_func: The sample function will be called for
-        x_samples * y_samples spread across the bounding box area, and should
-        return a float.
-    :type sample_func: ``func(point: Tuple[float, float]) -> float``
-    :return: PolylineSet with the polylines found.
-    """
-
-    pl_set = PolylineSet()
-    segment_data = ffi.new_handle(pl_set)
-    sample_data = ffi.new_handle(sample_func)
-
-    lib.cpMarchHard(
-        bb,
-        x_samples,
-        y_samples,
-        threshold,
-        lib.ext_cpMarchSegmentFunc,
-        segment_data,
-        lib.ext_cpMarchSampleFunc,
-        sample_data,
-    )
-
-    return pl_set
+"""This module contain functions for automatic generation of geometry, for 
+example from an image.
+
+Example::
+
+    >>> import pymunk
+    >>> from pymunk.autogeometry import march_soft
+    >>> img = [
+    ...     "  xx   ",
+    ...     "  xx   ",
+    ...     "  xx   ",
+    ...     "  xx   ",
+    ...     "  xx   ",
+    ...     "  xxxxx",
+    ...     "  xxxxx",
+    ... ]
+    >>> def sample_func(point):
+    ...     x = int(point[0])
+    ...     y = int(point[1])
+    ...     return 1 if img[y][x] == "x" else 0
+
+    >>> pl_set = march_soft(pymunk.BB(0,0,6,6), 7, 7, .5, sample_func)
+    >>> print(len(pl_set))
+    2
+
+The information in segments can now be used to create geometry, for example as 
+a Pymunk Poly or Segment::
+
+    >>> s = pymunk.Space()
+    >>> for poly_line in pl_set:
+    ...     for i in range(len(poly_line) - 1):
+    ...         a = poly_line[i]
+    ...         b = poly_line[i + 1]
+    ...         segment = pymunk.Segment(s.static_body, a, b, 1)  
+    ...         s.add(segment)
+
+
+"""
+__docformat__ = "reStructuredText"
+
+from typing import TYPE_CHECKING, Callable, List, Sequence, Tuple, Union, overload
+
+if TYPE_CHECKING:
+    from .bb import BB
+
+from . import area_for_poly
+from ._chipmunk_cffi import ffi, lib
+from .vec2d import Vec2d
+
+_SegmentFunc = Callable[[Tuple[float, float], Tuple[float, float]], None]
+_SampleFunc = Callable[[Tuple[float, float]], float]
+
+_Polyline = Union[List[Tuple[float, float]], List[Vec2d]]
+# Union is needed since List is invariant
+# and Sequence cant be used since CFFI requires a List (or Tuple)
+
+
+def _to_chipmunk(polyline: _Polyline) -> ffi.CData:
+    l = len(polyline)
+    _line = ffi.new("cpPolyline *", {"verts": l})
+    _line.count = l
+    _line.capacity = l
+    _line.verts = polyline
+    return _line
+
+
+def _from_polyline_set(_set: ffi.CData) -> List[List[Vec2d]]:
+    lines = []
+    for i in range(_set.count):
+        line = []
+        l = _set.lines[i]
+        for j in range(l.count):
+            line.append(Vec2d(l.verts[j].x, l.verts[j].y))
+        lines.append(line)
+    return lines
+
+
+def is_closed(polyline: _Polyline) -> bool:
+    """Returns true if the first vertex is equal to the last.
+
+    :param polyline: Polyline to simplify.
+    :type polyline: [(float,float)]
+    :rtype: `bool`
+    """
+    return bool(lib.cpPolylineIsClosed(_to_chipmunk(polyline)))
+
+
+def simplify_curves(polyline: _Polyline, tolerance: float) -> List[Vec2d]:
+    """Returns a copy of a polyline simplified by using the Douglas-Peucker
+    algorithm.
+
+    This works very well on smooth or gently curved shapes, but not well on
+    straight edged or angular shapes.
+
+    :param polyline: Polyline to simplify.
+    :type polyline: [(float,float)]
+    :param float tolerance: A higher value means more error is tolerated.
+    :rtype: [(float,float)]
+    """
+
+    _line = lib.cpPolylineSimplifyCurves(_to_chipmunk(polyline), tolerance)
+    simplified = []
+    for i in range(_line.count):
+        simplified.append(Vec2d(_line.verts[i].x, _line.verts[i].y))
+    return simplified
+
+
+def simplify_vertexes(polyline: _Polyline, tolerance: float) -> List[Vec2d]:
+    """Returns a copy of a polyline simplified by discarding "flat" vertexes.
+
+    This works well on straight edged or angular shapes, not as well on smooth
+    shapes.
+
+    :param polyline: Polyline to simplify.
+    :type polyline: [(float,float)]
+    :param float tolerance: A higher value means more error is tolerated.
+    :rtype: [(float,float)]
+    """
+    _line = lib.cpPolylineSimplifyVertexes(_to_chipmunk(polyline), tolerance)
+    simplified = []
+    for i in range(_line.count):
+        simplified.append(Vec2d(_line.verts[i].x, _line.verts[i].y))
+    return simplified
+
+
+def to_convex_hull(polyline: _Polyline, tolerance: float) -> List[Vec2d]:
+    """Get the convex hull of a polyline as a looped polyline.
+
+    :param polyline: Polyline to simplify.
+    :type polyline: [(float,float)]
+    :param float tolerance: A higher value means more error is tolerated.
+    :rtype: [(float,float)]
+    """
+    _line = lib.cpPolylineToConvexHull(_to_chipmunk(polyline), tolerance)
+    hull = []
+    for i in range(_line.count):
+        hull.append(Vec2d(_line.verts[i].x, _line.verts[i].y))
+    return hull
+
+
+def convex_decomposition(polyline: _Polyline, tolerance: float) -> List[List[Vec2d]]:
+    """Get an approximate convex decomposition from a polyline.
+
+    Returns a list of convex hulls that match the original shape to within
+    tolerance.
+
+    .. note::
+        If the input is a self intersecting polygon, the output might end up
+        overly simplified.
+
+    :param polyline: Polyline to simplify.
+    :type polyline: [(float,float)]
+    :param float tolerance: A higher value means more error is tolerated.
+    :rtype: [(float,float)]
+    """
+
+    assert is_closed(polyline), "Cannot decompose an open polygon."
+    assert (
+        area_for_poly(polyline) >= 0
+    ), "Winding is backwards. Try to reverse the vertices. (Are you passing a hole?)"
+
+    _line = _to_chipmunk(polyline)
+    _set = lib.cpPolylineConvexDecomposition(_line, tolerance)
+    return _from_polyline_set(_set)
+
+
+class PolylineSet(Sequence[List[Vec2d]]):
+    """A set of Polylines.
+
+    Mainly intended to be used for its :py:meth:`collect_segment` function
+    when generating geometry with the :py:func:`march_soft` and
+    :py:func:`march_hard` functions.
+    """
+
+    def __init__(self) -> None:
+        """Initalize a new PolylineSet"""
+
+        def free(_set: ffi.CData) -> None:
+            lib.cpPolylineSetFree(_set, True)
+
+        self._set = ffi.gc(lib.cpPolylineSetNew(), free)
+
+    def collect_segment(self, v0: Tuple[float, float], v1: Tuple[float, float]) -> None:
+        """Add a line segment to a polyline set.
+
+        A segment will either start a new polyline, join two others, or add to
+        or loop an existing polyline. This is mostly intended to be used as a
+        callback directly from :py:func:`march_soft` or :py:func:`march_hard`.
+
+        :param v0: Start of segment
+        :type v0: (float,float)
+        :param v1: End of segment
+        :type v1: (float,float)
+        """
+        assert len(v0) == 2
+        assert len(v1) == 2
+
+        lib.cpPolylineSetCollectSegment(v0, v1, self._set)
+
+    def __len__(self) -> int:
+        return self._set.count
+
+    @overload
+    def __getitem__(self, index: int) -> List[Vec2d]:
+        ...
+
+    @overload
+    def __getitem__(self, index: slice) -> "PolylineSet":
+        ...
+
+    def __getitem__(self, key: Union[int, slice]) -> Union[List[Vec2d], "PolylineSet"]:
+        assert not isinstance(key, slice), "Slice indexing not supported"
+        if key >= self._set.count:
+            raise IndexError
+        line = []
+        l = self._set.lines[key]
+        for i in range(l.count):
+            line.append(Vec2d(l.verts[i].x, l.verts[i].y))
+        return line
+
+
+def march_soft(
+    bb: "BB",
+    x_samples: int,
+    y_samples: int,
+    threshold: float,
+    sample_func: _SampleFunc,
+) -> PolylineSet:
+    """Trace an *anti-aliased* contour of an image along a particular threshold.
+
+    The given number of samples will be taken and spread across the bounding
+    box area using the sampling function and context.
+
+    :param BB bb: Bounding box of the area to sample within
+    :param int x_samples: Number of samples in x
+    :param int y_samples: Number of samples in y
+    :param float threshold: A higher value means more error is tolerated
+    :param sample_func: The sample function will be called for
+        x_samples * y_samples spread across the bounding box area, and should
+        return a float.
+    :type sample_func: ``func(point: Tuple[float, float]) -> float``
+    :return: PolylineSet with the polylines found.
+    """
+    pl_set = PolylineSet()
+
+    segment_data = ffi.new_handle(pl_set)
+    sample_data = ffi.new_handle(sample_func)
+
+    lib.cpMarchSoft(
+        bb,
+        x_samples,
+        y_samples,
+        threshold,
+        lib.ext_cpMarchSegmentFunc,
+        segment_data,
+        lib.ext_cpMarchSampleFunc,
+        sample_data,
+    )
+    return pl_set
+
+
+def march_hard(
+    bb: "BB",
+    x_samples: int,
+    y_samples: int,
+    threshold: float,
+    sample_func: _SampleFunc,
+) -> PolylineSet:
+    """Trace an *aliased* curve of an image along a particular threshold.
+
+    The given number of samples will be taken and spread across the bounding
+    box area using the sampling function and context.
+
+    :param BB bb: Bounding box of the area to sample within
+    :param int x_samples: Number of samples in x
+    :param int y_samples: Number of samples in y
+    :param float threshold: A higher value means more error is tolerated
+    :param sample_func: The sample function will be called for
+        x_samples * y_samples spread across the bounding box area, and should
+        return a float.
+    :type sample_func: ``func(point: Tuple[float, float]) -> float``
+    :return: PolylineSet with the polylines found.
+    """
+
+    pl_set = PolylineSet()
+    segment_data = ffi.new_handle(pl_set)
+    sample_data = ffi.new_handle(sample_func)
+
+    lib.cpMarchHard(
+        bb,
+        x_samples,
+        y_samples,
+        threshold,
+        lib.ext_cpMarchSegmentFunc,
+        segment_data,
+        lib.ext_cpMarchSampleFunc,
+        sample_data,
+    )
+
+    return pl_set
```

## Comparing `pymunk-6.5.0/pymunk/body.py` & `pymunk/body.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,747 +1,747 @@
-__docformat__ = "reStructuredText"
-
-import logging
-from typing import (  # Literal,
-    TYPE_CHECKING,
-    Any,
-    Callable,
-    ClassVar,
-    Optional,
-    Set,
-    Tuple,
-    Union,
-)
-from weakref import WeakSet
-
-if TYPE_CHECKING:
-    from .space import Space
-    from .constraints import Constraint
-    from .shapes import Shape
-
-from ._chipmunk_cffi import ffi, lib
-from ._pickle import PickleMixin, _State
-from ._typing_attr import TypingAttrMixing
-from .vec2d import Vec2d
-
-_BodyType = int
-# Literal only available in Python 3.8 and above
-# _BodyType = Literal[
-#    "lib.CP_BODY_TYPE_DYNAMIC", "lib.CP_BODY_TYPE_KINEMATIC", "lib.CP_BODY_TYPE_STATIC"
-# ]
-_PositionFunc = Callable[["Body", float], None]
-_VelocityFunc = Callable[["Body", Vec2d, float, float], None]
-
-_logger = logging.getLogger(__name__)
-
-
-class Body(PickleMixin, TypingAttrMixing, object):
-    """A rigid body
-
-    * Use forces to modify the rigid bodies if possible. This is likely to be
-      the most stable.
-    * Modifying a body's velocity shouldn't necessarily be avoided, but
-      applying large changes can cause strange results in the simulation.
-      Experiment freely, but be warned.
-    * Don't modify a body's position every step unless you really know what
-      you are doing. Otherwise you're likely to get the position/velocity badly
-      out of sync.
-
-    A Body can be copied and pickled. Sleeping bodies that are copied will be
-    awake in the fresh copy. When a Body is copied any spaces, shapes or
-    constraints attached to the body will not be copied.
-    """
-
-    DYNAMIC: ClassVar[int] = lib.CP_BODY_TYPE_DYNAMIC
-    """Dynamic bodies are the default body type.
-
-    They react to collisions,
-    are affected by forces and gravity, and have a finite amount of mass.
-    These are the type of bodies that you want the physics engine to
-    simulate for you. Dynamic bodies interact with all types of bodies
-    and can generate collision callbacks.
-    """
-
-    KINEMATIC: ClassVar[int] = lib.CP_BODY_TYPE_KINEMATIC
-    """Kinematic bodies are bodies that are controlled from your code
-    instead of inside the physics engine.
-
-    They arent affected by gravity and they have an infinite amount of mass
-    so they don't react to collisions or forces with other bodies. Kinematic
-    bodies are controlled by setting their velocity, which will cause them
-    to move. Good examples of kinematic bodies might include things like
-    moving platforms. Objects that are touching or jointed to a kinematic
-    body are never allowed to fall asleep.
-    """
-
-    STATIC: ClassVar[int] = lib.CP_BODY_TYPE_STATIC
-    """Static bodies are bodies that never (or rarely) move.
-
-    Using static bodies for things like terrain offers a big performance
-    boost over other body types- because Chipmunk doesn't need to check for
-    collisions between static objects and it never needs to update their
-    collision information. Additionally, because static bodies don't
-    move, Chipmunk knows it's safe to let objects that are touching or
-    jointed to them fall asleep. Generally all of your level geometry
-    will be attached to a static body except for things like moving
-    platforms or doors. Every space provide a built-in static body for
-    your convenience. Static bodies can be moved, but there is a
-    performance penalty as the collision information is recalculated.
-    There is no penalty for having multiple static bodies, and it can be
-    useful for simplifying your code by allowing different parts of your
-    static geometry to be initialized or moved separately.
-    """
-
-    _pickle_attrs_init = PickleMixin._pickle_attrs_init + [
-        "mass",
-        "moment",
-        "body_type",
-    ]
-    _pickle_attrs_general = PickleMixin._pickle_attrs_general + [
-        "force",
-        "angle",
-        "position",
-        "center_of_gravity",
-        "velocity",
-        "angular_velocity",
-        "torque",
-    ]
-    _pickle_attrs_skip = PickleMixin._pickle_attrs_skip + [
-        "is_sleeping",
-        "_velocity_func",
-        "_position_func",
-    ]
-
-    _position_func: Optional[_PositionFunc] = None
-    _velocity_func: Optional[_VelocityFunc] = None
-
-    _id_counter = 1
-
-    def __init__(
-        self, mass: float = 0, moment: float = 0, body_type: _BodyType = DYNAMIC
-    ) -> None:
-        """Create a new Body
-
-        Mass and moment are ignored when body_type is KINEMATIC or STATIC.
-
-        Guessing the mass for a body is usually fine, but guessing a moment
-        of inertia can lead to a very poor simulation so it's recommended to
-        use Chipmunk's moment calculations to estimate the moment for you.
-
-        There are two ways to set up a dynamic body. The easiest option is to
-        create a body with a mass and moment of 0, and set the mass or
-        density of each collision shape added to the body. Chipmunk will
-        automatically calculate the mass, moment of inertia, and center of
-        gravity for you. This is probably preferred in most cases. Note that
-        these will only be correctly calculated after the body and shape are
-        added to a space.
-
-        The other option is to set the mass of the body when it's created,
-        and leave the mass of the shapes added to it as 0.0. This approach is
-        more flexible, but is not as easy to use. Don't set the mass of both
-        the body and the shapes. If you do so, it will recalculate and
-        overwrite your custom mass value when the shapes are added to the body.
-
-        Examples of the different ways to set up the mass and moment:
-
-        >>> import pymunk
-        >>> radius = 2
-        >>> mass = 3
-        >>> density = 3
-        >>> def print_mass_moment(b):
-        ...    print("mass={:.0f} moment={:.0f}".format(b.mass, b.moment))
-
-        >>> # Using Shape.density
-        >>> s = pymunk.Space()
-        >>> b = pymunk.Body()
-        >>> c = pymunk.Circle(b, radius)
-        >>> c.density = density
-        >>> print_mass_moment(b)
-        mass=0 moment=0
-        >>> s.add(b, c)
-        >>> print_mass_moment(b)
-        mass=38 moment=75
-
-        >>> # Using Shape.mass
-        >>> b = pymunk.Body()
-        >>> c = pymunk.Circle(b, radius)
-        >>> c.mass = mass
-        >>> print_mass_moment(b)
-        mass=0 moment=0
-        >>> s.add(b, c)
-        >>> print_mass_moment(b)
-        mass=3 moment=6
-
-        >>> # Using Body constructor
-        >>> moment = pymunk.moment_for_circle(mass, 0, radius)
-        >>> b = pymunk.Body()
-        >>> c = pymunk.Circle(b, radius)
-        >>> c.mass = mass
-        >>> print_mass_moment(b)
-        mass=0 moment=0
-        >>> s.add(b, c)
-        >>> print_mass_moment(b)
-        mass=3 moment=6
-
-        It becomes even more useful to use the mass or density properties of
-        the shape when you attach multiple shapes to one body, like in this
-        example with density:
-
-        >>> # Using multiple Shape.density
-        >>> b = pymunk.Body()
-        >>> c1 = pymunk.Circle(b, radius, offset=(10,0))
-        >>> c1.density = density
-        >>> c2 = pymunk.Circle(b, radius, offset=(0,10))
-        >>> c2.density = density
-        >>> s.add(b, c1, c2)
-        >>> print_mass_moment(b)
-        mass=75 moment=3921
-
-        """
-
-        def freebody(cp_body):  # type: ignore
-            _logger.debug("bodyfree start %s", cp_body)
-
-            # remove all shapes on this body from the space
-            lib.cpBodyEachShape(cp_body, lib.ext_cpBodyShapeIteratorFunc, ffi.NULL)
-
-            # remove all constraints on this body from the space
-            lib.cpBodyEachConstraint(
-                cp_body, lib.ext_cpBodyConstraintIteratorFunc, ffi.NULL
-            )
-
-            cp_space = lib.cpBodyGetSpace(cp_body)
-            _logger.debug("bodyfree space %s", cp_space)
-            # print(cp_space, cp_space == ffi.NULL)
-            if cp_space != ffi.NULL:
-                _logger.debug("bodyfree space remove body %s %s", cp_space, cp_body)
-                lib.cpSpaceRemoveBody(cp_space, cp_body)
-
-            _logger.debug("bodyfree free %s", cp_body)
-            lib.cpBodyFree(cp_body)
-
-        if body_type == Body.DYNAMIC:
-            self._body = ffi.gc(lib.cpBodyNew(mass, moment), freebody)
-        elif body_type == Body.KINEMATIC:
-            self._body = ffi.gc(lib.cpBodyNewKinematic(), freebody)
-        elif body_type == Body.STATIC:
-            self._body = ffi.gc(lib.cpBodyNewStatic(), freebody)
-
-        self._position_func = None
-        self._velocity_func = None
-
-        self._space: Optional[
-            "Space"
-        ] = None  # Weak ref to the space holding this body (if any)
-
-        self._constraints: WeakSet[
-            "Constraint"
-        ] = WeakSet()  # weak refs to any constraints attached
-        self._shapes: WeakSet["Shape"] = WeakSet()  # weak refs to any shapes attached
-
-        d = ffi.new_handle(self)
-        self._data_handle = d  # to prevent gc to collect the handle
-        lib.cpBodySetUserData(self._body, d)
-
-        # self._set_id()
-
-    # @property
-    # def _id(self) -> int:
-    #     """Unique id of the Body
-
-    #     .. note::
-    #         Experimental API. Likely to change in future major, minor or point
-    #         releases.
-    #     """
-    #     return int(ffi.cast("int", lib.cpBodyGetUserData(self._body)))
-
-    # def _set_id(self) -> None:
-
-    #     Body._id_counter += 1
-
-    def __repr__(self) -> str:
-        if self.body_type == Body.DYNAMIC:
-            return "Body(%r, %r, Body.DYNAMIC)" % (self.mass, self.moment)
-        elif self.body_type == Body.KINEMATIC:
-            return "Body(Body.KINEMATIC)"
-        else:
-            return "Body(Body.STATIC)"
-
-    def _set_mass(self, mass: float) -> None:
-        lib.cpBodySetMass(self._body, mass)
-
-    def _get_mass(self) -> float:
-        return lib.cpBodyGetMass(self._body)
-
-    mass = property(_get_mass, _set_mass, doc="""Mass of the body.""")
-
-    def _set_moment(self, moment: float) -> None:
-        lib.cpBodySetMoment(self._body, moment)
-
-    def _get_moment(self) -> float:
-        return lib.cpBodyGetMoment(self._body)
-
-    moment = property(
-        _get_moment,
-        _set_moment,
-        doc="""Moment of inertia (MoI or sometimes just moment) of the body.
-
-        The moment is like the rotational mass of a body.
-        """,
-    )
-
-    def _set_position(self, pos: Union[Vec2d, Tuple[float, float]]) -> None:
-        assert len(pos) == 2
-        lib.cpBodySetPosition(self._body, pos)
-
-    def _get_position(self) -> Vec2d:
-        v = lib.cpBodyGetPosition(self._body)
-        return Vec2d(v.x, v.y)
-
-    position = property(
-        _get_position,
-        _set_position,
-        doc="""Position of the body.
-
-        When changing the position you may also want to call
-        :py:func:`Space.reindex_shapes_for_body` to update the collision 
-        detection information for the attached shapes if plan to make any 
-        queries against the space.""",
-    )
-
-    def _set_center_of_gravity(self, cog: Tuple[float, float]) -> None:
-        assert len(cog) == 2
-        lib.cpBodySetCenterOfGravity(self._body, cog)
-
-    def _get_center_of_gravity(self) -> Vec2d:
-        v = lib.cpBodyGetCenterOfGravity(self._body)
-        return Vec2d(v.x, v.y)
-
-    center_of_gravity = property(
-        _get_center_of_gravity,
-        _set_center_of_gravity,
-        doc="""Location of the center of gravity in body local coordinates.
-
-        The default value is (0, 0), meaning the center of gravity is the
-        same as the position of the body.
-        """,
-    )
-
-    def _set_velocity(self, vel: Tuple[float, float]) -> None:
-        assert len(vel) == 2
-        lib.cpBodySetVelocity(self._body, vel)
-
-    def _get_velocity(self) -> Vec2d:
-        v = lib.cpBodyGetVelocity(self._body)
-        return Vec2d(v.x, v.y)
-
-    velocity = property(
-        _get_velocity,
-        _set_velocity,
-        doc="""Linear velocity of the center of gravity of the body.""",
-    )
-
-    def _set_force(self, f: Tuple[float, float]) -> None:
-        assert len(f) == 2
-        lib.cpBodySetForce(self._body, f)
-
-    def _get_force(self) -> Vec2d:
-        v = lib.cpBodyGetForce(self._body)
-        return Vec2d(v.x, v.y)
-
-    force = property(
-        _get_force,
-        _set_force,
-        doc="""Force applied to the center of gravity of the body.
-
-        This value is reset for every time step. Note that this is not the 
-        total of forces acting on the body (such as from collisions), but the 
-        force applied manually from the apply force functions.""",
-    )
-
-    def _set_angle(self, angle: float) -> None:
-        lib.cpBodySetAngle(self._body, angle)
-
-    def _get_angle(self) -> float:
-        return lib.cpBodyGetAngle(self._body)
-
-    angle = property(
-        _get_angle,
-        _set_angle,
-        doc="""Rotation of the body in radians.
-
-        When changing the rotation you may also want to call
-        :py:func:`Space.reindex_shapes_for_body` to update the collision 
-        detection information for the attached shapes if plan to make any 
-        queries against the space. A body rotates around its center of gravity, 
-        not its position.
-
-        .. Note::
-            If you get small/no changes to the angle when for example a
-            ball is "rolling" down a slope it might be because the Circle shape
-            attached to the body or the slope shape does not have any friction
-            set.""",
-    )
-
-    def _set_angular_velocity(self, w: float) -> None:
-        lib.cpBodySetAngularVelocity(self._body, w)
-
-    def _get_angular_velocity(self) -> float:
-        return lib.cpBodyGetAngularVelocity(self._body)
-
-    angular_velocity = property(
-        _get_angular_velocity,
-        _set_angular_velocity,
-        doc="""The angular velocity of the body in radians per second.""",
-    )
-
-    def _set_torque(self, t: float) -> None:
-        lib.cpBodySetTorque(self._body, t)
-
-    def _get_torque(self) -> float:
-        return lib.cpBodyGetTorque(self._body)
-
-    torque = property(
-        _get_torque,
-        _set_torque,
-        doc="""The torque applied to the body.
-
-        This value is reset for every time step.""",
-    )
-
-    def _get_rotation_vector(self) -> Vec2d:
-        v = lib.cpBodyGetRotation(self._body)
-        return Vec2d(v.x, v.y)
-
-    rotation_vector = property(
-        _get_rotation_vector, doc="""The rotation vector for the body."""
-    )
-
-    @property
-    def space(self) -> Optional["Space"]:
-        """Get the :py:class:`Space` that the body has been added to (or
-        None)."""
-        if self._space is not None:
-            return self._space._get_self()  # ugly hack because of weakref
-        else:
-            return None
-
-    def _set_velocity_func(self, func: _VelocityFunc) -> None:
-        self._velocity_func = func
-        lib.cpBodySetVelocityUpdateFunc(self._body, lib.ext_cpBodyVelocityFunc)
-
-    velocity_func = property(
-        fset=_set_velocity_func,
-        doc="""The velocity callback function. 
-        
-        The velocity callback function is called each time step, and can be 
-        used to set a body's velocity.
-
-            ``func(body : Body, gravity, damping, dt)``
-
-        There are many cases when this can be useful. One example is individual 
-        gravity for some bodies, and another is to limit the velocity which is 
-        useful to prevent tunneling. 
-        
-        Example of a callback that sets gravity to zero for a object.
-
-        >>> import pymunk
-        >>> space = pymunk.Space()
-        >>> space.gravity = 0, 10
-        >>> body = pymunk.Body(1,2)
-        >>> space.add(body)
-        >>> def zero_gravity(body, gravity, damping, dt):
-        ...     pymunk.Body.update_velocity(body, (0,0), damping, dt)
-        ... 
-        >>> body.velocity_func = zero_gravity
-        >>> space.step(1)
-        >>> space.step(1)
-        >>> print(body.position, body.velocity)
-        Vec2d(0.0, 0.0) Vec2d(0.0, 0.0)
-
-        Example of a callback that limits the velocity:
-
-        >>> import pymunk
-        >>> body = pymunk.Body(1,2)
-        >>> def limit_velocity(body, gravity, damping, dt):
-        ...     max_velocity = 1000
-        ...     pymunk.Body.update_velocity(body, gravity, damping, dt)
-        ...     l = body.velocity.length
-        ...     if l > max_velocity:
-        ...         scale = max_velocity / l
-        ...         body.velocity = body.velocity * scale
-        ...
-        >>> body.velocity_func = limit_velocity
-
-        """,
-    )
-
-    def _set_position_func(self, func: Callable[["Body", float], None]) -> None:
-        self._position_func = func
-        lib.cpBodySetPositionUpdateFunc(self._body, lib.ext_cpBodyPositionFunc)
-
-    position_func = property(
-        fset=_set_position_func,
-        doc="""The position callback function. 
-        
-        The position callback function is called each time step and can be 
-        used to update the body's position.
-
-            ``func(body, dt) -> None``
-        """,
-    )
-
-    @property
-    def kinetic_energy(self) -> float:
-        """Get the kinetic energy of a body."""
-        # todo: use ffi method
-        # return lib._cpBodyKineticEnergy(self._body)
-
-        vsq: float = self.velocity.dot(self.velocity)
-        wsq: float = self.angular_velocity * self.angular_velocity
-        return (vsq * self.mass if vsq else 0.0) + (wsq * self.moment if wsq else 0.0)
-
-    @staticmethod
-    def update_velocity(
-        body: "Body", gravity: Tuple[float, float], damping: float, dt: float
-    ) -> None:
-        """Default rigid body velocity integration function.
-
-        Updates the velocity of the body using Euler integration.
-        """
-        assert len(gravity) == 2
-        lib.cpBodyUpdateVelocity(body._body, gravity, damping, dt)
-
-    @staticmethod
-    def update_position(body: "Body", dt: float) -> None:
-        """Default rigid body position integration function.
-
-        Updates the position of the body using Euler integration. Unlike the
-        velocity function, it's unlikely you'll want to override this
-        function. If you do, make sure you understand it's source code
-        (in Chipmunk) as it's an important part of the collision/joint
-        correction process.
-        """
-        lib.cpBodyUpdatePosition(body._body, dt)
-
-    def apply_force_at_world_point(
-        self, force: Tuple[float, float], point: Tuple[float, float]
-    ) -> None:
-        """Add the force force to body as if applied from the world point.
-
-        People are sometimes confused by the difference between a force and
-        an impulse. An impulse is a very large force applied over a very
-        short period of time. Some examples are a ball hitting a wall or
-        cannon firing. Chipmunk treats impulses as if they occur
-        instantaneously by adding directly to the velocity of an object.
-        Both impulses and forces are affected the mass of an object. Doubling
-        the mass of the object will halve the effect.
-        """
-        assert len(force) == 2
-        assert len(point) == 2
-        lib.cpBodyApplyForceAtWorldPoint(self._body, force, point)
-
-    def apply_force_at_local_point(
-        self, force: Tuple[float, float], point: Tuple[float, float] = (0, 0)
-    ) -> None:
-        """Add the local force force to body as if applied from the body
-        local point.
-        """
-        assert len(force) == 2
-        assert len(point) == 2
-        lib.cpBodyApplyForceAtLocalPoint(self._body, force, point)
-
-    def apply_impulse_at_world_point(
-        self, impulse: Tuple[float, float], point: Tuple[float, float]
-    ) -> None:
-        """Add the impulse impulse to body as if applied from the world point."""
-        assert len(impulse) == 2
-        assert len(point) == 2
-        lib.cpBodyApplyImpulseAtWorldPoint(self._body, impulse, point)
-
-    def apply_impulse_at_local_point(
-        self, impulse: Tuple[float, float], point: Tuple[float, float] = (0, 0)
-    ) -> None:
-        """Add the local impulse impulse to body as if applied from the body
-        local point.
-        """
-        assert len(impulse) == 2
-        assert len(point) == 2
-        lib.cpBodyApplyImpulseAtLocalPoint(self._body, impulse, point)
-
-    def activate(self) -> None:
-        """Reset the idle timer on a body.
-
-        If it was sleeping, wake it and any other bodies it was touching.
-        """
-        lib.cpBodyActivate(self._body)
-
-    def sleep(self) -> None:
-        """Forces a body to fall asleep immediately even if it's in midair.
-
-        Cannot be called from a callback.
-        """
-        if self._space == None:
-            raise Exception("Body not added to space")
-        lib.cpBodySleep(self._body)
-
-    def sleep_with_group(self, body: "Body") -> None:
-        """Force a body to fall asleep immediately along with other bodies
-        in a group.
-
-        When objects in Pymunk sleep, they sleep as a group of all objects
-        that are touching or jointed together. When an object is woken up,
-        all of the objects in its group are woken up.
-        :py:func:`Body.sleep_with_group` allows you group sleeping objects
-        together. It acts identically to :py:func:`Body.sleep` if you pass
-        None as group by starting a new group. If you pass a sleeping body
-        for group, body will be awoken when group is awoken. You can use this
-        to initialize levels and start stacks of objects in a pre-sleeping
-        state.
-        """
-        if self._space == None:
-            raise Exception("Body not added to space")
-        lib.cpBodySleepWithGroup(self._body, body._body)
-
-    @property
-    def is_sleeping(self) -> bool:
-        """Returns true if the body is sleeping."""
-        return bool(lib.cpBodyIsSleeping(self._body))
-
-    def _set_type(self, body_type: _BodyType) -> None:
-        lib.cpBodySetType(self._body, body_type)
-
-    def _get_type(self) -> _BodyType:
-        return lib.cpBodyGetType(self._body)
-
-    body_type = property(
-        _get_type,
-        _set_type,
-        doc="""The type of a body (:py:const:`Body.DYNAMIC`, 
-        :py:const:`Body.KINEMATIC` or :py:const:`Body.STATIC`).
-
-        When changing an body to a dynamic body, the mass and moment of
-        inertia are recalculated from the shapes added to the body. Custom
-        calculated moments of inertia are not preserved when changing types.
-        This function cannot be called directly in a collision callback.
-        """,
-    )
-
-    def each_arbiter(
-        self,
-        func: Callable[..., None],  # TODO: Fix me once PEP 612 is ready
-        *args: Any,
-        **kwargs: Any
-    ) -> None:
-        """Run func on each of the arbiters on this body.
-
-            ``func(arbiter, *args, **kwargs) -> None``
-
-            Callback Parameters
-                arbiter : :py:class:`Arbiter`
-                    The Arbiter
-                args
-                    Optional parameters passed to the callback function.
-                kwargs
-                    Optional keyword parameters passed on to the callback function.
-
-        .. warning::
-
-            Do not hold on to the Arbiter after the callback!
-        """
-        d = self, func, args, kwargs
-        data = ffi.new_handle(d)
-        lib.cpBodyEachArbiter(self._body, lib.ext_cpBodyArbiterIteratorFunc, data)
-
-    @property
-    def constraints(self) -> Set["Constraint"]:
-        """Get the constraints this body is attached to.
-
-        It is not possible to detach a body from a constraint. The only way is
-        to delete the constraint fully by removing it from any spaces and
-        remove any other references to it. The body only keeps a weak
-        reference to the constraint, meaning that the when all other
-        references to the constraint are removed and the constraint is garbage
-        collected it will automatically be removed from this collection as
-        well.
-        """
-        return set(self._constraints)
-
-    @property
-    def shapes(self) -> Set["Shape"]:
-        """Get the shapes attached to this body.
-
-        The body only keeps a weak reference to the shapes and a live
-        body wont prevent GC of the attached shapes"""
-        return set(self._shapes)
-
-    def local_to_world(self, v: Tuple[float, float]) -> Vec2d:
-        """Convert body local coordinates to world space coordinates
-
-        Many things are defined in coordinates local to a body meaning that
-        the (0,0) is at the center of gravity of the body and the axis rotate
-        along with the body.
-
-        :param v: Vector in body local coordinates
-        """
-        assert len(v) == 2
-        v2 = lib.cpBodyLocalToWorld(self._body, v)
-        return Vec2d(v2.x, v2.y)
-
-    def world_to_local(self, v: Tuple[float, float]) -> Vec2d:
-        """Convert world space coordinates to body local coordinates
-
-        :param v: Vector in world space coordinates
-        """
-        assert len(v) == 2
-        v2 = lib.cpBodyWorldToLocal(self._body, v)
-        return Vec2d(v2.x, v2.y)
-
-    def velocity_at_world_point(self, point: Tuple[float, float]) -> Vec2d:
-        """Get the absolute velocity of the rigid body at the given world
-        point
-
-        It's often useful to know the absolute velocity of a point on the
-        surface of a body since the angular velocity affects everything
-        except the center of gravity.
-        """
-        assert len(point) == 2
-        v = lib.cpBodyGetVelocityAtWorldPoint(self._body, point)
-        return Vec2d(v.x, v.y)
-
-    def velocity_at_local_point(self, point: Tuple[float, float]) -> Vec2d:
-        """Get the absolute velocity of the rigid body at the given body
-        local point
-        """
-        assert len(point) == 2
-        v = lib.cpBodyGetVelocityAtLocalPoint(self._body, point)
-        return Vec2d(v.x, v.y)
-
-    def __getstate__(self) -> _State:
-        """Return the state of this object
-
-        This method allows the usage of the :mod:`copy` and :mod:`pickle`
-        modules with this class.
-        """
-        d = super(Body, self).__getstate__()
-
-        d["special"].append(("is_sleeping", self.is_sleeping))
-        d["special"].append(("_velocity_func", self._velocity_func))
-        d["special"].append(("_position_func", self._position_func))
-
-        return d
-
-    def __setstate__(self, state: _State) -> None:
-        """Unpack this object from a saved state.
-
-        This method allows the usage of the :mod:`copy` and :mod:`pickle`
-        modules with this class.
-        """
-        super(Body, self).__setstate__(state)
-
-        for k, v in state["special"]:
-            if k == "is_sleeping" and v:
-                pass
-            elif k == "_velocity_func" and v != None:
-                self.velocity_func = v
-            elif k == "_position_func" and v != None:
-                self.position_func = v
+__docformat__ = "reStructuredText"
+
+import logging
+from typing import (  # Literal,
+    TYPE_CHECKING,
+    Any,
+    Callable,
+    ClassVar,
+    Optional,
+    Set,
+    Tuple,
+    Union,
+)
+from weakref import WeakSet
+
+if TYPE_CHECKING:
+    from .space import Space
+    from .constraints import Constraint
+    from .shapes import Shape
+
+from ._chipmunk_cffi import ffi, lib
+from ._pickle import PickleMixin, _State
+from ._typing_attr import TypingAttrMixing
+from .vec2d import Vec2d
+
+_BodyType = int
+# Literal only available in Python 3.8 and above
+# _BodyType = Literal[
+#    "lib.CP_BODY_TYPE_DYNAMIC", "lib.CP_BODY_TYPE_KINEMATIC", "lib.CP_BODY_TYPE_STATIC"
+# ]
+_PositionFunc = Callable[["Body", float], None]
+_VelocityFunc = Callable[["Body", Vec2d, float, float], None]
+
+_logger = logging.getLogger(__name__)
+
+
+class Body(PickleMixin, TypingAttrMixing, object):
+    """A rigid body
+
+    * Use forces to modify the rigid bodies if possible. This is likely to be
+      the most stable.
+    * Modifying a body's velocity shouldn't necessarily be avoided, but
+      applying large changes can cause strange results in the simulation.
+      Experiment freely, but be warned.
+    * Don't modify a body's position every step unless you really know what
+      you are doing. Otherwise you're likely to get the position/velocity badly
+      out of sync.
+
+    A Body can be copied and pickled. Sleeping bodies that are copied will be
+    awake in the fresh copy. When a Body is copied any spaces, shapes or
+    constraints attached to the body will not be copied.
+    """
+
+    DYNAMIC: ClassVar[int] = lib.CP_BODY_TYPE_DYNAMIC
+    """Dynamic bodies are the default body type.
+
+    They react to collisions,
+    are affected by forces and gravity, and have a finite amount of mass.
+    These are the type of bodies that you want the physics engine to
+    simulate for you. Dynamic bodies interact with all types of bodies
+    and can generate collision callbacks.
+    """
+
+    KINEMATIC: ClassVar[int] = lib.CP_BODY_TYPE_KINEMATIC
+    """Kinematic bodies are bodies that are controlled from your code
+    instead of inside the physics engine.
+
+    They arent affected by gravity and they have an infinite amount of mass
+    so they don't react to collisions or forces with other bodies. Kinematic
+    bodies are controlled by setting their velocity, which will cause them
+    to move. Good examples of kinematic bodies might include things like
+    moving platforms. Objects that are touching or jointed to a kinematic
+    body are never allowed to fall asleep.
+    """
+
+    STATIC: ClassVar[int] = lib.CP_BODY_TYPE_STATIC
+    """Static bodies are bodies that never (or rarely) move.
+
+    Using static bodies for things like terrain offers a big performance
+    boost over other body types- because Chipmunk doesn't need to check for
+    collisions between static objects and it never needs to update their
+    collision information. Additionally, because static bodies don't
+    move, Chipmunk knows it's safe to let objects that are touching or
+    jointed to them fall asleep. Generally all of your level geometry
+    will be attached to a static body except for things like moving
+    platforms or doors. Every space provide a built-in static body for
+    your convenience. Static bodies can be moved, but there is a
+    performance penalty as the collision information is recalculated.
+    There is no penalty for having multiple static bodies, and it can be
+    useful for simplifying your code by allowing different parts of your
+    static geometry to be initialized or moved separately.
+    """
+
+    _pickle_attrs_init = PickleMixin._pickle_attrs_init + [
+        "mass",
+        "moment",
+        "body_type",
+    ]
+    _pickle_attrs_general = PickleMixin._pickle_attrs_general + [
+        "force",
+        "angle",
+        "position",
+        "center_of_gravity",
+        "velocity",
+        "angular_velocity",
+        "torque",
+    ]
+    _pickle_attrs_skip = PickleMixin._pickle_attrs_skip + [
+        "is_sleeping",
+        "_velocity_func",
+        "_position_func",
+    ]
+
+    _position_func: Optional[_PositionFunc] = None
+    _velocity_func: Optional[_VelocityFunc] = None
+
+    _id_counter = 1
+
+    def __init__(
+        self, mass: float = 0, moment: float = 0, body_type: _BodyType = DYNAMIC
+    ) -> None:
+        """Create a new Body
+
+        Mass and moment are ignored when body_type is KINEMATIC or STATIC.
+
+        Guessing the mass for a body is usually fine, but guessing a moment
+        of inertia can lead to a very poor simulation so it's recommended to
+        use Chipmunk's moment calculations to estimate the moment for you.
+
+        There are two ways to set up a dynamic body. The easiest option is to
+        create a body with a mass and moment of 0, and set the mass or
+        density of each collision shape added to the body. Chipmunk will
+        automatically calculate the mass, moment of inertia, and center of
+        gravity for you. This is probably preferred in most cases. Note that
+        these will only be correctly calculated after the body and shape are
+        added to a space.
+
+        The other option is to set the mass of the body when it's created,
+        and leave the mass of the shapes added to it as 0.0. This approach is
+        more flexible, but is not as easy to use. Don't set the mass of both
+        the body and the shapes. If you do so, it will recalculate and
+        overwrite your custom mass value when the shapes are added to the body.
+
+        Examples of the different ways to set up the mass and moment:
+
+        >>> import pymunk
+        >>> radius = 2
+        >>> mass = 3
+        >>> density = 3
+        >>> def print_mass_moment(b):
+        ...    print("mass={:.0f} moment={:.0f}".format(b.mass, b.moment))
+
+        >>> # Using Shape.density
+        >>> s = pymunk.Space()
+        >>> b = pymunk.Body()
+        >>> c = pymunk.Circle(b, radius)
+        >>> c.density = density
+        >>> print_mass_moment(b)
+        mass=0 moment=0
+        >>> s.add(b, c)
+        >>> print_mass_moment(b)
+        mass=38 moment=75
+
+        >>> # Using Shape.mass
+        >>> b = pymunk.Body()
+        >>> c = pymunk.Circle(b, radius)
+        >>> c.mass = mass
+        >>> print_mass_moment(b)
+        mass=0 moment=0
+        >>> s.add(b, c)
+        >>> print_mass_moment(b)
+        mass=3 moment=6
+
+        >>> # Using Body constructor
+        >>> moment = pymunk.moment_for_circle(mass, 0, radius)
+        >>> b = pymunk.Body()
+        >>> c = pymunk.Circle(b, radius)
+        >>> c.mass = mass
+        >>> print_mass_moment(b)
+        mass=0 moment=0
+        >>> s.add(b, c)
+        >>> print_mass_moment(b)
+        mass=3 moment=6
+
+        It becomes even more useful to use the mass or density properties of
+        the shape when you attach multiple shapes to one body, like in this
+        example with density:
+
+        >>> # Using multiple Shape.density
+        >>> b = pymunk.Body()
+        >>> c1 = pymunk.Circle(b, radius, offset=(10,0))
+        >>> c1.density = density
+        >>> c2 = pymunk.Circle(b, radius, offset=(0,10))
+        >>> c2.density = density
+        >>> s.add(b, c1, c2)
+        >>> print_mass_moment(b)
+        mass=75 moment=3921
+
+        """
+
+        def freebody(cp_body):  # type: ignore
+            _logger.debug("bodyfree start %s", cp_body)
+
+            # remove all shapes on this body from the space
+            lib.cpBodyEachShape(cp_body, lib.ext_cpBodyShapeIteratorFunc, ffi.NULL)
+
+            # remove all constraints on this body from the space
+            lib.cpBodyEachConstraint(
+                cp_body, lib.ext_cpBodyConstraintIteratorFunc, ffi.NULL
+            )
+
+            cp_space = lib.cpBodyGetSpace(cp_body)
+            _logger.debug("bodyfree space %s", cp_space)
+            # print(cp_space, cp_space == ffi.NULL)
+            if cp_space != ffi.NULL:
+                _logger.debug("bodyfree space remove body %s %s", cp_space, cp_body)
+                lib.cpSpaceRemoveBody(cp_space, cp_body)
+
+            _logger.debug("bodyfree free %s", cp_body)
+            lib.cpBodyFree(cp_body)
+
+        if body_type == Body.DYNAMIC:
+            self._body = ffi.gc(lib.cpBodyNew(mass, moment), freebody)
+        elif body_type == Body.KINEMATIC:
+            self._body = ffi.gc(lib.cpBodyNewKinematic(), freebody)
+        elif body_type == Body.STATIC:
+            self._body = ffi.gc(lib.cpBodyNewStatic(), freebody)
+
+        self._position_func = None
+        self._velocity_func = None
+
+        self._space: Optional[
+            "Space"
+        ] = None  # Weak ref to the space holding this body (if any)
+
+        self._constraints: WeakSet[
+            "Constraint"
+        ] = WeakSet()  # weak refs to any constraints attached
+        self._shapes: WeakSet["Shape"] = WeakSet()  # weak refs to any shapes attached
+
+        d = ffi.new_handle(self)
+        self._data_handle = d  # to prevent gc to collect the handle
+        lib.cpBodySetUserData(self._body, d)
+
+        # self._set_id()
+
+    # @property
+    # def _id(self) -> int:
+    #     """Unique id of the Body
+
+    #     .. note::
+    #         Experimental API. Likely to change in future major, minor or point
+    #         releases.
+    #     """
+    #     return int(ffi.cast("int", lib.cpBodyGetUserData(self._body)))
+
+    # def _set_id(self) -> None:
+
+    #     Body._id_counter += 1
+
+    def __repr__(self) -> str:
+        if self.body_type == Body.DYNAMIC:
+            return "Body(%r, %r, Body.DYNAMIC)" % (self.mass, self.moment)
+        elif self.body_type == Body.KINEMATIC:
+            return "Body(Body.KINEMATIC)"
+        else:
+            return "Body(Body.STATIC)"
+
+    def _set_mass(self, mass: float) -> None:
+        lib.cpBodySetMass(self._body, mass)
+
+    def _get_mass(self) -> float:
+        return lib.cpBodyGetMass(self._body)
+
+    mass = property(_get_mass, _set_mass, doc="""Mass of the body.""")
+
+    def _set_moment(self, moment: float) -> None:
+        lib.cpBodySetMoment(self._body, moment)
+
+    def _get_moment(self) -> float:
+        return lib.cpBodyGetMoment(self._body)
+
+    moment = property(
+        _get_moment,
+        _set_moment,
+        doc="""Moment of inertia (MoI or sometimes just moment) of the body.
+
+        The moment is like the rotational mass of a body.
+        """,
+    )
+
+    def _set_position(self, pos: Union[Vec2d, Tuple[float, float]]) -> None:
+        assert len(pos) == 2
+        lib.cpBodySetPosition(self._body, pos)
+
+    def _get_position(self) -> Vec2d:
+        v = lib.cpBodyGetPosition(self._body)
+        return Vec2d(v.x, v.y)
+
+    position = property(
+        _get_position,
+        _set_position,
+        doc="""Position of the body.
+
+        When changing the position you may also want to call
+        :py:func:`Space.reindex_shapes_for_body` to update the collision 
+        detection information for the attached shapes if plan to make any 
+        queries against the space.""",
+    )
+
+    def _set_center_of_gravity(self, cog: Tuple[float, float]) -> None:
+        assert len(cog) == 2
+        lib.cpBodySetCenterOfGravity(self._body, cog)
+
+    def _get_center_of_gravity(self) -> Vec2d:
+        v = lib.cpBodyGetCenterOfGravity(self._body)
+        return Vec2d(v.x, v.y)
+
+    center_of_gravity = property(
+        _get_center_of_gravity,
+        _set_center_of_gravity,
+        doc="""Location of the center of gravity in body local coordinates.
+
+        The default value is (0, 0), meaning the center of gravity is the
+        same as the position of the body.
+        """,
+    )
+
+    def _set_velocity(self, vel: Tuple[float, float]) -> None:
+        assert len(vel) == 2
+        lib.cpBodySetVelocity(self._body, vel)
+
+    def _get_velocity(self) -> Vec2d:
+        v = lib.cpBodyGetVelocity(self._body)
+        return Vec2d(v.x, v.y)
+
+    velocity = property(
+        _get_velocity,
+        _set_velocity,
+        doc="""Linear velocity of the center of gravity of the body.""",
+    )
+
+    def _set_force(self, f: Tuple[float, float]) -> None:
+        assert len(f) == 2
+        lib.cpBodySetForce(self._body, f)
+
+    def _get_force(self) -> Vec2d:
+        v = lib.cpBodyGetForce(self._body)
+        return Vec2d(v.x, v.y)
+
+    force = property(
+        _get_force,
+        _set_force,
+        doc="""Force applied to the center of gravity of the body.
+
+        This value is reset for every time step. Note that this is not the 
+        total of forces acting on the body (such as from collisions), but the 
+        force applied manually from the apply force functions.""",
+    )
+
+    def _set_angle(self, angle: float) -> None:
+        lib.cpBodySetAngle(self._body, angle)
+
+    def _get_angle(self) -> float:
+        return lib.cpBodyGetAngle(self._body)
+
+    angle = property(
+        _get_angle,
+        _set_angle,
+        doc="""Rotation of the body in radians.
+
+        When changing the rotation you may also want to call
+        :py:func:`Space.reindex_shapes_for_body` to update the collision 
+        detection information for the attached shapes if plan to make any 
+        queries against the space. A body rotates around its center of gravity, 
+        not its position.
+
+        .. Note::
+            If you get small/no changes to the angle when for example a
+            ball is "rolling" down a slope it might be because the Circle shape
+            attached to the body or the slope shape does not have any friction
+            set.""",
+    )
+
+    def _set_angular_velocity(self, w: float) -> None:
+        lib.cpBodySetAngularVelocity(self._body, w)
+
+    def _get_angular_velocity(self) -> float:
+        return lib.cpBodyGetAngularVelocity(self._body)
+
+    angular_velocity = property(
+        _get_angular_velocity,
+        _set_angular_velocity,
+        doc="""The angular velocity of the body in radians per second.""",
+    )
+
+    def _set_torque(self, t: float) -> None:
+        lib.cpBodySetTorque(self._body, t)
+
+    def _get_torque(self) -> float:
+        return lib.cpBodyGetTorque(self._body)
+
+    torque = property(
+        _get_torque,
+        _set_torque,
+        doc="""The torque applied to the body.
+
+        This value is reset for every time step.""",
+    )
+
+    def _get_rotation_vector(self) -> Vec2d:
+        v = lib.cpBodyGetRotation(self._body)
+        return Vec2d(v.x, v.y)
+
+    rotation_vector = property(
+        _get_rotation_vector, doc="""The rotation vector for the body."""
+    )
+
+    @property
+    def space(self) -> Optional["Space"]:
+        """Get the :py:class:`Space` that the body has been added to (or
+        None)."""
+        if self._space is not None:
+            return self._space._get_self()  # ugly hack because of weakref
+        else:
+            return None
+
+    def _set_velocity_func(self, func: _VelocityFunc) -> None:
+        self._velocity_func = func
+        lib.cpBodySetVelocityUpdateFunc(self._body, lib.ext_cpBodyVelocityFunc)
+
+    velocity_func = property(
+        fset=_set_velocity_func,
+        doc="""The velocity callback function. 
+        
+        The velocity callback function is called each time step, and can be 
+        used to set a body's velocity.
+
+            ``func(body : Body, gravity, damping, dt)``
+
+        There are many cases when this can be useful. One example is individual 
+        gravity for some bodies, and another is to limit the velocity which is 
+        useful to prevent tunneling. 
+        
+        Example of a callback that sets gravity to zero for a object.
+
+        >>> import pymunk
+        >>> space = pymunk.Space()
+        >>> space.gravity = 0, 10
+        >>> body = pymunk.Body(1,2)
+        >>> space.add(body)
+        >>> def zero_gravity(body, gravity, damping, dt):
+        ...     pymunk.Body.update_velocity(body, (0,0), damping, dt)
+        ... 
+        >>> body.velocity_func = zero_gravity
+        >>> space.step(1)
+        >>> space.step(1)
+        >>> print(body.position, body.velocity)
+        Vec2d(0.0, 0.0) Vec2d(0.0, 0.0)
+
+        Example of a callback that limits the velocity:
+
+        >>> import pymunk
+        >>> body = pymunk.Body(1,2)
+        >>> def limit_velocity(body, gravity, damping, dt):
+        ...     max_velocity = 1000
+        ...     pymunk.Body.update_velocity(body, gravity, damping, dt)
+        ...     l = body.velocity.length
+        ...     if l > max_velocity:
+        ...         scale = max_velocity / l
+        ...         body.velocity = body.velocity * scale
+        ...
+        >>> body.velocity_func = limit_velocity
+
+        """,
+    )
+
+    def _set_position_func(self, func: Callable[["Body", float], None]) -> None:
+        self._position_func = func
+        lib.cpBodySetPositionUpdateFunc(self._body, lib.ext_cpBodyPositionFunc)
+
+    position_func = property(
+        fset=_set_position_func,
+        doc="""The position callback function. 
+        
+        The position callback function is called each time step and can be 
+        used to update the body's position.
+
+            ``func(body, dt) -> None``
+        """,
+    )
+
+    @property
+    def kinetic_energy(self) -> float:
+        """Get the kinetic energy of a body."""
+        # todo: use ffi method
+        # return lib._cpBodyKineticEnergy(self._body)
+
+        vsq: float = self.velocity.dot(self.velocity)
+        wsq: float = self.angular_velocity * self.angular_velocity
+        return (vsq * self.mass if vsq else 0.0) + (wsq * self.moment if wsq else 0.0)
+
+    @staticmethod
+    def update_velocity(
+        body: "Body", gravity: Tuple[float, float], damping: float, dt: float
+    ) -> None:
+        """Default rigid body velocity integration function.
+
+        Updates the velocity of the body using Euler integration.
+        """
+        assert len(gravity) == 2
+        lib.cpBodyUpdateVelocity(body._body, gravity, damping, dt)
+
+    @staticmethod
+    def update_position(body: "Body", dt: float) -> None:
+        """Default rigid body position integration function.
+
+        Updates the position of the body using Euler integration. Unlike the
+        velocity function, it's unlikely you'll want to override this
+        function. If you do, make sure you understand it's source code
+        (in Chipmunk) as it's an important part of the collision/joint
+        correction process.
+        """
+        lib.cpBodyUpdatePosition(body._body, dt)
+
+    def apply_force_at_world_point(
+        self, force: Tuple[float, float], point: Tuple[float, float]
+    ) -> None:
+        """Add the force force to body as if applied from the world point.
+
+        People are sometimes confused by the difference between a force and
+        an impulse. An impulse is a very large force applied over a very
+        short period of time. Some examples are a ball hitting a wall or
+        cannon firing. Chipmunk treats impulses as if they occur
+        instantaneously by adding directly to the velocity of an object.
+        Both impulses and forces are affected the mass of an object. Doubling
+        the mass of the object will halve the effect.
+        """
+        assert len(force) == 2
+        assert len(point) == 2
+        lib.cpBodyApplyForceAtWorldPoint(self._body, force, point)
+
+    def apply_force_at_local_point(
+        self, force: Tuple[float, float], point: Tuple[float, float] = (0, 0)
+    ) -> None:
+        """Add the local force force to body as if applied from the body
+        local point.
+        """
+        assert len(force) == 2
+        assert len(point) == 2
+        lib.cpBodyApplyForceAtLocalPoint(self._body, force, point)
+
+    def apply_impulse_at_world_point(
+        self, impulse: Tuple[float, float], point: Tuple[float, float]
+    ) -> None:
+        """Add the impulse impulse to body as if applied from the world point."""
+        assert len(impulse) == 2
+        assert len(point) == 2
+        lib.cpBodyApplyImpulseAtWorldPoint(self._body, impulse, point)
+
+    def apply_impulse_at_local_point(
+        self, impulse: Tuple[float, float], point: Tuple[float, float] = (0, 0)
+    ) -> None:
+        """Add the local impulse impulse to body as if applied from the body
+        local point.
+        """
+        assert len(impulse) == 2
+        assert len(point) == 2
+        lib.cpBodyApplyImpulseAtLocalPoint(self._body, impulse, point)
+
+    def activate(self) -> None:
+        """Reset the idle timer on a body.
+
+        If it was sleeping, wake it and any other bodies it was touching.
+        """
+        lib.cpBodyActivate(self._body)
+
+    def sleep(self) -> None:
+        """Forces a body to fall asleep immediately even if it's in midair.
+
+        Cannot be called from a callback.
+        """
+        if self._space == None:
+            raise Exception("Body not added to space")
+        lib.cpBodySleep(self._body)
+
+    def sleep_with_group(self, body: "Body") -> None:
+        """Force a body to fall asleep immediately along with other bodies
+        in a group.
+
+        When objects in Pymunk sleep, they sleep as a group of all objects
+        that are touching or jointed together. When an object is woken up,
+        all of the objects in its group are woken up.
+        :py:func:`Body.sleep_with_group` allows you group sleeping objects
+        together. It acts identically to :py:func:`Body.sleep` if you pass
+        None as group by starting a new group. If you pass a sleeping body
+        for group, body will be awoken when group is awoken. You can use this
+        to initialize levels and start stacks of objects in a pre-sleeping
+        state.
+        """
+        if self._space == None:
+            raise Exception("Body not added to space")
+        lib.cpBodySleepWithGroup(self._body, body._body)
+
+    @property
+    def is_sleeping(self) -> bool:
+        """Returns true if the body is sleeping."""
+        return bool(lib.cpBodyIsSleeping(self._body))
+
+    def _set_type(self, body_type: _BodyType) -> None:
+        lib.cpBodySetType(self._body, body_type)
+
+    def _get_type(self) -> _BodyType:
+        return lib.cpBodyGetType(self._body)
+
+    body_type = property(
+        _get_type,
+        _set_type,
+        doc="""The type of a body (:py:const:`Body.DYNAMIC`, 
+        :py:const:`Body.KINEMATIC` or :py:const:`Body.STATIC`).
+
+        When changing an body to a dynamic body, the mass and moment of
+        inertia are recalculated from the shapes added to the body. Custom
+        calculated moments of inertia are not preserved when changing types.
+        This function cannot be called directly in a collision callback.
+        """,
+    )
+
+    def each_arbiter(
+        self,
+        func: Callable[..., None],  # TODO: Fix me once PEP 612 is ready
+        *args: Any,
+        **kwargs: Any
+    ) -> None:
+        """Run func on each of the arbiters on this body.
+
+            ``func(arbiter, *args, **kwargs) -> None``
+
+            Callback Parameters
+                arbiter : :py:class:`Arbiter`
+                    The Arbiter
+                args
+                    Optional parameters passed to the callback function.
+                kwargs
+                    Optional keyword parameters passed on to the callback function.
+
+        .. warning::
+
+            Do not hold on to the Arbiter after the callback!
+        """
+        d = self, func, args, kwargs
+        data = ffi.new_handle(d)
+        lib.cpBodyEachArbiter(self._body, lib.ext_cpBodyArbiterIteratorFunc, data)
+
+    @property
+    def constraints(self) -> Set["Constraint"]:
+        """Get the constraints this body is attached to.
+
+        It is not possible to detach a body from a constraint. The only way is
+        to delete the constraint fully by removing it from any spaces and
+        remove any other references to it. The body only keeps a weak
+        reference to the constraint, meaning that the when all other
+        references to the constraint are removed and the constraint is garbage
+        collected it will automatically be removed from this collection as
+        well.
+        """
+        return set(self._constraints)
+
+    @property
+    def shapes(self) -> Set["Shape"]:
+        """Get the shapes attached to this body.
+
+        The body only keeps a weak reference to the shapes and a live
+        body wont prevent GC of the attached shapes"""
+        return set(self._shapes)
+
+    def local_to_world(self, v: Tuple[float, float]) -> Vec2d:
+        """Convert body local coordinates to world space coordinates
+
+        Many things are defined in coordinates local to a body meaning that
+        the (0,0) is at the center of gravity of the body and the axis rotate
+        along with the body.
+
+        :param v: Vector in body local coordinates
+        """
+        assert len(v) == 2
+        v2 = lib.cpBodyLocalToWorld(self._body, v)
+        return Vec2d(v2.x, v2.y)
+
+    def world_to_local(self, v: Tuple[float, float]) -> Vec2d:
+        """Convert world space coordinates to body local coordinates
+
+        :param v: Vector in world space coordinates
+        """
+        assert len(v) == 2
+        v2 = lib.cpBodyWorldToLocal(self._body, v)
+        return Vec2d(v2.x, v2.y)
+
+    def velocity_at_world_point(self, point: Tuple[float, float]) -> Vec2d:
+        """Get the absolute velocity of the rigid body at the given world
+        point
+
+        It's often useful to know the absolute velocity of a point on the
+        surface of a body since the angular velocity affects everything
+        except the center of gravity.
+        """
+        assert len(point) == 2
+        v = lib.cpBodyGetVelocityAtWorldPoint(self._body, point)
+        return Vec2d(v.x, v.y)
+
+    def velocity_at_local_point(self, point: Tuple[float, float]) -> Vec2d:
+        """Get the absolute velocity of the rigid body at the given body
+        local point
+        """
+        assert len(point) == 2
+        v = lib.cpBodyGetVelocityAtLocalPoint(self._body, point)
+        return Vec2d(v.x, v.y)
+
+    def __getstate__(self) -> _State:
+        """Return the state of this object
+
+        This method allows the usage of the :mod:`copy` and :mod:`pickle`
+        modules with this class.
+        """
+        d = super(Body, self).__getstate__()
+
+        d["special"].append(("is_sleeping", self.is_sleeping))
+        d["special"].append(("_velocity_func", self._velocity_func))
+        d["special"].append(("_position_func", self._position_func))
+
+        return d
+
+    def __setstate__(self, state: _State) -> None:
+        """Unpack this object from a saved state.
+
+        This method allows the usage of the :mod:`copy` and :mod:`pickle`
+        modules with this class.
+        """
+        super(Body, self).__setstate__(state)
+
+        for k, v in state["special"]:
+            if k == "is_sleeping" and v:
+                pass
+            elif k == "_velocity_func" and v != None:
+                self.velocity_func = v
+            elif k == "_position_func" and v != None:
+                self.position_func = v
```

## Comparing `pymunk-6.5.0/pymunk/collision_handler.py` & `pymunk/collision_handler.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,161 +1,161 @@
-__version__ = "$Id$"
-__docformat__ = "reStructuredText"
-
-from typing import TYPE_CHECKING, Any, Callable, Dict, Optional
-
-if TYPE_CHECKING:
-    from .space import Space
-
-from ._chipmunk_cffi import ffi, lib
-from .arbiter import Arbiter
-
-_CollisionCallbackBool = Callable[[Arbiter, "Space", Any], bool]
-_CollisionCallbackNoReturn = Callable[[Arbiter, "Space", Any], None]
-
-
-class CollisionHandler(object):
-    """A collision handler is a set of 4 function callbacks for the different
-    collision events that Pymunk recognizes.
-
-    Collision callbacks are closely associated with Arbiter objects. You
-    should familiarize yourself with those as well.
-
-    Note #1: Shapes tagged as sensors (Shape.sensor == true) never generate
-    collisions that get processed, so collisions between sensors shapes and
-    other shapes will never call the post_solve() callback. They still
-    generate begin(), and separate() callbacks, and the pre_solve() callback
-    is also called every frame even though there is no collision response.
-    Note #2: pre_solve() callbacks are called before the sleeping algorithm
-    runs. If an object falls asleep, its post_solve() callback won't be
-    called until it's re-awoken.
-    """
-
-    def __init__(self, _handler: Any, space: "Space") -> None:
-        """Initialize a CollisionHandler object from the Chipmunk equivalent
-        struct and the Space.
-
-        .. note::
-            You should never need to create an instance of this class directly.
-        """
-        self._userData = ffi.new_handle(self)
-
-        self._handler = _handler
-        self._handler.userData = self._userData
-
-        self._space = space
-        self._begin: Optional[_CollisionCallbackBool] = None
-        self._pre_solve: Optional[_CollisionCallbackBool] = None
-        self._post_solve: Optional[_CollisionCallbackNoReturn] = None
-        self._separate: Optional[_CollisionCallbackNoReturn] = None
-
-        self._data: Dict[Any, Any] = {}
-
-    def _reset(self) -> None:
-        def allways_collide(arb: Arbiter, space: "Space", data: Any) -> bool:
-            return True
-
-        def do_nothing(arb: Arbiter, space: "Space", data: Any) -> None:
-            return
-
-        self.begin = allways_collide
-        self.pre_solve = allways_collide
-        self.post_solve = do_nothing
-        self.separate = do_nothing
-
-    @property
-    def data(self) -> Dict[Any, Any]:
-        """Data property that get passed on into the
-        callbacks.
-
-        data is a dictionary and you can not replace it, only fill it with data.
-
-        Usefull if the callback needs some extra data to perform its function.
-        """
-        return self._data
-
-    def _set_begin(self, func: Callable[[Arbiter, "Space", Any], bool]) -> None:
-        self._begin = func
-        self._handler.beginFunc = lib.ext_cpCollisionBeginFunc
-
-    def _get_begin(self) -> Optional[_CollisionCallbackBool]:
-        return self._begin
-
-    begin = property(
-        _get_begin,
-        _set_begin,
-        doc="""Two shapes just started touching for the first time this step.
-
-        ``func(arbiter, space, data) -> bool``
-
-        Return true from the callback to process the collision normally or
-        false to cause pymunk to ignore the collision entirely. If you return
-        false, the `pre_solve` and `post_solve` callbacks will never be run,
-        but you will still recieve a separate event when the shapes stop
-        overlapping.
-        """,
-    )
-
-    def _set_pre_solve(self, func: _CollisionCallbackBool) -> None:
-        self._pre_solve = func
-        self._handler.preSolveFunc = lib.ext_cpCollisionPreSolveFunc
-
-    def _get_pre_solve(self) -> Optional[Callable[[Arbiter, "Space", Any], bool]]:
-        return self._pre_solve
-
-    pre_solve = property(
-        _get_pre_solve,
-        _set_pre_solve,
-        doc="""Two shapes are touching during this step.
-
-        ``func(arbiter, space, data) -> bool``
-
-        Return false from the callback to make pymunk ignore the collision
-        this step or true to process it normally. Additionally, you may
-        override collision values using Arbiter.friction, Arbiter.elasticity
-        or Arbiter.surfaceVelocity to provide custom friction, elasticity,
-        or surface velocity values. See Arbiter for more info.
-        """,
-    )
-
-    def _set_post_solve(self, func: _CollisionCallbackNoReturn) -> None:
-
-        self._post_solve = func
-        self._handler.postSolveFunc = lib.ext_cpCollisionPostSolveFunc
-
-    def _get_post_solve(self) -> Optional[_CollisionCallbackNoReturn]:
-        return self._post_solve
-
-    post_solve = property(
-        _get_post_solve,
-        _set_post_solve,
-        doc="""Two shapes are touching and their collision response has been
-        processed.
-
-        ``func(arbiter, space, data)``
-
-        You can retrieve the collision impulse or kinetic energy at this
-        time if you want to use it to calculate sound volumes or damage
-        amounts. See Arbiter for more info.
-        """,
-    )
-
-    def _set_separate(self, func: _CollisionCallbackNoReturn) -> None:
-        self._separate = func
-        self._handler.separateFunc = lib.ext_cpCollisionSeparateFunc
-
-    def _get_separate(self) -> Optional[_CollisionCallbackNoReturn]:
-        return self._separate
-
-    separate = property(
-        _get_separate,
-        _set_separate,
-        doc="""Two shapes have just stopped touching for the first time this
-        step.
-
-        ``func(arbiter, space, data)``
-
-        To ensure that begin()/separate() are always called in balanced
-        pairs, it will also be called when removing a shape while its in
-        contact with something or when de-allocating the space.
-        """,
-    )
+__version__ = "$Id$"
+__docformat__ = "reStructuredText"
+
+from typing import TYPE_CHECKING, Any, Callable, Dict, Optional
+
+if TYPE_CHECKING:
+    from .space import Space
+
+from ._chipmunk_cffi import ffi, lib
+from .arbiter import Arbiter
+
+_CollisionCallbackBool = Callable[[Arbiter, "Space", Any], bool]
+_CollisionCallbackNoReturn = Callable[[Arbiter, "Space", Any], None]
+
+
+class CollisionHandler(object):
+    """A collision handler is a set of 4 function callbacks for the different
+    collision events that Pymunk recognizes.
+
+    Collision callbacks are closely associated with Arbiter objects. You
+    should familiarize yourself with those as well.
+
+    Note #1: Shapes tagged as sensors (Shape.sensor == true) never generate
+    collisions that get processed, so collisions between sensors shapes and
+    other shapes will never call the post_solve() callback. They still
+    generate begin(), and separate() callbacks, and the pre_solve() callback
+    is also called every frame even though there is no collision response.
+    Note #2: pre_solve() callbacks are called before the sleeping algorithm
+    runs. If an object falls asleep, its post_solve() callback won't be
+    called until it's re-awoken.
+    """
+
+    def __init__(self, _handler: Any, space: "Space") -> None:
+        """Initialize a CollisionHandler object from the Chipmunk equivalent
+        struct and the Space.
+
+        .. note::
+            You should never need to create an instance of this class directly.
+        """
+        self._userData = ffi.new_handle(self)
+
+        self._handler = _handler
+        self._handler.userData = self._userData
+
+        self._space = space
+        self._begin: Optional[_CollisionCallbackBool] = None
+        self._pre_solve: Optional[_CollisionCallbackBool] = None
+        self._post_solve: Optional[_CollisionCallbackNoReturn] = None
+        self._separate: Optional[_CollisionCallbackNoReturn] = None
+
+        self._data: Dict[Any, Any] = {}
+
+    def _reset(self) -> None:
+        def allways_collide(arb: Arbiter, space: "Space", data: Any) -> bool:
+            return True
+
+        def do_nothing(arb: Arbiter, space: "Space", data: Any) -> None:
+            return
+
+        self.begin = allways_collide
+        self.pre_solve = allways_collide
+        self.post_solve = do_nothing
+        self.separate = do_nothing
+
+    @property
+    def data(self) -> Dict[Any, Any]:
+        """Data property that get passed on into the
+        callbacks.
+
+        data is a dictionary and you can not replace it, only fill it with data.
+
+        Usefull if the callback needs some extra data to perform its function.
+        """
+        return self._data
+
+    def _set_begin(self, func: Callable[[Arbiter, "Space", Any], bool]) -> None:
+        self._begin = func
+        self._handler.beginFunc = lib.ext_cpCollisionBeginFunc
+
+    def _get_begin(self) -> Optional[_CollisionCallbackBool]:
+        return self._begin
+
+    begin = property(
+        _get_begin,
+        _set_begin,
+        doc="""Two shapes just started touching for the first time this step.
+
+        ``func(arbiter, space, data) -> bool``
+
+        Return true from the callback to process the collision normally or
+        false to cause pymunk to ignore the collision entirely. If you return
+        false, the `pre_solve` and `post_solve` callbacks will never be run,
+        but you will still recieve a separate event when the shapes stop
+        overlapping.
+        """,
+    )
+
+    def _set_pre_solve(self, func: _CollisionCallbackBool) -> None:
+        self._pre_solve = func
+        self._handler.preSolveFunc = lib.ext_cpCollisionPreSolveFunc
+
+    def _get_pre_solve(self) -> Optional[Callable[[Arbiter, "Space", Any], bool]]:
+        return self._pre_solve
+
+    pre_solve = property(
+        _get_pre_solve,
+        _set_pre_solve,
+        doc="""Two shapes are touching during this step.
+
+        ``func(arbiter, space, data) -> bool``
+
+        Return false from the callback to make pymunk ignore the collision
+        this step or true to process it normally. Additionally, you may
+        override collision values using Arbiter.friction, Arbiter.elasticity
+        or Arbiter.surfaceVelocity to provide custom friction, elasticity,
+        or surface velocity values. See Arbiter for more info.
+        """,
+    )
+
+    def _set_post_solve(self, func: _CollisionCallbackNoReturn) -> None:
+
+        self._post_solve = func
+        self._handler.postSolveFunc = lib.ext_cpCollisionPostSolveFunc
+
+    def _get_post_solve(self) -> Optional[_CollisionCallbackNoReturn]:
+        return self._post_solve
+
+    post_solve = property(
+        _get_post_solve,
+        _set_post_solve,
+        doc="""Two shapes are touching and their collision response has been
+        processed.
+
+        ``func(arbiter, space, data)``
+
+        You can retrieve the collision impulse or kinetic energy at this
+        time if you want to use it to calculate sound volumes or damage
+        amounts. See Arbiter for more info.
+        """,
+    )
+
+    def _set_separate(self, func: _CollisionCallbackNoReturn) -> None:
+        self._separate = func
+        self._handler.separateFunc = lib.ext_cpCollisionSeparateFunc
+
+    def _get_separate(self) -> Optional[_CollisionCallbackNoReturn]:
+        return self._separate
+
+    separate = property(
+        _get_separate,
+        _set_separate,
+        doc="""Two shapes have just stopped touching for the first time this
+        step.
+
+        ``func(arbiter, space, data)``
+
+        To ensure that begin()/separate() are always called in balanced
+        pairs, it will also be called when removing a shape while its in
+        contact with something or when de-allocating the space.
+        """,
+    )
```

## Comparing `pymunk-6.5.0/pymunk/constraints.py` & `pymunk/constraints.py`

 * *Ordering differences only*

 * *Files 25% similar despite different names*

```diff
@@ -1,863 +1,863 @@
-# ----------------------------------------------------------------------------
-# pymunk
-# Copyright (c) 2007-2017 Victor Blomqvist
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice shall be included in
-# all copies or substantial portions of the Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-# ----------------------------------------------------------------------------
-
-"""A constraint is something that describes how two bodies interact with
-each other. (how they constrain each other). Constraints can be simple
-joints that allow bodies to pivot around each other like the bones in your
-body, or they can be more abstract like the gear joint or motors.
-
-This submodule contain all the constraints that are supported by Pymunk.
-
-All the constraints support copy and pickle from the standard library. Custom 
-properties set on a constraint will also be copied/pickled.
-
-Chipmunk has a good overview of the different constraint on youtube which
-works fine to showcase them in Pymunk as well.
-http://www.youtube.com/watch?v=ZgJJZTS0aMM
-
-.. raw:: html
-
-    <iframe width="420" height="315" style="display: block; margin: 0 auto;"
-    src="http://www.youtube.com/embed/ZgJJZTS0aMM" frameborder="0"
-    allowfullscreen></iframe>
-
-
-Example::
-
->>> import pymunk
->>> import pymunk.constraints
->>> s = pymunk.Space()
->>> a,b = pymunk.Body(10,10), pymunk.Body(10,10)
->>> c = pymunk.constraints.PivotJoint(a, b, (0,0))
->>> s.add(c)
-
-"""
-__docformat__ = "reStructuredText"
-
-__all__ = [
-    "Constraint",
-    "PinJoint",
-    "SlideJoint",
-    "PivotJoint",
-    "GrooveJoint",
-    "DampedSpring",
-    "DampedRotarySpring",
-    "RotaryLimitJoint",
-    "RatchetJoint",
-    "GearJoint",
-    "SimpleMotor",
-]
-
-import logging
-from typing import TYPE_CHECKING, Any, Callable, Dict, List, Optional, Tuple, Union
-
-if TYPE_CHECKING:
-    from .body import Body
-    from .space import Space
-
-from ._chipmunk_cffi import ffi, lib
-from ._pickle import PickleMixin
-from ._typing_attr import TypingAttrMixing
-from .vec2d import Vec2d
-
-_logger = logging.getLogger(__name__)
-
-
-class Constraint(PickleMixin, TypingAttrMixing, object):
-    """Base class of all constraints.
-
-    You usually don't want to create instances of this class directly, but
-    instead use one of the specific constraints such as the PinJoint.
-    """
-
-    _pickle_attrs_init = PickleMixin._pickle_attrs_init + ["a", "b"]
-    _pickle_attrs_general = PickleMixin._pickle_attrs_general + [
-        "max_force",
-        "error_bias",
-        "max_bias",
-        "collide_bodies",
-    ]
-    _pickle_attrs_skip = PickleMixin._pickle_attrs_skip + ["pre_solve", "post_solve"]
-
-    _pre_solve_func: Optional[Callable[["Constraint", "Space"], None]] = None
-    _post_solve_func: Optional[Callable[["Constraint", "Space"], None]] = None
-
-    def __init__(self, constraint: ffi.CData) -> None:
-        self._constraint = constraint
-
-    def _init(self, a: "Body", b: "Body", _constraint: Any) -> None:
-        def constraintfree(cp_constraint: ffi.CData) -> None:
-            cp_space = lib.cpConstraintGetSpace(cp_constraint)
-            if cp_space != ffi.NULL:
-                lib.cpSpaceRemoveConstraint(cp_space, cp_constraint)
-
-            _logger.debug("constraintfree %s", cp_constraint)
-            lib.cpConstraintFree(cp_constraint)
-
-        self._constraint = ffi.gc(_constraint, constraintfree)
-        self._set_bodies(a, b)
-
-        d = ffi.new_handle(self)
-        self._data_handle = d  # to prevent gc to collect the handle
-        lib.cpConstraintSetUserData(self._constraint, d)
-
-    def _get_max_force(self) -> float:
-        return lib.cpConstraintGetMaxForce(self._constraint)
-
-    def _set_max_force(self, f: float) -> None:
-        lib.cpConstraintSetMaxForce(self._constraint, f)
-
-    max_force = property(
-        _get_max_force,
-        _set_max_force,
-        doc="""The maximum force that the constraint can use to act on the two
-        bodies.
-
-        Defaults to infinity
-        """,
-    )
-
-    def _get_error_bias(self) -> float:
-        return lib.cpConstraintGetErrorBias(self._constraint)
-
-    def _set_error_bias(self, error_bias: float) -> None:
-        lib.cpConstraintSetErrorBias(self._constraint, error_bias)
-
-    error_bias = property(
-        _get_error_bias,
-        _set_error_bias,
-        doc="""The percentage of joint error that remains unfixed after a
-        second.
-
-        This works exactly the same as the collision bias property of a space,
-        but applies to fixing error (stretching) of joints instead of
-        overlapping collisions.
-
-        Defaults to pow(1.0 - 0.1, 60.0) meaning that it will correct 10% of
-        the error every 1/60th of a second.
-        """,
-    )
-
-    def _get_max_bias(self) -> float:
-        return lib.cpConstraintGetMaxBias(self._constraint)
-
-    def _set_max_bias(self, max_bias: float) -> None:
-        lib.cpConstraintSetMaxBias(self._constraint, max_bias)
-
-    max_bias = property(
-        _get_max_bias,
-        _set_max_bias,
-        doc="""The maximum speed at which the constraint can apply error
-        correction.
-
-        Defaults to infinity
-        """,
-    )
-
-    def _get_collide_bodies(self) -> bool:
-        return lib.cpConstraintGetCollideBodies(self._constraint)
-
-    def _set_collide_bodies(self, collide_bodies: bool) -> None:
-        lib.cpConstraintSetCollideBodies(self._constraint, collide_bodies)
-
-    collide_bodies = property(
-        _get_collide_bodies,
-        _set_collide_bodies,
-        doc="""Constraints can be used for filtering collisions too.
-
-        When two bodies collide, Pymunk ignores the collisions if this property
-        is set to False on any constraint that connects the two bodies.
-        Defaults to True. This can be used to create a chain that self
-        collides, but adjacent links in the chain do not collide.
-        """,
-    )
-
-    @property
-    def impulse(self) -> float:
-        """The most recent impulse that constraint applied.
-
-        To convert this to a force, divide by the timestep passed to
-        space.step(). You can use this to implement breakable joints to check
-        if the force they attempted to apply exceeded a certain threshold.
-        """
-        return lib.cpConstraintGetImpulse(self._constraint)
-
-    @property
-    def a(self) -> "Body":
-        """The first of the two bodies constrained"""
-        return self._a
-
-    @property
-    def b(self) -> "Body":
-        """The second of the two bodies constrained"""
-        return self._b
-
-    def activate_bodies(self) -> None:
-        """Activate the bodies this constraint is attached to"""
-        self._a.activate()
-        self._b.activate()
-
-    @property
-    def pre_solve(self) -> Optional[Callable[["Constraint", "Space"], None]]:
-        """The pre-solve function is called before the constraint solver runs.
-
-        Note that None can be used to reset it to default value.
-
-        >>> import pymunk
-        >>> j = pymunk.PinJoint(pymunk.Body(1,2), pymunk.Body(3,4), (0,0))
-        >>> def pre_solve_func(constraint, space):
-        ...     print("Hello from pre-solve")
-        >>> j.pre_solve = pre_solve_func
-        >>> j.pre_solve = None
-        """
-
-        return self._pre_solve_func
-
-    @pre_solve.setter
-    def pre_solve(
-        self, func: Optional[Callable[["Constraint", "Space"], None]]
-    ) -> None:
-        self._pre_solve_func = func
-
-        if func is None:
-            lib.cpConstraintSetPreSolveFunc(self._constraint, ffi.NULL)
-        else:
-            lib.cpConstraintSetPreSolveFunc(
-                self._constraint, lib.ext_cpConstraintPreSolveFunc
-            )
-
-    @property
-    def post_solve(self) -> Optional[Callable[["Constraint", "Space"], None]]:
-        """The post-solve function is called after the constraint solver runs.
-
-        Note that None can be used to reset it to default value.
-
-        >>> import pymunk
-        >>> j = pymunk.PinJoint(pymunk.Body(1,2), pymunk.Body(3,4), (0,0))
-        >>> def post_solve_func(constraint, space):
-        ...     print("Hello from pre-solve")
-        >>> j.post_solve = post_solve_func
-        >>> j.post_solve = None
-        """
-        return self._post_solve_func
-
-    @post_solve.setter
-    def post_solve(
-        self, func: Optional[Callable[["Constraint", "Space"], None]]
-    ) -> None:
-        self._post_solve_func = func
-
-        if func is None:
-            lib.cpConstraintSetPostSolveFunc(self._constraint, ffi.NULL)
-        else:
-            lib.cpConstraintSetPostSolveFunc(
-                self._constraint, lib.ext_cpConstraintPostSolveFunc
-            )
-
-    def _set_bodies(self, a: "Body", b: "Body") -> None:
-        assert a is not b
-        self._a = a
-        self._b = b
-        a._constraints.add(self)
-        b._constraints.add(self)
-
-    def __getstate__(self) -> Dict[str, List[Tuple[str, Any]]]:
-        """Return the state of this object
-
-        This method allows the usage of the :mod:`copy` and :mod:`pickle`
-        modules with this class.
-        """
-        d = super(Constraint, self).__getstate__()
-
-        d["special"].append(("_pre_solve_func", self._pre_solve_func))
-        d["special"].append(("_post_solve_func", self._post_solve_func))
-
-        return d
-
-    def __setstate__(self, state: Dict[str, List[Tuple[str, Any]]]) -> None:
-        """Unpack this object from a saved state.
-
-        This method allows the usage of the :mod:`copy` and :mod:`pickle`
-        modules with this class.
-        """
-        super(Constraint, self).__setstate__(state)
-
-        for k, v in state["special"]:
-            if k == "_pre_solve_func" and v != None:
-                self.pre_solve = v
-            elif k == "_post_solve_func" and v != None:
-                self.post_solve = v
-
-
-class PinJoint(Constraint):
-    """PinJoint links shapes with a solid bar or pin.
-
-    Keeps the anchor points at a set distance from one another.
-    """
-
-    _pickle_attrs_init = Constraint._pickle_attrs_init + ["anchor_a", "anchor_b"]
-
-    def __init__(
-        self,
-        a: "Body",
-        b: "Body",
-        anchor_a: Tuple[float, float] = (0, 0),
-        anchor_b: Tuple[float, float] = (0, 0),
-    ) -> None:
-        """a and b are the two bodies to connect, and anchor_a and anchor_b are
-        the anchor points on those bodies.
-
-        The distance between the two anchor points is measured when the joint
-        is created. If you want to set a specific distance, use the setter
-        function to override it.
-        """
-        assert len(anchor_a) == 2
-        assert len(anchor_b) == 2
-        _constraint = lib.cpPinJointNew(a._body, b._body, anchor_a, anchor_b)
-        self._init(a, b, _constraint)
-
-    def _get_anchor_a(self) -> Vec2d:
-        v = lib.cpPinJointGetAnchorA(self._constraint)
-        return Vec2d(v.x, v.y)
-
-    def _set_anchor_a(self, anchor: Tuple[float, float]) -> None:
-        assert len(anchor) == 2
-        lib.cpPinJointSetAnchorA(self._constraint, anchor)
-
-    anchor_a = property(_get_anchor_a, _set_anchor_a)
-
-    def _get_anchor_b(self) -> Vec2d:
-        v = lib.cpPinJointGetAnchorB(self._constraint)
-        return Vec2d(v.x, v.y)
-
-    def _set_anchor_b(self, anchor: Tuple[float, float]) -> None:
-        assert len(anchor) == 2
-        lib.cpPinJointSetAnchorB(self._constraint, anchor)
-
-    anchor_b = property(_get_anchor_b, _set_anchor_b)
-
-    def _get_distance(self) -> float:
-        return lib.cpPinJointGetDist(self._constraint)
-
-    def _set_distance(self, distance: float) -> None:
-        lib.cpPinJointSetDist(self._constraint, distance)
-
-    distance = property(_get_distance, _set_distance)
-
-
-class SlideJoint(Constraint):
-    """SlideJoint is like a PinJoint, but have a minimum and maximum distance.
-
-    A chain could be modeled using this joint. It keeps the anchor points
-    from getting to far apart, but will allow them to get closer together.
-    """
-
-    _pickle_attrs_init = Constraint._pickle_attrs_init + [
-        "anchor_a",
-        "anchor_b",
-        "min",
-        "max",
-    ]
-
-    def __init__(
-        self,
-        a: "Body",
-        b: "Body",
-        anchor_a: Tuple[float, float],
-        anchor_b: Tuple[float, float],
-        min: float,
-        max: float,
-    ) -> None:
-        """a and b are the two bodies to connect, anchor_a and anchor_b are the
-        anchor points on those bodies, and min and max define the allowed
-        distances of the anchor points.
-        """
-        assert len(anchor_a) == 2
-        assert len(anchor_b) == 2
-        _constraint = lib.cpSlideJointNew(
-            a._body, b._body, anchor_a, anchor_b, min, max
-        )
-        self._init(a, b, _constraint)
-
-    def _get_anchor_a(self) -> Vec2d:
-        v = lib.cpSlideJointGetAnchorA(self._constraint)
-        return Vec2d(v.x, v.y)
-
-    def _set_anchor_a(self, anchor: Tuple[float, float]) -> None:
-        assert len(anchor) == 2
-        lib.cpSlideJointSetAnchorA(self._constraint, anchor)
-
-    anchor_a = property(_get_anchor_a, _set_anchor_a)
-
-    def _get_anchor_b(self) -> Vec2d:
-        v = lib.cpSlideJointGetAnchorB(self._constraint)
-        return Vec2d(v.x, v.y)
-
-    def _set_anchor_b(self, anchor: Tuple[float, float]) -> None:
-        assert len(anchor) == 2
-        lib.cpSlideJointSetAnchorB(self._constraint, anchor)
-
-    anchor_b = property(_get_anchor_b, _set_anchor_b)
-
-    def _get_min(self) -> float:
-        return lib.cpSlideJointGetMin(self._constraint)
-
-    def _set_min(self, min: float) -> None:
-        lib.cpSlideJointSetMin(self._constraint, min)
-
-    min = property(_get_min, _set_min)
-
-    def _get_max(self) -> float:
-        return lib.cpSlideJointGetMax(self._constraint)
-
-    def _set_max(self, max: float) -> None:
-        lib.cpSlideJointSetMax(self._constraint, max)
-
-    max = property(_get_max, _set_max)
-
-
-class PivotJoint(Constraint):
-    """PivotJoint allow two objects to pivot about a single point.
-
-    Its like a swivel.
-    """
-
-    _pickle_attrs_init = Constraint._pickle_attrs_init + ["anchor_a", "anchor_b"]
-
-    def __init__(
-        self,
-        a: "Body",
-        b: "Body",
-        *args: Union[
-            Tuple[float, float], Tuple[Tuple[float, float], Tuple[float, float]]
-        ]
-    ) -> None:
-        """a and b are the two bodies to connect, and pivot is the point in
-        world coordinates of the pivot.
-
-        Because the pivot location is given in world coordinates, you must
-        have the bodies moved into the correct positions already.
-        Alternatively you can specify the joint based on a pair of anchor
-        points, but make sure you have the bodies in the right place as the
-        joint will fix itself as soon as you start simulating the space.
-
-        That is, either create the joint with PivotJoint(a, b, pivot) or
-        PivotJoint(a, b, anchor_a, anchor_b).
-
-        :param Body a: The first of the two bodies
-        :param Body b: The second of the two bodies
-        :param args: Either one pivot point, or two anchor points
-        :type args: (float,float) or (float,float) (float,float)
-        """
-        if len(args) == 1:
-            assert len(args[0]) == 2
-            _constraint = lib.cpPivotJointNew(a._body, b._body, args[0])
-        elif len(args) == 2:
-            assert len(args[0]) == 2
-            assert len(args[1]) == 2
-            _constraint = lib.cpPivotJointNew2(a._body, b._body, args[0], args[1])
-        else:
-            raise Exception(
-                "You must specify either one pivot point" " or two anchor points"
-            )
-
-        self._init(a, b, _constraint)
-
-    def _get_anchor_a(self) -> Vec2d:
-        v = lib.cpPivotJointGetAnchorA(self._constraint)
-        return Vec2d(v.x, v.y)
-
-    def _set_anchor_a(self, anchor: Tuple[float, float]) -> None:
-        assert len(anchor) == 2
-        lib.cpPivotJointSetAnchorA(self._constraint, anchor)
-
-    anchor_a = property(_get_anchor_a, _set_anchor_a)
-
-    def _get_anchor_b(self) -> Vec2d:
-        v = lib.cpPivotJointGetAnchorB(self._constraint)
-        return Vec2d(v.x, v.y)
-
-    def _set_anchor_b(self, anchor: Tuple[float, float]) -> None:
-        assert len(anchor) == 2
-        lib.cpPivotJointSetAnchorB(self._constraint, anchor)
-
-    anchor_b = property(_get_anchor_b, _set_anchor_b)
-
-
-class GrooveJoint(Constraint):
-    """GrooveJoint is similar to a PivotJoint, but with a linear slide.
-
-    One of the anchor points is a line segment that the pivot can slide in instead of being fixed.
-    """
-
-    _pickle_attrs_init = Constraint._pickle_attrs_init + [
-        "groove_a",
-        "groove_b",
-        "anchor_b",
-    ]
-
-    def __init__(
-        self,
-        a: "Body",
-        b: "Body",
-        groove_a: Tuple[float, float],
-        groove_b: Tuple[float, float],
-        anchor_b: Tuple[float, float],
-    ) -> None:
-        """The groove goes from groove_a to groove_b on body a, and the pivot
-        is attached to anchor_b on body b.
-
-        All coordinates are body local.
-        """
-        assert len(groove_a) == 2
-        assert len(groove_b) == 2
-        assert len(anchor_b) == 2
-        _constraint = lib.cpGrooveJointNew(
-            a._body, b._body, groove_a, groove_b, anchor_b
-        )
-        self._init(a, b, _constraint)
-
-    def _get_anchor_b(self) -> Vec2d:
-        v = lib.cpGrooveJointGetAnchorB(self._constraint)
-        return Vec2d(v.x, v.y)
-
-    def _set_anchor_b(self, anchor: Tuple[float, float]) -> None:
-        assert len(anchor) == 2
-        lib.cpGrooveJointSetAnchorB(self._constraint, anchor)
-
-    anchor_b = property(_get_anchor_b, _set_anchor_b)
-
-    def _get_groove_a(self) -> Vec2d:
-        v = lib.cpGrooveJointGetGrooveA(self._constraint)
-        return Vec2d(v.x, v.y)
-
-    def _set_groove_a(self, groove: Tuple[float, float]) -> None:
-        assert len(groove) == 2
-        lib.cpGrooveJointSetGrooveA(self._constraint, groove)
-
-    groove_a = property(_get_groove_a, _set_groove_a)
-
-    def _get_groove_b(self) -> Vec2d:
-        v = lib.cpGrooveJointGetGrooveB(self._constraint)
-        return Vec2d(v.x, v.y)
-
-    def _set_groove_b(self, groove: Tuple[float, float]) -> None:
-        assert len(groove) == 2
-        lib.cpGrooveJointSetGrooveB(self._constraint, groove)
-
-    groove_b = property(_get_groove_b, _set_groove_b)
-
-
-class DampedSpring(Constraint):
-    """DampedSpring is a damped spring.
-
-    The spring allows you to define the rest length, stiffness and damping.
-    """
-
-    _pickle_attrs_init = Constraint._pickle_attrs_init + [
-        "anchor_a",
-        "anchor_b",
-        "rest_length",
-        "stiffness",
-        "damping",
-    ]
-
-    def __init__(
-        self,
-        a: "Body",
-        b: "Body",
-        anchor_a: Tuple[float, float],
-        anchor_b: Tuple[float, float],
-        rest_length: float,
-        stiffness: float,
-        damping: float,
-    ) -> None:
-        """Defined much like a slide joint.
-
-        :param Body a: Body a
-        :param Body b: Body b
-        :param anchor_a: Anchor point a, relative to body a
-        :type anchor_a: `(float,float)`
-        :param anchor_b: Anchor point b, relative to body b
-        :type anchor_b: `(float,float)`
-        :param float rest_length: The distance the spring wants to be.
-        :param float stiffness: The spring constant (Young's modulus).
-        :param float damping: How soft to make the damping of the spring.
-        """
-        assert len(anchor_a) == 2
-        assert len(anchor_b) == 2
-        _constraint = lib.cpDampedSpringNew(
-            a._body,
-            b._body,
-            anchor_a,
-            anchor_b,
-            rest_length,
-            stiffness,
-            damping,
-        )
-
-        self._init(a, b, _constraint)
-
-    def _get_anchor_a(self) -> Vec2d:
-        v = lib.cpDampedSpringGetAnchorA(self._constraint)
-        return Vec2d(v.x, v.y)
-
-    def _set_anchor_a(self, anchor: Tuple[float, float]) -> None:
-        assert len(anchor) == 2
-        lib.cpDampedSpringSetAnchorA(self._constraint, anchor)
-
-    anchor_a = property(_get_anchor_a, _set_anchor_a)
-
-    def _get_anchor_b(self) -> Vec2d:
-        v = lib.cpDampedSpringGetAnchorB(self._constraint)
-        return Vec2d(v.x, v.y)
-
-    def _set_anchor_b(self, anchor: Tuple[float, float]) -> None:
-        assert len(anchor) == 2
-        lib.cpDampedSpringSetAnchorB(self._constraint, anchor)
-
-    anchor_b = property(_get_anchor_b, _set_anchor_b)
-
-    def _get_rest_length(self) -> float:
-        return lib.cpDampedSpringGetRestLength(self._constraint)
-
-    def _set_rest_length(self, rest_length: float) -> None:
-        lib.cpDampedSpringSetRestLength(self._constraint, rest_length)
-
-    rest_length = property(
-        _get_rest_length,
-        _set_rest_length,
-        doc="""The distance the spring wants to be.""",
-    )
-
-    def _get_stiffness(self) -> float:
-        return lib.cpDampedSpringGetStiffness(self._constraint)
-
-    def _set_stiffness(self, stiffness: float) -> None:
-        lib.cpDampedSpringSetStiffness(self._constraint, stiffness)
-
-    stiffness = property(
-        _get_stiffness, _set_stiffness, doc="""The spring constant (Young's modulus)."""
-    )
-
-    def _get_damping(self) -> float:
-        return lib.cpDampedSpringGetDamping(self._constraint)
-
-    def _set_damping(self, damping: float) -> None:
-        lib.cpDampedSpringSetDamping(self._constraint, damping)
-
-    damping = property(
-        _get_damping,
-        _set_damping,
-        doc="""How soft to make the damping of the spring.""",
-    )
-
-
-class DampedRotarySpring(Constraint):
-    """DampedRotarySpring works like the DammpedSpring but in a angular fashion."""
-
-    _pickle_attrs_init = Constraint._pickle_attrs_init + [
-        "rest_angle",
-        "stiffness",
-        "damping",
-    ]
-
-    def __init__(
-        self, a: "Body", b: "Body", rest_angle: float, stiffness: float, damping: float
-    ) -> None:
-        """Like a damped spring, but works in an angular fashion.
-
-        :param Body a: Body a
-        :param Body b: Body b
-        :param float rest_angle: The relative angle in radians that the bodies
-            want to have
-        :param float stiffness: The spring constant (Young's modulus).
-        :param float damping: How soft to make the damping of the spring.
-        """
-        _constraint = lib.cpDampedRotarySpringNew(
-            a._body, b._body, rest_angle, stiffness, damping
-        )
-        self._init(a, b, _constraint)
-
-    def _get_rest_angle(self) -> float:
-        return lib.cpDampedRotarySpringGetRestAngle(self._constraint)
-
-    def _set_rest_angle(self, rest_angle: float) -> None:
-        lib.cpDampedRotarySpringSetRestAngle(self._constraint, rest_angle)
-
-    rest_angle = property(
-        _get_rest_angle,
-        _set_rest_angle,
-        doc="""The relative angle in radians that the bodies want to have""",
-    )
-
-    def _get_stiffness(self) -> float:
-        return lib.cpDampedRotarySpringGetStiffness(self._constraint)
-
-    def _set_stiffness(self, stiffness: float) -> None:
-        lib.cpDampedRotarySpringSetStiffness(self._constraint, stiffness)
-
-    stiffness = property(
-        _get_stiffness, _set_stiffness, doc="""The spring constant (Young's modulus)."""
-    )
-
-    def _get_damping(self) -> float:
-        return lib.cpDampedRotarySpringGetDamping(self._constraint)
-
-    def _set_damping(self, damping: float) -> None:
-        lib.cpDampedRotarySpringSetDamping(self._constraint, damping)
-
-    damping = property(
-        _get_damping,
-        _set_damping,
-        doc="""How soft to make the damping of the spring.""",
-    )
-
-
-class RotaryLimitJoint(Constraint):
-    """RotaryLimitJoint constrains the relative rotations of two bodies."""
-
-    _pickle_attrs_init = Constraint._pickle_attrs_init + ["min", "max"]
-
-    def __init__(self, a: "Body", b: "Body", min: float, max: float) -> None:
-        """Constrains the relative rotations of two bodies.
-
-        min and max are the angular limits in radians. It is implemented so
-        that it's possible to for the range to be greater than a full
-        revolution.
-        """
-        _constraint = lib.cpRotaryLimitJointNew(a._body, b._body, min, max)
-        self._init(a, b, _constraint)
-
-    def _get_min(self) -> float:
-        return lib.cpRotaryLimitJointGetMin(self._constraint)
-
-    def _set_min(self, min: float) -> None:
-        lib.cpRotaryLimitJointSetMin(self._constraint, min)
-
-    min = property(_get_min, _set_min)
-
-    def _get_max(self) -> float:
-        return lib.cpRotaryLimitJointGetMax(self._constraint)
-
-    def _set_max(self, max: float) -> None:
-        lib.cpRotaryLimitJointSetMax(self._constraint, max)
-
-    max = property(_get_max, _set_max)
-
-
-class RatchetJoint(Constraint):
-    """RatchetJoint is a rotary ratchet, it works like a socket wrench."""
-
-    _pickle_attrs_init = Constraint._pickle_attrs_init + ["phase", "ratchet"]
-
-    def __init__(self, a: "Body", b: "Body", phase: float, ratchet: float) -> None:
-        """Works like a socket wrench.
-
-        ratchet is the distance between "clicks", phase is the initial offset
-        to use when deciding where the ratchet angles are.
-        """
-        _constraint = lib.cpRatchetJointNew(a._body, b._body, phase, ratchet)
-        self._init(a, b, _constraint)
-
-    def _get_angle(self) -> float:
-        return lib.cpRatchetJointGetAngle(self._constraint)
-
-    def _set_angle(self, angle: float) -> None:
-        lib.cpRatchetJointSetAngle(self._constraint, angle)
-
-    angle = property(_get_angle, _set_angle)
-
-    def _get_phase(self) -> float:
-        return lib.cpRatchetJointGetPhase(self._constraint)
-
-    def _set_phase(self, phase: float) -> None:
-        lib.cpRatchetJointSetPhase(self._constraint, phase)
-
-    phase = property(_get_phase, _set_phase)
-
-    def _get_ratchet(self) -> float:
-        return lib.cpRatchetJointGetRatchet(self._constraint)
-
-    def _set_ratchet(self, ratchet: float) -> None:
-        lib.cpRatchetJointSetRatchet(self._constraint, ratchet)
-
-    ratchet = property(_get_ratchet, _set_ratchet)
-
-
-class GearJoint(Constraint):
-    """GearJoint keeps the angular velocity ratio of a pair of bodies constant."""
-
-    _pickle_attrs_init = Constraint._pickle_attrs_init + ["phase", "ratio"]
-
-    def __init__(self, a: "Body", b: "Body", phase: float, ratio: float):
-        """Keeps the angular velocity ratio of a pair of bodies constant.
-
-        ratio is always measured in absolute terms. It is currently not
-        possible to set the ratio in relation to a third body's angular
-        velocity. phase is the initial angular offset of the two bodies.
-        """
-        _constraint = lib.cpGearJointNew(a._body, b._body, phase, ratio)
-        self._init(a, b, _constraint)
-
-    def _get_phase(self) -> float:
-        return lib.cpGearJointGetPhase(self._constraint)
-
-    def _set_phase(self, phase: float) -> None:
-        lib.cpGearJointSetPhase(self._constraint, phase)
-
-    phase = property(_get_phase, _set_phase)
-
-    def _get_ratio(self) -> float:
-        return lib.cpGearJointGetRatio(self._constraint)
-
-    def _set_ratio(self, ratio: float) -> None:
-        lib.cpGearJointSetRatio(self._constraint, ratio)
-
-    ratio = property(_get_ratio, _set_ratio)
-
-
-class SimpleMotor(Constraint):
-    """SimpleMotor keeps the relative angular velocity constant."""
-
-    _pickle_attrs_init = Constraint._pickle_attrs_init + ["rate"]
-
-    def __init__(self, a: "Body", b: "Body", rate: float) -> None:
-        """Keeps the relative angular velocity of a pair of bodies constant.
-
-        rate is the desired relative angular velocity. You will usually want
-        to set an force (torque) maximum for motors as otherwise they will be
-        able to apply a nearly infinite torque to keep the bodies moving.
-        """
-        _constraint = lib.cpSimpleMotorNew(a._body, b._body, rate)
-        self._init(a, b, _constraint)
-
-    def _get_rate(self) -> float:
-        return lib.cpSimpleMotorGetRate(self._constraint)
-
-    def _set_rate(self, rate: float) -> None:
-        lib.cpSimpleMotorSetRate(self._constraint, rate)
-
-    rate = property(
-        _get_rate, _set_rate, doc="""The desired relative angular velocity"""
-    )
+# ----------------------------------------------------------------------------
+# pymunk
+# Copyright (c) 2007-2017 Victor Blomqvist
+#
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+#
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+# SOFTWARE.
+# ----------------------------------------------------------------------------
+
+"""A constraint is something that describes how two bodies interact with
+each other. (how they constrain each other). Constraints can be simple
+joints that allow bodies to pivot around each other like the bones in your
+body, or they can be more abstract like the gear joint or motors.
+
+This submodule contain all the constraints that are supported by Pymunk.
+
+All the constraints support copy and pickle from the standard library. Custom 
+properties set on a constraint will also be copied/pickled.
+
+Chipmunk has a good overview of the different constraint on youtube which
+works fine to showcase them in Pymunk as well.
+http://www.youtube.com/watch?v=ZgJJZTS0aMM
+
+.. raw:: html
+
+    <iframe width="420" height="315" style="display: block; margin: 0 auto;"
+    src="http://www.youtube.com/embed/ZgJJZTS0aMM" frameborder="0"
+    allowfullscreen></iframe>
+
+
+Example::
+
+>>> import pymunk
+>>> import pymunk.constraints
+>>> s = pymunk.Space()
+>>> a,b = pymunk.Body(10,10), pymunk.Body(10,10)
+>>> c = pymunk.constraints.PivotJoint(a, b, (0,0))
+>>> s.add(c)
+
+"""
+__docformat__ = "reStructuredText"
+
+__all__ = [
+    "Constraint",
+    "PinJoint",
+    "SlideJoint",
+    "PivotJoint",
+    "GrooveJoint",
+    "DampedSpring",
+    "DampedRotarySpring",
+    "RotaryLimitJoint",
+    "RatchetJoint",
+    "GearJoint",
+    "SimpleMotor",
+]
+
+import logging
+from typing import TYPE_CHECKING, Any, Callable, Dict, List, Optional, Tuple, Union
+
+if TYPE_CHECKING:
+    from .body import Body
+    from .space import Space
+
+from ._chipmunk_cffi import ffi, lib
+from ._pickle import PickleMixin
+from ._typing_attr import TypingAttrMixing
+from .vec2d import Vec2d
+
+_logger = logging.getLogger(__name__)
+
+
+class Constraint(PickleMixin, TypingAttrMixing, object):
+    """Base class of all constraints.
+
+    You usually don't want to create instances of this class directly, but
+    instead use one of the specific constraints such as the PinJoint.
+    """
+
+    _pickle_attrs_init = PickleMixin._pickle_attrs_init + ["a", "b"]
+    _pickle_attrs_general = PickleMixin._pickle_attrs_general + [
+        "max_force",
+        "error_bias",
+        "max_bias",
+        "collide_bodies",
+    ]
+    _pickle_attrs_skip = PickleMixin._pickle_attrs_skip + ["pre_solve", "post_solve"]
+
+    _pre_solve_func: Optional[Callable[["Constraint", "Space"], None]] = None
+    _post_solve_func: Optional[Callable[["Constraint", "Space"], None]] = None
+
+    def __init__(self, constraint: ffi.CData) -> None:
+        self._constraint = constraint
+
+    def _init(self, a: "Body", b: "Body", _constraint: Any) -> None:
+        def constraintfree(cp_constraint: ffi.CData) -> None:
+            cp_space = lib.cpConstraintGetSpace(cp_constraint)
+            if cp_space != ffi.NULL:
+                lib.cpSpaceRemoveConstraint(cp_space, cp_constraint)
+
+            _logger.debug("constraintfree %s", cp_constraint)
+            lib.cpConstraintFree(cp_constraint)
+
+        self._constraint = ffi.gc(_constraint, constraintfree)
+        self._set_bodies(a, b)
+
+        d = ffi.new_handle(self)
+        self._data_handle = d  # to prevent gc to collect the handle
+        lib.cpConstraintSetUserData(self._constraint, d)
+
+    def _get_max_force(self) -> float:
+        return lib.cpConstraintGetMaxForce(self._constraint)
+
+    def _set_max_force(self, f: float) -> None:
+        lib.cpConstraintSetMaxForce(self._constraint, f)
+
+    max_force = property(
+        _get_max_force,
+        _set_max_force,
+        doc="""The maximum force that the constraint can use to act on the two
+        bodies.
+
+        Defaults to infinity
+        """,
+    )
+
+    def _get_error_bias(self) -> float:
+        return lib.cpConstraintGetErrorBias(self._constraint)
+
+    def _set_error_bias(self, error_bias: float) -> None:
+        lib.cpConstraintSetErrorBias(self._constraint, error_bias)
+
+    error_bias = property(
+        _get_error_bias,
+        _set_error_bias,
+        doc="""The percentage of joint error that remains unfixed after a
+        second.
+
+        This works exactly the same as the collision bias property of a space,
+        but applies to fixing error (stretching) of joints instead of
+        overlapping collisions.
+
+        Defaults to pow(1.0 - 0.1, 60.0) meaning that it will correct 10% of
+        the error every 1/60th of a second.
+        """,
+    )
+
+    def _get_max_bias(self) -> float:
+        return lib.cpConstraintGetMaxBias(self._constraint)
+
+    def _set_max_bias(self, max_bias: float) -> None:
+        lib.cpConstraintSetMaxBias(self._constraint, max_bias)
+
+    max_bias = property(
+        _get_max_bias,
+        _set_max_bias,
+        doc="""The maximum speed at which the constraint can apply error
+        correction.
+
+        Defaults to infinity
+        """,
+    )
+
+    def _get_collide_bodies(self) -> bool:
+        return lib.cpConstraintGetCollideBodies(self._constraint)
+
+    def _set_collide_bodies(self, collide_bodies: bool) -> None:
+        lib.cpConstraintSetCollideBodies(self._constraint, collide_bodies)
+
+    collide_bodies = property(
+        _get_collide_bodies,
+        _set_collide_bodies,
+        doc="""Constraints can be used for filtering collisions too.
+
+        When two bodies collide, Pymunk ignores the collisions if this property
+        is set to False on any constraint that connects the two bodies.
+        Defaults to True. This can be used to create a chain that self
+        collides, but adjacent links in the chain do not collide.
+        """,
+    )
+
+    @property
+    def impulse(self) -> float:
+        """The most recent impulse that constraint applied.
+
+        To convert this to a force, divide by the timestep passed to
+        space.step(). You can use this to implement breakable joints to check
+        if the force they attempted to apply exceeded a certain threshold.
+        """
+        return lib.cpConstraintGetImpulse(self._constraint)
+
+    @property
+    def a(self) -> "Body":
+        """The first of the two bodies constrained"""
+        return self._a
+
+    @property
+    def b(self) -> "Body":
+        """The second of the two bodies constrained"""
+        return self._b
+
+    def activate_bodies(self) -> None:
+        """Activate the bodies this constraint is attached to"""
+        self._a.activate()
+        self._b.activate()
+
+    @property
+    def pre_solve(self) -> Optional[Callable[["Constraint", "Space"], None]]:
+        """The pre-solve function is called before the constraint solver runs.
+
+        Note that None can be used to reset it to default value.
+
+        >>> import pymunk
+        >>> j = pymunk.PinJoint(pymunk.Body(1,2), pymunk.Body(3,4), (0,0))
+        >>> def pre_solve_func(constraint, space):
+        ...     print("Hello from pre-solve")
+        >>> j.pre_solve = pre_solve_func
+        >>> j.pre_solve = None
+        """
+
+        return self._pre_solve_func
+
+    @pre_solve.setter
+    def pre_solve(
+        self, func: Optional[Callable[["Constraint", "Space"], None]]
+    ) -> None:
+        self._pre_solve_func = func
+
+        if func is None:
+            lib.cpConstraintSetPreSolveFunc(self._constraint, ffi.NULL)
+        else:
+            lib.cpConstraintSetPreSolveFunc(
+                self._constraint, lib.ext_cpConstraintPreSolveFunc
+            )
+
+    @property
+    def post_solve(self) -> Optional[Callable[["Constraint", "Space"], None]]:
+        """The post-solve function is called after the constraint solver runs.
+
+        Note that None can be used to reset it to default value.
+
+        >>> import pymunk
+        >>> j = pymunk.PinJoint(pymunk.Body(1,2), pymunk.Body(3,4), (0,0))
+        >>> def post_solve_func(constraint, space):
+        ...     print("Hello from pre-solve")
+        >>> j.post_solve = post_solve_func
+        >>> j.post_solve = None
+        """
+        return self._post_solve_func
+
+    @post_solve.setter
+    def post_solve(
+        self, func: Optional[Callable[["Constraint", "Space"], None]]
+    ) -> None:
+        self._post_solve_func = func
+
+        if func is None:
+            lib.cpConstraintSetPostSolveFunc(self._constraint, ffi.NULL)
+        else:
+            lib.cpConstraintSetPostSolveFunc(
+                self._constraint, lib.ext_cpConstraintPostSolveFunc
+            )
+
+    def _set_bodies(self, a: "Body", b: "Body") -> None:
+        assert a is not b
+        self._a = a
+        self._b = b
+        a._constraints.add(self)
+        b._constraints.add(self)
+
+    def __getstate__(self) -> Dict[str, List[Tuple[str, Any]]]:
+        """Return the state of this object
+
+        This method allows the usage of the :mod:`copy` and :mod:`pickle`
+        modules with this class.
+        """
+        d = super(Constraint, self).__getstate__()
+
+        d["special"].append(("_pre_solve_func", self._pre_solve_func))
+        d["special"].append(("_post_solve_func", self._post_solve_func))
+
+        return d
+
+    def __setstate__(self, state: Dict[str, List[Tuple[str, Any]]]) -> None:
+        """Unpack this object from a saved state.
+
+        This method allows the usage of the :mod:`copy` and :mod:`pickle`
+        modules with this class.
+        """
+        super(Constraint, self).__setstate__(state)
+
+        for k, v in state["special"]:
+            if k == "_pre_solve_func" and v != None:
+                self.pre_solve = v
+            elif k == "_post_solve_func" and v != None:
+                self.post_solve = v
+
+
+class PinJoint(Constraint):
+    """PinJoint links shapes with a solid bar or pin.
+
+    Keeps the anchor points at a set distance from one another.
+    """
+
+    _pickle_attrs_init = Constraint._pickle_attrs_init + ["anchor_a", "anchor_b"]
+
+    def __init__(
+        self,
+        a: "Body",
+        b: "Body",
+        anchor_a: Tuple[float, float] = (0, 0),
+        anchor_b: Tuple[float, float] = (0, 0),
+    ) -> None:
+        """a and b are the two bodies to connect, and anchor_a and anchor_b are
+        the anchor points on those bodies.
+
+        The distance between the two anchor points is measured when the joint
+        is created. If you want to set a specific distance, use the setter
+        function to override it.
+        """
+        assert len(anchor_a) == 2
+        assert len(anchor_b) == 2
+        _constraint = lib.cpPinJointNew(a._body, b._body, anchor_a, anchor_b)
+        self._init(a, b, _constraint)
+
+    def _get_anchor_a(self) -> Vec2d:
+        v = lib.cpPinJointGetAnchorA(self._constraint)
+        return Vec2d(v.x, v.y)
+
+    def _set_anchor_a(self, anchor: Tuple[float, float]) -> None:
+        assert len(anchor) == 2
+        lib.cpPinJointSetAnchorA(self._constraint, anchor)
+
+    anchor_a = property(_get_anchor_a, _set_anchor_a)
+
+    def _get_anchor_b(self) -> Vec2d:
+        v = lib.cpPinJointGetAnchorB(self._constraint)
+        return Vec2d(v.x, v.y)
+
+    def _set_anchor_b(self, anchor: Tuple[float, float]) -> None:
+        assert len(anchor) == 2
+        lib.cpPinJointSetAnchorB(self._constraint, anchor)
+
+    anchor_b = property(_get_anchor_b, _set_anchor_b)
+
+    def _get_distance(self) -> float:
+        return lib.cpPinJointGetDist(self._constraint)
+
+    def _set_distance(self, distance: float) -> None:
+        lib.cpPinJointSetDist(self._constraint, distance)
+
+    distance = property(_get_distance, _set_distance)
+
+
+class SlideJoint(Constraint):
+    """SlideJoint is like a PinJoint, but have a minimum and maximum distance.
+
+    A chain could be modeled using this joint. It keeps the anchor points
+    from getting to far apart, but will allow them to get closer together.
+    """
+
+    _pickle_attrs_init = Constraint._pickle_attrs_init + [
+        "anchor_a",
+        "anchor_b",
+        "min",
+        "max",
+    ]
+
+    def __init__(
+        self,
+        a: "Body",
+        b: "Body",
+        anchor_a: Tuple[float, float],
+        anchor_b: Tuple[float, float],
+        min: float,
+        max: float,
+    ) -> None:
+        """a and b are the two bodies to connect, anchor_a and anchor_b are the
+        anchor points on those bodies, and min and max define the allowed
+        distances of the anchor points.
+        """
+        assert len(anchor_a) == 2
+        assert len(anchor_b) == 2
+        _constraint = lib.cpSlideJointNew(
+            a._body, b._body, anchor_a, anchor_b, min, max
+        )
+        self._init(a, b, _constraint)
+
+    def _get_anchor_a(self) -> Vec2d:
+        v = lib.cpSlideJointGetAnchorA(self._constraint)
+        return Vec2d(v.x, v.y)
+
+    def _set_anchor_a(self, anchor: Tuple[float, float]) -> None:
+        assert len(anchor) == 2
+        lib.cpSlideJointSetAnchorA(self._constraint, anchor)
+
+    anchor_a = property(_get_anchor_a, _set_anchor_a)
+
+    def _get_anchor_b(self) -> Vec2d:
+        v = lib.cpSlideJointGetAnchorB(self._constraint)
+        return Vec2d(v.x, v.y)
+
+    def _set_anchor_b(self, anchor: Tuple[float, float]) -> None:
+        assert len(anchor) == 2
+        lib.cpSlideJointSetAnchorB(self._constraint, anchor)
+
+    anchor_b = property(_get_anchor_b, _set_anchor_b)
+
+    def _get_min(self) -> float:
+        return lib.cpSlideJointGetMin(self._constraint)
+
+    def _set_min(self, min: float) -> None:
+        lib.cpSlideJointSetMin(self._constraint, min)
+
+    min = property(_get_min, _set_min)
+
+    def _get_max(self) -> float:
+        return lib.cpSlideJointGetMax(self._constraint)
+
+    def _set_max(self, max: float) -> None:
+        lib.cpSlideJointSetMax(self._constraint, max)
+
+    max = property(_get_max, _set_max)
+
+
+class PivotJoint(Constraint):
+    """PivotJoint allow two objects to pivot about a single point.
+
+    Its like a swivel.
+    """
+
+    _pickle_attrs_init = Constraint._pickle_attrs_init + ["anchor_a", "anchor_b"]
+
+    def __init__(
+        self,
+        a: "Body",
+        b: "Body",
+        *args: Union[
+            Tuple[float, float], Tuple[Tuple[float, float], Tuple[float, float]]
+        ]
+    ) -> None:
+        """a and b are the two bodies to connect, and pivot is the point in
+        world coordinates of the pivot.
+
+        Because the pivot location is given in world coordinates, you must
+        have the bodies moved into the correct positions already.
+        Alternatively you can specify the joint based on a pair of anchor
+        points, but make sure you have the bodies in the right place as the
+        joint will fix itself as soon as you start simulating the space.
+
+        That is, either create the joint with PivotJoint(a, b, pivot) or
+        PivotJoint(a, b, anchor_a, anchor_b).
+
+        :param Body a: The first of the two bodies
+        :param Body b: The second of the two bodies
+        :param args: Either one pivot point, or two anchor points
+        :type args: (float,float) or (float,float) (float,float)
+        """
+        if len(args) == 1:
+            assert len(args[0]) == 2
+            _constraint = lib.cpPivotJointNew(a._body, b._body, args[0])
+        elif len(args) == 2:
+            assert len(args[0]) == 2
+            assert len(args[1]) == 2
+            _constraint = lib.cpPivotJointNew2(a._body, b._body, args[0], args[1])
+        else:
+            raise Exception(
+                "You must specify either one pivot point" " or two anchor points"
+            )
+
+        self._init(a, b, _constraint)
+
+    def _get_anchor_a(self) -> Vec2d:
+        v = lib.cpPivotJointGetAnchorA(self._constraint)
+        return Vec2d(v.x, v.y)
+
+    def _set_anchor_a(self, anchor: Tuple[float, float]) -> None:
+        assert len(anchor) == 2
+        lib.cpPivotJointSetAnchorA(self._constraint, anchor)
+
+    anchor_a = property(_get_anchor_a, _set_anchor_a)
+
+    def _get_anchor_b(self) -> Vec2d:
+        v = lib.cpPivotJointGetAnchorB(self._constraint)
+        return Vec2d(v.x, v.y)
+
+    def _set_anchor_b(self, anchor: Tuple[float, float]) -> None:
+        assert len(anchor) == 2
+        lib.cpPivotJointSetAnchorB(self._constraint, anchor)
+
+    anchor_b = property(_get_anchor_b, _set_anchor_b)
+
+
+class GrooveJoint(Constraint):
+    """GrooveJoint is similar to a PivotJoint, but with a linear slide.
+
+    One of the anchor points is a line segment that the pivot can slide in instead of being fixed.
+    """
+
+    _pickle_attrs_init = Constraint._pickle_attrs_init + [
+        "groove_a",
+        "groove_b",
+        "anchor_b",
+    ]
+
+    def __init__(
+        self,
+        a: "Body",
+        b: "Body",
+        groove_a: Tuple[float, float],
+        groove_b: Tuple[float, float],
+        anchor_b: Tuple[float, float],
+    ) -> None:
+        """The groove goes from groove_a to groove_b on body a, and the pivot
+        is attached to anchor_b on body b.
+
+        All coordinates are body local.
+        """
+        assert len(groove_a) == 2
+        assert len(groove_b) == 2
+        assert len(anchor_b) == 2
+        _constraint = lib.cpGrooveJointNew(
+            a._body, b._body, groove_a, groove_b, anchor_b
+        )
+        self._init(a, b, _constraint)
+
+    def _get_anchor_b(self) -> Vec2d:
+        v = lib.cpGrooveJointGetAnchorB(self._constraint)
+        return Vec2d(v.x, v.y)
+
+    def _set_anchor_b(self, anchor: Tuple[float, float]) -> None:
+        assert len(anchor) == 2
+        lib.cpGrooveJointSetAnchorB(self._constraint, anchor)
+
+    anchor_b = property(_get_anchor_b, _set_anchor_b)
+
+    def _get_groove_a(self) -> Vec2d:
+        v = lib.cpGrooveJointGetGrooveA(self._constraint)
+        return Vec2d(v.x, v.y)
+
+    def _set_groove_a(self, groove: Tuple[float, float]) -> None:
+        assert len(groove) == 2
+        lib.cpGrooveJointSetGrooveA(self._constraint, groove)
+
+    groove_a = property(_get_groove_a, _set_groove_a)
+
+    def _get_groove_b(self) -> Vec2d:
+        v = lib.cpGrooveJointGetGrooveB(self._constraint)
+        return Vec2d(v.x, v.y)
+
+    def _set_groove_b(self, groove: Tuple[float, float]) -> None:
+        assert len(groove) == 2
+        lib.cpGrooveJointSetGrooveB(self._constraint, groove)
+
+    groove_b = property(_get_groove_b, _set_groove_b)
+
+
+class DampedSpring(Constraint):
+    """DampedSpring is a damped spring.
+
+    The spring allows you to define the rest length, stiffness and damping.
+    """
+
+    _pickle_attrs_init = Constraint._pickle_attrs_init + [
+        "anchor_a",
+        "anchor_b",
+        "rest_length",
+        "stiffness",
+        "damping",
+    ]
+
+    def __init__(
+        self,
+        a: "Body",
+        b: "Body",
+        anchor_a: Tuple[float, float],
+        anchor_b: Tuple[float, float],
+        rest_length: float,
+        stiffness: float,
+        damping: float,
+    ) -> None:
+        """Defined much like a slide joint.
+
+        :param Body a: Body a
+        :param Body b: Body b
+        :param anchor_a: Anchor point a, relative to body a
+        :type anchor_a: `(float,float)`
+        :param anchor_b: Anchor point b, relative to body b
+        :type anchor_b: `(float,float)`
+        :param float rest_length: The distance the spring wants to be.
+        :param float stiffness: The spring constant (Young's modulus).
+        :param float damping: How soft to make the damping of the spring.
+        """
+        assert len(anchor_a) == 2
+        assert len(anchor_b) == 2
+        _constraint = lib.cpDampedSpringNew(
+            a._body,
+            b._body,
+            anchor_a,
+            anchor_b,
+            rest_length,
+            stiffness,
+            damping,
+        )
+
+        self._init(a, b, _constraint)
+
+    def _get_anchor_a(self) -> Vec2d:
+        v = lib.cpDampedSpringGetAnchorA(self._constraint)
+        return Vec2d(v.x, v.y)
+
+    def _set_anchor_a(self, anchor: Tuple[float, float]) -> None:
+        assert len(anchor) == 2
+        lib.cpDampedSpringSetAnchorA(self._constraint, anchor)
+
+    anchor_a = property(_get_anchor_a, _set_anchor_a)
+
+    def _get_anchor_b(self) -> Vec2d:
+        v = lib.cpDampedSpringGetAnchorB(self._constraint)
+        return Vec2d(v.x, v.y)
+
+    def _set_anchor_b(self, anchor: Tuple[float, float]) -> None:
+        assert len(anchor) == 2
+        lib.cpDampedSpringSetAnchorB(self._constraint, anchor)
+
+    anchor_b = property(_get_anchor_b, _set_anchor_b)
+
+    def _get_rest_length(self) -> float:
+        return lib.cpDampedSpringGetRestLength(self._constraint)
+
+    def _set_rest_length(self, rest_length: float) -> None:
+        lib.cpDampedSpringSetRestLength(self._constraint, rest_length)
+
+    rest_length = property(
+        _get_rest_length,
+        _set_rest_length,
+        doc="""The distance the spring wants to be.""",
+    )
+
+    def _get_stiffness(self) -> float:
+        return lib.cpDampedSpringGetStiffness(self._constraint)
+
+    def _set_stiffness(self, stiffness: float) -> None:
+        lib.cpDampedSpringSetStiffness(self._constraint, stiffness)
+
+    stiffness = property(
+        _get_stiffness, _set_stiffness, doc="""The spring constant (Young's modulus)."""
+    )
+
+    def _get_damping(self) -> float:
+        return lib.cpDampedSpringGetDamping(self._constraint)
+
+    def _set_damping(self, damping: float) -> None:
+        lib.cpDampedSpringSetDamping(self._constraint, damping)
+
+    damping = property(
+        _get_damping,
+        _set_damping,
+        doc="""How soft to make the damping of the spring.""",
+    )
+
+
+class DampedRotarySpring(Constraint):
+    """DampedRotarySpring works like the DammpedSpring but in a angular fashion."""
+
+    _pickle_attrs_init = Constraint._pickle_attrs_init + [
+        "rest_angle",
+        "stiffness",
+        "damping",
+    ]
+
+    def __init__(
+        self, a: "Body", b: "Body", rest_angle: float, stiffness: float, damping: float
+    ) -> None:
+        """Like a damped spring, but works in an angular fashion.
+
+        :param Body a: Body a
+        :param Body b: Body b
+        :param float rest_angle: The relative angle in radians that the bodies
+            want to have
+        :param float stiffness: The spring constant (Young's modulus).
+        :param float damping: How soft to make the damping of the spring.
+        """
+        _constraint = lib.cpDampedRotarySpringNew(
+            a._body, b._body, rest_angle, stiffness, damping
+        )
+        self._init(a, b, _constraint)
+
+    def _get_rest_angle(self) -> float:
+        return lib.cpDampedRotarySpringGetRestAngle(self._constraint)
+
+    def _set_rest_angle(self, rest_angle: float) -> None:
+        lib.cpDampedRotarySpringSetRestAngle(self._constraint, rest_angle)
+
+    rest_angle = property(
+        _get_rest_angle,
+        _set_rest_angle,
+        doc="""The relative angle in radians that the bodies want to have""",
+    )
+
+    def _get_stiffness(self) -> float:
+        return lib.cpDampedRotarySpringGetStiffness(self._constraint)
+
+    def _set_stiffness(self, stiffness: float) -> None:
+        lib.cpDampedRotarySpringSetStiffness(self._constraint, stiffness)
+
+    stiffness = property(
+        _get_stiffness, _set_stiffness, doc="""The spring constant (Young's modulus)."""
+    )
+
+    def _get_damping(self) -> float:
+        return lib.cpDampedRotarySpringGetDamping(self._constraint)
+
+    def _set_damping(self, damping: float) -> None:
+        lib.cpDampedRotarySpringSetDamping(self._constraint, damping)
+
+    damping = property(
+        _get_damping,
+        _set_damping,
+        doc="""How soft to make the damping of the spring.""",
+    )
+
+
+class RotaryLimitJoint(Constraint):
+    """RotaryLimitJoint constrains the relative rotations of two bodies."""
+
+    _pickle_attrs_init = Constraint._pickle_attrs_init + ["min", "max"]
+
+    def __init__(self, a: "Body", b: "Body", min: float, max: float) -> None:
+        """Constrains the relative rotations of two bodies.
+
+        min and max are the angular limits in radians. It is implemented so
+        that it's possible to for the range to be greater than a full
+        revolution.
+        """
+        _constraint = lib.cpRotaryLimitJointNew(a._body, b._body, min, max)
+        self._init(a, b, _constraint)
+
+    def _get_min(self) -> float:
+        return lib.cpRotaryLimitJointGetMin(self._constraint)
+
+    def _set_min(self, min: float) -> None:
+        lib.cpRotaryLimitJointSetMin(self._constraint, min)
+
+    min = property(_get_min, _set_min)
+
+    def _get_max(self) -> float:
+        return lib.cpRotaryLimitJointGetMax(self._constraint)
+
+    def _set_max(self, max: float) -> None:
+        lib.cpRotaryLimitJointSetMax(self._constraint, max)
+
+    max = property(_get_max, _set_max)
+
+
+class RatchetJoint(Constraint):
+    """RatchetJoint is a rotary ratchet, it works like a socket wrench."""
+
+    _pickle_attrs_init = Constraint._pickle_attrs_init + ["phase", "ratchet"]
+
+    def __init__(self, a: "Body", b: "Body", phase: float, ratchet: float) -> None:
+        """Works like a socket wrench.
+
+        ratchet is the distance between "clicks", phase is the initial offset
+        to use when deciding where the ratchet angles are.
+        """
+        _constraint = lib.cpRatchetJointNew(a._body, b._body, phase, ratchet)
+        self._init(a, b, _constraint)
+
+    def _get_angle(self) -> float:
+        return lib.cpRatchetJointGetAngle(self._constraint)
+
+    def _set_angle(self, angle: float) -> None:
+        lib.cpRatchetJointSetAngle(self._constraint, angle)
+
+    angle = property(_get_angle, _set_angle)
+
+    def _get_phase(self) -> float:
+        return lib.cpRatchetJointGetPhase(self._constraint)
+
+    def _set_phase(self, phase: float) -> None:
+        lib.cpRatchetJointSetPhase(self._constraint, phase)
+
+    phase = property(_get_phase, _set_phase)
+
+    def _get_ratchet(self) -> float:
+        return lib.cpRatchetJointGetRatchet(self._constraint)
+
+    def _set_ratchet(self, ratchet: float) -> None:
+        lib.cpRatchetJointSetRatchet(self._constraint, ratchet)
+
+    ratchet = property(_get_ratchet, _set_ratchet)
+
+
+class GearJoint(Constraint):
+    """GearJoint keeps the angular velocity ratio of a pair of bodies constant."""
+
+    _pickle_attrs_init = Constraint._pickle_attrs_init + ["phase", "ratio"]
+
+    def __init__(self, a: "Body", b: "Body", phase: float, ratio: float):
+        """Keeps the angular velocity ratio of a pair of bodies constant.
+
+        ratio is always measured in absolute terms. It is currently not
+        possible to set the ratio in relation to a third body's angular
+        velocity. phase is the initial angular offset of the two bodies.
+        """
+        _constraint = lib.cpGearJointNew(a._body, b._body, phase, ratio)
+        self._init(a, b, _constraint)
+
+    def _get_phase(self) -> float:
+        return lib.cpGearJointGetPhase(self._constraint)
+
+    def _set_phase(self, phase: float) -> None:
+        lib.cpGearJointSetPhase(self._constraint, phase)
+
+    phase = property(_get_phase, _set_phase)
+
+    def _get_ratio(self) -> float:
+        return lib.cpGearJointGetRatio(self._constraint)
+
+    def _set_ratio(self, ratio: float) -> None:
+        lib.cpGearJointSetRatio(self._constraint, ratio)
+
+    ratio = property(_get_ratio, _set_ratio)
+
+
+class SimpleMotor(Constraint):
+    """SimpleMotor keeps the relative angular velocity constant."""
+
+    _pickle_attrs_init = Constraint._pickle_attrs_init + ["rate"]
+
+    def __init__(self, a: "Body", b: "Body", rate: float) -> None:
+        """Keeps the relative angular velocity of a pair of bodies constant.
+
+        rate is the desired relative angular velocity. You will usually want
+        to set an force (torque) maximum for motors as otherwise they will be
+        able to apply a nearly infinite torque to keep the bodies moving.
+        """
+        _constraint = lib.cpSimpleMotorNew(a._body, b._body, rate)
+        self._init(a, b, _constraint)
+
+    def _get_rate(self) -> float:
+        return lib.cpSimpleMotorGetRate(self._constraint)
+
+    def _set_rate(self, rate: float) -> None:
+        lib.cpSimpleMotorSetRate(self._constraint, rate)
+
+    rate = property(
+        _get_rate, _set_rate, doc="""The desired relative angular velocity"""
+    )
```

## Comparing `pymunk-6.5.0/pymunk/contact_point_set.py` & `pymunk/contact_point_set.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,81 +1,81 @@
-__docformat__ = "reStructuredText"
-
-from typing import TYPE_CHECKING, List, Tuple
-
-if TYPE_CHECKING:
-    from ._chipmunk_cffi import ffi
-
-from .vec2d import Vec2d
-
-
-class ContactPoint(object):
-    """Contains information about a contact point.
-
-    point_a and point_b are the contact position on the surface of each shape.
-
-    distance is the penetration distance of the two shapes. Overlapping
-    means it will be negative. This value is calculated as
-    dot(point2 - point1), normal) and is ignored when you set the
-    Arbiter.contact_point_set.
-    """
-
-    point_a: Vec2d
-    point_b: Vec2d
-    distance: float
-
-    __slots__ = ("point_a", "point_b", "distance")
-
-    def __init__(
-        self,
-        point_a: Vec2d,
-        point_b: Vec2d,
-        distance: float,
-    ) -> None:
-        assert len(point_a) == 2
-        assert len(point_b) == 2
-        self.point_a = point_a
-        self.point_b = point_b
-        self.distance = distance
-
-    def __repr__(self) -> str:
-        return "ContactPoint(point_a={}, point_b={}, distance={})".format(
-            self.point_a, self.point_b, self.distance
-        )
-
-
-class ContactPointSet(object):
-    """Contact point sets make getting contact information simpler.
-
-    normal is the normal of the collision
-
-    points is the array of contact points. Can be at most 2 points.
-    """
-
-    normal: Vec2d
-    points: List[ContactPoint]
-
-    __slots__ = ("normal", "points")
-
-    def __init__(self, normal: Vec2d, points: List[ContactPoint]) -> None:
-        assert len(normal) == 2
-        self.normal = normal
-        self.points = points
-
-    def __repr__(self) -> str:
-        return "ContactPointSet(normal={}, points={})".format(self.normal, self.points)
-
-    @classmethod
-    def _from_cp(cls, _points: "ffi.CData") -> "ContactPointSet":
-        normal = Vec2d(_points.normal.x, _points.normal.y)
-
-        points = []
-        for i in range(_points.count):
-            _p = _points.points[i]
-            p = ContactPoint(
-                Vec2d(_p.pointA.x, _p.pointA.y),
-                Vec2d(_p.pointB.x, _p.pointB.y),
-                _p.distance,
-            )
-            points.append(p)
-
-        return cls(normal, points)
+__docformat__ = "reStructuredText"
+
+from typing import TYPE_CHECKING, List, Tuple
+
+if TYPE_CHECKING:
+    from ._chipmunk_cffi import ffi
+
+from .vec2d import Vec2d
+
+
+class ContactPoint(object):
+    """Contains information about a contact point.
+
+    point_a and point_b are the contact position on the surface of each shape.
+
+    distance is the penetration distance of the two shapes. Overlapping
+    means it will be negative. This value is calculated as
+    dot(point2 - point1), normal) and is ignored when you set the
+    Arbiter.contact_point_set.
+    """
+
+    point_a: Vec2d
+    point_b: Vec2d
+    distance: float
+
+    __slots__ = ("point_a", "point_b", "distance")
+
+    def __init__(
+        self,
+        point_a: Vec2d,
+        point_b: Vec2d,
+        distance: float,
+    ) -> None:
+        assert len(point_a) == 2
+        assert len(point_b) == 2
+        self.point_a = point_a
+        self.point_b = point_b
+        self.distance = distance
+
+    def __repr__(self) -> str:
+        return "ContactPoint(point_a={}, point_b={}, distance={})".format(
+            self.point_a, self.point_b, self.distance
+        )
+
+
+class ContactPointSet(object):
+    """Contact point sets make getting contact information simpler.
+
+    normal is the normal of the collision
+
+    points is the array of contact points. Can be at most 2 points.
+    """
+
+    normal: Vec2d
+    points: List[ContactPoint]
+
+    __slots__ = ("normal", "points")
+
+    def __init__(self, normal: Vec2d, points: List[ContactPoint]) -> None:
+        assert len(normal) == 2
+        self.normal = normal
+        self.points = points
+
+    def __repr__(self) -> str:
+        return "ContactPointSet(normal={}, points={})".format(self.normal, self.points)
+
+    @classmethod
+    def _from_cp(cls, _points: "ffi.CData") -> "ContactPointSet":
+        normal = Vec2d(_points.normal.x, _points.normal.y)
+
+        points = []
+        for i in range(_points.count):
+            _p = _points.points[i]
+            p = ContactPoint(
+                Vec2d(_p.pointA.x, _p.pointA.y),
+                Vec2d(_p.pointB.x, _p.pointB.y),
+                _p.distance,
+            )
+            points.append(p)
+
+        return cls(normal, points)
```

## Comparing `pymunk-6.5.0/pymunk/matplotlib_util.py` & `pymunk/matplotlib_util.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,121 +1,121 @@
-"""This submodule contains helper functions to help with quick prototyping 
-using pymunk together with pyglet.
-
-Intended to help with debugging and prototyping, not for actual production use
-in a full application. The methods contained in this module is opinionated 
-about your coordinate system and not very optimized (they use batched 
-drawing, but there is probably room for optimizations still). 
-"""
-
-__docformat__ = "reStructuredText"
-
-from typing import TYPE_CHECKING, Any, Sequence
-
-import matplotlib.pyplot as plt  # type: ignore
-
-import pymunk
-from pymunk.space_debug_draw_options import SpaceDebugColor
-from pymunk.vec2d import Vec2d
-
-if TYPE_CHECKING:
-    import matplotlib as mpl
-
-
-class DrawOptions(pymunk.SpaceDebugDrawOptions):
-    def __init__(self, ax: Any) -> None:
-        """DrawOptions for space.debug_draw() to draw a space on a ax object.
-
-        Typical usage::
-
-        >>> import matplotlib as mpl
-        >>> import matplotlib.pyplot as plt
-        >>> import pymunk
-        >>> import pymunk.matplotlib_util
-        >>> space = pymunk.Space()
-        >>> ax = plt.subplot()
-        >>> options = pymunk.matplotlib_util.DrawOptions(ax)
-        >>> space.debug_draw(options)
-
-        You can control the color of a Shape by setting shape.color to the color
-        you want it drawn in.
-
-        >>> shape = pymunk.Circle(space.static_body, 10)
-        >>> shape.color = (1, 0, 0, 1) # will draw shape in red
-
-        See matplotlib_util.demo.py for a full example
-
-        :Param:
-            ax: matplotlib.Axes
-                A matplotlib Axes object.
-
-        """
-        super(DrawOptions, self).__init__()
-
-        self.ax = ax
-
-    def draw_circle(
-        self,
-        pos: Vec2d,
-        angle: float,
-        radius: float,
-        outline_color: SpaceDebugColor,
-        fill_color: SpaceDebugColor,
-    ) -> None:
-        p = plt.Circle(
-            pos,
-            radius,
-            facecolor=fill_color.as_float(),
-            edgecolor=outline_color.as_float(),
-        )
-        self.ax.add_patch(p)
-
-        circle_edge = pos + Vec2d(radius, 0).rotated(angle)
-        line = plt.Line2D(
-            [pos.x, circle_edge.x],
-            [pos.y, circle_edge.y],
-            linewidth=1,
-            color=outline_color.as_float(),
-        )
-        line.set_solid_capstyle("round")
-        self.ax.add_line(line)
-
-    def draw_segment(self, a: Vec2d, b: Vec2d, color: SpaceDebugColor) -> None:
-        line = plt.Line2D([a.x, b.x], [a.y, b.y], linewidth=1, color=color.as_float())
-        line.set_solid_capstyle("round")
-        self.ax.add_line(line)
-
-    def draw_fat_segment(
-        self,
-        a: Vec2d,
-        b: Vec2d,
-        radius: float,
-        outline_color: SpaceDebugColor,
-        fill_color: SpaceDebugColor,
-    ) -> None:
-        radius = max(1, 2 * radius)
-        line = plt.Line2D(
-            [a.x, b.x], [a.y, b.y], linewidth=radius, color=fill_color.as_float()
-        )
-        line.set_solid_capstyle("round")
-        self.ax.add_line(line)
-
-    def draw_polygon(
-        self,
-        verts: Sequence[Vec2d],
-        radius: float,
-        outline_color: SpaceDebugColor,
-        fill_color: SpaceDebugColor,
-    ) -> None:
-        radius = max(1, 2 * radius)
-        p = plt.Polygon(
-            verts,
-            linewidth=radius,
-            joinstyle="round",
-            facecolor=fill_color.as_float(),
-            edgecolor=outline_color.as_float(),
-        )
-        self.ax.add_patch(p)
-
-    def draw_dot(self, size: float, pos: Vec2d, color: SpaceDebugColor) -> None:
-        p = plt.Circle(pos, size, facecolor=color.as_float(), edgecolor="None")
-        self.ax.add_patch(p)
+"""This submodule contains helper functions to help with quick prototyping 
+using pymunk together with pyglet.
+
+Intended to help with debugging and prototyping, not for actual production use
+in a full application. The methods contained in this module is opinionated 
+about your coordinate system and not very optimized (they use batched 
+drawing, but there is probably room for optimizations still). 
+"""
+
+__docformat__ = "reStructuredText"
+
+from typing import TYPE_CHECKING, Any, Sequence
+
+import matplotlib.pyplot as plt  # type: ignore
+
+import pymunk
+from pymunk.space_debug_draw_options import SpaceDebugColor
+from pymunk.vec2d import Vec2d
+
+if TYPE_CHECKING:
+    import matplotlib as mpl
+
+
+class DrawOptions(pymunk.SpaceDebugDrawOptions):
+    def __init__(self, ax: Any) -> None:
+        """DrawOptions for space.debug_draw() to draw a space on a ax object.
+
+        Typical usage::
+
+        >>> import matplotlib as mpl
+        >>> import matplotlib.pyplot as plt
+        >>> import pymunk
+        >>> import pymunk.matplotlib_util
+        >>> space = pymunk.Space()
+        >>> ax = plt.subplot()
+        >>> options = pymunk.matplotlib_util.DrawOptions(ax)
+        >>> space.debug_draw(options)
+
+        You can control the color of a Shape by setting shape.color to the color
+        you want it drawn in.
+
+        >>> shape = pymunk.Circle(space.static_body, 10)
+        >>> shape.color = (1, 0, 0, 1) # will draw shape in red
+
+        See matplotlib_util.demo.py for a full example
+
+        :Param:
+            ax: matplotlib.Axes
+                A matplotlib Axes object.
+
+        """
+        super(DrawOptions, self).__init__()
+
+        self.ax = ax
+
+    def draw_circle(
+        self,
+        pos: Vec2d,
+        angle: float,
+        radius: float,
+        outline_color: SpaceDebugColor,
+        fill_color: SpaceDebugColor,
+    ) -> None:
+        p = plt.Circle(
+            pos,
+            radius,
+            facecolor=fill_color.as_float(),
+            edgecolor=outline_color.as_float(),
+        )
+        self.ax.add_patch(p)
+
+        circle_edge = pos + Vec2d(radius, 0).rotated(angle)
+        line = plt.Line2D(
+            [pos.x, circle_edge.x],
+            [pos.y, circle_edge.y],
+            linewidth=1,
+            color=outline_color.as_float(),
+        )
+        line.set_solid_capstyle("round")
+        self.ax.add_line(line)
+
+    def draw_segment(self, a: Vec2d, b: Vec2d, color: SpaceDebugColor) -> None:
+        line = plt.Line2D([a.x, b.x], [a.y, b.y], linewidth=1, color=color.as_float())
+        line.set_solid_capstyle("round")
+        self.ax.add_line(line)
+
+    def draw_fat_segment(
+        self,
+        a: Vec2d,
+        b: Vec2d,
+        radius: float,
+        outline_color: SpaceDebugColor,
+        fill_color: SpaceDebugColor,
+    ) -> None:
+        radius = max(1, 2 * radius)
+        line = plt.Line2D(
+            [a.x, b.x], [a.y, b.y], linewidth=radius, color=fill_color.as_float()
+        )
+        line.set_solid_capstyle("round")
+        self.ax.add_line(line)
+
+    def draw_polygon(
+        self,
+        verts: Sequence[Vec2d],
+        radius: float,
+        outline_color: SpaceDebugColor,
+        fill_color: SpaceDebugColor,
+    ) -> None:
+        radius = max(1, 2 * radius)
+        p = plt.Polygon(
+            verts,
+            linewidth=radius,
+            joinstyle="round",
+            facecolor=fill_color.as_float(),
+            edgecolor=outline_color.as_float(),
+        )
+        self.ax.add_patch(p)
+
+    def draw_dot(self, size: float, pos: Vec2d, color: SpaceDebugColor) -> None:
+        p = plt.Circle(pos, size, facecolor=color.as_float(), edgecolor="None")
+        self.ax.add_patch(p)
```

## Comparing `pymunk-6.5.0/pymunk/pygame_util.py` & `pymunk/pygame_util.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,236 +1,236 @@
-# ----------------------------------------------------------------------------
-# pymunk
-# Copyright (c) 2007-2016 Victor Blomqvist
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice shall be included in
-# all copies or substantial portions of the Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-# ----------------------------------------------------------------------------
-
-"""This submodule contains helper functions to help with quick prototyping 
-using pymunk together with pygame.
-
-Intended to help with debugging and prototyping, not for actual production use
-in a full application. The methods contained in this module is opinionated 
-about your coordinate system and not in any way optimized. 
-"""
-
-__docformat__ = "reStructuredText"
-
-__all__ = [
-    "DrawOptions",
-    "get_mouse_pos",
-    "to_pygame",
-    "from_pygame",
-    "positive_y_is_up",
-]
-
-from typing import List, Sequence, Tuple
-
-import pygame
-
-import pymunk
-from pymunk.space_debug_draw_options import SpaceDebugColor
-from pymunk.vec2d import Vec2d
-
-positive_y_is_up: bool = False
-"""Make increasing values of y point upwards.
-
-When True::
-
-    y
-    ^
-    |      . (3, 3)
-    |
-    |   . (2, 2)
-    |
-    +------ > x
-    
-When False::
-
-    +------ > x
-    |
-    |   . (2, 2)
-    |
-    |      . (3, 3)
-    v
-    y
-    
-"""
-
-
-class DrawOptions(pymunk.SpaceDebugDrawOptions):
-    def __init__(self, surface: pygame.Surface) -> None:
-        """Draw a pymunk.Space on a pygame.Surface object.
-
-        Typical usage::
-
-        >>> import pymunk
-        >>> surface = pygame.Surface((10,10))
-        >>> space = pymunk.Space()
-        >>> options = pymunk.pygame_util.DrawOptions(surface)
-        >>> space.debug_draw(options)
-
-        You can control the color of a shape by setting shape.color to the color
-        you want it drawn in::
-
-        >>> c = pymunk.Circle(None, 10)
-        >>> c.color = pygame.Color("pink")
-
-        See pygame_util.demo.py for a full example
-
-        Since pygame uses a coordiante system where y points down (in contrast
-        to many other cases), you either have to make the physics simulation
-        with Pymunk also behave in that way, or flip everything when you draw.
-
-        The easiest is probably to just make the simulation behave the same
-        way as Pygame does. In that way all coordinates used are in the same
-        orientation and easy to reason about::
-
-        >>> space = pymunk.Space()
-        >>> space.gravity = (0, -1000)
-        >>> body = pymunk.Body()
-        >>> body.position = (0, 0) # will be positioned in the top left corner
-        >>> space.debug_draw(options)
-
-        To flip the drawing its possible to set the module property
-        :py:data:`positive_y_is_up` to True. Then the pygame drawing will flip
-        the simulation upside down before drawing::
-
-        >>> positive_y_is_up = True
-        >>> body = pymunk.Body()
-        >>> body.position = (0, 0)
-        >>> # Body will be position in bottom left corner
-
-        :Parameters:
-                surface : pygame.Surface
-                    Surface that the objects will be drawn on
-        """
-        self.surface = surface
-        super(DrawOptions, self).__init__()
-
-    def draw_circle(
-        self,
-        pos: Vec2d,
-        angle: float,
-        radius: float,
-        outline_color: SpaceDebugColor,
-        fill_color: SpaceDebugColor,
-    ) -> None:
-        p = to_pygame(pos, self.surface)
-
-        pygame.draw.circle(self.surface, fill_color.as_int(), p, round(radius), 0)
-
-        circle_edge = pos + Vec2d(radius, 0).rotated(angle)
-        p2 = to_pygame(circle_edge, self.surface)
-        line_r = 2 if radius > 20 else 1
-        pygame.draw.lines(self.surface, outline_color.as_int(), False, [p, p2], line_r)
-
-    def draw_segment(self, a: Vec2d, b: Vec2d, color: SpaceDebugColor) -> None:
-        p1 = to_pygame(a, self.surface)
-        p2 = to_pygame(b, self.surface)
-
-        pygame.draw.aalines(self.surface, color.as_int(), False, [p1, p2])
-
-    def draw_fat_segment(
-        self,
-        a: Tuple[float, float],
-        b: Tuple[float, float],
-        radius: float,
-        outline_color: SpaceDebugColor,
-        fill_color: SpaceDebugColor,
-    ) -> None:
-        p1 = to_pygame(a, self.surface)
-        p2 = to_pygame(b, self.surface)
-
-        r = round(max(1, radius * 2))
-        pygame.draw.lines(self.surface, fill_color.as_int(), False, [p1, p2], r)
-        if r > 2:
-            orthog = [abs(p2[1] - p1[1]), abs(p2[0] - p1[0])]
-            if orthog[0] == 0 and orthog[1] == 0:
-                return
-            scale = radius / (orthog[0] * orthog[0] + orthog[1] * orthog[1]) ** 0.5
-            orthog[0] = round(orthog[0] * scale)
-            orthog[1] = round(orthog[1] * scale)
-            points = [
-                (p1[0] - orthog[0], p1[1] - orthog[1]),
-                (p1[0] + orthog[0], p1[1] + orthog[1]),
-                (p2[0] + orthog[0], p2[1] + orthog[1]),
-                (p2[0] - orthog[0], p2[1] - orthog[1]),
-            ]
-            pygame.draw.polygon(self.surface, fill_color.as_int(), points)
-            pygame.draw.circle(
-                self.surface,
-                fill_color.as_int(),
-                (round(p1[0]), round(p1[1])),
-                round(radius),
-            )
-            pygame.draw.circle(
-                self.surface,
-                fill_color.as_int(),
-                (round(p2[0]), round(p2[1])),
-                round(radius),
-            )
-
-    def draw_polygon(
-        self,
-        verts: Sequence[Tuple[float, float]],
-        radius: float,
-        outline_color: SpaceDebugColor,
-        fill_color: SpaceDebugColor,
-    ) -> None:
-        ps = [to_pygame(v, self.surface) for v in verts]
-        ps += [ps[0]]
-        pygame.draw.polygon(self.surface, fill_color.as_int(), ps)
-
-        if radius > 0:
-            for i in range(len(verts)):
-                a = verts[i]
-                b = verts[(i + 1) % len(verts)]
-                self.draw_fat_segment(a, b, radius, outline_color, outline_color)
-
-    def draw_dot(
-        self, size: float, pos: Tuple[float, float], color: SpaceDebugColor
-    ) -> None:
-        p = to_pygame(pos, self.surface)
-        pygame.draw.circle(self.surface, color.as_int(), p, round(size), 0)
-
-
-def get_mouse_pos(surface: pygame.Surface) -> Tuple[int, int]:
-    """Get position of the mouse pointer in pymunk coordinates."""
-    p = pygame.mouse.get_pos()
-    return from_pygame(p, surface)
-
-
-def to_pygame(p: Tuple[float, float], surface: pygame.Surface) -> Tuple[int, int]:
-    """Convenience method to convert pymunk coordinates to pygame surface
-    local coordinates.
-
-    Note that in case positive_y_is_up is False, this function wont actually do
-    anything except converting the point to integers.
-    """
-    if positive_y_is_up:
-        return round(p[0]), surface.get_height() - round(p[1])
-    else:
-        return round(p[0]), round(p[1])
-
-
-def from_pygame(p: Tuple[float, float], surface: pygame.Surface) -> Tuple[int, int]:
-    """Convenience method to convert pygame surface local coordinates to
-    pymunk coordinates
-    """
-    return to_pygame(p, surface)
+# ----------------------------------------------------------------------------
+# pymunk
+# Copyright (c) 2007-2016 Victor Blomqvist
+#
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+#
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+# SOFTWARE.
+# ----------------------------------------------------------------------------
+
+"""This submodule contains helper functions to help with quick prototyping 
+using pymunk together with pygame.
+
+Intended to help with debugging and prototyping, not for actual production use
+in a full application. The methods contained in this module is opinionated 
+about your coordinate system and not in any way optimized. 
+"""
+
+__docformat__ = "reStructuredText"
+
+__all__ = [
+    "DrawOptions",
+    "get_mouse_pos",
+    "to_pygame",
+    "from_pygame",
+    "positive_y_is_up",
+]
+
+from typing import List, Sequence, Tuple
+
+import pygame
+
+import pymunk
+from pymunk.space_debug_draw_options import SpaceDebugColor
+from pymunk.vec2d import Vec2d
+
+positive_y_is_up: bool = False
+"""Make increasing values of y point upwards.
+
+When True::
+
+    y
+    ^
+    |      . (3, 3)
+    |
+    |   . (2, 2)
+    |
+    +------ > x
+    
+When False::
+
+    +------ > x
+    |
+    |   . (2, 2)
+    |
+    |      . (3, 3)
+    v
+    y
+    
+"""
+
+
+class DrawOptions(pymunk.SpaceDebugDrawOptions):
+    def __init__(self, surface: pygame.Surface) -> None:
+        """Draw a pymunk.Space on a pygame.Surface object.
+
+        Typical usage::
+
+        >>> import pymunk
+        >>> surface = pygame.Surface((10,10))
+        >>> space = pymunk.Space()
+        >>> options = pymunk.pygame_util.DrawOptions(surface)
+        >>> space.debug_draw(options)
+
+        You can control the color of a shape by setting shape.color to the color
+        you want it drawn in::
+
+        >>> c = pymunk.Circle(None, 10)
+        >>> c.color = pygame.Color("pink")
+
+        See pygame_util.demo.py for a full example
+
+        Since pygame uses a coordiante system where y points down (in contrast
+        to many other cases), you either have to make the physics simulation
+        with Pymunk also behave in that way, or flip everything when you draw.
+
+        The easiest is probably to just make the simulation behave the same
+        way as Pygame does. In that way all coordinates used are in the same
+        orientation and easy to reason about::
+
+        >>> space = pymunk.Space()
+        >>> space.gravity = (0, -1000)
+        >>> body = pymunk.Body()
+        >>> body.position = (0, 0) # will be positioned in the top left corner
+        >>> space.debug_draw(options)
+
+        To flip the drawing its possible to set the module property
+        :py:data:`positive_y_is_up` to True. Then the pygame drawing will flip
+        the simulation upside down before drawing::
+
+        >>> positive_y_is_up = True
+        >>> body = pymunk.Body()
+        >>> body.position = (0, 0)
+        >>> # Body will be position in bottom left corner
+
+        :Parameters:
+                surface : pygame.Surface
+                    Surface that the objects will be drawn on
+        """
+        self.surface = surface
+        super(DrawOptions, self).__init__()
+
+    def draw_circle(
+        self,
+        pos: Vec2d,
+        angle: float,
+        radius: float,
+        outline_color: SpaceDebugColor,
+        fill_color: SpaceDebugColor,
+    ) -> None:
+        p = to_pygame(pos, self.surface)
+
+        pygame.draw.circle(self.surface, fill_color.as_int(), p, round(radius), 0)
+
+        circle_edge = pos + Vec2d(radius, 0).rotated(angle)
+        p2 = to_pygame(circle_edge, self.surface)
+        line_r = 2 if radius > 20 else 1
+        pygame.draw.lines(self.surface, outline_color.as_int(), False, [p, p2], line_r)
+
+    def draw_segment(self, a: Vec2d, b: Vec2d, color: SpaceDebugColor) -> None:
+        p1 = to_pygame(a, self.surface)
+        p2 = to_pygame(b, self.surface)
+
+        pygame.draw.aalines(self.surface, color.as_int(), False, [p1, p2])
+
+    def draw_fat_segment(
+        self,
+        a: Tuple[float, float],
+        b: Tuple[float, float],
+        radius: float,
+        outline_color: SpaceDebugColor,
+        fill_color: SpaceDebugColor,
+    ) -> None:
+        p1 = to_pygame(a, self.surface)
+        p2 = to_pygame(b, self.surface)
+
+        r = round(max(1, radius * 2))
+        pygame.draw.lines(self.surface, fill_color.as_int(), False, [p1, p2], r)
+        if r > 2:
+            orthog = [abs(p2[1] - p1[1]), abs(p2[0] - p1[0])]
+            if orthog[0] == 0 and orthog[1] == 0:
+                return
+            scale = radius / (orthog[0] * orthog[0] + orthog[1] * orthog[1]) ** 0.5
+            orthog[0] = round(orthog[0] * scale)
+            orthog[1] = round(orthog[1] * scale)
+            points = [
+                (p1[0] - orthog[0], p1[1] - orthog[1]),
+                (p1[0] + orthog[0], p1[1] + orthog[1]),
+                (p2[0] + orthog[0], p2[1] + orthog[1]),
+                (p2[0] - orthog[0], p2[1] - orthog[1]),
+            ]
+            pygame.draw.polygon(self.surface, fill_color.as_int(), points)
+            pygame.draw.circle(
+                self.surface,
+                fill_color.as_int(),
+                (round(p1[0]), round(p1[1])),
+                round(radius),
+            )
+            pygame.draw.circle(
+                self.surface,
+                fill_color.as_int(),
+                (round(p2[0]), round(p2[1])),
+                round(radius),
+            )
+
+    def draw_polygon(
+        self,
+        verts: Sequence[Tuple[float, float]],
+        radius: float,
+        outline_color: SpaceDebugColor,
+        fill_color: SpaceDebugColor,
+    ) -> None:
+        ps = [to_pygame(v, self.surface) for v in verts]
+        ps += [ps[0]]
+        pygame.draw.polygon(self.surface, fill_color.as_int(), ps)
+
+        if radius > 0:
+            for i in range(len(verts)):
+                a = verts[i]
+                b = verts[(i + 1) % len(verts)]
+                self.draw_fat_segment(a, b, radius, outline_color, outline_color)
+
+    def draw_dot(
+        self, size: float, pos: Tuple[float, float], color: SpaceDebugColor
+    ) -> None:
+        p = to_pygame(pos, self.surface)
+        pygame.draw.circle(self.surface, color.as_int(), p, round(size), 0)
+
+
+def get_mouse_pos(surface: pygame.Surface) -> Tuple[int, int]:
+    """Get position of the mouse pointer in pymunk coordinates."""
+    p = pygame.mouse.get_pos()
+    return from_pygame(p, surface)
+
+
+def to_pygame(p: Tuple[float, float], surface: pygame.Surface) -> Tuple[int, int]:
+    """Convenience method to convert pymunk coordinates to pygame surface
+    local coordinates.
+
+    Note that in case positive_y_is_up is False, this function wont actually do
+    anything except converting the point to integers.
+    """
+    if positive_y_is_up:
+        return round(p[0]), surface.get_height() - round(p[1])
+    else:
+        return round(p[0]), round(p[1])
+
+
+def from_pygame(p: Tuple[float, float], surface: pygame.Surface) -> Tuple[int, int]:
+    """Convenience method to convert pygame surface local coordinates to
+    pymunk coordinates
+    """
+    return to_pygame(p, surface)
```

## Comparing `pymunk-6.5.0/pymunk/pyglet_util.py` & `pymunk/pyglet_util.py`

 * *Files identical despite different names*

## Comparing `pymunk-6.5.0/pymunk/pymunk_extension_build.py` & `pymunk/pymunk_extension_build.py`

 * *Ordering differences only*

 * *Files 19% similar despite different names*

```diff
@@ -1,85 +1,85 @@
-import os
-import os.path
-import platform
-from typing import List
-
-from cffi import FFI  # type: ignore
-
-ffibuilder = FFI()
-
-with open("pymunk/cffi/chipmunk_cdef.h", "r") as f:
-    ffibuilder.cdef(f.read())
-
-# Callbacks need extra extern Python definitions
-with open("pymunk/cffi/callbacks_cdef.h", "r") as f:
-    ffibuilder.cdef(f.read())
-
-hasty_space_include = ""
-if platform.system() != "Windows":
-    with open("pymunk/cffi/hastyspace_cdef.h", "r") as f:
-        ffibuilder.cdef(f.read())
-    hasty_space_include = """#include "chipmunk/cpHastySpace.h" """
-
-source_folders = [os.path.join("Chipmunk2D", "src")]
-sources = []
-for folder in source_folders:
-    for fn in os.listdir(folder):
-        fn_path = os.path.join(folder, fn)
-        if fn[-1] == "c":
-            # Ignore cpHastySpace since it depends on pthread which
-            # creates a dependency on libwinpthread-1.dll when built
-            # with  mingw-w64 gcc.
-            # Will prevent the code from being multithreaded, would be
-            # good if some tests could be made to verify the performance
-            # of this.
-            if platform.system() != "Windows" or fn != "cpHastySpace.c":
-                sources.append(fn_path)
-            # sources.append(fn_path)
-        elif fn[-1] == "o":
-            os.remove(fn_path)
-
-libraries: List[str] = []
-# if os == linux:
-#    libraries.append('m')
-
-extra_compile_args = []
-if platform.system() != "Windows":
-    extra_compile_args.append("-std=c99")
-# extra_compile_args.append('/Od')
-# extra_compile_args.append('/DEBUG:FULL')
-#, '/D_CHIPMUNK_FFI'],
-with open("pymunk/cffi/extensions_cdef.h", "r") as f:
-    ffibuilder.cdef(f.read())
-
-with open("pymunk/cffi/extensions.c", "r") as f:
-    custom_functions = f.read()
-
-ffibuilder.set_source(
-    "pymunk._chipmunk",  # name of the output C extension
-    f"""
-        //#include "chipmunk/chipmunk_types.h"
-        //#include "chipmunk/cpVect.h"
-        #include "chipmunk/chipmunk_ffi.h"
-        #include "chipmunk/chipmunk.h"
-        #include "chipmunk/chipmunk_unsafe.h"
-        #include "chipmunk/cpPolyline.h"
-        #include "chipmunk/cpMarch.h"
-        
-        {hasty_space_include}
-
-        // from chipmunk_private.h
-        // Ideally this should not come from here, but pickle needs it.
-        void cpSpaceSetStaticBody(cpSpace *space, cpBody *body);
-
-        {custom_functions}
-    """,
-    
-    extra_compile_args=extra_compile_args,
-    #extra_link_args=['/DEBUG:FULL'],
-    include_dirs=[os.path.join("Chipmunk2D", "include")],
-    sources=sources,
-    libraries=libraries,
-)
-
-if __name__ == "__main__":
-    ffibuilder.compile(verbose=True, debug=False)
+import os
+import os.path
+import platform
+from typing import List
+
+from cffi import FFI  # type: ignore
+
+ffibuilder = FFI()
+
+with open("pymunk/cffi/chipmunk_cdef.h", "r") as f:
+    ffibuilder.cdef(f.read())
+
+# Callbacks need extra extern Python definitions
+with open("pymunk/cffi/callbacks_cdef.h", "r") as f:
+    ffibuilder.cdef(f.read())
+
+hasty_space_include = ""
+if platform.system() != "Windows":
+    with open("pymunk/cffi/hastyspace_cdef.h", "r") as f:
+        ffibuilder.cdef(f.read())
+    hasty_space_include = """#include "chipmunk/cpHastySpace.h" """
+
+source_folders = [os.path.join("Chipmunk2D", "src")]
+sources = []
+for folder in source_folders:
+    for fn in os.listdir(folder):
+        fn_path = os.path.join(folder, fn)
+        if fn[-1] == "c":
+            # Ignore cpHastySpace since it depends on pthread which
+            # creates a dependency on libwinpthread-1.dll when built
+            # with  mingw-w64 gcc.
+            # Will prevent the code from being multithreaded, would be
+            # good if some tests could be made to verify the performance
+            # of this.
+            if platform.system() != "Windows" or fn != "cpHastySpace.c":
+                sources.append(fn_path)
+            # sources.append(fn_path)
+        elif fn[-1] == "o":
+            os.remove(fn_path)
+
+libraries: List[str] = []
+# if os == linux:
+#    libraries.append('m')
+
+extra_compile_args = []
+if platform.system() != "Windows":
+    extra_compile_args.append("-std=c99")
+# extra_compile_args.append('/Od')
+# extra_compile_args.append('/DEBUG:FULL')
+#, '/D_CHIPMUNK_FFI'],
+with open("pymunk/cffi/extensions_cdef.h", "r") as f:
+    ffibuilder.cdef(f.read())
+
+with open("pymunk/cffi/extensions.c", "r") as f:
+    custom_functions = f.read()
+
+ffibuilder.set_source(
+    "pymunk._chipmunk",  # name of the output C extension
+    f"""
+        //#include "chipmunk/chipmunk_types.h"
+        //#include "chipmunk/cpVect.h"
+        #include "chipmunk/chipmunk_ffi.h"
+        #include "chipmunk/chipmunk.h"
+        #include "chipmunk/chipmunk_unsafe.h"
+        #include "chipmunk/cpPolyline.h"
+        #include "chipmunk/cpMarch.h"
+        
+        {hasty_space_include}
+
+        // from chipmunk_private.h
+        // Ideally this should not come from here, but pickle needs it.
+        void cpSpaceSetStaticBody(cpSpace *space, cpBody *body);
+
+        {custom_functions}
+    """,
+    
+    extra_compile_args=extra_compile_args,
+    #extra_link_args=['/DEBUG:FULL'],
+    include_dirs=[os.path.join("Chipmunk2D", "include")],
+    sources=sources,
+    libraries=libraries,
+)
+
+if __name__ == "__main__":
+    ffibuilder.compile(verbose=True, debug=False)
```

## Comparing `pymunk-6.5.0/pymunk/query_info.py` & `pymunk/query_info.py`

 * *Ordering differences only*

 * *Files 27% similar despite different names*

```diff
@@ -1,75 +1,75 @@
-__docformat__ = "reStructuredText"
-
-from typing import TYPE_CHECKING, NamedTuple, Optional
-
-if TYPE_CHECKING:
-    from .contact_point_set import ContactPointSet
-    from .shapes import Shape
-    from .vec2d import Vec2d
-
-
-class PointQueryInfo(NamedTuple):
-    """PointQueryInfo holds the result of a point query made on a Shape or
-    Space.
-    """
-
-    shape: Optional["Shape"]
-    """The nearest shape, None if no shape was within range."""
-
-    point: "Vec2d"
-    """The closest point on the shape's surface. (in world space
-    coordinates)
-    """
-
-    distance: float
-    """The distance to the point. The distance is negative if the
-    point is inside the shape.
-    """
-
-    gradient: "Vec2d"
-    """The gradient of the signed distance function.
-
-    The value should be similar to
-    PointQueryInfo.point/PointQueryInfo.distance, but accurate even for
-    very small values of info.distance.
-    """
-
-
-class SegmentQueryInfo(NamedTuple):
-    """Segment queries return more information than just a simple yes or no,
-    they also return where a shape was hit and it's surface normal at the hit
-    point. This object hold that information.
-
-    To test if the query hit something, check if
-    SegmentQueryInfo.shape == None or not.
-
-    Segment queries are like ray casting, but because not all spatial indexes
-    allow processing infinitely long ray queries it is limited to segments.
-    In practice this is still very fast and you don't need to worry too much
-    about the performance as long as you aren't using extremely long segments
-    for your queries.
-
-    """
-
-    shape: Optional["Shape"]
-    """Shape that was hit, or None if no collision occured"""
-
-    point: "Vec2d"
-    """The point of impact."""
-
-    normal: "Vec2d"
-    """The normal of the surface hit."""
-
-    alpha: float
-    """The normalized distance along the query segment in the range [0, 1]"""
-
-
-class ShapeQueryInfo(NamedTuple):
-    """Shape queries return more information than just a simple yes or no,
-    they also return where a shape was hit. This object hold that information.
-    """
-
-    shape: Optional["Shape"]
-    """Shape that was hit, or None if no collision occured"""
-
-    contact_point_set: "ContactPointSet"
+__docformat__ = "reStructuredText"
+
+from typing import TYPE_CHECKING, NamedTuple, Optional
+
+if TYPE_CHECKING:
+    from .contact_point_set import ContactPointSet
+    from .shapes import Shape
+    from .vec2d import Vec2d
+
+
+class PointQueryInfo(NamedTuple):
+    """PointQueryInfo holds the result of a point query made on a Shape or
+    Space.
+    """
+
+    shape: Optional["Shape"]
+    """The nearest shape, None if no shape was within range."""
+
+    point: "Vec2d"
+    """The closest point on the shape's surface. (in world space
+    coordinates)
+    """
+
+    distance: float
+    """The distance to the point. The distance is negative if the
+    point is inside the shape.
+    """
+
+    gradient: "Vec2d"
+    """The gradient of the signed distance function.
+
+    The value should be similar to
+    PointQueryInfo.point/PointQueryInfo.distance, but accurate even for
+    very small values of info.distance.
+    """
+
+
+class SegmentQueryInfo(NamedTuple):
+    """Segment queries return more information than just a simple yes or no,
+    they also return where a shape was hit and it's surface normal at the hit
+    point. This object hold that information.
+
+    To test if the query hit something, check if
+    SegmentQueryInfo.shape == None or not.
+
+    Segment queries are like ray casting, but because not all spatial indexes
+    allow processing infinitely long ray queries it is limited to segments.
+    In practice this is still very fast and you don't need to worry too much
+    about the performance as long as you aren't using extremely long segments
+    for your queries.
+
+    """
+
+    shape: Optional["Shape"]
+    """Shape that was hit, or None if no collision occured"""
+
+    point: "Vec2d"
+    """The point of impact."""
+
+    normal: "Vec2d"
+    """The normal of the surface hit."""
+
+    alpha: float
+    """The normalized distance along the query segment in the range [0, 1]"""
+
+
+class ShapeQueryInfo(NamedTuple):
+    """Shape queries return more information than just a simple yes or no,
+    they also return where a shape was hit. This object hold that information.
+    """
+
+    shape: Optional["Shape"]
+    """Shape that was hit, or None if no collision occured"""
+
+    contact_point_set: "ContactPointSet"
```

## Comparing `pymunk-6.5.0/pymunk/shapes.py` & `pymunk/shapes.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,761 +1,761 @@
-__docformat__ = "reStructuredText"
-
-import logging
-from typing import TYPE_CHECKING, List, Optional, Sequence, Tuple
-
-if TYPE_CHECKING:
-    from .body import Body
-    from .space import Space
-
-from ._chipmunk_cffi import ffi
-from ._chipmunk_cffi import lib as cp
-from ._pickle import PickleMixin, _State
-from ._typing_attr import TypingAttrMixing
-from .bb import BB
-from .contact_point_set import ContactPointSet
-from .query_info import PointQueryInfo, SegmentQueryInfo
-from .shape_filter import ShapeFilter
-from .transform import Transform
-from .vec2d import Vec2d
-
-_logger = logging.getLogger(__name__)
-
-
-class Shape(PickleMixin, TypingAttrMixing, object):
-    """Base class for all the shapes.
-
-    You usually dont want to create instances of this class directly but use
-    one of the specialized shapes instead (:py:class:`Circle`,
-    :py:class:`Poly` or :py:class:`Segment`).
-
-    All the shapes can be copied and pickled. If you copy/pickle a shape the
-    body (if any) will also be copied.
-    """
-
-    _pickle_attrs_init = PickleMixin._pickle_attrs_init + ["body"]
-    _pickle_attrs_general = PickleMixin._pickle_attrs_general + [
-        "sensor",
-        "collision_type",
-        "filter",
-        "elasticity",
-        "friction",
-        "surface_velocity",
-        "_hashid",
-    ]
-    _pickle_attrs_skip = PickleMixin._pickle_attrs_skip + ["mass", "density"]
-
-    _space = None  # Weak ref to the space holding this body (if any)
-
-    _id_counter = 1
-
-    def __init__(self, shape: "Shape") -> None:
-        self._shape = shape
-        self._body: Optional["Body"] = shape.body
-
-    def _init(self, body: Optional["Body"], _shape: ffi.CData) -> None:
-        self._body = body
-
-        if body is not None:
-            body._shapes.add(self)
-
-        def shapefree(cp_shape):  # type: ignore
-            _logger.debug("shapefree start %s", cp_shape)
-            cp_space = cp.cpShapeGetSpace(cp_shape)
-            if cp_space != ffi.NULL:
-                _logger.debug("shapefree remove from space %s %s", cp_space, cp_shape)
-                cp.cpSpaceRemoveShape(cp_space, cp_shape)
-
-            _logger.debug("shapefree get body %s", cp_shape)
-            cp_body = cp.cpShapeGetBody(cp_shape)
-            if cp_body != ffi.NULL:
-                _logger.debug("shapefree set body %s", cp_shape)
-                # print(cp.cpShapeActive2(cp_shape))
-                cp.cpShapeSetBody(cp_shape, ffi.NULL)
-            _logger.debug("shapefree free %s", cp_shape)
-            cp.cpShapeFree(cp_shape)
-
-        self._shape = ffi.gc(_shape, shapefree)
-        self._set_id()
-
-    @property
-    def _id(self) -> int:
-        """Unique id of the Shape
-
-        .. note::
-            Experimental API. Likely to change in future major, minor orpoint
-            releases.
-        """
-        return int(ffi.cast("int", cp.cpShapeGetUserData(self._shape)))
-
-    def _set_id(self) -> None:
-        cp.cpShapeSetUserData(self._shape, ffi.cast("cpDataPointer", Shape._id_counter))
-        Shape._id_counter += 1
-
-    def _get_mass(self) -> float:
-        return cp.cpShapeGetMass(self._shape)
-
-    def _set_mass(self, mass: float) -> None:
-        cp.cpShapeSetMass(self._shape, mass)
-
-    mass = property(
-        _get_mass,
-        _set_mass,
-        doc="""The mass of this shape.
-
-        This is useful when you let Pymunk calculate the total mass and inertia 
-        of a body from the shapes attached to it. (Instead of setting the body 
-        mass and inertia directly)
-        """,
-    )
-
-    def _get_density(self) -> float:
-        return cp.cpShapeGetDensity(self._shape)
-
-    def _set_density(self, density: float) -> None:
-        cp.cpShapeSetDensity(self._shape, density)
-
-    density = property(
-        _get_density,
-        _set_density,
-        doc="""The density of this shape.
-        
-        This is useful when you let Pymunk calculate the total mass and inertia 
-        of a body from the shapes attached to it. (Instead of setting the body 
-        mass and inertia directly)
-        """,
-    )
-
-    @property
-    def moment(self) -> float:
-        """The calculated moment of this shape."""
-        return cp.cpShapeGetMoment(self._shape)
-
-    @property
-    def area(self) -> float:
-        """The calculated area of this shape."""
-        return cp.cpShapeGetArea(self._shape)
-
-    @property
-    def center_of_gravity(self) -> Vec2d:
-        """The calculated center of gravity of this shape."""
-        v = cp.cpShapeGetCenterOfGravity(self._shape)
-        return Vec2d(v.x, v.y)
-
-    def _get_sensor(self) -> bool:
-        return bool(cp.cpShapeGetSensor(self._shape))
-
-    def _set_sensor(self, is_sensor: bool) -> None:
-        cp.cpShapeSetSensor(self._shape, is_sensor)
-
-    sensor = property(
-        _get_sensor,
-        _set_sensor,
-        doc="""A boolean value if this shape is a sensor or not.
-
-        Sensors only call collision callbacks, and never generate real
-        collisions.
-        """,
-    )
-
-    def _get_collision_type(self) -> int:
-        return cp.cpShapeGetCollisionType(self._shape)
-
-    def _set_collision_type(self, t: int) -> None:
-        cp.cpShapeSetCollisionType(self._shape, t)
-
-    collision_type = property(
-        _get_collision_type,
-        _set_collision_type,
-        doc="""User defined collision type for the shape.
-
-        See :py:meth:`Space.add_collision_handler` function for more 
-        information on when to use this property.
-        """,
-    )
-
-    def _get_filter(self) -> ShapeFilter:
-        f = cp.cpShapeGetFilter(self._shape)
-        return ShapeFilter(f.group, f.categories, f.mask)
-
-    def _set_filter(self, f: ShapeFilter) -> None:
-        cp.cpShapeSetFilter(self._shape, f)
-
-    filter = property(
-        _get_filter,
-        _set_filter,
-        doc="""Set the collision :py:class:`ShapeFilter` for this shape.
-        """,
-    )
-
-    def _get_elasticity(self) -> float:
-        return cp.cpShapeGetElasticity(self._shape)
-
-    def _set_elasticity(self, e: float) -> None:
-        cp.cpShapeSetElasticity(self._shape, e)
-
-    elasticity = property(
-        _get_elasticity,
-        _set_elasticity,
-        doc="""Elasticity of the shape.
-
-        A value of 0.0 gives no bounce, while a value of 1.0 will give a
-        'perfect' bounce. However due to inaccuracies in the simulation
-        using 1.0 or greater is not recommended.
-        """,
-    )
-
-    def _get_friction(self) -> float:
-        return cp.cpShapeGetFriction(self._shape)
-
-    def _set_friction(self, u: float) -> None:
-        cp.cpShapeSetFriction(self._shape, u)
-
-    friction = property(
-        _get_friction,
-        _set_friction,
-        doc="""Friction coefficient.
-
-        Pymunk uses the Coulomb friction model, a value of 0.0 is
-        frictionless.
-
-        A value over 1.0 is perfectly fine.
-
-        Some real world example values from Wikipedia (Remember that
-        it is what looks good that is important, not the exact value).
-
-        ==============  ======  ========
-        Material        Other   Friction
-        ==============  ======  ========
-        Aluminium       Steel   0.61
-        Copper          Steel   0.53
-        Brass           Steel   0.51
-        Cast iron       Copper  1.05
-        Cast iron       Zinc    0.85
-        Concrete (wet)  Rubber  0.30
-        Concrete (dry)  Rubber  1.0
-        Concrete        Wood    0.62
-        Copper          Glass   0.68
-        Glass           Glass   0.94
-        Metal           Wood    0.5
-        Polyethene      Steel   0.2
-        Steel           Steel   0.80
-        Steel           Teflon  0.04
-        Teflon (PTFE)   Teflon  0.04
-        Wood            Wood    0.4
-        ==============  ======  ========
-        """,
-    )
-
-    def _get_surface_velocity(self) -> Vec2d:
-        v = cp.cpShapeGetSurfaceVelocity(self._shape)
-        return Vec2d(v.x, v.y)
-
-    def _set_surface_velocity(self, surface_v: Vec2d) -> None:
-        assert len(surface_v) == 2
-        cp.cpShapeSetSurfaceVelocity(self._shape, surface_v)
-
-    surface_velocity = property(
-        _get_surface_velocity,
-        _set_surface_velocity,
-        doc="""The surface velocity of the object.
-
-        Useful for creating conveyor belts or players that move around. This
-        value is only used when calculating friction, not resolving the
-        collision.
-        """,
-    )
-
-    def _get_body(self) -> Optional["Body"]:
-        return self._body
-
-    def _set_body(self, body: Optional["Body"]) -> None:
-        if self._body is not None:
-            self._body._shapes.remove(self)
-        body_body = ffi.NULL if body is None else body._body
-        cp.cpShapeSetBody(self._shape, body_body)
-        if body is not None:
-            body._shapes.add(self)
-        self._body = body
-
-    body = property(
-        _get_body,
-        _set_body,
-        doc="""The body this shape is attached to. Can be set to None to
-        indicate that this shape doesnt belong to a body.""",
-    )
-
-    def update(self, transform: Transform) -> BB:
-        """Update, cache and return the bounding box of a shape with an
-        explicit transformation.
-
-        Useful if you have a shape without a body and want to use it for
-        querying.
-        """
-        _bb = cp.cpShapeUpdate(self._shape, transform)
-        return BB(_bb.l, _bb.b, _bb.r, _bb.t)
-
-    def cache_bb(self) -> BB:
-        """Update and returns the bounding box of this shape"""
-        _bb = cp.cpShapeCacheBB(self._shape)
-        return BB(_bb.l, _bb.b, _bb.r, _bb.t)
-
-    @property
-    def bb(self) -> BB:
-        """The bounding box :py:class:`BB` of the shape.
-
-        Only guaranteed to be valid after :py:meth:`Shape.cache_bb` or
-        :py:meth:`Space.step` is called. Moving a body that a shape is
-        connected to does not update it's bounding box. For shapes used for
-        queries that aren't attached to bodies, you can also use
-        :py:meth:`Shape.update`.
-        """
-        _bb = cp.cpShapeGetBB(self._shape)
-        return BB(_bb.l, _bb.b, _bb.r, _bb.t)
-
-    def point_query(self, p: Tuple[float, float]) -> PointQueryInfo:
-        """Check if the given point lies within the shape.
-
-        A negative distance means the point is within the shape.
-
-        :return: Tuple of (distance, info)
-        :rtype: (float, :py:class:`PointQueryInfo`)
-        """
-        assert len(p) == 2
-        info = ffi.new("cpPointQueryInfo *")
-        _ = cp.cpShapePointQuery(self._shape, p, info)
-
-        ud = int(ffi.cast("int", cp.cpShapeGetUserData(info.shape)))
-        assert ud == self._id
-        return PointQueryInfo(
-            self,
-            Vec2d(info.point.x, info.point.y),
-            info.distance,
-            Vec2d(info.gradient.x, info.gradient.y),
-        )
-
-    def segment_query(
-        self, start: Tuple[float, float], end: Tuple[float, float], radius: float = 0
-    ) -> SegmentQueryInfo:
-        """Check if the line segment from start to end intersects the shape.
-
-        :rtype: :py:class:`SegmentQueryInfo`
-        """
-        assert len(start) == 2
-        assert len(end) == 2
-        info = ffi.new("cpSegmentQueryInfo *")
-        r = cp.cpShapeSegmentQuery(self._shape, start, end, radius, info)
-        if r:
-            ud = int(ffi.cast("int", cp.cpShapeGetUserData(info.shape)))
-            assert ud == self._id
-            return SegmentQueryInfo(
-                self,
-                Vec2d(info.point.x, info.point.y),
-                Vec2d(info.normal.x, info.normal.y),
-                info.alpha,
-            )
-        else:
-            return SegmentQueryInfo(
-                None,
-                Vec2d(info.point.x, info.point.y),
-                Vec2d(info.normal.x, info.normal.y),
-                info.alpha,
-            )
-
-    def shapes_collide(self, b: "Shape") -> ContactPointSet:
-        """Get contact information about this shape and shape b.
-
-        :rtype: :py:class:`ContactPointSet`
-        """
-        _points = cp.cpShapesCollide(self._shape, b._shape)
-        return ContactPointSet._from_cp(_points)
-
-    @property
-    def space(self) -> Optional["Space"]:
-        """Get the :py:class:`Space` that shape has been added to (or
-        None).
-        """
-        if self._space is not None:
-            try:
-                return self._space._get_self()  # ugly hack because of weakref
-            except ReferenceError:
-                return None
-        else:
-            return None
-
-    @property
-    def _hashid(self) -> int:
-        return cp.cpShapeGetHashID(self._shape)
-
-    @_hashid.setter
-    def _hashid(self, v: int) -> None:
-        cp.cpShapeSetHashID(self._shape, v)
-
-    def __getstate__(self) -> _State:
-        """Return the state of this object
-
-        This method allows the usage of the :mod:`copy` and :mod:`pickle`
-        modules with this class.
-        """
-        d = super(Shape, self).__getstate__()
-
-        if self.mass > 0:
-            d["general"].append(("mass", self.mass))
-        if self.density > 0:
-            d["general"].append(("density", self.density))
-
-        return d
-
-
-class Circle(Shape):
-    """A circle shape defined by a radius
-
-    This is the fastest and simplest collision shape
-    """
-
-    _pickle_attrs_init = Shape._pickle_attrs_init + ["radius", "offset"]
-
-    def __init__(
-        self,
-        body: Optional["Body"],
-        radius: float,
-        offset: Tuple[float, float] = (0, 0),
-    ) -> None:
-        """body is the body attach the circle to, offset is the offset from the
-        body's center of gravity in body local coordinates.
-
-        It is legal to send in None as body argument to indicate that this
-        shape is not attached to a body. However, you must attach it to a body
-        before adding the shape to a space or used for a space shape query.
-        """
-        assert len(offset) == 2
-        body_body = ffi.NULL if body is None else body._body
-        _shape = cp.cpCircleShapeNew(body_body, radius, offset)
-        self._init(body, _shape)
-
-    def unsafe_set_radius(self, r: float) -> None:
-        """Unsafe set the radius of the circle.
-
-        .. note::
-            This change is only picked up as a change to the position
-            of the shape's surface, but not it's velocity. Changing it will
-            not result in realistic physical behavior. Only use if you know
-            what you are doing!
-        """
-        cp.cpCircleShapeSetRadius(self._shape, r)
-
-    @property
-    def radius(self) -> float:
-        """The Radius of the circle"""
-        return cp.cpCircleShapeGetRadius(self._shape)
-
-    def unsafe_set_offset(self, o: Tuple[float, float]) -> None:
-        """Unsafe set the offset of the circle.
-
-        .. note::
-            This change is only picked up as a change to the position
-            of the shape's surface, but not it's velocity. Changing it will
-            not result in realistic physical behavior. Only use if you know
-            what you are doing!
-        """
-        assert len(o) == 2
-        cp.cpCircleShapeSetOffset(self._shape, o)
-
-    @property
-    def offset(self) -> Vec2d:
-        """Offset. (body space coordinates)"""
-        v = cp.cpCircleShapeGetOffset(self._shape)
-        return Vec2d(v.x, v.y)
-
-
-class Segment(Shape):
-    """A line segment shape between two points
-
-    Meant mainly as a static shape. Can be beveled in order to give them a
-    thickness.
-    """
-
-    _pickle_attrs_init = Shape._pickle_attrs_init + ["a", "b", "radius"]
-
-    def __init__(
-        self,
-        body: Optional["Body"],
-        a: Tuple[float, float],
-        b: Tuple[float, float],
-        radius: float,
-    ) -> None:
-        """Create a Segment
-
-        It is legal to send in None as body argument to indicate that this
-        shape is not attached to a body. However, you must attach it to a body
-        before adding the shape to a space or used for a space shape query.
-
-        :param Body body: The body to attach the segment to
-        :param a: The first endpoint of the segment
-        :param b: The second endpoint of the segment
-        :param float radius: The thickness of the segment
-        """
-        assert len(a) == 2
-        assert len(b) == 2
-
-        body_body = ffi.NULL if body is None else body._body
-        _shape = cp.cpSegmentShapeNew(body_body, a, b, radius)
-        self._init(body, _shape)
-
-    def _get_a(self) -> Vec2d:
-        v = cp.cpSegmentShapeGetA(self._shape)
-        return Vec2d(v.x, v.y)
-
-    a = property(_get_a, doc="""The first of the two endpoints for this segment""")
-
-    def _get_b(self) -> Vec2d:
-        v = cp.cpSegmentShapeGetB(self._shape)
-        return Vec2d(v.x, v.y)
-
-    b = property(_get_b, doc="""The second of the two endpoints for this segment""")
-
-    def unsafe_set_endpoints(
-        self, a: Tuple[float, float], b: Tuple[float, float]
-    ) -> None:
-        """Set the two endpoints for this segment
-
-        .. note::
-            This change is only picked up as a change to the position
-            of the shape's surface, but not it's velocity. Changing it will
-            not result in realistic physical behavior. Only use if you know
-            what you are doing!
-        """
-        assert len(a) == 2
-        assert len(b) == 2
-        cp.cpSegmentShapeSetEndpoints(self._shape, a, b)
-
-    @property
-    def normal(self) -> Vec2d:
-        """The normal"""
-        v = cp.cpSegmentShapeGetNormal(self._shape)
-        return Vec2d(v.x, v.y)
-
-    def unsafe_set_radius(self, r: float) -> None:
-        """Set the radius of the segment
-
-        .. note::
-            This change is only picked up as a change to the position
-            of the shape's surface, but not it's velocity. Changing it will
-            not result in realistic physical behavior. Only use if you know
-            what you are doing!
-        """
-        cp.cpSegmentShapeSetRadius(self._shape, r)
-
-    @property
-    def radius(self) -> float:
-        """The radius/thickness of the segment"""
-        return cp.cpSegmentShapeGetRadius(self._shape)
-
-    def set_neighbors(
-        self, prev: Tuple[float, float], next: Tuple[float, float]
-    ) -> None:
-        """When you have a number of segment shapes that are all joined
-        together, things can still collide with the "cracks" between the
-        segments. By setting the neighbor segment endpoints you can tell
-        Chipmunk to avoid colliding with the inner parts of the crack.
-        """
-        assert len(prev) == 2
-        assert len(next) == 2
-        cp.cpSegmentShapeSetNeighbors(self._shape, prev, next)
-
-
-class Poly(Shape):
-    """A convex polygon shape
-
-    Slowest, but most flexible collision shape.
-    """
-
-    def __init__(
-        self,
-        body: Optional["Body"],
-        vertices: Sequence[Tuple[float, float]],
-        transform: Optional[Transform] = None,
-        radius: float = 0,
-    ) -> None:
-        """Create a polygon.
-
-        A convex hull will be calculated from the vertexes automatically.
-
-        Adding a small radius will bevel the corners and can significantly
-        reduce problems where the poly gets stuck on seams in your geometry.
-
-        It is legal to send in None as body argument to indicate that this
-        shape is not attached to a body. However, you must attach it to a body
-        before adding the shape to a space or used for a space shape query.
-
-        .. note::
-            Make sure to put the vertices around (0,0) or the shape might
-            behave strange.
-
-            Either directly place the vertices like the below example:
-
-            >>> import pymunk
-            >>> w, h = 10, 20
-            >>> vs = [(-w/2,-h/2), (w/2,-h/2), (w/2,h/2), (-w/2,h/2)]
-            >>> poly_good = pymunk.Poly(None, vs)
-            >>> print(poly_good.center_of_gravity)
-            Vec2d(0.0, 0.0)
-
-            Or use a transform to move them:
-
-            >>> import pymunk
-            >>> width, height = 10, 20
-            >>> vs = [(0, 0), (width, 0), (width, height), (0, height)]
-            >>> poly_bad = pymunk.Poly(None, vs)
-            >>> print(poly_bad.center_of_gravity)
-            Vec2d(5.0, 10.0)
-            >>> t = pymunk.Transform(tx=-width/2, ty=-height/2)
-            >>> poly_good = pymunk.Poly(None, vs, transform=t)
-            >>> print(poly_good.center_of_gravity)
-            Vec2d(0.0, 0.0)
-
-        :param Body body: The body to attach the poly to
-        :param [(float,float)] vertices: Define a convex hull of the polygon
-            with a counterclockwise winding.
-        :param Transform transform: Transform will be applied to every vertex.
-        :param float radius: Set the radius of the poly shape
-
-        """
-        if transform is None:
-            transform = Transform.identity()
-
-        body_body = ffi.NULL if body is None else body._body
-        _shape = cp.cpPolyShapeNew(
-            body_body, len(vertices), vertices, transform, radius
-        )
-        self._init(body, _shape)
-
-    def unsafe_set_radius(self, radius: float) -> None:
-        """Unsafe set the radius of the poly.
-
-        .. note::
-            This change is only picked up as a change to the position
-            of the shape's surface, but not it's velocity. Changing it will
-            not result in realistic physical behavior. Only use if you know
-            what you are doing!
-        """
-        cp.cpPolyShapeSetRadius(self._shape, radius)
-
-    @property
-    def radius(self) -> float:
-        """The radius of the poly shape.
-
-        Extends the poly in all directions with the given radius.
-        """
-        return cp.cpPolyShapeGetRadius(self._shape)
-
-    @staticmethod
-    def create_box(
-        body: Optional["Body"], size: Tuple[float, float] = (10, 10), radius: float = 0
-    ) -> "Poly":
-        """Convenience function to create a box given a width and height.
-
-        The boxes will always be centered at the center of gravity of the
-        body you are attaching them to.  If you want to create an off-center
-        box, you will need to use the normal constructor Poly(...).
-
-        Adding a small radius will bevel the corners and can significantly
-        reduce problems where the box gets stuck on seams in your geometry.
-
-        :param Body body: The body to attach the poly to
-        :param size: Size of the box as (width, height)
-        :type size: (`float, float`)
-        :param float radius: Radius of poly
-        :rtype: :py:class:`Poly`
-        """
-
-        self = Poly.__new__(Poly)
-        body_body = ffi.NULL if body is None else body._body
-        _shape = cp.cpBoxShapeNew(body_body, size[0], size[1], radius)
-        self._init(body, _shape)
-
-        return self
-
-    @staticmethod
-    def create_box_bb(body: Optional["Body"], bb: BB, radius: float = 0) -> "Poly":
-        """Convenience function to create a box shape from a :py:class:`BB`.
-
-        The boxes will always be centered at the center of gravity of the
-        body you are attaching them to.  If you want to create an off-center
-        box, you will need to use the normal constructor Poly(..).
-
-        Adding a small radius will bevel the corners and can significantly
-        reduce problems where the box gets stuck on seams in your geometry.
-
-        :param Body body: The body to attach the poly to
-        :param BB bb: Size of the box
-        :param float radius: Radius of poly
-        :rtype: :py:class:`Poly`
-        """
-
-        self = Poly.__new__(Poly)
-        body_body = ffi.NULL if body is None else body._body
-        _shape = cp.cpBoxShapeNew2(body_body, bb, radius)
-        self._init(body, _shape)
-
-        return self
-
-    def get_vertices(self) -> List[Vec2d]:
-        """Get the vertices in local coordinates for the polygon
-
-        If you need the vertices in world coordinates then the vertices can be
-        transformed by adding the body position and each vertex rotated by the
-        body rotation in the following way::
-
-            >>> import pymunk
-            >>> b = pymunk.Body()
-            >>> b.position = 1,2
-            >>> b.angle = 0.5
-            >>> shape = pymunk.Poly(b, [(0,0), (10,0), (10,10)])
-            >>> for v in shape.get_vertices():
-            ...     x,y = v.rotated(shape.body.angle) + shape.body.position
-            ...     (int(x), int(y))
-            (1, 2)
-            (9, 6)
-            (4, 15)
-
-        :return: The vertices in local coords
-        :rtype: [:py:class:`Vec2d`]
-        """
-        verts = []
-        l = cp.cpPolyShapeGetCount(self._shape)
-        for i in range(l):
-            v = cp.cpPolyShapeGetVert(self._shape, i)
-            verts.append(Vec2d(v.x, v.y))
-        return verts
-
-    def unsafe_set_vertices(
-        self,
-        vertices: Sequence[Tuple[float, float]],
-        transform: Optional[Transform] = None,
-    ) -> None:
-        """Unsafe set the vertices of the poly.
-
-        .. note::
-            This change is only picked up as a change to the position
-            of the shape's surface, but not it's velocity. Changing it will
-            not result in realistic physical behavior. Only use if you know
-            what you are doing!
-        """
-        if transform is None:
-            cp.cpPolyShapeSetVertsRaw(self._shape, len(vertices), vertices)
-            return
-
-        cp.cpPolyShapeSetVerts(self._shape, len(vertices), vertices, transform)
-
-    def __getstate__(self) -> _State:
-        """Return the state of this object
-
-        This method allows the usage of the :mod:`copy` and :mod:`pickle`
-        modules with this class.
-        """
-        d = super(Poly, self).__getstate__()
-
-        d["init"].append(("vertices", self.get_vertices()))
-        d["init"].append(("transform", None))
-        d["init"].append(("radius", self.radius))
-        return d
+__docformat__ = "reStructuredText"
+
+import logging
+from typing import TYPE_CHECKING, List, Optional, Sequence, Tuple
+
+if TYPE_CHECKING:
+    from .body import Body
+    from .space import Space
+
+from ._chipmunk_cffi import ffi
+from ._chipmunk_cffi import lib as cp
+from ._pickle import PickleMixin, _State
+from ._typing_attr import TypingAttrMixing
+from .bb import BB
+from .contact_point_set import ContactPointSet
+from .query_info import PointQueryInfo, SegmentQueryInfo
+from .shape_filter import ShapeFilter
+from .transform import Transform
+from .vec2d import Vec2d
+
+_logger = logging.getLogger(__name__)
+
+
+class Shape(PickleMixin, TypingAttrMixing, object):
+    """Base class for all the shapes.
+
+    You usually dont want to create instances of this class directly but use
+    one of the specialized shapes instead (:py:class:`Circle`,
+    :py:class:`Poly` or :py:class:`Segment`).
+
+    All the shapes can be copied and pickled. If you copy/pickle a shape the
+    body (if any) will also be copied.
+    """
+
+    _pickle_attrs_init = PickleMixin._pickle_attrs_init + ["body"]
+    _pickle_attrs_general = PickleMixin._pickle_attrs_general + [
+        "sensor",
+        "collision_type",
+        "filter",
+        "elasticity",
+        "friction",
+        "surface_velocity",
+        "_hashid",
+    ]
+    _pickle_attrs_skip = PickleMixin._pickle_attrs_skip + ["mass", "density"]
+
+    _space = None  # Weak ref to the space holding this body (if any)
+
+    _id_counter = 1
+
+    def __init__(self, shape: "Shape") -> None:
+        self._shape = shape
+        self._body: Optional["Body"] = shape.body
+
+    def _init(self, body: Optional["Body"], _shape: ffi.CData) -> None:
+        self._body = body
+
+        if body is not None:
+            body._shapes.add(self)
+
+        def shapefree(cp_shape):  # type: ignore
+            _logger.debug("shapefree start %s", cp_shape)
+            cp_space = cp.cpShapeGetSpace(cp_shape)
+            if cp_space != ffi.NULL:
+                _logger.debug("shapefree remove from space %s %s", cp_space, cp_shape)
+                cp.cpSpaceRemoveShape(cp_space, cp_shape)
+
+            _logger.debug("shapefree get body %s", cp_shape)
+            cp_body = cp.cpShapeGetBody(cp_shape)
+            if cp_body != ffi.NULL:
+                _logger.debug("shapefree set body %s", cp_shape)
+                # print(cp.cpShapeActive2(cp_shape))
+                cp.cpShapeSetBody(cp_shape, ffi.NULL)
+            _logger.debug("shapefree free %s", cp_shape)
+            cp.cpShapeFree(cp_shape)
+
+        self._shape = ffi.gc(_shape, shapefree)
+        self._set_id()
+
+    @property
+    def _id(self) -> int:
+        """Unique id of the Shape
+
+        .. note::
+            Experimental API. Likely to change in future major, minor orpoint
+            releases.
+        """
+        return int(ffi.cast("int", cp.cpShapeGetUserData(self._shape)))
+
+    def _set_id(self) -> None:
+        cp.cpShapeSetUserData(self._shape, ffi.cast("cpDataPointer", Shape._id_counter))
+        Shape._id_counter += 1
+
+    def _get_mass(self) -> float:
+        return cp.cpShapeGetMass(self._shape)
+
+    def _set_mass(self, mass: float) -> None:
+        cp.cpShapeSetMass(self._shape, mass)
+
+    mass = property(
+        _get_mass,
+        _set_mass,
+        doc="""The mass of this shape.
+
+        This is useful when you let Pymunk calculate the total mass and inertia 
+        of a body from the shapes attached to it. (Instead of setting the body 
+        mass and inertia directly)
+        """,
+    )
+
+    def _get_density(self) -> float:
+        return cp.cpShapeGetDensity(self._shape)
+
+    def _set_density(self, density: float) -> None:
+        cp.cpShapeSetDensity(self._shape, density)
+
+    density = property(
+        _get_density,
+        _set_density,
+        doc="""The density of this shape.
+        
+        This is useful when you let Pymunk calculate the total mass and inertia 
+        of a body from the shapes attached to it. (Instead of setting the body 
+        mass and inertia directly)
+        """,
+    )
+
+    @property
+    def moment(self) -> float:
+        """The calculated moment of this shape."""
+        return cp.cpShapeGetMoment(self._shape)
+
+    @property
+    def area(self) -> float:
+        """The calculated area of this shape."""
+        return cp.cpShapeGetArea(self._shape)
+
+    @property
+    def center_of_gravity(self) -> Vec2d:
+        """The calculated center of gravity of this shape."""
+        v = cp.cpShapeGetCenterOfGravity(self._shape)
+        return Vec2d(v.x, v.y)
+
+    def _get_sensor(self) -> bool:
+        return bool(cp.cpShapeGetSensor(self._shape))
+
+    def _set_sensor(self, is_sensor: bool) -> None:
+        cp.cpShapeSetSensor(self._shape, is_sensor)
+
+    sensor = property(
+        _get_sensor,
+        _set_sensor,
+        doc="""A boolean value if this shape is a sensor or not.
+
+        Sensors only call collision callbacks, and never generate real
+        collisions.
+        """,
+    )
+
+    def _get_collision_type(self) -> int:
+        return cp.cpShapeGetCollisionType(self._shape)
+
+    def _set_collision_type(self, t: int) -> None:
+        cp.cpShapeSetCollisionType(self._shape, t)
+
+    collision_type = property(
+        _get_collision_type,
+        _set_collision_type,
+        doc="""User defined collision type for the shape.
+
+        See :py:meth:`Space.add_collision_handler` function for more 
+        information on when to use this property.
+        """,
+    )
+
+    def _get_filter(self) -> ShapeFilter:
+        f = cp.cpShapeGetFilter(self._shape)
+        return ShapeFilter(f.group, f.categories, f.mask)
+
+    def _set_filter(self, f: ShapeFilter) -> None:
+        cp.cpShapeSetFilter(self._shape, f)
+
+    filter = property(
+        _get_filter,
+        _set_filter,
+        doc="""Set the collision :py:class:`ShapeFilter` for this shape.
+        """,
+    )
+
+    def _get_elasticity(self) -> float:
+        return cp.cpShapeGetElasticity(self._shape)
+
+    def _set_elasticity(self, e: float) -> None:
+        cp.cpShapeSetElasticity(self._shape, e)
+
+    elasticity = property(
+        _get_elasticity,
+        _set_elasticity,
+        doc="""Elasticity of the shape.
+
+        A value of 0.0 gives no bounce, while a value of 1.0 will give a
+        'perfect' bounce. However due to inaccuracies in the simulation
+        using 1.0 or greater is not recommended.
+        """,
+    )
+
+    def _get_friction(self) -> float:
+        return cp.cpShapeGetFriction(self._shape)
+
+    def _set_friction(self, u: float) -> None:
+        cp.cpShapeSetFriction(self._shape, u)
+
+    friction = property(
+        _get_friction,
+        _set_friction,
+        doc="""Friction coefficient.
+
+        Pymunk uses the Coulomb friction model, a value of 0.0 is
+        frictionless.
+
+        A value over 1.0 is perfectly fine.
+
+        Some real world example values from Wikipedia (Remember that
+        it is what looks good that is important, not the exact value).
+
+        ==============  ======  ========
+        Material        Other   Friction
+        ==============  ======  ========
+        Aluminium       Steel   0.61
+        Copper          Steel   0.53
+        Brass           Steel   0.51
+        Cast iron       Copper  1.05
+        Cast iron       Zinc    0.85
+        Concrete (wet)  Rubber  0.30
+        Concrete (dry)  Rubber  1.0
+        Concrete        Wood    0.62
+        Copper          Glass   0.68
+        Glass           Glass   0.94
+        Metal           Wood    0.5
+        Polyethene      Steel   0.2
+        Steel           Steel   0.80
+        Steel           Teflon  0.04
+        Teflon (PTFE)   Teflon  0.04
+        Wood            Wood    0.4
+        ==============  ======  ========
+        """,
+    )
+
+    def _get_surface_velocity(self) -> Vec2d:
+        v = cp.cpShapeGetSurfaceVelocity(self._shape)
+        return Vec2d(v.x, v.y)
+
+    def _set_surface_velocity(self, surface_v: Vec2d) -> None:
+        assert len(surface_v) == 2
+        cp.cpShapeSetSurfaceVelocity(self._shape, surface_v)
+
+    surface_velocity = property(
+        _get_surface_velocity,
+        _set_surface_velocity,
+        doc="""The surface velocity of the object.
+
+        Useful for creating conveyor belts or players that move around. This
+        value is only used when calculating friction, not resolving the
+        collision.
+        """,
+    )
+
+    def _get_body(self) -> Optional["Body"]:
+        return self._body
+
+    def _set_body(self, body: Optional["Body"]) -> None:
+        if self._body is not None:
+            self._body._shapes.remove(self)
+        body_body = ffi.NULL if body is None else body._body
+        cp.cpShapeSetBody(self._shape, body_body)
+        if body is not None:
+            body._shapes.add(self)
+        self._body = body
+
+    body = property(
+        _get_body,
+        _set_body,
+        doc="""The body this shape is attached to. Can be set to None to
+        indicate that this shape doesnt belong to a body.""",
+    )
+
+    def update(self, transform: Transform) -> BB:
+        """Update, cache and return the bounding box of a shape with an
+        explicit transformation.
+
+        Useful if you have a shape without a body and want to use it for
+        querying.
+        """
+        _bb = cp.cpShapeUpdate(self._shape, transform)
+        return BB(_bb.l, _bb.b, _bb.r, _bb.t)
+
+    def cache_bb(self) -> BB:
+        """Update and returns the bounding box of this shape"""
+        _bb = cp.cpShapeCacheBB(self._shape)
+        return BB(_bb.l, _bb.b, _bb.r, _bb.t)
+
+    @property
+    def bb(self) -> BB:
+        """The bounding box :py:class:`BB` of the shape.
+
+        Only guaranteed to be valid after :py:meth:`Shape.cache_bb` or
+        :py:meth:`Space.step` is called. Moving a body that a shape is
+        connected to does not update it's bounding box. For shapes used for
+        queries that aren't attached to bodies, you can also use
+        :py:meth:`Shape.update`.
+        """
+        _bb = cp.cpShapeGetBB(self._shape)
+        return BB(_bb.l, _bb.b, _bb.r, _bb.t)
+
+    def point_query(self, p: Tuple[float, float]) -> PointQueryInfo:
+        """Check if the given point lies within the shape.
+
+        A negative distance means the point is within the shape.
+
+        :return: Tuple of (distance, info)
+        :rtype: (float, :py:class:`PointQueryInfo`)
+        """
+        assert len(p) == 2
+        info = ffi.new("cpPointQueryInfo *")
+        _ = cp.cpShapePointQuery(self._shape, p, info)
+
+        ud = int(ffi.cast("int", cp.cpShapeGetUserData(info.shape)))
+        assert ud == self._id
+        return PointQueryInfo(
+            self,
+            Vec2d(info.point.x, info.point.y),
+            info.distance,
+            Vec2d(info.gradient.x, info.gradient.y),
+        )
+
+    def segment_query(
+        self, start: Tuple[float, float], end: Tuple[float, float], radius: float = 0
+    ) -> SegmentQueryInfo:
+        """Check if the line segment from start to end intersects the shape.
+
+        :rtype: :py:class:`SegmentQueryInfo`
+        """
+        assert len(start) == 2
+        assert len(end) == 2
+        info = ffi.new("cpSegmentQueryInfo *")
+        r = cp.cpShapeSegmentQuery(self._shape, start, end, radius, info)
+        if r:
+            ud = int(ffi.cast("int", cp.cpShapeGetUserData(info.shape)))
+            assert ud == self._id
+            return SegmentQueryInfo(
+                self,
+                Vec2d(info.point.x, info.point.y),
+                Vec2d(info.normal.x, info.normal.y),
+                info.alpha,
+            )
+        else:
+            return SegmentQueryInfo(
+                None,
+                Vec2d(info.point.x, info.point.y),
+                Vec2d(info.normal.x, info.normal.y),
+                info.alpha,
+            )
+
+    def shapes_collide(self, b: "Shape") -> ContactPointSet:
+        """Get contact information about this shape and shape b.
+
+        :rtype: :py:class:`ContactPointSet`
+        """
+        _points = cp.cpShapesCollide(self._shape, b._shape)
+        return ContactPointSet._from_cp(_points)
+
+    @property
+    def space(self) -> Optional["Space"]:
+        """Get the :py:class:`Space` that shape has been added to (or
+        None).
+        """
+        if self._space is not None:
+            try:
+                return self._space._get_self()  # ugly hack because of weakref
+            except ReferenceError:
+                return None
+        else:
+            return None
+
+    @property
+    def _hashid(self) -> int:
+        return cp.cpShapeGetHashID(self._shape)
+
+    @_hashid.setter
+    def _hashid(self, v: int) -> None:
+        cp.cpShapeSetHashID(self._shape, v)
+
+    def __getstate__(self) -> _State:
+        """Return the state of this object
+
+        This method allows the usage of the :mod:`copy` and :mod:`pickle`
+        modules with this class.
+        """
+        d = super(Shape, self).__getstate__()
+
+        if self.mass > 0:
+            d["general"].append(("mass", self.mass))
+        if self.density > 0:
+            d["general"].append(("density", self.density))
+
+        return d
+
+
+class Circle(Shape):
+    """A circle shape defined by a radius
+
+    This is the fastest and simplest collision shape
+    """
+
+    _pickle_attrs_init = Shape._pickle_attrs_init + ["radius", "offset"]
+
+    def __init__(
+        self,
+        body: Optional["Body"],
+        radius: float,
+        offset: Tuple[float, float] = (0, 0),
+    ) -> None:
+        """body is the body attach the circle to, offset is the offset from the
+        body's center of gravity in body local coordinates.
+
+        It is legal to send in None as body argument to indicate that this
+        shape is not attached to a body. However, you must attach it to a body
+        before adding the shape to a space or used for a space shape query.
+        """
+        assert len(offset) == 2
+        body_body = ffi.NULL if body is None else body._body
+        _shape = cp.cpCircleShapeNew(body_body, radius, offset)
+        self._init(body, _shape)
+
+    def unsafe_set_radius(self, r: float) -> None:
+        """Unsafe set the radius of the circle.
+
+        .. note::
+            This change is only picked up as a change to the position
+            of the shape's surface, but not it's velocity. Changing it will
+            not result in realistic physical behavior. Only use if you know
+            what you are doing!
+        """
+        cp.cpCircleShapeSetRadius(self._shape, r)
+
+    @property
+    def radius(self) -> float:
+        """The Radius of the circle"""
+        return cp.cpCircleShapeGetRadius(self._shape)
+
+    def unsafe_set_offset(self, o: Tuple[float, float]) -> None:
+        """Unsafe set the offset of the circle.
+
+        .. note::
+            This change is only picked up as a change to the position
+            of the shape's surface, but not it's velocity. Changing it will
+            not result in realistic physical behavior. Only use if you know
+            what you are doing!
+        """
+        assert len(o) == 2
+        cp.cpCircleShapeSetOffset(self._shape, o)
+
+    @property
+    def offset(self) -> Vec2d:
+        """Offset. (body space coordinates)"""
+        v = cp.cpCircleShapeGetOffset(self._shape)
+        return Vec2d(v.x, v.y)
+
+
+class Segment(Shape):
+    """A line segment shape between two points
+
+    Meant mainly as a static shape. Can be beveled in order to give them a
+    thickness.
+    """
+
+    _pickle_attrs_init = Shape._pickle_attrs_init + ["a", "b", "radius"]
+
+    def __init__(
+        self,
+        body: Optional["Body"],
+        a: Tuple[float, float],
+        b: Tuple[float, float],
+        radius: float,
+    ) -> None:
+        """Create a Segment
+
+        It is legal to send in None as body argument to indicate that this
+        shape is not attached to a body. However, you must attach it to a body
+        before adding the shape to a space or used for a space shape query.
+
+        :param Body body: The body to attach the segment to
+        :param a: The first endpoint of the segment
+        :param b: The second endpoint of the segment
+        :param float radius: The thickness of the segment
+        """
+        assert len(a) == 2
+        assert len(b) == 2
+
+        body_body = ffi.NULL if body is None else body._body
+        _shape = cp.cpSegmentShapeNew(body_body, a, b, radius)
+        self._init(body, _shape)
+
+    def _get_a(self) -> Vec2d:
+        v = cp.cpSegmentShapeGetA(self._shape)
+        return Vec2d(v.x, v.y)
+
+    a = property(_get_a, doc="""The first of the two endpoints for this segment""")
+
+    def _get_b(self) -> Vec2d:
+        v = cp.cpSegmentShapeGetB(self._shape)
+        return Vec2d(v.x, v.y)
+
+    b = property(_get_b, doc="""The second of the two endpoints for this segment""")
+
+    def unsafe_set_endpoints(
+        self, a: Tuple[float, float], b: Tuple[float, float]
+    ) -> None:
+        """Set the two endpoints for this segment
+
+        .. note::
+            This change is only picked up as a change to the position
+            of the shape's surface, but not it's velocity. Changing it will
+            not result in realistic physical behavior. Only use if you know
+            what you are doing!
+        """
+        assert len(a) == 2
+        assert len(b) == 2
+        cp.cpSegmentShapeSetEndpoints(self._shape, a, b)
+
+    @property
+    def normal(self) -> Vec2d:
+        """The normal"""
+        v = cp.cpSegmentShapeGetNormal(self._shape)
+        return Vec2d(v.x, v.y)
+
+    def unsafe_set_radius(self, r: float) -> None:
+        """Set the radius of the segment
+
+        .. note::
+            This change is only picked up as a change to the position
+            of the shape's surface, but not it's velocity. Changing it will
+            not result in realistic physical behavior. Only use if you know
+            what you are doing!
+        """
+        cp.cpSegmentShapeSetRadius(self._shape, r)
+
+    @property
+    def radius(self) -> float:
+        """The radius/thickness of the segment"""
+        return cp.cpSegmentShapeGetRadius(self._shape)
+
+    def set_neighbors(
+        self, prev: Tuple[float, float], next: Tuple[float, float]
+    ) -> None:
+        """When you have a number of segment shapes that are all joined
+        together, things can still collide with the "cracks" between the
+        segments. By setting the neighbor segment endpoints you can tell
+        Chipmunk to avoid colliding with the inner parts of the crack.
+        """
+        assert len(prev) == 2
+        assert len(next) == 2
+        cp.cpSegmentShapeSetNeighbors(self._shape, prev, next)
+
+
+class Poly(Shape):
+    """A convex polygon shape
+
+    Slowest, but most flexible collision shape.
+    """
+
+    def __init__(
+        self,
+        body: Optional["Body"],
+        vertices: Sequence[Tuple[float, float]],
+        transform: Optional[Transform] = None,
+        radius: float = 0,
+    ) -> None:
+        """Create a polygon.
+
+        A convex hull will be calculated from the vertexes automatically.
+
+        Adding a small radius will bevel the corners and can significantly
+        reduce problems where the poly gets stuck on seams in your geometry.
+
+        It is legal to send in None as body argument to indicate that this
+        shape is not attached to a body. However, you must attach it to a body
+        before adding the shape to a space or used for a space shape query.
+
+        .. note::
+            Make sure to put the vertices around (0,0) or the shape might
+            behave strange.
+
+            Either directly place the vertices like the below example:
+
+            >>> import pymunk
+            >>> w, h = 10, 20
+            >>> vs = [(-w/2,-h/2), (w/2,-h/2), (w/2,h/2), (-w/2,h/2)]
+            >>> poly_good = pymunk.Poly(None, vs)
+            >>> print(poly_good.center_of_gravity)
+            Vec2d(0.0, 0.0)
+
+            Or use a transform to move them:
+
+            >>> import pymunk
+            >>> width, height = 10, 20
+            >>> vs = [(0, 0), (width, 0), (width, height), (0, height)]
+            >>> poly_bad = pymunk.Poly(None, vs)
+            >>> print(poly_bad.center_of_gravity)
+            Vec2d(5.0, 10.0)
+            >>> t = pymunk.Transform(tx=-width/2, ty=-height/2)
+            >>> poly_good = pymunk.Poly(None, vs, transform=t)
+            >>> print(poly_good.center_of_gravity)
+            Vec2d(0.0, 0.0)
+
+        :param Body body: The body to attach the poly to
+        :param [(float,float)] vertices: Define a convex hull of the polygon
+            with a counterclockwise winding.
+        :param Transform transform: Transform will be applied to every vertex.
+        :param float radius: Set the radius of the poly shape
+
+        """
+        if transform is None:
+            transform = Transform.identity()
+
+        body_body = ffi.NULL if body is None else body._body
+        _shape = cp.cpPolyShapeNew(
+            body_body, len(vertices), vertices, transform, radius
+        )
+        self._init(body, _shape)
+
+    def unsafe_set_radius(self, radius: float) -> None:
+        """Unsafe set the radius of the poly.
+
+        .. note::
+            This change is only picked up as a change to the position
+            of the shape's surface, but not it's velocity. Changing it will
+            not result in realistic physical behavior. Only use if you know
+            what you are doing!
+        """
+        cp.cpPolyShapeSetRadius(self._shape, radius)
+
+    @property
+    def radius(self) -> float:
+        """The radius of the poly shape.
+
+        Extends the poly in all directions with the given radius.
+        """
+        return cp.cpPolyShapeGetRadius(self._shape)
+
+    @staticmethod
+    def create_box(
+        body: Optional["Body"], size: Tuple[float, float] = (10, 10), radius: float = 0
+    ) -> "Poly":
+        """Convenience function to create a box given a width and height.
+
+        The boxes will always be centered at the center of gravity of the
+        body you are attaching them to.  If you want to create an off-center
+        box, you will need to use the normal constructor Poly(...).
+
+        Adding a small radius will bevel the corners and can significantly
+        reduce problems where the box gets stuck on seams in your geometry.
+
+        :param Body body: The body to attach the poly to
+        :param size: Size of the box as (width, height)
+        :type size: (`float, float`)
+        :param float radius: Radius of poly
+        :rtype: :py:class:`Poly`
+        """
+
+        self = Poly.__new__(Poly)
+        body_body = ffi.NULL if body is None else body._body
+        _shape = cp.cpBoxShapeNew(body_body, size[0], size[1], radius)
+        self._init(body, _shape)
+
+        return self
+
+    @staticmethod
+    def create_box_bb(body: Optional["Body"], bb: BB, radius: float = 0) -> "Poly":
+        """Convenience function to create a box shape from a :py:class:`BB`.
+
+        The boxes will always be centered at the center of gravity of the
+        body you are attaching them to.  If you want to create an off-center
+        box, you will need to use the normal constructor Poly(..).
+
+        Adding a small radius will bevel the corners and can significantly
+        reduce problems where the box gets stuck on seams in your geometry.
+
+        :param Body body: The body to attach the poly to
+        :param BB bb: Size of the box
+        :param float radius: Radius of poly
+        :rtype: :py:class:`Poly`
+        """
+
+        self = Poly.__new__(Poly)
+        body_body = ffi.NULL if body is None else body._body
+        _shape = cp.cpBoxShapeNew2(body_body, bb, radius)
+        self._init(body, _shape)
+
+        return self
+
+    def get_vertices(self) -> List[Vec2d]:
+        """Get the vertices in local coordinates for the polygon
+
+        If you need the vertices in world coordinates then the vertices can be
+        transformed by adding the body position and each vertex rotated by the
+        body rotation in the following way::
+
+            >>> import pymunk
+            >>> b = pymunk.Body()
+            >>> b.position = 1,2
+            >>> b.angle = 0.5
+            >>> shape = pymunk.Poly(b, [(0,0), (10,0), (10,10)])
+            >>> for v in shape.get_vertices():
+            ...     x,y = v.rotated(shape.body.angle) + shape.body.position
+            ...     (int(x), int(y))
+            (1, 2)
+            (9, 6)
+            (4, 15)
+
+        :return: The vertices in local coords
+        :rtype: [:py:class:`Vec2d`]
+        """
+        verts = []
+        l = cp.cpPolyShapeGetCount(self._shape)
+        for i in range(l):
+            v = cp.cpPolyShapeGetVert(self._shape, i)
+            verts.append(Vec2d(v.x, v.y))
+        return verts
+
+    def unsafe_set_vertices(
+        self,
+        vertices: Sequence[Tuple[float, float]],
+        transform: Optional[Transform] = None,
+    ) -> None:
+        """Unsafe set the vertices of the poly.
+
+        .. note::
+            This change is only picked up as a change to the position
+            of the shape's surface, but not it's velocity. Changing it will
+            not result in realistic physical behavior. Only use if you know
+            what you are doing!
+        """
+        if transform is None:
+            cp.cpPolyShapeSetVertsRaw(self._shape, len(vertices), vertices)
+            return
+
+        cp.cpPolyShapeSetVerts(self._shape, len(vertices), vertices, transform)
+
+    def __getstate__(self) -> _State:
+        """Return the state of this object
+
+        This method allows the usage of the :mod:`copy` and :mod:`pickle`
+        modules with this class.
+        """
+        d = super(Poly, self).__getstate__()
+
+        d["init"].append(("vertices", self.get_vertices()))
+        d["init"].append(("transform", None))
+        d["init"].append(("radius", self.radius))
+        return d
```

## Comparing `pymunk-6.5.0/pymunk/shape_filter.py` & `pymunk/shape_filter.py`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,109 +1,109 @@
-from typing import NamedTuple
-
-
-class ShapeFilter(NamedTuple):
-    """
-    Pymunk has two primary means of ignoring collisions: groups and
-    category masks.
-
-    Groups are used to ignore collisions between parts on a complex object. A
-    ragdoll is a good example. When jointing an arm onto the torso, you'll
-    want them to allow them to overlap. Groups allow you to do exactly that.
-    Shapes that have the same group don't generate collisions. So by placing
-    all of the shapes in a ragdoll in the same group, you'll prevent it from
-    colliding against other parts of itself. Category masks allow you to mark
-    which categories an object belongs to and which categories it collides
-    with.
-
-    For example, a game has four collision categories: player (0), enemy (1),
-    player bullet (2), and enemy bullet (3). Neither players nor enemies
-    should not collide with their own bullets, and bullets should not collide
-    with other bullets. However, players collide with enemy bullets, and
-    enemies collide with player bullets.
-
-    ============= =============== ====================
-    Object        Object Category Category Mask
-    ============= =============== ====================
-    Player        0b00001 (1)     0b11000 (4, 5)
-    Enemy         0b00010 (2)     0b01110 (2, 3, 4)
-    Player Bullet 0b00100 (3)     0b10001 (1, 5)
-    Enemy Bullet  0b01000 (4)     0b10010 (2, 5)
-    Walls         0b10000 (5)     0b01111 (1, 2, 3, 4)
-    ============= =============== ====================
-
-    Note that in the table the categories and masks are written as binary
-    values to clearly show the logic. To save space only 5 digits are used. The
-    default type of categories and mask in ShapeFilter is an unsigned int,
-    with a resolution of 32 bits. That means that the you have 32 bits to use,
-    in binary notation that is `0b00000000000000000000000000000000` to
-    `0b11111111111111111111111111111111` which can be written in hex as
-    `0x00000000` to `0xFFFFFFFF`.
-
-    Everything in this example collides with walls. Additionally,
-    the enemies collide with each other.
-
-    By default, objects exist in every category and collide with every category.
-
-    Objects can fall into multiple categories. For instance, you might have a
-    category for a red team, and have a red player bullet. In the above
-    example, each object only has one category.
-
-    The default type of categories and mask in ShapeFilter is unsigned int
-    which has a resolution of 32 bits on most systems.
-
-    There is one last way of filtering collisions using collision handlers.
-    See the section on callbacks for more information. Collision handlers can
-    be more flexible, but can be slower. Fast collision filtering rejects
-    collisions before running the expensive collision detection code, so
-    using groups or category masks is preferred.
-
-    Example of how category and mask can be used to filter out player from
-    enemy object:
-
-    >>> import pymunk
-    >>> s = pymunk.Space()
-    >>> player_b = pymunk.Body(1,1)
-    >>> player_c = pymunk.Circle(player_b, 10)
-    >>> s.add(player_b, player_c)
-    >>> player_c.filter = pymunk.ShapeFilter(categories=0b1)
-    >>> hit = s.point_query_nearest((0,0), 0, pymunk.ShapeFilter())
-    >>> hit != None
-    True
-    >>> filter = pymunk.ShapeFilter(mask=pymunk.ShapeFilter.ALL_MASKS() ^ 0b1)
-    >>> hit = s.point_query_nearest((0,0), 0, filter)
-    >>> hit == None
-    True
-    >>> enemy_b = pymunk.Body(1,1)
-    >>> enemy_c = pymunk.Circle(enemy_b, 10)
-    >>> s.add(enemy_b, enemy_c)
-    >>> hit = s.point_query_nearest((0,0), 0, filter)
-    >>> hit != None
-    True
-
-    """
-
-    group: int = 0
-    """Two objects with the same non-zero group value do not collide.
-	
-    This is generally used to group objects in a composite object together to disable self collisions.
-    """
-
-    categories: int = 0xFFFFFFFF
-    """A bitmask of user definable categories that this object belongs to.
-	
-    The category/mask combinations of both objects in a collision must agree for a collision to occur.
-    """
-
-    mask: int = 0xFFFFFFFF
-    """A bitmask of user definable category types that this object object collides with.
-	
-    The category/mask combinations of both objects in a collision must agree for a collision to occur.
-	"""
-
-    @staticmethod
-    def ALL_MASKS() -> int:
-        return 0xFFFFFFFF
-
-    @staticmethod
-    def ALL_CATEGORIES() -> int:
-        return 0xFFFFFFFF
+from typing import NamedTuple
+
+
+class ShapeFilter(NamedTuple):
+    """
+    Pymunk has two primary means of ignoring collisions: groups and
+    category masks.
+
+    Groups are used to ignore collisions between parts on a complex object. A
+    ragdoll is a good example. When jointing an arm onto the torso, you'll
+    want them to allow them to overlap. Groups allow you to do exactly that.
+    Shapes that have the same group don't generate collisions. So by placing
+    all of the shapes in a ragdoll in the same group, you'll prevent it from
+    colliding against other parts of itself. Category masks allow you to mark
+    which categories an object belongs to and which categories it collides
+    with.
+
+    For example, a game has four collision categories: player (0), enemy (1),
+    player bullet (2), and enemy bullet (3). Neither players nor enemies
+    should not collide with their own bullets, and bullets should not collide
+    with other bullets. However, players collide with enemy bullets, and
+    enemies collide with player bullets.
+
+    ============= =============== ====================
+    Object        Object Category Category Mask
+    ============= =============== ====================
+    Player        0b00001 (1)     0b11000 (4, 5)
+    Enemy         0b00010 (2)     0b01110 (2, 3, 4)
+    Player Bullet 0b00100 (3)     0b10001 (1, 5)
+    Enemy Bullet  0b01000 (4)     0b10010 (2, 5)
+    Walls         0b10000 (5)     0b01111 (1, 2, 3, 4)
+    ============= =============== ====================
+
+    Note that in the table the categories and masks are written as binary
+    values to clearly show the logic. To save space only 5 digits are used. The
+    default type of categories and mask in ShapeFilter is an unsigned int,
+    with a resolution of 32 bits. That means that the you have 32 bits to use,
+    in binary notation that is `0b00000000000000000000000000000000` to
+    `0b11111111111111111111111111111111` which can be written in hex as
+    `0x00000000` to `0xFFFFFFFF`.
+
+    Everything in this example collides with walls. Additionally,
+    the enemies collide with each other.
+
+    By default, objects exist in every category and collide with every category.
+
+    Objects can fall into multiple categories. For instance, you might have a
+    category for a red team, and have a red player bullet. In the above
+    example, each object only has one category.
+
+    The default type of categories and mask in ShapeFilter is unsigned int
+    which has a resolution of 32 bits on most systems.
+
+    There is one last way of filtering collisions using collision handlers.
+    See the section on callbacks for more information. Collision handlers can
+    be more flexible, but can be slower. Fast collision filtering rejects
+    collisions before running the expensive collision detection code, so
+    using groups or category masks is preferred.
+
+    Example of how category and mask can be used to filter out player from
+    enemy object:
+
+    >>> import pymunk
+    >>> s = pymunk.Space()
+    >>> player_b = pymunk.Body(1,1)
+    >>> player_c = pymunk.Circle(player_b, 10)
+    >>> s.add(player_b, player_c)
+    >>> player_c.filter = pymunk.ShapeFilter(categories=0b1)
+    >>> hit = s.point_query_nearest((0,0), 0, pymunk.ShapeFilter())
+    >>> hit != None
+    True
+    >>> filter = pymunk.ShapeFilter(mask=pymunk.ShapeFilter.ALL_MASKS() ^ 0b1)
+    >>> hit = s.point_query_nearest((0,0), 0, filter)
+    >>> hit == None
+    True
+    >>> enemy_b = pymunk.Body(1,1)
+    >>> enemy_c = pymunk.Circle(enemy_b, 10)
+    >>> s.add(enemy_b, enemy_c)
+    >>> hit = s.point_query_nearest((0,0), 0, filter)
+    >>> hit != None
+    True
+
+    """
+
+    group: int = 0
+    """Two objects with the same non-zero group value do not collide.
+	
+    This is generally used to group objects in a composite object together to disable self collisions.
+    """
+
+    categories: int = 0xFFFFFFFF
+    """A bitmask of user definable categories that this object belongs to.
+	
+    The category/mask combinations of both objects in a collision must agree for a collision to occur.
+    """
+
+    mask: int = 0xFFFFFFFF
+    """A bitmask of user definable category types that this object object collides with.
+	
+    The category/mask combinations of both objects in a collision must agree for a collision to occur.
+	"""
+
+    @staticmethod
+    def ALL_MASKS() -> int:
+        return 0xFFFFFFFF
+
+    @staticmethod
+    def ALL_CATEGORIES() -> int:
+        return 0xFFFFFFFF
```

## Comparing `pymunk-6.5.0/pymunk/space.py` & `pymunk/space.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,1100 +1,1100 @@
-__docformat__ = "reStructuredText"
-
-import logging
-import platform
-import weakref
-from typing import (
-    TYPE_CHECKING,
-    Any,
-    Callable,
-    Dict,
-    Hashable,
-    List,
-    Optional,
-    Set,
-    Tuple,
-    Union,
-)
-
-from pymunk.constraints import Constraint
-from pymunk.shape_filter import ShapeFilter
-from pymunk.space_debug_draw_options import SpaceDebugDrawOptions
-
-from . import _version
-from ._callbacks import *
-from ._chipmunk_cffi import ffi, lib
-
-cp = lib
-
-from ._pickle import PickleMixin, _State
-from .arbiter import _arbiter_from_dict, _arbiter_to_dict
-from .body import Body
-from .collision_handler import CollisionHandler
-from .query_info import PointQueryInfo, SegmentQueryInfo, ShapeQueryInfo
-from .shapes import Shape
-from .vec2d import Vec2d
-
-if TYPE_CHECKING:
-    from .bb import BB
-
-_AddableObjects = Union[Body, Shape, Constraint]
-
-_logger = logging.getLogger(__name__)
-
-
-class Space(PickleMixin, object):
-    """Spaces are the basic unit of simulation. You add rigid bodies, shapes
-    and joints to it and then step them all forward together through time.
-
-    A Space can be copied and pickled. Note that any post step callbacks are
-    not copied. Also note that some internal collision cache data is not copied,
-    which can make the simulation a bit unstable the first few steps of the
-    fresh copy.
-
-    Custom properties set on the space will also be copied/pickled.
-
-    Any collision handlers will also be copied/pickled. Note that depending on
-    the pickle protocol used there are some restrictions on what functions can
-    be copied/pickled.
-
-    Example::
-
-    >>> import pymunk, pickle
-    >>> space = pymunk.Space()
-    >>> space2 = space.copy()
-    >>> space3 = pickle.loads(pickle.dumps(space))
-    """
-
-    _pickle_attrs_init = PickleMixin._pickle_attrs_init + ["threaded"]
-    _pickle_attrs_general = PickleMixin._pickle_attrs_general + [
-        "iterations",
-        "gravity",
-        "damping",
-        "idle_speed_threshold",
-        "sleep_time_threshold",
-        "collision_slop",
-        "collision_bias",
-        "collision_persistence",
-        "threads",
-    ]
-
-    def __init__(self, threaded: bool = False) -> None:
-        """Create a new instance of the Space.
-
-        If you set threaded=True the step function will run in threaded mode
-        which might give a speedup. Note that even when you set threaded=True
-        you still have to set Space.threads=2 to actually use more than one
-        thread.
-
-        Also note that threaded mode is not available on Windows, and setting
-        threaded=True has no effect on that platform.
-        """
-
-        self.threaded = threaded and platform.system() != "Windows"
-
-        if self.threaded:
-            cp_space = cp.cpHastySpaceNew()
-            freefunc = cp.cpHastySpaceFree
-        else:
-            cp_space = cp.cpSpaceNew()
-            freefunc = cp.cpSpaceFree
-
-        def spacefree(cp_space):  # type: ignore
-            _logger.debug("spacefree start %s", cp_space)
-
-            cp_shapes: List[Shape] = []
-            cp_shapes_h = ffi.new_handle(cp_shapes)
-            cp.cpSpaceEachShape(cp_space, lib.ext_cpSpaceShapeIteratorFunc, cp_shapes_h)
-
-            for cp_shape in cp_shapes:
-                cp_space = lib.cpShapeGetSpace(cp_shape)
-                _logger.debug("spacefree remove shape %s %s", cp_space, cp_shape)
-
-                lib.cpSpaceRemoveShape(cp_space, cp_shape)
-                lib.cpShapeSetBody(cp_shape, ffi.NULL)
-
-            cp_constraints: List[Constraint] = []
-            cp_constraints_h = ffi.new_handle(cp_constraints)
-            cp.cpSpaceEachConstraint(
-                cp_space, lib.ext_cpSpaceConstraintIteratorFunc, cp_constraints_h
-            )
-            for cp_constraint in cp_constraints:
-                cp_space = lib.cpConstraintGetSpace(cp_constraint)
-                _logger.debug(
-                    "spacefree remove constraint %s %s", cp_space, cp_constraint
-                )
-                lib.cpSpaceRemoveConstraint(cp_space, cp_constraint)
-
-            cp_bodys: List[Body] = []
-            cp_bodys_h = ffi.new_handle(cp_bodys)
-            cp.cpSpaceEachBody(cp_space, lib.ext_cpSpaceBodyIteratorFunc, cp_bodys_h)
-            for cp_body in cp_bodys:
-                cp_space = lib.cpBodyGetSpace(cp_body)
-                _logger.debug("spacefree remove body %s %s", cp_space, cp_body)
-                lib.cpSpaceRemoveBody(cp_space, cp_body)
-
-            _logger.debug("spacefree free %s", cp_space)
-            freefunc(cp_space)
-
-        self._space = ffi.gc(cp_space, spacefree)
-
-        self._handlers: Dict[
-            Any, CollisionHandler
-        ] = {}  # To prevent the gc to collect the callbacks.
-
-        self._post_step_callbacks: Dict[Any, Callable[["Space"], None]] = {}
-        self._removed_shapes: Dict[int, Shape] = {}
-
-        self._shapes: Dict[int, Shape] = {}
-        self._bodies: Dict[Body, None] = {}
-        self._static_body: Optional[Body] = None
-        self._constraints: Dict[Constraint, None] = {}
-
-        self._locked = False
-
-        self._add_later: Set[_AddableObjects] = set()
-        self._remove_later: Set[_AddableObjects] = set()
-
-    def _get_self(self) -> "Space":
-        return self
-
-    @property
-    def shapes(self) -> List[Shape]:
-        """A list of all the shapes added to this space
-
-        (includes both static and non-static)
-        """
-        return list(self._shapes.values())
-
-    @property
-    def bodies(self) -> List[Body]:
-        """A list of the bodies added to this space"""
-        return list(self._bodies)
-
-    @property
-    def constraints(self) -> List[Constraint]:
-        """A list of the constraints added to this space"""
-        return list(self._constraints)
-
-    def _setup_static_body(self, static_body: Body) -> None:
-        static_body._space = weakref.proxy(self)
-        cp.cpSpaceAddBody(self._space, static_body._body)
-
-    @property
-    def static_body(self) -> Body:
-        """A dedicated static body for the space.
-
-        You don't have to use it, but many times it can be convenient to have
-        a static body together with the space.
-        """
-        if self._static_body is None:
-            self._static_body = Body(body_type=Body.STATIC)
-            self._setup_static_body(self._static_body)
-            # self.add(self._static_body)
-
-            # b = cp.cpSpaceGetStaticBody(self._space)
-            # self._static_body = Body._init_with_body(b)
-            # self._static_body._space = self
-            # assert self._static_body is not None
-        return self._static_body
-
-    def _set_iterations(self, value: int) -> None:
-        cp.cpSpaceSetIterations(self._space, value)
-
-    def _get_iterations(self) -> int:
-        return cp.cpSpaceGetIterations(self._space)
-
-    iterations = property(
-        _get_iterations,
-        _set_iterations,
-        doc="""Iterations allow you to control the accuracy of the solver.
-
-        Defaults to 10.
-
-        Pymunk uses an iterative solver to figure out the forces between
-        objects in the space. What this means is that it builds a big list of
-        all of the collisions, joints, and other constraints between the
-        bodies and makes several passes over the list considering each one
-        individually. The number of passes it makes is the iteration count,
-        and each iteration makes the solution more accurate. If you use too
-        many iterations, the physics should look nice and solid, but may use
-        up too much CPU time. If you use too few iterations, the simulation
-        may seem mushy or bouncy when the objects should be solid. Setting
-        the number of iterations lets you balance between CPU usage and the
-        accuracy of the physics. Pymunk's default of 10 iterations is
-        sufficient for most simple games.
-        """,
-    )
-
-    def _set_gravity(self, gravity_vector: Tuple[float, float]) -> None:
-        assert len(gravity_vector) == 2
-        cp.cpSpaceSetGravity(self._space, gravity_vector)
-
-    def _get_gravity(self) -> Vec2d:
-        v = cp.cpSpaceGetGravity(self._space)
-        return Vec2d(v.x, v.y)
-
-    gravity = property(
-        _get_gravity,
-        _set_gravity,
-        doc="""Global gravity applied to the space.
-
-        Defaults to (0,0). Can be overridden on a per body basis by writing
-        custom integration functions and set it on the body:
-        :py:meth:`pymunk.Body.velocity_func`.
-        """,
-    )
-
-    def _set_damping(self, damping: float) -> None:
-        cp.cpSpaceSetDamping(self._space, damping)
-
-    def _get_damping(self) -> float:
-        return cp.cpSpaceGetDamping(self._space)
-
-    damping = property(
-        _get_damping,
-        _set_damping,
-        doc="""Amount of simple damping to apply to the space.
-
-        A value of 0.9 means that each body will lose 10% of its velocity per
-        second. Defaults to 1. Like gravity, it can be overridden on a per
-        body basis.
-        """,
-    )
-
-    def _set_idle_speed_threshold(self, idle_speed_threshold: float) -> None:
-        cp.cpSpaceSetIdleSpeedThreshold(self._space, idle_speed_threshold)
-
-    def _get_idle_speed_threshold(self) -> float:
-        return cp.cpSpaceGetIdleSpeedThreshold(self._space)
-
-    idle_speed_threshold = property(
-        _get_idle_speed_threshold,
-        _set_idle_speed_threshold,
-        doc="""Speed threshold for a body to be considered idle.
-
-        The default value of 0 means the space estimates a good threshold
-        based on gravity.
-        """,
-    )
-
-    def _set_sleep_time_threshold(self, sleep_time_threshold: float) -> None:
-        cp.cpSpaceSetSleepTimeThreshold(self._space, sleep_time_threshold)
-
-    def _get_sleep_time_threshold(self) -> float:
-        return cp.cpSpaceGetSleepTimeThreshold(self._space)
-
-    sleep_time_threshold = property(
-        _get_sleep_time_threshold,
-        _set_sleep_time_threshold,
-        doc="""Time a group of bodies must remain idle in order to fall
-        asleep.
-
-        The default value of `inf` disables the sleeping algorithm.
-        """,
-    )
-
-    def _set_collision_slop(self, collision_slop: float) -> None:
-        cp.cpSpaceSetCollisionSlop(self._space, collision_slop)
-
-    def _get_collision_slop(self) -> float:
-        return cp.cpSpaceGetCollisionSlop(self._space)
-
-    collision_slop = property(
-        _get_collision_slop,
-        _set_collision_slop,
-        doc="""Amount of overlap between shapes that is allowed.
-
-        To improve stability, set this as high as you can without noticeable
-        overlapping. It defaults to 0.1.
-        """,
-    )
-
-    def _set_collision_bias(self, collision_bias: float) -> None:
-        cp.cpSpaceSetCollisionBias(self._space, collision_bias)
-
-    def _get_collision_bias(self) -> float:
-        return cp.cpSpaceGetCollisionBias(self._space)
-
-    collision_bias = property(
-        _get_collision_bias,
-        _set_collision_bias,
-        doc="""Determines how fast overlapping shapes are pushed apart.
-
-        Pymunk allows fast moving objects to overlap, then fixes the overlap
-        over time. Overlapping objects are unavoidable even if swept
-        collisions are supported, and this is an efficient and stable way to
-        deal with overlapping objects. The bias value controls what
-        percentage of overlap remains unfixed after a second and defaults
-        to ~0.2%. Valid values are in the range from 0 to 1, but using 0 is
-        not recommended for stability reasons. The default value is
-        calculated as cpfpow(1.0f - 0.1f, 60.0f) meaning that pymunk attempts
-        to correct 10% of error ever 1/60th of a second.
-
-        ..Note::
-            Very very few games will need to change this value.
-        """,
-    )
-
-    def _set_collision_persistence(self, collision_persistence: float) -> None:
-        cp.cpSpaceSetCollisionPersistence(self._space, collision_persistence)
-
-    def _get_collision_persistence(self) -> float:
-        return cp.cpSpaceGetCollisionPersistence(self._space)
-
-    collision_persistence = property(
-        _get_collision_persistence,
-        _set_collision_persistence,
-        doc="""The number of frames the space keeps collision solutions
-        around for.
-
-        Helps prevent jittering contacts from getting worse. This defaults
-        to 3.
-
-        ..Note::
-            Very very few games will need to change this value.
-        """,
-    )
-
-    def _get_current_time_step(self) -> float:
-        return cp.cpSpaceGetCurrentTimeStep(self._space)
-
-    current_time_step = property(
-        _get_current_time_step,
-        doc="""Retrieves the current (if you are in a callback from
-        Space.step()) or most recent (outside of a Space.step() call)
-        timestep.
-        """,
-    )
-
-    def add(self, *objs: _AddableObjects) -> None:
-        """Add one or many shapes, bodies or constraints (joints) to the space
-
-        Unlike Chipmunk and earlier versions of pymunk its now allowed to add
-        objects even from a callback during the simulation step. However, the
-        add will not be performed until the end of the step.
-        """
-
-        if self._locked:
-            self._add_later.update(objs)
-            return
-
-        # add bodies first, since the shapes require their bodies to be
-        # already added. This allows code like space.add(shape, body).
-        for o in objs:
-            if isinstance(o, Body):
-                self._add_body(o)
-
-        for o in objs:
-            if isinstance(o, Body):
-                pass
-            elif isinstance(o, Shape):
-                self._add_shape(o)
-            elif isinstance(o, Constraint):
-                self._add_constraint(o)
-            else:
-                raise Exception(f"Unsupported type  {type(o)} of {o}.")
-
-    def remove(self, *objs: _AddableObjects) -> None:
-        """Remove one or many shapes, bodies or constraints from the space
-
-        Unlike Chipmunk and earlier versions of Pymunk its now allowed to
-        remove objects even from a callback during the simulation step.
-        However, the removal will not be performed until the end of the step.
-
-        .. Note::
-            When removing objects from the space, make sure you remove any
-            other objects that reference it. For instance, when you remove a
-            body, remove the joints and shapes attached to it.
-        """
-        if self._locked:
-            self._remove_later.update(objs)
-            return
-
-        for o in objs:
-            if isinstance(o, Body):
-                self._remove_body(o)
-            elif isinstance(o, Shape):
-                self._remove_shape(o)
-            elif isinstance(o, Constraint):
-                self._remove_constraint(o)
-            else:
-                raise Exception(f"Unsupported type  {type(o)} of {o}.")
-
-    def _add_shape(self, shape: "Shape") -> None:
-        """Adds a shape to the space"""
-        # print("addshape", self._space, shape)
-        assert shape._id not in self._shapes, "Shape already added to space."
-        assert (
-            shape.space == None
-        ), "Shape already added to another space. A shape can only be in one space at a time."
-        assert shape.body != None, "The shape's body is not set."
-        assert (
-            shape.body.space == self
-        ), "The shape's body must be added to the space before (or at the same time) as the shape."
-
-        shape._space = weakref.proxy(self)
-        self._shapes[shape._id] = shape
-        cp.cpSpaceAddShape(self._space, shape._shape)
-
-    def _add_body(self, body: "Body") -> None:
-        """Adds a body to the space"""
-        assert body not in self._bodies, "Body already added to this space."
-        assert body.space == None, "Body already added to another space."
-
-        body._space = weakref.proxy(self)
-        self._bodies[body] = None
-        cp.cpSpaceAddBody(self._space, body._body)
-
-    def _add_constraint(self, constraint: "Constraint") -> None:
-        """Adds a constraint to the space"""
-        assert constraint not in self._constraints, "Constraint already added to space."
-
-        self._constraints[constraint] = None
-        cp.cpSpaceAddConstraint(self._space, constraint._constraint)
-
-    def _remove_shape(self, shape: "Shape") -> None:
-        """Removes a shape from the space"""
-        assert shape._id in self._shapes, "shape not in space, already removed?"
-        self._removed_shapes[shape._id] = shape
-        shape._space = None
-        # During GC at program exit sometimes the shape might already be removed. Then skip this step.
-        if cp.cpSpaceContainsShape(self._space, shape._shape):
-            cp.cpSpaceRemoveShape(self._space, shape._shape)
-        del self._shapes[shape._id]
-
-    def _remove_body(self, body: "Body") -> None:
-        """Removes a body from the space"""
-        assert body in self._bodies, "body not in space, already removed?"
-        body._space = None
-        # During GC at program exit sometimes the shape might already be removed. Then skip this step.
-        if cp.cpSpaceContainsBody(self._space, body._body):
-            cp.cpSpaceRemoveBody(self._space, body._body)
-        del self._bodies[body]
-
-    def _remove_constraint(self, constraint: "Constraint") -> None:
-        """Removes a constraint from the space"""
-        assert (
-            constraint in self._constraints
-        ), "constraint not in space, already removed?"
-        # print("remove", constraint, constraint._constraint, self._constraints)
-        # During GC at program exit sometimes the constraint might already be removed. Then skip this steip.
-        if cp.cpSpaceContainsConstraint(self._space, constraint._constraint):
-            cp.cpSpaceRemoveConstraint(self._space, constraint._constraint)
-        del self._constraints[constraint]
-
-    def reindex_shape(self, shape: Shape) -> None:
-        """Update the collision detection data for a specific shape in the
-        space.
-        """
-        cp.cpSpaceReindexShape(self._space, shape._shape)
-
-    def reindex_shapes_for_body(self, body: Body) -> None:
-        """Reindex all the shapes for a certain body."""
-        cp.cpSpaceReindexShapesForBody(self._space, body._body)
-
-    def reindex_static(self) -> None:
-        """Update the collision detection info for the static shapes in the
-        space. You only need to call this if you move one of the static shapes.
-        """
-        cp.cpSpaceReindexStatic(self._space)
-
-    def _get_threads(self) -> int:
-        if self.threaded:
-            return int(cp.cpHastySpaceGetThreads(self._space))
-        return 1
-
-    def _set_threads(self, n: int) -> None:
-        if self.threaded:
-            cp.cpHastySpaceSetThreads(self._space, n)
-
-    threads = property(
-        _get_threads,
-        _set_threads,
-        doc="""The number of threads to use for running the step function. 
-        
-        Only valid when the Space was created with threaded=True. Currently the 
-        max limit is 2, setting a higher value wont have any effect. The 
-        default is 1 regardless if the Space was created with threaded=True, 
-        to keep determinism in the simulation. Note that Windows does not 
-        support the threaded solver.
-        """,
-    )
-
-    def use_spatial_hash(self, dim: float, count: int) -> None:
-        """Switch the space to use a spatial hash instead of the bounding box
-        tree.
-
-        Pymunk supports two spatial indexes. The default is an axis-aligned
-        bounding box tree inspired by the one used in the Bullet Physics
-        library, but caching of overlapping leaves was added to give it very
-        good temporal coherence. The tree requires no tuning, and most games
-        will find that they get the best performance using from the tree. The
-        other available spatial index type available is a spatial hash, which
-        can be much faster when you have a very large number (1000s) of
-        objects that are all the same size. For smaller numbers of objects,
-        or objects that vary a lot in size, the spatial hash is usually much
-        slower. It also requires tuning (usually through experimentation) to
-        get the best possible performance.
-
-        The spatial hash data is fairly size sensitive. dim is the size of
-        the hash cells. Setting dim to the average collision shape size is
-        likely to give the best performance. Setting dim too small will cause
-        the shape to be inserted into many cells, setting it too low will
-        cause too many objects into the same hash slot.
-
-        count is the suggested minimum number of cells in the hash table. If
-        there are too few cells, the spatial hash will return many false
-        positives. Too many cells will be hard on the cache and waste memory.
-        Setting count to ~10x the number of objects in the space is probably a
-        good starting point. Tune from there if necessary.
-
-        :param dim: the size of the hash cells
-        :param count: the suggested minimum number of cells in the hash table
-        """
-        cp.cpSpaceUseSpatialHash(self._space, dim, count)
-
-    def step(self, dt: float) -> None:
-        """Update the space for the given time step.
-
-        Using a fixed time step is highly recommended. Doing so will increase
-        the efficiency of the contact persistence, requiring an order of
-        magnitude fewer iterations to resolve the collisions in the usual case.
-
-        It is not the same to call step 10 times with a dt of 0.1 and
-        calling it 100 times with a dt of 0.01 even if the end result is
-        that the simulation moved forward 100 units. Performing  multiple
-        calls with a smaller dt creates a more stable and accurate
-        simulation. Therefor it sometimes make sense to have a little for loop
-        around the step call, like in this example:
-
-        >>> import pymunk
-        >>> s = pymunk.Space()
-        >>> steps = 10
-        >>> for x in range(steps): # move simulation forward 0.1 seconds:
-        ...     s.step(0.1 / steps)
-
-        :param dt: Time step length
-        """
-        try:
-            self._locked = True
-            if self.threaded:
-                cp.cpHastySpaceStep(self._space, dt)
-            else:
-                cp.cpSpaceStep(self._space, dt)
-            self._removed_shapes = {}
-        finally:
-            self._locked = False
-        self.add(*self._add_later)
-        self._add_later.clear()
-        for obj in self._remove_later:
-            self.remove(obj)
-        self._remove_later.clear()
-
-        for key in self._post_step_callbacks:
-            self._post_step_callbacks[key](self)
-
-        self._post_step_callbacks = {}
-
-    def add_collision_handler(
-        self, collision_type_a: int, collision_type_b: int
-    ) -> CollisionHandler:
-        """Return the :py:class:`CollisionHandler` for collisions between
-        objects of type collision_type_a and collision_type_b.
-
-        Fill the desired collision callback functions, for details see the
-        :py:class:`CollisionHandler` object.
-
-        Whenever shapes with collision types (:py:attr:`Shape.collision_type`)
-        a and b collide, this handler will be used to process the collision
-        events. When a new collision handler is created, the callbacks will all be
-        set to builtin callbacks that perform the default behavior (call the
-        wildcard handlers, and accept all collisions).
-
-        :param int collision_type_a: Collision type a
-        :param int collision_type_b: Collision type b
-
-        :rtype: :py:class:`CollisionHandler`
-        """
-        key = min(collision_type_a, collision_type_b), max(
-            collision_type_a, collision_type_b
-        )
-        if key in self._handlers:
-            return self._handlers[key]
-
-        h = cp.cpSpaceAddCollisionHandler(
-            self._space, collision_type_a, collision_type_b
-        )
-        ch = CollisionHandler(h, self)
-        self._handlers[key] = ch
-        return ch
-
-    def add_wildcard_collision_handler(self, collision_type_a: int) -> CollisionHandler:
-        """Add a wildcard collision handler for given collision type.
-
-        This handler will be used any time an object with this type collides
-        with another object, regardless of its type. A good example is a
-        projectile that should be destroyed the first time it hits anything.
-        There may be a specific collision handler and two wildcard handlers.
-        It's up to the specific handler to decide if and when to call the
-        wildcard handlers and what to do with their return values.
-
-        When a new wildcard handler is created, the callbacks will all be
-        set to builtin callbacks that perform the default behavior. (accept
-        all collisions in :py:func:`~CollisionHandler.begin` and
-        :py:func:`~CollisionHandler.pre_solve`, or do nothing for
-        :py:func:`~CollisionHandler.post_solve` and
-        :py:func:`~CollisionHandler.separate`.
-
-        :param int collision_type_a: Collision type
-        :rtype: :py:class:`CollisionHandler`
-        """
-
-        if collision_type_a in self._handlers:
-            return self._handlers[collision_type_a]
-
-        h = cp.cpSpaceAddWildcardHandler(self._space, collision_type_a)
-        ch = CollisionHandler(h, self)
-        self._handlers[collision_type_a] = ch
-        return ch
-
-    def add_default_collision_handler(self) -> CollisionHandler:
-        """Return a reference to the default collision handler or that is
-        used to process all collisions that don't have a more specific
-        handler.
-
-        The default behavior for each of the callbacks is to call
-        the wildcard handlers, ANDing their return values together if
-        applicable.
-        """
-        if None in self._handlers:
-            return self._handlers[None]
-
-        _h = cp.cpSpaceAddDefaultCollisionHandler(self._space)
-        h = CollisionHandler(_h, self)
-        self._handlers[None] = h
-        return h
-
-    def add_post_step_callback(
-        self,
-        callback_function: Callable[
-            ..., None
-        ],  # TODO: Fix me once PEP-612 is implemented
-        key: Hashable,
-        *args: Any,
-        **kwargs: Any,
-    ) -> bool:
-        """Add a function to be called last in the next simulation step.
-
-        Post step callbacks are registered as a function and an object used as
-        a key. You can only register one post step callback per object.
-
-        This function was more useful with earlier versions of pymunk where
-        you weren't allowed to use the add and remove methods on the space
-        during a simulation step. But this function is still available for
-        other uses and to keep backwards compatibility.
-
-        .. Note::
-            If you remove a shape from the callback it will trigger the
-            collision handler for the 'separate' event if it the shape was
-            touching when removed.
-
-        .. Note::
-            Post step callbacks are not included in pickle / copy of the space.
-
-        :param callback_function: The callback function
-        :type callback_function: `func(space : Space, key, *args, **kwargs)`
-        :param Any key:
-            This object is used as a key, you can only have one callback
-            for a single object. It is passed on to the callback function.
-        :param args: Optional parameters passed to the callback
-        :param kwargs: Optional keyword parameters passed on to the callback
-
-        :return: True if key was not previously added, False otherwise
-        """
-
-        if key in self._post_step_callbacks:
-            return False
-
-        def f(x):  # type: ignore
-            callback_function(self, key, *args, **kwargs)
-
-        self._post_step_callbacks[key] = f
-        return True
-
-    def point_query(
-        self, point: Tuple[float, float], max_distance: float, shape_filter: ShapeFilter
-    ) -> List[PointQueryInfo]:
-        """Query space at point for shapes within the given distance range.
-
-        The filter is applied to the query and follows the same rules as the
-        collision detection. If a maxDistance of 0.0 is used, the point must
-        lie inside a shape. Negative max_distance is also allowed meaning that
-        the point must be a under a certain depth within a shape to be
-        considered a match.
-
-        See :py:class:`ShapeFilter` for details about how the shape_filter
-        parameter can be used.
-
-        .. Note::
-            Sensor shapes are included in the result (In
-            :py:meth:`Space.point_query_nearest` they are not)
-
-        :param point: Where to check for collision in the Space
-        :type point: :py:class:`~vec2d.Vec2d` or (float,float)
-        :param float max_distance: Match only within this distance
-        :param ShapeFilter shape_filter: Only pick shapes matching the filter
-
-        :rtype: [:py:class:`PointQueryInfo`]
-        """
-        assert len(point) == 2
-        query_hits: List[PointQueryInfo] = []
-        d = (self, query_hits)
-        data = ffi.new_handle(d)
-        cp.cpSpacePointQuery(
-            self._space,
-            point,
-            max_distance,
-            shape_filter,
-            cp.ext_cpSpacePointQueryFunc,
-            data,
-        )
-        return query_hits
-
-    def _get_shape(self, _shape: Any) -> Optional[Shape]:
-        if not bool(_shape):
-            return None
-
-        shapeid = int(ffi.cast("int", cp.cpShapeGetUserData(_shape)))
-        # return self._shapes[hashid_private]
-
-        if shapeid in self._shapes:
-            return self._shapes[shapeid]
-        elif shapeid in self._removed_shapes:
-            return self._removed_shapes[shapeid]
-        else:
-            return None
-
-    def point_query_nearest(
-        self, point: Tuple[float, float], max_distance: float, shape_filter: ShapeFilter
-    ) -> Optional[PointQueryInfo]:
-        """Query space at point the nearest shape within the given distance
-        range.
-
-        The filter is applied to the query and follows the same rules as the
-        collision detection. If a maxDistance of 0.0 is used, the point must
-        lie inside a shape. Negative max_distance is also allowed meaning that
-        the point must be a under a certain depth within a shape to be
-        considered a match.
-
-        See :py:class:`ShapeFilter` for details about how the shape_filter
-        parameter can be used.
-
-        .. Note::
-            Sensor shapes are not included in the result (In
-            :py:meth:`Space.point_query` they are)
-
-        :param point: Where to check for collision in the Space
-        :type point: :py:class:`~vec2d.Vec2d` or (float,float)
-        :param float max_distance: Match only within this distance
-        :param ShapeFilter shape_filter: Only pick shapes matching the filter
-
-        :rtype: :py:class:`PointQueryInfo` or None
-        """
-        assert len(point) == 2
-        info = ffi.new("cpPointQueryInfo *")
-        _shape = cp.cpSpacePointQueryNearest(
-            self._space, point, max_distance, shape_filter, info
-        )
-
-        shape = self._get_shape(_shape)
-
-        if shape != None:
-            return PointQueryInfo(
-                shape,
-                Vec2d(info.point.x, info.point.y),
-                info.distance,
-                Vec2d(info.gradient.x, info.gradient.y),
-            )
-        return None
-
-    def segment_query(
-        self,
-        start: Tuple[float, float],
-        end: Tuple[float, float],
-        radius: float,
-        shape_filter: ShapeFilter,
-    ) -> List[SegmentQueryInfo]:
-        """Query space along the line segment from start to end with the
-        given radius.
-
-        The filter is applied to the query and follows the same rules as the
-        collision detection.
-
-        See :py:class:`ShapeFilter` for details about how the shape_filter
-        parameter can be used.
-
-        .. Note::
-            Sensor shapes are included in the result (In
-            :py:meth:`Space.segment_query_first` they are not)
-
-        :param start: Starting point
-        :param end: End point
-        :param float radius: Radius
-        :param ShapeFilter shape_filter: Shape filter
-
-        :rtype: [:py:class:`SegmentQueryInfo`]
-        """
-        assert len(start) == 2
-        assert len(end) == 2
-        query_hits: List[SegmentQueryInfo] = []
-
-        d = (self, query_hits)
-        data = ffi.new_handle(d)
-
-        cp.cpSpaceSegmentQuery(
-            self._space,
-            start,
-            end,
-            radius,
-            shape_filter,
-            cp.ext_cpSpaceSegmentQueryFunc,
-            data,
-        )
-        return query_hits
-
-    def segment_query_first(
-        self,
-        start: Tuple[float, float],
-        end: Tuple[float, float],
-        radius: float,
-        shape_filter: ShapeFilter,
-    ) -> Optional[SegmentQueryInfo]:
-        """Query space along the line segment from start to end with the
-        given radius.
-
-        The filter is applied to the query and follows the same rules as the
-        collision detection.
-
-        .. Note::
-            Sensor shapes are not included in the result (In
-            :py:meth:`Space.segment_query` they are)
-
-        See :py:class:`ShapeFilter` for details about how the shape_filter
-        parameter can be used.
-
-        :rtype: :py:class:`SegmentQueryInfo` or None
-        """
-        assert len(start) == 2
-        assert len(end) == 2
-        info = ffi.new("cpSegmentQueryInfo *")
-        _shape = cp.cpSpaceSegmentQueryFirst(
-            self._space, start, end, radius, shape_filter, info
-        )
-
-        shape = self._get_shape(_shape)
-        if shape != None:
-            return SegmentQueryInfo(
-                shape,
-                Vec2d(info.point.x, info.point.y),
-                Vec2d(info.normal.x, info.normal.y),
-                info.alpha,
-            )
-        return None
-
-    def bb_query(self, bb: "BB", shape_filter: ShapeFilter) -> List[Shape]:
-        """Query space to find all shapes near bb.
-
-        The filter is applied to the query and follows the same rules as the
-        collision detection.
-
-        .. Note::
-            Sensor shapes are included in the result
-
-        :param bb: Bounding box
-        :param shape_filter: Shape filter
-
-        :rtype: [:py:class:`Shape`]
-        """
-
-        query_hits: List[Shape] = []
-
-        d = (self, query_hits)
-        data = ffi.new_handle(d)
-
-        cp.cpSpaceBBQuery(
-            self._space, bb, shape_filter, cp.ext_cpSpaceBBQueryFunc, data
-        )
-        return query_hits
-
-    def shape_query(self, shape: Shape) -> List[ShapeQueryInfo]:
-        """Query a space for any shapes overlapping the given shape
-
-        .. Note::
-            Sensor shapes are included in the result
-
-        :param shape: Shape to query with
-        :type shape: :py:class:`Circle`, :py:class:`Poly` or :py:class:`Segment`
-
-        :rtype: [:py:class:`ShapeQueryInfo`]
-        """
-
-        query_hits: List[ShapeQueryInfo] = []
-        d = (self, query_hits)
-        data = ffi.new_handle(d)
-
-        cp.cpSpaceShapeQuery(
-            self._space, shape._shape, cp.ext_cpSpaceShapeQueryFunc, data
-        )
-
-        return query_hits
-
-    def debug_draw(self, options: SpaceDebugDrawOptions) -> None:
-        """Debug draw the current state of the space using the supplied drawing
-        options.
-
-        If you use a graphics backend that is already supported, such as pygame
-        and pyglet, you can use the predefined options in their x_util modules,
-        for example :py:class:`pygame_util.DrawOptions`.
-
-        Its also possible to write your own graphics backend, see
-        :py:class:`SpaceDebugDrawOptions`.
-
-        If you require any advanced or optimized drawing its probably best to
-        not use this function for the drawing since its meant for debugging
-        and quick scripting.
-
-        :type options: :py:class:`SpaceDebugDrawOptions`
-        """
-        if options._use_chipmunk_debug_draw:
-            d = (options, self)
-            h = ffi.new_handle(d)
-            # we need to hold h until the end of cpSpaceDebugDraw to prevent GC
-            options._options.data = h
-
-            with options:
-                cp.cpSpaceDebugDraw(self._space, options._options)
-        else:
-            for shape in self.shapes:
-                options.draw_shape(shape)
-
-    # def get_batched_bodies(self, shape_filter):
-    #     """Return a memoryview for use when the non-batch api is not performant enough.
-
-    #     .. note::
-    #         Experimental API. Likely to change in future major, minor or point
-    #         releases.
-    #     """
-    #     pass
-
-    def _get_arbiters(self) -> List[ffi.CData]:
-        _arbiters: List[ffi.CData] = []
-        data = ffi.new_handle(_arbiters)
-        cp.cpSpaceEachCachedArbiter(self._space, cp.ext_cpArbiterIteratorFunc, data)
-        return _arbiters
-
-    def __getstate__(self) -> _State:
-        """Return the state of this object
-
-        This method allows the usage of the :mod:`copy` and :mod:`pickle`
-        modules with this class.
-        """
-        d = super(Space, self).__getstate__()
-
-        d["special"].append(("pymunk_version", _version.version))
-        # bodies needs to be added to the state before their shapes.
-        d["special"].append(("bodies", self.bodies))
-        if self._static_body != None:
-            # print("getstate", self._static_body)
-            d["special"].append(("_static_body", self._static_body))
-
-        d["special"].append(("shapes", self.shapes))
-        d["special"].append(("constraints", self.constraints))
-
-        handlers = []
-        for k, v in self._handlers.items():
-            h: Dict[str, Any] = {}
-            if v._begin is not None:
-                h["_begin"] = v._begin
-            if v._pre_solve is not None:
-                h["_pre_solve"] = v._pre_solve
-            if v._post_solve is not None:
-                h["_post_solve"] = v._post_solve
-            if v._separate is not None:
-                h["_separate"] = v._separate
-            handlers.append((k, h))
-
-        d["special"].append(("_handlers", handlers))
-
-        d["special"].append(
-            ("shapeIDCounter", cp.cpSpaceGetShapeIDCounter(self._space))
-        )
-        d["special"].append(("stamp", cp.cpSpaceGetTimestamp(self._space)))
-        d["special"].append(
-            ("currentTimeStep", cp.cpSpaceGetCurrentTimeStep(self._space))
-        )
-
-        _arbs = self._get_arbiters()
-        d["special"].append(
-            ("arbiters", [_arbiter_to_dict(_arb, self) for _arb in _arbs])
-        )
-        return d
-
-    def __setstate__(self, state: _State) -> None:
-        """Unpack this object from a saved state.
-
-        This method allows the usage of the :mod:`copy` and :mod:`pickle`
-        modules with this class.
-        """
-        super(Space, self).__setstate__(state)
-
-        for k, v in state["special"]:
-            if k == "pymunk_version":
-                assert (
-                    _version.version == v
-                ), f"Pymunk version {v} of pickled object does not match current Pymunk version {_version.version}"
-            elif k == "bodies":
-                self.add(*v)
-            elif k == "_static_body":
-                # _ = cp.cpSpaceSetStaticBody(self._space, v._body)
-                # v._space = self
-                # self._static_body = v
-                # print("setstate", v, self._static_body)
-                self._static_body = v
-                self._setup_static_body(v)
-                # self._static_body._space = weakref.proxy(self)
-                # cp.cpSpaceAddBody(self._space, v._body)
-                # self.add(v)
-
-            elif k == "shapes":
-                # print("setstate shapes", v)
-                self.add(*v)
-            elif k == "constraints":
-                self.add(*v)
-            elif k == "_handlers":
-                for k2, hd in v:
-                    if k2 == None:
-                        h = self.add_default_collision_handler()
-                    elif isinstance(k2, tuple):
-                        h = self.add_collision_handler(k2[0], k2[1])
-                    else:
-                        h = self.add_wildcard_collision_handler(k2)
-                    if "_begin" in hd:
-                        h.begin = hd["_begin"]
-                    if "_pre_solve" in hd:
-                        h.pre_solve = hd["_pre_solve"]
-                    if "_post_solve" in hd:
-                        h.post_solve = hd["_post_solve"]
-                    if "_separate" in hd:
-                        h.separate = hd["_separate"]
-            elif k == "stamp":
-                cp.cpSpaceSetTimestamp(self._space, v)
-            elif k == "shapeIDCounter":
-                cp.cpSpaceSetShapeIDCounter(self._space, v)
-            elif k == "currentTimeStep":
-                cp.cpSpaceSetCurrentTimeStep(self._space, v)
-            elif k == "arbiters":
-                for d in v:
-                    # cp.cpSpaceTest(self._space)
-                    _arbiter = _arbiter_from_dict(d, self)
-                    cp.cpSpaceAddCachedArbiter(self._space, _arbiter)
+__docformat__ = "reStructuredText"
+
+import logging
+import platform
+import weakref
+from typing import (
+    TYPE_CHECKING,
+    Any,
+    Callable,
+    Dict,
+    Hashable,
+    List,
+    Optional,
+    Set,
+    Tuple,
+    Union,
+)
+
+from pymunk.constraints import Constraint
+from pymunk.shape_filter import ShapeFilter
+from pymunk.space_debug_draw_options import SpaceDebugDrawOptions
+
+from . import _version
+from ._callbacks import *
+from ._chipmunk_cffi import ffi, lib
+
+cp = lib
+
+from ._pickle import PickleMixin, _State
+from .arbiter import _arbiter_from_dict, _arbiter_to_dict
+from .body import Body
+from .collision_handler import CollisionHandler
+from .query_info import PointQueryInfo, SegmentQueryInfo, ShapeQueryInfo
+from .shapes import Shape
+from .vec2d import Vec2d
+
+if TYPE_CHECKING:
+    from .bb import BB
+
+_AddableObjects = Union[Body, Shape, Constraint]
+
+_logger = logging.getLogger(__name__)
+
+
+class Space(PickleMixin, object):
+    """Spaces are the basic unit of simulation. You add rigid bodies, shapes
+    and joints to it and then step them all forward together through time.
+
+    A Space can be copied and pickled. Note that any post step callbacks are
+    not copied. Also note that some internal collision cache data is not copied,
+    which can make the simulation a bit unstable the first few steps of the
+    fresh copy.
+
+    Custom properties set on the space will also be copied/pickled.
+
+    Any collision handlers will also be copied/pickled. Note that depending on
+    the pickle protocol used there are some restrictions on what functions can
+    be copied/pickled.
+
+    Example::
+
+    >>> import pymunk, pickle
+    >>> space = pymunk.Space()
+    >>> space2 = space.copy()
+    >>> space3 = pickle.loads(pickle.dumps(space))
+    """
+
+    _pickle_attrs_init = PickleMixin._pickle_attrs_init + ["threaded"]
+    _pickle_attrs_general = PickleMixin._pickle_attrs_general + [
+        "iterations",
+        "gravity",
+        "damping",
+        "idle_speed_threshold",
+        "sleep_time_threshold",
+        "collision_slop",
+        "collision_bias",
+        "collision_persistence",
+        "threads",
+    ]
+
+    def __init__(self, threaded: bool = False) -> None:
+        """Create a new instance of the Space.
+
+        If you set threaded=True the step function will run in threaded mode
+        which might give a speedup. Note that even when you set threaded=True
+        you still have to set Space.threads=2 to actually use more than one
+        thread.
+
+        Also note that threaded mode is not available on Windows, and setting
+        threaded=True has no effect on that platform.
+        """
+
+        self.threaded = threaded and platform.system() != "Windows"
+
+        if self.threaded:
+            cp_space = cp.cpHastySpaceNew()
+            freefunc = cp.cpHastySpaceFree
+        else:
+            cp_space = cp.cpSpaceNew()
+            freefunc = cp.cpSpaceFree
+
+        def spacefree(cp_space):  # type: ignore
+            _logger.debug("spacefree start %s", cp_space)
+
+            cp_shapes: List[Shape] = []
+            cp_shapes_h = ffi.new_handle(cp_shapes)
+            cp.cpSpaceEachShape(cp_space, lib.ext_cpSpaceShapeIteratorFunc, cp_shapes_h)
+
+            for cp_shape in cp_shapes:
+                cp_space = lib.cpShapeGetSpace(cp_shape)
+                _logger.debug("spacefree remove shape %s %s", cp_space, cp_shape)
+
+                lib.cpSpaceRemoveShape(cp_space, cp_shape)
+                lib.cpShapeSetBody(cp_shape, ffi.NULL)
+
+            cp_constraints: List[Constraint] = []
+            cp_constraints_h = ffi.new_handle(cp_constraints)
+            cp.cpSpaceEachConstraint(
+                cp_space, lib.ext_cpSpaceConstraintIteratorFunc, cp_constraints_h
+            )
+            for cp_constraint in cp_constraints:
+                cp_space = lib.cpConstraintGetSpace(cp_constraint)
+                _logger.debug(
+                    "spacefree remove constraint %s %s", cp_space, cp_constraint
+                )
+                lib.cpSpaceRemoveConstraint(cp_space, cp_constraint)
+
+            cp_bodys: List[Body] = []
+            cp_bodys_h = ffi.new_handle(cp_bodys)
+            cp.cpSpaceEachBody(cp_space, lib.ext_cpSpaceBodyIteratorFunc, cp_bodys_h)
+            for cp_body in cp_bodys:
+                cp_space = lib.cpBodyGetSpace(cp_body)
+                _logger.debug("spacefree remove body %s %s", cp_space, cp_body)
+                lib.cpSpaceRemoveBody(cp_space, cp_body)
+
+            _logger.debug("spacefree free %s", cp_space)
+            freefunc(cp_space)
+
+        self._space = ffi.gc(cp_space, spacefree)
+
+        self._handlers: Dict[
+            Any, CollisionHandler
+        ] = {}  # To prevent the gc to collect the callbacks.
+
+        self._post_step_callbacks: Dict[Any, Callable[["Space"], None]] = {}
+        self._removed_shapes: Dict[int, Shape] = {}
+
+        self._shapes: Dict[int, Shape] = {}
+        self._bodies: Dict[Body, None] = {}
+        self._static_body: Optional[Body] = None
+        self._constraints: Dict[Constraint, None] = {}
+
+        self._locked = False
+
+        self._add_later: Set[_AddableObjects] = set()
+        self._remove_later: Set[_AddableObjects] = set()
+
+    def _get_self(self) -> "Space":
+        return self
+
+    @property
+    def shapes(self) -> List[Shape]:
+        """A list of all the shapes added to this space
+
+        (includes both static and non-static)
+        """
+        return list(self._shapes.values())
+
+    @property
+    def bodies(self) -> List[Body]:
+        """A list of the bodies added to this space"""
+        return list(self._bodies)
+
+    @property
+    def constraints(self) -> List[Constraint]:
+        """A list of the constraints added to this space"""
+        return list(self._constraints)
+
+    def _setup_static_body(self, static_body: Body) -> None:
+        static_body._space = weakref.proxy(self)
+        cp.cpSpaceAddBody(self._space, static_body._body)
+
+    @property
+    def static_body(self) -> Body:
+        """A dedicated static body for the space.
+
+        You don't have to use it, but many times it can be convenient to have
+        a static body together with the space.
+        """
+        if self._static_body is None:
+            self._static_body = Body(body_type=Body.STATIC)
+            self._setup_static_body(self._static_body)
+            # self.add(self._static_body)
+
+            # b = cp.cpSpaceGetStaticBody(self._space)
+            # self._static_body = Body._init_with_body(b)
+            # self._static_body._space = self
+            # assert self._static_body is not None
+        return self._static_body
+
+    def _set_iterations(self, value: int) -> None:
+        cp.cpSpaceSetIterations(self._space, value)
+
+    def _get_iterations(self) -> int:
+        return cp.cpSpaceGetIterations(self._space)
+
+    iterations = property(
+        _get_iterations,
+        _set_iterations,
+        doc="""Iterations allow you to control the accuracy of the solver.
+
+        Defaults to 10.
+
+        Pymunk uses an iterative solver to figure out the forces between
+        objects in the space. What this means is that it builds a big list of
+        all of the collisions, joints, and other constraints between the
+        bodies and makes several passes over the list considering each one
+        individually. The number of passes it makes is the iteration count,
+        and each iteration makes the solution more accurate. If you use too
+        many iterations, the physics should look nice and solid, but may use
+        up too much CPU time. If you use too few iterations, the simulation
+        may seem mushy or bouncy when the objects should be solid. Setting
+        the number of iterations lets you balance between CPU usage and the
+        accuracy of the physics. Pymunk's default of 10 iterations is
+        sufficient for most simple games.
+        """,
+    )
+
+    def _set_gravity(self, gravity_vector: Tuple[float, float]) -> None:
+        assert len(gravity_vector) == 2
+        cp.cpSpaceSetGravity(self._space, gravity_vector)
+
+    def _get_gravity(self) -> Vec2d:
+        v = cp.cpSpaceGetGravity(self._space)
+        return Vec2d(v.x, v.y)
+
+    gravity = property(
+        _get_gravity,
+        _set_gravity,
+        doc="""Global gravity applied to the space.
+
+        Defaults to (0,0). Can be overridden on a per body basis by writing
+        custom integration functions and set it on the body:
+        :py:meth:`pymunk.Body.velocity_func`.
+        """,
+    )
+
+    def _set_damping(self, damping: float) -> None:
+        cp.cpSpaceSetDamping(self._space, damping)
+
+    def _get_damping(self) -> float:
+        return cp.cpSpaceGetDamping(self._space)
+
+    damping = property(
+        _get_damping,
+        _set_damping,
+        doc="""Amount of simple damping to apply to the space.
+
+        A value of 0.9 means that each body will lose 10% of its velocity per
+        second. Defaults to 1. Like gravity, it can be overridden on a per
+        body basis.
+        """,
+    )
+
+    def _set_idle_speed_threshold(self, idle_speed_threshold: float) -> None:
+        cp.cpSpaceSetIdleSpeedThreshold(self._space, idle_speed_threshold)
+
+    def _get_idle_speed_threshold(self) -> float:
+        return cp.cpSpaceGetIdleSpeedThreshold(self._space)
+
+    idle_speed_threshold = property(
+        _get_idle_speed_threshold,
+        _set_idle_speed_threshold,
+        doc="""Speed threshold for a body to be considered idle.
+
+        The default value of 0 means the space estimates a good threshold
+        based on gravity.
+        """,
+    )
+
+    def _set_sleep_time_threshold(self, sleep_time_threshold: float) -> None:
+        cp.cpSpaceSetSleepTimeThreshold(self._space, sleep_time_threshold)
+
+    def _get_sleep_time_threshold(self) -> float:
+        return cp.cpSpaceGetSleepTimeThreshold(self._space)
+
+    sleep_time_threshold = property(
+        _get_sleep_time_threshold,
+        _set_sleep_time_threshold,
+        doc="""Time a group of bodies must remain idle in order to fall
+        asleep.
+
+        The default value of `inf` disables the sleeping algorithm.
+        """,
+    )
+
+    def _set_collision_slop(self, collision_slop: float) -> None:
+        cp.cpSpaceSetCollisionSlop(self._space, collision_slop)
+
+    def _get_collision_slop(self) -> float:
+        return cp.cpSpaceGetCollisionSlop(self._space)
+
+    collision_slop = property(
+        _get_collision_slop,
+        _set_collision_slop,
+        doc="""Amount of overlap between shapes that is allowed.
+
+        To improve stability, set this as high as you can without noticeable
+        overlapping. It defaults to 0.1.
+        """,
+    )
+
+    def _set_collision_bias(self, collision_bias: float) -> None:
+        cp.cpSpaceSetCollisionBias(self._space, collision_bias)
+
+    def _get_collision_bias(self) -> float:
+        return cp.cpSpaceGetCollisionBias(self._space)
+
+    collision_bias = property(
+        _get_collision_bias,
+        _set_collision_bias,
+        doc="""Determines how fast overlapping shapes are pushed apart.
+
+        Pymunk allows fast moving objects to overlap, then fixes the overlap
+        over time. Overlapping objects are unavoidable even if swept
+        collisions are supported, and this is an efficient and stable way to
+        deal with overlapping objects. The bias value controls what
+        percentage of overlap remains unfixed after a second and defaults
+        to ~0.2%. Valid values are in the range from 0 to 1, but using 0 is
+        not recommended for stability reasons. The default value is
+        calculated as cpfpow(1.0f - 0.1f, 60.0f) meaning that pymunk attempts
+        to correct 10% of error ever 1/60th of a second.
+
+        ..Note::
+            Very very few games will need to change this value.
+        """,
+    )
+
+    def _set_collision_persistence(self, collision_persistence: float) -> None:
+        cp.cpSpaceSetCollisionPersistence(self._space, collision_persistence)
+
+    def _get_collision_persistence(self) -> float:
+        return cp.cpSpaceGetCollisionPersistence(self._space)
+
+    collision_persistence = property(
+        _get_collision_persistence,
+        _set_collision_persistence,
+        doc="""The number of frames the space keeps collision solutions
+        around for.
+
+        Helps prevent jittering contacts from getting worse. This defaults
+        to 3.
+
+        ..Note::
+            Very very few games will need to change this value.
+        """,
+    )
+
+    def _get_current_time_step(self) -> float:
+        return cp.cpSpaceGetCurrentTimeStep(self._space)
+
+    current_time_step = property(
+        _get_current_time_step,
+        doc="""Retrieves the current (if you are in a callback from
+        Space.step()) or most recent (outside of a Space.step() call)
+        timestep.
+        """,
+    )
+
+    def add(self, *objs: _AddableObjects) -> None:
+        """Add one or many shapes, bodies or constraints (joints) to the space
+
+        Unlike Chipmunk and earlier versions of pymunk its now allowed to add
+        objects even from a callback during the simulation step. However, the
+        add will not be performed until the end of the step.
+        """
+
+        if self._locked:
+            self._add_later.update(objs)
+            return
+
+        # add bodies first, since the shapes require their bodies to be
+        # already added. This allows code like space.add(shape, body).
+        for o in objs:
+            if isinstance(o, Body):
+                self._add_body(o)
+
+        for o in objs:
+            if isinstance(o, Body):
+                pass
+            elif isinstance(o, Shape):
+                self._add_shape(o)
+            elif isinstance(o, Constraint):
+                self._add_constraint(o)
+            else:
+                raise Exception(f"Unsupported type  {type(o)} of {o}.")
+
+    def remove(self, *objs: _AddableObjects) -> None:
+        """Remove one or many shapes, bodies or constraints from the space
+
+        Unlike Chipmunk and earlier versions of Pymunk its now allowed to
+        remove objects even from a callback during the simulation step.
+        However, the removal will not be performed until the end of the step.
+
+        .. Note::
+            When removing objects from the space, make sure you remove any
+            other objects that reference it. For instance, when you remove a
+            body, remove the joints and shapes attached to it.
+        """
+        if self._locked:
+            self._remove_later.update(objs)
+            return
+
+        for o in objs:
+            if isinstance(o, Body):
+                self._remove_body(o)
+            elif isinstance(o, Shape):
+                self._remove_shape(o)
+            elif isinstance(o, Constraint):
+                self._remove_constraint(o)
+            else:
+                raise Exception(f"Unsupported type  {type(o)} of {o}.")
+
+    def _add_shape(self, shape: "Shape") -> None:
+        """Adds a shape to the space"""
+        # print("addshape", self._space, shape)
+        assert shape._id not in self._shapes, "Shape already added to space."
+        assert (
+            shape.space == None
+        ), "Shape already added to another space. A shape can only be in one space at a time."
+        assert shape.body != None, "The shape's body is not set."
+        assert (
+            shape.body.space == self
+        ), "The shape's body must be added to the space before (or at the same time) as the shape."
+
+        shape._space = weakref.proxy(self)
+        self._shapes[shape._id] = shape
+        cp.cpSpaceAddShape(self._space, shape._shape)
+
+    def _add_body(self, body: "Body") -> None:
+        """Adds a body to the space"""
+        assert body not in self._bodies, "Body already added to this space."
+        assert body.space == None, "Body already added to another space."
+
+        body._space = weakref.proxy(self)
+        self._bodies[body] = None
+        cp.cpSpaceAddBody(self._space, body._body)
+
+    def _add_constraint(self, constraint: "Constraint") -> None:
+        """Adds a constraint to the space"""
+        assert constraint not in self._constraints, "Constraint already added to space."
+
+        self._constraints[constraint] = None
+        cp.cpSpaceAddConstraint(self._space, constraint._constraint)
+
+    def _remove_shape(self, shape: "Shape") -> None:
+        """Removes a shape from the space"""
+        assert shape._id in self._shapes, "shape not in space, already removed?"
+        self._removed_shapes[shape._id] = shape
+        shape._space = None
+        # During GC at program exit sometimes the shape might already be removed. Then skip this step.
+        if cp.cpSpaceContainsShape(self._space, shape._shape):
+            cp.cpSpaceRemoveShape(self._space, shape._shape)
+        del self._shapes[shape._id]
+
+    def _remove_body(self, body: "Body") -> None:
+        """Removes a body from the space"""
+        assert body in self._bodies, "body not in space, already removed?"
+        body._space = None
+        # During GC at program exit sometimes the shape might already be removed. Then skip this step.
+        if cp.cpSpaceContainsBody(self._space, body._body):
+            cp.cpSpaceRemoveBody(self._space, body._body)
+        del self._bodies[body]
+
+    def _remove_constraint(self, constraint: "Constraint") -> None:
+        """Removes a constraint from the space"""
+        assert (
+            constraint in self._constraints
+        ), "constraint not in space, already removed?"
+        # print("remove", constraint, constraint._constraint, self._constraints)
+        # During GC at program exit sometimes the constraint might already be removed. Then skip this steip.
+        if cp.cpSpaceContainsConstraint(self._space, constraint._constraint):
+            cp.cpSpaceRemoveConstraint(self._space, constraint._constraint)
+        del self._constraints[constraint]
+
+    def reindex_shape(self, shape: Shape) -> None:
+        """Update the collision detection data for a specific shape in the
+        space.
+        """
+        cp.cpSpaceReindexShape(self._space, shape._shape)
+
+    def reindex_shapes_for_body(self, body: Body) -> None:
+        """Reindex all the shapes for a certain body."""
+        cp.cpSpaceReindexShapesForBody(self._space, body._body)
+
+    def reindex_static(self) -> None:
+        """Update the collision detection info for the static shapes in the
+        space. You only need to call this if you move one of the static shapes.
+        """
+        cp.cpSpaceReindexStatic(self._space)
+
+    def _get_threads(self) -> int:
+        if self.threaded:
+            return int(cp.cpHastySpaceGetThreads(self._space))
+        return 1
+
+    def _set_threads(self, n: int) -> None:
+        if self.threaded:
+            cp.cpHastySpaceSetThreads(self._space, n)
+
+    threads = property(
+        _get_threads,
+        _set_threads,
+        doc="""The number of threads to use for running the step function. 
+        
+        Only valid when the Space was created with threaded=True. Currently the 
+        max limit is 2, setting a higher value wont have any effect. The 
+        default is 1 regardless if the Space was created with threaded=True, 
+        to keep determinism in the simulation. Note that Windows does not 
+        support the threaded solver.
+        """,
+    )
+
+    def use_spatial_hash(self, dim: float, count: int) -> None:
+        """Switch the space to use a spatial hash instead of the bounding box
+        tree.
+
+        Pymunk supports two spatial indexes. The default is an axis-aligned
+        bounding box tree inspired by the one used in the Bullet Physics
+        library, but caching of overlapping leaves was added to give it very
+        good temporal coherence. The tree requires no tuning, and most games
+        will find that they get the best performance using from the tree. The
+        other available spatial index type available is a spatial hash, which
+        can be much faster when you have a very large number (1000s) of
+        objects that are all the same size. For smaller numbers of objects,
+        or objects that vary a lot in size, the spatial hash is usually much
+        slower. It also requires tuning (usually through experimentation) to
+        get the best possible performance.
+
+        The spatial hash data is fairly size sensitive. dim is the size of
+        the hash cells. Setting dim to the average collision shape size is
+        likely to give the best performance. Setting dim too small will cause
+        the shape to be inserted into many cells, setting it too low will
+        cause too many objects into the same hash slot.
+
+        count is the suggested minimum number of cells in the hash table. If
+        there are too few cells, the spatial hash will return many false
+        positives. Too many cells will be hard on the cache and waste memory.
+        Setting count to ~10x the number of objects in the space is probably a
+        good starting point. Tune from there if necessary.
+
+        :param dim: the size of the hash cells
+        :param count: the suggested minimum number of cells in the hash table
+        """
+        cp.cpSpaceUseSpatialHash(self._space, dim, count)
+
+    def step(self, dt: float) -> None:
+        """Update the space for the given time step.
+
+        Using a fixed time step is highly recommended. Doing so will increase
+        the efficiency of the contact persistence, requiring an order of
+        magnitude fewer iterations to resolve the collisions in the usual case.
+
+        It is not the same to call step 10 times with a dt of 0.1 and
+        calling it 100 times with a dt of 0.01 even if the end result is
+        that the simulation moved forward 100 units. Performing  multiple
+        calls with a smaller dt creates a more stable and accurate
+        simulation. Therefor it sometimes make sense to have a little for loop
+        around the step call, like in this example:
+
+        >>> import pymunk
+        >>> s = pymunk.Space()
+        >>> steps = 10
+        >>> for x in range(steps): # move simulation forward 0.1 seconds:
+        ...     s.step(0.1 / steps)
+
+        :param dt: Time step length
+        """
+        try:
+            self._locked = True
+            if self.threaded:
+                cp.cpHastySpaceStep(self._space, dt)
+            else:
+                cp.cpSpaceStep(self._space, dt)
+            self._removed_shapes = {}
+        finally:
+            self._locked = False
+        self.add(*self._add_later)
+        self._add_later.clear()
+        for obj in self._remove_later:
+            self.remove(obj)
+        self._remove_later.clear()
+
+        for key in self._post_step_callbacks:
+            self._post_step_callbacks[key](self)
+
+        self._post_step_callbacks = {}
+
+    def add_collision_handler(
+        self, collision_type_a: int, collision_type_b: int
+    ) -> CollisionHandler:
+        """Return the :py:class:`CollisionHandler` for collisions between
+        objects of type collision_type_a and collision_type_b.
+
+        Fill the desired collision callback functions, for details see the
+        :py:class:`CollisionHandler` object.
+
+        Whenever shapes with collision types (:py:attr:`Shape.collision_type`)
+        a and b collide, this handler will be used to process the collision
+        events. When a new collision handler is created, the callbacks will all be
+        set to builtin callbacks that perform the default behavior (call the
+        wildcard handlers, and accept all collisions).
+
+        :param int collision_type_a: Collision type a
+        :param int collision_type_b: Collision type b
+
+        :rtype: :py:class:`CollisionHandler`
+        """
+        key = min(collision_type_a, collision_type_b), max(
+            collision_type_a, collision_type_b
+        )
+        if key in self._handlers:
+            return self._handlers[key]
+
+        h = cp.cpSpaceAddCollisionHandler(
+            self._space, collision_type_a, collision_type_b
+        )
+        ch = CollisionHandler(h, self)
+        self._handlers[key] = ch
+        return ch
+
+    def add_wildcard_collision_handler(self, collision_type_a: int) -> CollisionHandler:
+        """Add a wildcard collision handler for given collision type.
+
+        This handler will be used any time an object with this type collides
+        with another object, regardless of its type. A good example is a
+        projectile that should be destroyed the first time it hits anything.
+        There may be a specific collision handler and two wildcard handlers.
+        It's up to the specific handler to decide if and when to call the
+        wildcard handlers and what to do with their return values.
+
+        When a new wildcard handler is created, the callbacks will all be
+        set to builtin callbacks that perform the default behavior. (accept
+        all collisions in :py:func:`~CollisionHandler.begin` and
+        :py:func:`~CollisionHandler.pre_solve`, or do nothing for
+        :py:func:`~CollisionHandler.post_solve` and
+        :py:func:`~CollisionHandler.separate`.
+
+        :param int collision_type_a: Collision type
+        :rtype: :py:class:`CollisionHandler`
+        """
+
+        if collision_type_a in self._handlers:
+            return self._handlers[collision_type_a]
+
+        h = cp.cpSpaceAddWildcardHandler(self._space, collision_type_a)
+        ch = CollisionHandler(h, self)
+        self._handlers[collision_type_a] = ch
+        return ch
+
+    def add_default_collision_handler(self) -> CollisionHandler:
+        """Return a reference to the default collision handler or that is
+        used to process all collisions that don't have a more specific
+        handler.
+
+        The default behavior for each of the callbacks is to call
+        the wildcard handlers, ANDing their return values together if
+        applicable.
+        """
+        if None in self._handlers:
+            return self._handlers[None]
+
+        _h = cp.cpSpaceAddDefaultCollisionHandler(self._space)
+        h = CollisionHandler(_h, self)
+        self._handlers[None] = h
+        return h
+
+    def add_post_step_callback(
+        self,
+        callback_function: Callable[
+            ..., None
+        ],  # TODO: Fix me once PEP-612 is implemented
+        key: Hashable,
+        *args: Any,
+        **kwargs: Any,
+    ) -> bool:
+        """Add a function to be called last in the next simulation step.
+
+        Post step callbacks are registered as a function and an object used as
+        a key. You can only register one post step callback per object.
+
+        This function was more useful with earlier versions of pymunk where
+        you weren't allowed to use the add and remove methods on the space
+        during a simulation step. But this function is still available for
+        other uses and to keep backwards compatibility.
+
+        .. Note::
+            If you remove a shape from the callback it will trigger the
+            collision handler for the 'separate' event if it the shape was
+            touching when removed.
+
+        .. Note::
+            Post step callbacks are not included in pickle / copy of the space.
+
+        :param callback_function: The callback function
+        :type callback_function: `func(space : Space, key, *args, **kwargs)`
+        :param Any key:
+            This object is used as a key, you can only have one callback
+            for a single object. It is passed on to the callback function.
+        :param args: Optional parameters passed to the callback
+        :param kwargs: Optional keyword parameters passed on to the callback
+
+        :return: True if key was not previously added, False otherwise
+        """
+
+        if key in self._post_step_callbacks:
+            return False
+
+        def f(x):  # type: ignore
+            callback_function(self, key, *args, **kwargs)
+
+        self._post_step_callbacks[key] = f
+        return True
+
+    def point_query(
+        self, point: Tuple[float, float], max_distance: float, shape_filter: ShapeFilter
+    ) -> List[PointQueryInfo]:
+        """Query space at point for shapes within the given distance range.
+
+        The filter is applied to the query and follows the same rules as the
+        collision detection. If a maxDistance of 0.0 is used, the point must
+        lie inside a shape. Negative max_distance is also allowed meaning that
+        the point must be a under a certain depth within a shape to be
+        considered a match.
+
+        See :py:class:`ShapeFilter` for details about how the shape_filter
+        parameter can be used.
+
+        .. Note::
+            Sensor shapes are included in the result (In
+            :py:meth:`Space.point_query_nearest` they are not)
+
+        :param point: Where to check for collision in the Space
+        :type point: :py:class:`~vec2d.Vec2d` or (float,float)
+        :param float max_distance: Match only within this distance
+        :param ShapeFilter shape_filter: Only pick shapes matching the filter
+
+        :rtype: [:py:class:`PointQueryInfo`]
+        """
+        assert len(point) == 2
+        query_hits: List[PointQueryInfo] = []
+        d = (self, query_hits)
+        data = ffi.new_handle(d)
+        cp.cpSpacePointQuery(
+            self._space,
+            point,
+            max_distance,
+            shape_filter,
+            cp.ext_cpSpacePointQueryFunc,
+            data,
+        )
+        return query_hits
+
+    def _get_shape(self, _shape: Any) -> Optional[Shape]:
+        if not bool(_shape):
+            return None
+
+        shapeid = int(ffi.cast("int", cp.cpShapeGetUserData(_shape)))
+        # return self._shapes[hashid_private]
+
+        if shapeid in self._shapes:
+            return self._shapes[shapeid]
+        elif shapeid in self._removed_shapes:
+            return self._removed_shapes[shapeid]
+        else:
+            return None
+
+    def point_query_nearest(
+        self, point: Tuple[float, float], max_distance: float, shape_filter: ShapeFilter
+    ) -> Optional[PointQueryInfo]:
+        """Query space at point the nearest shape within the given distance
+        range.
+
+        The filter is applied to the query and follows the same rules as the
+        collision detection. If a maxDistance of 0.0 is used, the point must
+        lie inside a shape. Negative max_distance is also allowed meaning that
+        the point must be a under a certain depth within a shape to be
+        considered a match.
+
+        See :py:class:`ShapeFilter` for details about how the shape_filter
+        parameter can be used.
+
+        .. Note::
+            Sensor shapes are not included in the result (In
+            :py:meth:`Space.point_query` they are)
+
+        :param point: Where to check for collision in the Space
+        :type point: :py:class:`~vec2d.Vec2d` or (float,float)
+        :param float max_distance: Match only within this distance
+        :param ShapeFilter shape_filter: Only pick shapes matching the filter
+
+        :rtype: :py:class:`PointQueryInfo` or None
+        """
+        assert len(point) == 2
+        info = ffi.new("cpPointQueryInfo *")
+        _shape = cp.cpSpacePointQueryNearest(
+            self._space, point, max_distance, shape_filter, info
+        )
+
+        shape = self._get_shape(_shape)
+
+        if shape != None:
+            return PointQueryInfo(
+                shape,
+                Vec2d(info.point.x, info.point.y),
+                info.distance,
+                Vec2d(info.gradient.x, info.gradient.y),
+            )
+        return None
+
+    def segment_query(
+        self,
+        start: Tuple[float, float],
+        end: Tuple[float, float],
+        radius: float,
+        shape_filter: ShapeFilter,
+    ) -> List[SegmentQueryInfo]:
+        """Query space along the line segment from start to end with the
+        given radius.
+
+        The filter is applied to the query and follows the same rules as the
+        collision detection.
+
+        See :py:class:`ShapeFilter` for details about how the shape_filter
+        parameter can be used.
+
+        .. Note::
+            Sensor shapes are included in the result (In
+            :py:meth:`Space.segment_query_first` they are not)
+
+        :param start: Starting point
+        :param end: End point
+        :param float radius: Radius
+        :param ShapeFilter shape_filter: Shape filter
+
+        :rtype: [:py:class:`SegmentQueryInfo`]
+        """
+        assert len(start) == 2
+        assert len(end) == 2
+        query_hits: List[SegmentQueryInfo] = []
+
+        d = (self, query_hits)
+        data = ffi.new_handle(d)
+
+        cp.cpSpaceSegmentQuery(
+            self._space,
+            start,
+            end,
+            radius,
+            shape_filter,
+            cp.ext_cpSpaceSegmentQueryFunc,
+            data,
+        )
+        return query_hits
+
+    def segment_query_first(
+        self,
+        start: Tuple[float, float],
+        end: Tuple[float, float],
+        radius: float,
+        shape_filter: ShapeFilter,
+    ) -> Optional[SegmentQueryInfo]:
+        """Query space along the line segment from start to end with the
+        given radius.
+
+        The filter is applied to the query and follows the same rules as the
+        collision detection.
+
+        .. Note::
+            Sensor shapes are not included in the result (In
+            :py:meth:`Space.segment_query` they are)
+
+        See :py:class:`ShapeFilter` for details about how the shape_filter
+        parameter can be used.
+
+        :rtype: :py:class:`SegmentQueryInfo` or None
+        """
+        assert len(start) == 2
+        assert len(end) == 2
+        info = ffi.new("cpSegmentQueryInfo *")
+        _shape = cp.cpSpaceSegmentQueryFirst(
+            self._space, start, end, radius, shape_filter, info
+        )
+
+        shape = self._get_shape(_shape)
+        if shape != None:
+            return SegmentQueryInfo(
+                shape,
+                Vec2d(info.point.x, info.point.y),
+                Vec2d(info.normal.x, info.normal.y),
+                info.alpha,
+            )
+        return None
+
+    def bb_query(self, bb: "BB", shape_filter: ShapeFilter) -> List[Shape]:
+        """Query space to find all shapes near bb.
+
+        The filter is applied to the query and follows the same rules as the
+        collision detection.
+
+        .. Note::
+            Sensor shapes are included in the result
+
+        :param bb: Bounding box
+        :param shape_filter: Shape filter
+
+        :rtype: [:py:class:`Shape`]
+        """
+
+        query_hits: List[Shape] = []
+
+        d = (self, query_hits)
+        data = ffi.new_handle(d)
+
+        cp.cpSpaceBBQuery(
+            self._space, bb, shape_filter, cp.ext_cpSpaceBBQueryFunc, data
+        )
+        return query_hits
+
+    def shape_query(self, shape: Shape) -> List[ShapeQueryInfo]:
+        """Query a space for any shapes overlapping the given shape
+
+        .. Note::
+            Sensor shapes are included in the result
+
+        :param shape: Shape to query with
+        :type shape: :py:class:`Circle`, :py:class:`Poly` or :py:class:`Segment`
+
+        :rtype: [:py:class:`ShapeQueryInfo`]
+        """
+
+        query_hits: List[ShapeQueryInfo] = []
+        d = (self, query_hits)
+        data = ffi.new_handle(d)
+
+        cp.cpSpaceShapeQuery(
+            self._space, shape._shape, cp.ext_cpSpaceShapeQueryFunc, data
+        )
+
+        return query_hits
+
+    def debug_draw(self, options: SpaceDebugDrawOptions) -> None:
+        """Debug draw the current state of the space using the supplied drawing
+        options.
+
+        If you use a graphics backend that is already supported, such as pygame
+        and pyglet, you can use the predefined options in their x_util modules,
+        for example :py:class:`pygame_util.DrawOptions`.
+
+        Its also possible to write your own graphics backend, see
+        :py:class:`SpaceDebugDrawOptions`.
+
+        If you require any advanced or optimized drawing its probably best to
+        not use this function for the drawing since its meant for debugging
+        and quick scripting.
+
+        :type options: :py:class:`SpaceDebugDrawOptions`
+        """
+        if options._use_chipmunk_debug_draw:
+            d = (options, self)
+            h = ffi.new_handle(d)
+            # we need to hold h until the end of cpSpaceDebugDraw to prevent GC
+            options._options.data = h
+
+            with options:
+                cp.cpSpaceDebugDraw(self._space, options._options)
+        else:
+            for shape in self.shapes:
+                options.draw_shape(shape)
+
+    # def get_batched_bodies(self, shape_filter):
+    #     """Return a memoryview for use when the non-batch api is not performant enough.
+
+    #     .. note::
+    #         Experimental API. Likely to change in future major, minor or point
+    #         releases.
+    #     """
+    #     pass
+
+    def _get_arbiters(self) -> List[ffi.CData]:
+        _arbiters: List[ffi.CData] = []
+        data = ffi.new_handle(_arbiters)
+        cp.cpSpaceEachCachedArbiter(self._space, cp.ext_cpArbiterIteratorFunc, data)
+        return _arbiters
+
+    def __getstate__(self) -> _State:
+        """Return the state of this object
+
+        This method allows the usage of the :mod:`copy` and :mod:`pickle`
+        modules with this class.
+        """
+        d = super(Space, self).__getstate__()
+
+        d["special"].append(("pymunk_version", _version.version))
+        # bodies needs to be added to the state before their shapes.
+        d["special"].append(("bodies", self.bodies))
+        if self._static_body != None:
+            # print("getstate", self._static_body)
+            d["special"].append(("_static_body", self._static_body))
+
+        d["special"].append(("shapes", self.shapes))
+        d["special"].append(("constraints", self.constraints))
+
+        handlers = []
+        for k, v in self._handlers.items():
+            h: Dict[str, Any] = {}
+            if v._begin is not None:
+                h["_begin"] = v._begin
+            if v._pre_solve is not None:
+                h["_pre_solve"] = v._pre_solve
+            if v._post_solve is not None:
+                h["_post_solve"] = v._post_solve
+            if v._separate is not None:
+                h["_separate"] = v._separate
+            handlers.append((k, h))
+
+        d["special"].append(("_handlers", handlers))
+
+        d["special"].append(
+            ("shapeIDCounter", cp.cpSpaceGetShapeIDCounter(self._space))
+        )
+        d["special"].append(("stamp", cp.cpSpaceGetTimestamp(self._space)))
+        d["special"].append(
+            ("currentTimeStep", cp.cpSpaceGetCurrentTimeStep(self._space))
+        )
+
+        _arbs = self._get_arbiters()
+        d["special"].append(
+            ("arbiters", [_arbiter_to_dict(_arb, self) for _arb in _arbs])
+        )
+        return d
+
+    def __setstate__(self, state: _State) -> None:
+        """Unpack this object from a saved state.
+
+        This method allows the usage of the :mod:`copy` and :mod:`pickle`
+        modules with this class.
+        """
+        super(Space, self).__setstate__(state)
+
+        for k, v in state["special"]:
+            if k == "pymunk_version":
+                assert (
+                    _version.version == v
+                ), f"Pymunk version {v} of pickled object does not match current Pymunk version {_version.version}"
+            elif k == "bodies":
+                self.add(*v)
+            elif k == "_static_body":
+                # _ = cp.cpSpaceSetStaticBody(self._space, v._body)
+                # v._space = self
+                # self._static_body = v
+                # print("setstate", v, self._static_body)
+                self._static_body = v
+                self._setup_static_body(v)
+                # self._static_body._space = weakref.proxy(self)
+                # cp.cpSpaceAddBody(self._space, v._body)
+                # self.add(v)
+
+            elif k == "shapes":
+                # print("setstate shapes", v)
+                self.add(*v)
+            elif k == "constraints":
+                self.add(*v)
+            elif k == "_handlers":
+                for k2, hd in v:
+                    if k2 == None:
+                        h = self.add_default_collision_handler()
+                    elif isinstance(k2, tuple):
+                        h = self.add_collision_handler(k2[0], k2[1])
+                    else:
+                        h = self.add_wildcard_collision_handler(k2)
+                    if "_begin" in hd:
+                        h.begin = hd["_begin"]
+                    if "_pre_solve" in hd:
+                        h.pre_solve = hd["_pre_solve"]
+                    if "_post_solve" in hd:
+                        h.post_solve = hd["_post_solve"]
+                    if "_separate" in hd:
+                        h.separate = hd["_separate"]
+            elif k == "stamp":
+                cp.cpSpaceSetTimestamp(self._space, v)
+            elif k == "shapeIDCounter":
+                cp.cpSpaceSetShapeIDCounter(self._space, v)
+            elif k == "currentTimeStep":
+                cp.cpSpaceSetCurrentTimeStep(self._space, v)
+            elif k == "arbiters":
+                for d in v:
+                    # cp.cpSpaceTest(self._space)
+                    _arbiter = _arbiter_from_dict(d, self)
+                    cp.cpSpaceAddCachedArbiter(self._space, _arbiter)
```

## Comparing `pymunk-6.5.0/pymunk/space_debug_draw_options.py` & `pymunk/space_debug_draw_options.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,343 +1,343 @@
-__docformat__ = "reStructuredText"
-
-from typing import TYPE_CHECKING, ClassVar, NamedTuple, Optional, Sequence, Tuple, Type
-
-if TYPE_CHECKING:
-    from .shapes import Shape
-    from types import TracebackType
-
-import math
-
-from ._chipmunk_cffi import ffi, lib
-from .body import Body
-from .transform import Transform
-from .vec2d import Vec2d
-
-_DrawFlags = int
-
-
-class SpaceDebugColor(NamedTuple):
-    """Color tuple used by the debug drawing API."""
-
-    r: float
-    g: float
-    b: float
-    a: float
-
-    def as_int(self) -> Tuple[int, int, int, int]:
-        """Return the color as a tuple of ints, where each value is rounded.
-
-        >>> SpaceDebugColor(0, 51.1, 101.9, 255).as_int()
-        (0, 51, 102, 255)
-        """
-        return round(self[0]), round(self[1]), round(self[2]), round(self[3])
-
-    def as_float(self) -> Tuple[float, float, float, float]:
-        """Return the color as a tuple of floats, each value divided by 255.
-
-        >>> SpaceDebugColor(0, 51, 102, 255).as_float()
-        (0.0, 0.2, 0.4, 1.0)
-        """
-        return self[0] / 255.0, self[1] / 255.0, self[2] / 255.0, self[3] / 255.0
-
-
-class SpaceDebugDrawOptions(object):
-    """SpaceDebugDrawOptions configures debug drawing.
-
-    If appropriate its usually easy to use the supplied draw implementations
-    directly: pymunk.pygame_util, pymunk.pyglet_util and pymunk.matplotlib_util.
-    """
-
-    DRAW_SHAPES: ClassVar[_DrawFlags] = lib.CP_SPACE_DEBUG_DRAW_SHAPES
-    """Draw shapes.  
-    
-    Use on the flags property to control if shapes should be drawn or not.
-    """
-
-    DRAW_CONSTRAINTS: ClassVar[_DrawFlags] = lib.CP_SPACE_DEBUG_DRAW_CONSTRAINTS
-    """Draw constraints. 
-    
-    Use on the flags property to control if constraints should be drawn or not.
-    """
-
-    DRAW_COLLISION_POINTS: ClassVar[
-        _DrawFlags
-    ] = lib.CP_SPACE_DEBUG_DRAW_COLLISION_POINTS
-    """Draw collision points.
-    
-    Use on the flags property to control if collision points should be drawn or
-    not.
-    """
-
-    shape_dynamic_color: SpaceDebugColor = SpaceDebugColor(52, 152, 219, 255)
-    shape_static_color: SpaceDebugColor = SpaceDebugColor(149, 165, 166, 255)
-    shape_kinematic_color: SpaceDebugColor = SpaceDebugColor(39, 174, 96, 255)
-    shape_sleeping_color: SpaceDebugColor = SpaceDebugColor(114, 148, 168, 255)
-
-    def __init__(self) -> None:
-        _options = ffi.new("cpSpaceDebugDrawOptions *")
-        self._options = _options
-        self._options.transform = Transform.identity()
-        self.shape_outline_color = SpaceDebugColor(44, 62, 80, 255)
-        self.constraint_color = SpaceDebugColor(142, 68, 173, 255)
-        self.collision_point_color = SpaceDebugColor(231, 76, 60, 255)
-
-        # Set to false to bypass chipmunk shape drawing code
-        self._use_chipmunk_debug_draw = True
-
-        _options.drawCircle = lib.ext_cpSpaceDebugDrawCircleImpl
-        _options.drawSegment = lib.ext_cpSpaceDebugDrawSegmentImpl
-        _options.drawFatSegment = lib.ext_cpSpaceDebugDrawFatSegmentImpl
-        _options.drawPolygon = lib.ext_cpSpaceDebugDrawPolygonImpl
-        _options.drawDot = lib.ext_cpSpaceDebugDrawDotImpl
-        _options.colorForShape = lib.ext_cpSpaceDebugDrawColorForShapeImpl
-
-        self.flags = (
-            SpaceDebugDrawOptions.DRAW_SHAPES
-            | SpaceDebugDrawOptions.DRAW_CONSTRAINTS
-            | SpaceDebugDrawOptions.DRAW_COLLISION_POINTS
-        )
-
-    def _get_shape_outline_color(self) -> SpaceDebugColor:
-        return self._c(self._options.shapeOutlineColor)
-
-    def _set_shape_outline_color(self, c: SpaceDebugColor) -> None:
-        self._options.shapeOutlineColor = c
-
-    shape_outline_color = property(
-        _get_shape_outline_color,
-        _set_shape_outline_color,
-        doc="""The outline color of shapes.
-        
-        Should be a tuple of 4 ints between 0 and 255 (r,g,b,a).
-
-        Example:
-
-        >>> import pymunk
-        >>> s = pymunk.Space()
-        >>> c = pymunk.Circle(s.static_body, 10)
-        >>> s.add(c)
-        >>> options = pymunk.SpaceDebugDrawOptions()
-        >>> s.debug_draw(options)
-        draw_circle (Vec2d(0.0, 0.0), 0.0, 10.0, SpaceDebugColor(r=44.0, g=62.0, b=80.0, a=255.0), SpaceDebugColor(r=149.0, g=165.0, b=166.0, a=255.0))
-        >>> options.shape_outline_color = (10,20,30,40)
-        >>> s.debug_draw(options)
-        draw_circle (Vec2d(0.0, 0.0), 0.0, 10.0, SpaceDebugColor(r=10.0, g=20.0, b=30.0, a=40.0), SpaceDebugColor(r=149.0, g=165.0, b=166.0, a=255.0))
-
-        """,
-    )
-
-    def _get_constraint_color(self) -> SpaceDebugColor:
-        return self._c(self._options.constraintColor)
-
-    def _set_constraint_color(self, c: SpaceDebugColor) -> None:
-        self._options.constraintColor = c
-
-    constraint_color = property(
-        _get_constraint_color,
-        _set_constraint_color,
-        doc="""The color of constraints.
-
-        Should be a tuple of 4 ints between 0 and 255 (r,g,b,a).
-        
-        Example:
-
-        >>> import pymunk
-        >>> s = pymunk.Space()
-        >>> b = pymunk.Body(1, 10)
-        >>> j = pymunk.PivotJoint(s.static_body, b, (0,0))
-        >>> s.add(j)
-        >>> options = pymunk.SpaceDebugDrawOptions()
-        >>> s.debug_draw(options)
-        draw_dot (5.0, Vec2d(0.0, 0.0), SpaceDebugColor(r=142.0, g=68.0, b=173.0, a=255.0))
-        draw_dot (5.0, Vec2d(0.0, 0.0), SpaceDebugColor(r=142.0, g=68.0, b=173.0, a=255.0))
-        >>> options.constraint_color = (10,20,30,40)
-        >>> s.debug_draw(options)
-        draw_dot (5.0, Vec2d(0.0, 0.0), SpaceDebugColor(r=10.0, g=20.0, b=30.0, a=40.0))
-        draw_dot (5.0, Vec2d(0.0, 0.0), SpaceDebugColor(r=10.0, g=20.0, b=30.0, a=40.0))
-
-        """,
-    )
-
-    def _get_collision_point_color(self) -> SpaceDebugColor:
-        return self._c(self._options.collisionPointColor)
-
-    def _set_collision_point_color(self, c: SpaceDebugColor) -> None:
-        self._options.collisionPointColor = c
-
-    collision_point_color = property(
-        _get_collision_point_color,
-        _set_collision_point_color,
-        doc="""The color of collisions.
-
-        Should be a tuple of 4 ints between 0 and 255 (r,g,b,a).
-        
-        Example:
-
-        >>> import pymunk
-        >>> s = pymunk.Space()
-        >>> b = pymunk.Body(1,10)
-        >>> c1 = pymunk.Circle(b, 10)
-        >>> c2 = pymunk.Circle(s.static_body, 10)
-        >>> s.add(b, c1, c2)
-        >>> s.step(1)
-        >>> options = pymunk.SpaceDebugDrawOptions()
-        >>> s.debug_draw(options)
-        draw_circle (Vec2d(0.0, 0.0), 0.0, 10.0, SpaceDebugColor(r=44.0, g=62.0, b=80.0, a=255.0), SpaceDebugColor(r=52.0, g=152.0, b=219.0, a=255.0))
-        draw_circle (Vec2d(0.0, 0.0), 0.0, 10.0, SpaceDebugColor(r=44.0, g=62.0, b=80.0, a=255.0), SpaceDebugColor(r=149.0, g=165.0, b=166.0, a=255.0))
-        draw_segment (Vec2d(8.0, 0.0), Vec2d(-8.0, 0.0), SpaceDebugColor(r=231.0, g=76.0, b=60.0, a=255.0))
-        >>> options.collision_point_color = (10,20,30,40)
-        >>> s.debug_draw(options)
-        draw_circle (Vec2d(0.0, 0.0), 0.0, 10.0, SpaceDebugColor(r=44.0, g=62.0, b=80.0, a=255.0), SpaceDebugColor(r=52.0, g=152.0, b=219.0, a=255.0))
-        draw_circle (Vec2d(0.0, 0.0), 0.0, 10.0, SpaceDebugColor(r=44.0, g=62.0, b=80.0, a=255.0), SpaceDebugColor(r=149.0, g=165.0, b=166.0, a=255.0))
-        draw_segment (Vec2d(8.0, 0.0), Vec2d(-8.0, 0.0), SpaceDebugColor(r=10.0, g=20.0, b=30.0, a=40.0))
-        """,
-    )
-
-    def __enter__(self) -> None:
-        pass
-
-    def __exit__(
-        self,
-        type: Optional[Type[BaseException]],
-        value: Optional[BaseException],
-        traceback: Optional["TracebackType"],
-    ) -> None:
-        pass
-
-    def _c(self, color: ffi.CData) -> SpaceDebugColor:
-        return SpaceDebugColor(color.r, color.g, color.b, color.a)
-
-    def _get_flags(self) -> _DrawFlags:
-        return self._options.flags
-
-    def _set_flags(self, f: _DrawFlags) -> None:
-        self._options.flags = f
-
-    flags = property(
-        _get_flags,
-        _set_flags,
-        doc="""Bit flags which of shapes, joints and collisions should be drawn.
-
-        By default all 3 flags are set, meaning shapes, joints and collisions 
-        will be drawn.
-
-        Example using the basic text only DebugDraw implementation (normally
-        you would the desired backend instead, such as 
-        `pygame_util.DrawOptions` or `pyglet_util.DrawOptions`):
-
-        >>> import pymunk
-        >>> s = pymunk.Space()
-        >>> b = pymunk.Body()
-        >>> c = pymunk.Circle(b, 10)
-        >>> c.mass = 3
-        >>> s.add(b, c)
-        >>> s.add(pymunk.Circle(s.static_body, 3))
-        >>> s.step(0.01)
-        >>> options = pymunk.SpaceDebugDrawOptions() 
-        
-        >>> # Only draw the shapes, nothing else:
-        >>> options.flags = pymunk.SpaceDebugDrawOptions.DRAW_SHAPES
-        >>> s.debug_draw(options) 
-        draw_circle (Vec2d(0.0, 0.0), 0.0, 10.0, SpaceDebugColor(r=44.0, g=62.0, b=80.0, a=255.0), SpaceDebugColor(r=52.0, g=152.0, b=219.0, a=255.0))
-        draw_circle (Vec2d(0.0, 0.0), 0.0, 3.0, SpaceDebugColor(r=44.0, g=62.0, b=80.0, a=255.0), SpaceDebugColor(r=149.0, g=165.0, b=166.0, a=255.0))
-
-        >>> # Draw the shapes and collision points:
-        >>> options.flags = pymunk.SpaceDebugDrawOptions.DRAW_SHAPES
-        >>> options.flags |= pymunk.SpaceDebugDrawOptions.DRAW_COLLISION_POINTS
-        >>> s.debug_draw(options)
-        draw_circle (Vec2d(0.0, 0.0), 0.0, 10.0, SpaceDebugColor(r=44.0, g=62.0, b=80.0, a=255.0), SpaceDebugColor(r=52.0, g=152.0, b=219.0, a=255.0))
-        draw_circle (Vec2d(0.0, 0.0), 0.0, 3.0, SpaceDebugColor(r=44.0, g=62.0, b=80.0, a=255.0), SpaceDebugColor(r=149.0, g=165.0, b=166.0, a=255.0))
-        draw_segment (Vec2d(1.0, 0.0), Vec2d(-8.0, 0.0), SpaceDebugColor(r=231.0, g=76.0, b=60.0, a=255.0))
-        
-        """,
-    )
-
-    def _get_transform(self) -> Transform:
-        t = self._options.transform
-        return Transform(t.a, t.b, t.c, t.d, t.tx, t.ty)
-
-    def _set_transform(self, t: Transform) -> None:
-        self._options.transform = t
-
-    transform = property(
-        _get_transform,
-        _set_transform,
-        doc="""The transform is applied before drawing, e.g for scaling or 
-        translation.
-
-        Example: 
-
-        >>> import pymunk
-        >>> s = pymunk.Space()
-        >>> c = pymunk.Circle(s.static_body, 10)
-        >>> s.add(c)
-        >>> options = pymunk.SpaceDebugDrawOptions() 
-        >>> s.debug_draw(options) 
-        draw_circle (Vec2d(0.0, 0.0), 0.0, 10.0, SpaceDebugColor(r=44.0, g=62.0, b=80.0, a=255.0), SpaceDebugColor(r=149.0, g=165.0, b=166.0, a=255.0))
-        >>> options.transform = pymunk.Transform.scaling(2)
-        >>> s.debug_draw(options)
-        draw_circle (Vec2d(0.0, 0.0), 0.0, 20.0, SpaceDebugColor(r=44.0, g=62.0, b=80.0, a=255.0), SpaceDebugColor(r=149.0, g=165.0, b=166.0, a=255.0))
-        >>> options.transform = pymunk.Transform.translation(2,3)
-        >>> s.debug_draw(options)
-        draw_circle (Vec2d(2.0, 3.0), 0.0, 10.0, SpaceDebugColor(r=44.0, g=62.0, b=80.0, a=255.0), SpaceDebugColor(r=149.0, g=165.0, b=166.0, a=255.0))
-        
-        .. Note::
-            Not all tranformations are supported by the debug drawing logic. 
-            Uniform scaling and translation are supported, but not rotation,
-            linear stretching or shearing. 
-        """,
-    )
-
-    def draw_circle(
-        self,
-        pos: Vec2d,
-        angle: float,
-        radius: float,
-        outline_color: SpaceDebugColor,
-        fill_color: SpaceDebugColor,
-    ) -> None:
-        print("draw_circle", (pos, angle, radius, outline_color, fill_color))
-
-    def draw_segment(self, a: Vec2d, b: Vec2d, color: SpaceDebugColor) -> None:
-        print("draw_segment", (a, b, color))
-
-    def draw_fat_segment(
-        self,
-        a: Vec2d,
-        b: Vec2d,
-        radius: float,
-        outline_color: SpaceDebugColor,
-        fill_color: SpaceDebugColor,
-    ) -> None:
-        print("draw_fat_segment", (a, b, radius, outline_color, fill_color))
-
-    def draw_polygon(
-        self,
-        verts: Sequence[Vec2d],
-        radius: float,
-        outline_color: SpaceDebugColor,
-        fill_color: SpaceDebugColor,
-    ) -> None:
-        print("draw_polygon", (verts, radius, outline_color, fill_color))
-
-    def draw_dot(self, size: float, pos: Vec2d, color: SpaceDebugColor) -> None:
-        print("draw_dot", (size, pos, color))
-
-    def draw_shape(self, shape: "Shape") -> None:
-        print("draw_shape", shape)
-
-    def color_for_shape(self, shape: "Shape") -> SpaceDebugColor:
-        if hasattr(shape, "color"):
-            return SpaceDebugColor(*shape.color)
-
-        color = self.shape_dynamic_color
-        if shape.body != None:
-            if shape.body.body_type == Body.STATIC:
-                color = self.shape_static_color
-            elif shape.body.body_type == Body.KINEMATIC:
-                color = self.shape_kinematic_color
-            elif shape.body.is_sleeping:
-                color = self.shape_sleeping_color
-
-        return color
+__docformat__ = "reStructuredText"
+
+from typing import TYPE_CHECKING, ClassVar, NamedTuple, Optional, Sequence, Tuple, Type
+
+if TYPE_CHECKING:
+    from .shapes import Shape
+    from types import TracebackType
+
+import math
+
+from ._chipmunk_cffi import ffi, lib
+from .body import Body
+from .transform import Transform
+from .vec2d import Vec2d
+
+_DrawFlags = int
+
+
+class SpaceDebugColor(NamedTuple):
+    """Color tuple used by the debug drawing API."""
+
+    r: float
+    g: float
+    b: float
+    a: float
+
+    def as_int(self) -> Tuple[int, int, int, int]:
+        """Return the color as a tuple of ints, where each value is rounded.
+
+        >>> SpaceDebugColor(0, 51.1, 101.9, 255).as_int()
+        (0, 51, 102, 255)
+        """
+        return round(self[0]), round(self[1]), round(self[2]), round(self[3])
+
+    def as_float(self) -> Tuple[float, float, float, float]:
+        """Return the color as a tuple of floats, each value divided by 255.
+
+        >>> SpaceDebugColor(0, 51, 102, 255).as_float()
+        (0.0, 0.2, 0.4, 1.0)
+        """
+        return self[0] / 255.0, self[1] / 255.0, self[2] / 255.0, self[3] / 255.0
+
+
+class SpaceDebugDrawOptions(object):
+    """SpaceDebugDrawOptions configures debug drawing.
+
+    If appropriate its usually easy to use the supplied draw implementations
+    directly: pymunk.pygame_util, pymunk.pyglet_util and pymunk.matplotlib_util.
+    """
+
+    DRAW_SHAPES: ClassVar[_DrawFlags] = lib.CP_SPACE_DEBUG_DRAW_SHAPES
+    """Draw shapes.  
+    
+    Use on the flags property to control if shapes should be drawn or not.
+    """
+
+    DRAW_CONSTRAINTS: ClassVar[_DrawFlags] = lib.CP_SPACE_DEBUG_DRAW_CONSTRAINTS
+    """Draw constraints. 
+    
+    Use on the flags property to control if constraints should be drawn or not.
+    """
+
+    DRAW_COLLISION_POINTS: ClassVar[
+        _DrawFlags
+    ] = lib.CP_SPACE_DEBUG_DRAW_COLLISION_POINTS
+    """Draw collision points.
+    
+    Use on the flags property to control if collision points should be drawn or
+    not.
+    """
+
+    shape_dynamic_color: SpaceDebugColor = SpaceDebugColor(52, 152, 219, 255)
+    shape_static_color: SpaceDebugColor = SpaceDebugColor(149, 165, 166, 255)
+    shape_kinematic_color: SpaceDebugColor = SpaceDebugColor(39, 174, 96, 255)
+    shape_sleeping_color: SpaceDebugColor = SpaceDebugColor(114, 148, 168, 255)
+
+    def __init__(self) -> None:
+        _options = ffi.new("cpSpaceDebugDrawOptions *")
+        self._options = _options
+        self._options.transform = Transform.identity()
+        self.shape_outline_color = SpaceDebugColor(44, 62, 80, 255)
+        self.constraint_color = SpaceDebugColor(142, 68, 173, 255)
+        self.collision_point_color = SpaceDebugColor(231, 76, 60, 255)
+
+        # Set to false to bypass chipmunk shape drawing code
+        self._use_chipmunk_debug_draw = True
+
+        _options.drawCircle = lib.ext_cpSpaceDebugDrawCircleImpl
+        _options.drawSegment = lib.ext_cpSpaceDebugDrawSegmentImpl
+        _options.drawFatSegment = lib.ext_cpSpaceDebugDrawFatSegmentImpl
+        _options.drawPolygon = lib.ext_cpSpaceDebugDrawPolygonImpl
+        _options.drawDot = lib.ext_cpSpaceDebugDrawDotImpl
+        _options.colorForShape = lib.ext_cpSpaceDebugDrawColorForShapeImpl
+
+        self.flags = (
+            SpaceDebugDrawOptions.DRAW_SHAPES
+            | SpaceDebugDrawOptions.DRAW_CONSTRAINTS
+            | SpaceDebugDrawOptions.DRAW_COLLISION_POINTS
+        )
+
+    def _get_shape_outline_color(self) -> SpaceDebugColor:
+        return self._c(self._options.shapeOutlineColor)
+
+    def _set_shape_outline_color(self, c: SpaceDebugColor) -> None:
+        self._options.shapeOutlineColor = c
+
+    shape_outline_color = property(
+        _get_shape_outline_color,
+        _set_shape_outline_color,
+        doc="""The outline color of shapes.
+        
+        Should be a tuple of 4 ints between 0 and 255 (r,g,b,a).
+
+        Example:
+
+        >>> import pymunk
+        >>> s = pymunk.Space()
+        >>> c = pymunk.Circle(s.static_body, 10)
+        >>> s.add(c)
+        >>> options = pymunk.SpaceDebugDrawOptions()
+        >>> s.debug_draw(options)
+        draw_circle (Vec2d(0.0, 0.0), 0.0, 10.0, SpaceDebugColor(r=44.0, g=62.0, b=80.0, a=255.0), SpaceDebugColor(r=149.0, g=165.0, b=166.0, a=255.0))
+        >>> options.shape_outline_color = (10,20,30,40)
+        >>> s.debug_draw(options)
+        draw_circle (Vec2d(0.0, 0.0), 0.0, 10.0, SpaceDebugColor(r=10.0, g=20.0, b=30.0, a=40.0), SpaceDebugColor(r=149.0, g=165.0, b=166.0, a=255.0))
+
+        """,
+    )
+
+    def _get_constraint_color(self) -> SpaceDebugColor:
+        return self._c(self._options.constraintColor)
+
+    def _set_constraint_color(self, c: SpaceDebugColor) -> None:
+        self._options.constraintColor = c
+
+    constraint_color = property(
+        _get_constraint_color,
+        _set_constraint_color,
+        doc="""The color of constraints.
+
+        Should be a tuple of 4 ints between 0 and 255 (r,g,b,a).
+        
+        Example:
+
+        >>> import pymunk
+        >>> s = pymunk.Space()
+        >>> b = pymunk.Body(1, 10)
+        >>> j = pymunk.PivotJoint(s.static_body, b, (0,0))
+        >>> s.add(j)
+        >>> options = pymunk.SpaceDebugDrawOptions()
+        >>> s.debug_draw(options)
+        draw_dot (5.0, Vec2d(0.0, 0.0), SpaceDebugColor(r=142.0, g=68.0, b=173.0, a=255.0))
+        draw_dot (5.0, Vec2d(0.0, 0.0), SpaceDebugColor(r=142.0, g=68.0, b=173.0, a=255.0))
+        >>> options.constraint_color = (10,20,30,40)
+        >>> s.debug_draw(options)
+        draw_dot (5.0, Vec2d(0.0, 0.0), SpaceDebugColor(r=10.0, g=20.0, b=30.0, a=40.0))
+        draw_dot (5.0, Vec2d(0.0, 0.0), SpaceDebugColor(r=10.0, g=20.0, b=30.0, a=40.0))
+
+        """,
+    )
+
+    def _get_collision_point_color(self) -> SpaceDebugColor:
+        return self._c(self._options.collisionPointColor)
+
+    def _set_collision_point_color(self, c: SpaceDebugColor) -> None:
+        self._options.collisionPointColor = c
+
+    collision_point_color = property(
+        _get_collision_point_color,
+        _set_collision_point_color,
+        doc="""The color of collisions.
+
+        Should be a tuple of 4 ints between 0 and 255 (r,g,b,a).
+        
+        Example:
+
+        >>> import pymunk
+        >>> s = pymunk.Space()
+        >>> b = pymunk.Body(1,10)
+        >>> c1 = pymunk.Circle(b, 10)
+        >>> c2 = pymunk.Circle(s.static_body, 10)
+        >>> s.add(b, c1, c2)
+        >>> s.step(1)
+        >>> options = pymunk.SpaceDebugDrawOptions()
+        >>> s.debug_draw(options)
+        draw_circle (Vec2d(0.0, 0.0), 0.0, 10.0, SpaceDebugColor(r=44.0, g=62.0, b=80.0, a=255.0), SpaceDebugColor(r=52.0, g=152.0, b=219.0, a=255.0))
+        draw_circle (Vec2d(0.0, 0.0), 0.0, 10.0, SpaceDebugColor(r=44.0, g=62.0, b=80.0, a=255.0), SpaceDebugColor(r=149.0, g=165.0, b=166.0, a=255.0))
+        draw_segment (Vec2d(8.0, 0.0), Vec2d(-8.0, 0.0), SpaceDebugColor(r=231.0, g=76.0, b=60.0, a=255.0))
+        >>> options.collision_point_color = (10,20,30,40)
+        >>> s.debug_draw(options)
+        draw_circle (Vec2d(0.0, 0.0), 0.0, 10.0, SpaceDebugColor(r=44.0, g=62.0, b=80.0, a=255.0), SpaceDebugColor(r=52.0, g=152.0, b=219.0, a=255.0))
+        draw_circle (Vec2d(0.0, 0.0), 0.0, 10.0, SpaceDebugColor(r=44.0, g=62.0, b=80.0, a=255.0), SpaceDebugColor(r=149.0, g=165.0, b=166.0, a=255.0))
+        draw_segment (Vec2d(8.0, 0.0), Vec2d(-8.0, 0.0), SpaceDebugColor(r=10.0, g=20.0, b=30.0, a=40.0))
+        """,
+    )
+
+    def __enter__(self) -> None:
+        pass
+
+    def __exit__(
+        self,
+        type: Optional[Type[BaseException]],
+        value: Optional[BaseException],
+        traceback: Optional["TracebackType"],
+    ) -> None:
+        pass
+
+    def _c(self, color: ffi.CData) -> SpaceDebugColor:
+        return SpaceDebugColor(color.r, color.g, color.b, color.a)
+
+    def _get_flags(self) -> _DrawFlags:
+        return self._options.flags
+
+    def _set_flags(self, f: _DrawFlags) -> None:
+        self._options.flags = f
+
+    flags = property(
+        _get_flags,
+        _set_flags,
+        doc="""Bit flags which of shapes, joints and collisions should be drawn.
+
+        By default all 3 flags are set, meaning shapes, joints and collisions 
+        will be drawn.
+
+        Example using the basic text only DebugDraw implementation (normally
+        you would the desired backend instead, such as 
+        `pygame_util.DrawOptions` or `pyglet_util.DrawOptions`):
+
+        >>> import pymunk
+        >>> s = pymunk.Space()
+        >>> b = pymunk.Body()
+        >>> c = pymunk.Circle(b, 10)
+        >>> c.mass = 3
+        >>> s.add(b, c)
+        >>> s.add(pymunk.Circle(s.static_body, 3))
+        >>> s.step(0.01)
+        >>> options = pymunk.SpaceDebugDrawOptions() 
+        
+        >>> # Only draw the shapes, nothing else:
+        >>> options.flags = pymunk.SpaceDebugDrawOptions.DRAW_SHAPES
+        >>> s.debug_draw(options) 
+        draw_circle (Vec2d(0.0, 0.0), 0.0, 10.0, SpaceDebugColor(r=44.0, g=62.0, b=80.0, a=255.0), SpaceDebugColor(r=52.0, g=152.0, b=219.0, a=255.0))
+        draw_circle (Vec2d(0.0, 0.0), 0.0, 3.0, SpaceDebugColor(r=44.0, g=62.0, b=80.0, a=255.0), SpaceDebugColor(r=149.0, g=165.0, b=166.0, a=255.0))
+
+        >>> # Draw the shapes and collision points:
+        >>> options.flags = pymunk.SpaceDebugDrawOptions.DRAW_SHAPES
+        >>> options.flags |= pymunk.SpaceDebugDrawOptions.DRAW_COLLISION_POINTS
+        >>> s.debug_draw(options)
+        draw_circle (Vec2d(0.0, 0.0), 0.0, 10.0, SpaceDebugColor(r=44.0, g=62.0, b=80.0, a=255.0), SpaceDebugColor(r=52.0, g=152.0, b=219.0, a=255.0))
+        draw_circle (Vec2d(0.0, 0.0), 0.0, 3.0, SpaceDebugColor(r=44.0, g=62.0, b=80.0, a=255.0), SpaceDebugColor(r=149.0, g=165.0, b=166.0, a=255.0))
+        draw_segment (Vec2d(1.0, 0.0), Vec2d(-8.0, 0.0), SpaceDebugColor(r=231.0, g=76.0, b=60.0, a=255.0))
+        
+        """,
+    )
+
+    def _get_transform(self) -> Transform:
+        t = self._options.transform
+        return Transform(t.a, t.b, t.c, t.d, t.tx, t.ty)
+
+    def _set_transform(self, t: Transform) -> None:
+        self._options.transform = t
+
+    transform = property(
+        _get_transform,
+        _set_transform,
+        doc="""The transform is applied before drawing, e.g for scaling or 
+        translation.
+
+        Example: 
+
+        >>> import pymunk
+        >>> s = pymunk.Space()
+        >>> c = pymunk.Circle(s.static_body, 10)
+        >>> s.add(c)
+        >>> options = pymunk.SpaceDebugDrawOptions() 
+        >>> s.debug_draw(options) 
+        draw_circle (Vec2d(0.0, 0.0), 0.0, 10.0, SpaceDebugColor(r=44.0, g=62.0, b=80.0, a=255.0), SpaceDebugColor(r=149.0, g=165.0, b=166.0, a=255.0))
+        >>> options.transform = pymunk.Transform.scaling(2)
+        >>> s.debug_draw(options)
+        draw_circle (Vec2d(0.0, 0.0), 0.0, 20.0, SpaceDebugColor(r=44.0, g=62.0, b=80.0, a=255.0), SpaceDebugColor(r=149.0, g=165.0, b=166.0, a=255.0))
+        >>> options.transform = pymunk.Transform.translation(2,3)
+        >>> s.debug_draw(options)
+        draw_circle (Vec2d(2.0, 3.0), 0.0, 10.0, SpaceDebugColor(r=44.0, g=62.0, b=80.0, a=255.0), SpaceDebugColor(r=149.0, g=165.0, b=166.0, a=255.0))
+        
+        .. Note::
+            Not all tranformations are supported by the debug drawing logic. 
+            Uniform scaling and translation are supported, but not rotation,
+            linear stretching or shearing. 
+        """,
+    )
+
+    def draw_circle(
+        self,
+        pos: Vec2d,
+        angle: float,
+        radius: float,
+        outline_color: SpaceDebugColor,
+        fill_color: SpaceDebugColor,
+    ) -> None:
+        print("draw_circle", (pos, angle, radius, outline_color, fill_color))
+
+    def draw_segment(self, a: Vec2d, b: Vec2d, color: SpaceDebugColor) -> None:
+        print("draw_segment", (a, b, color))
+
+    def draw_fat_segment(
+        self,
+        a: Vec2d,
+        b: Vec2d,
+        radius: float,
+        outline_color: SpaceDebugColor,
+        fill_color: SpaceDebugColor,
+    ) -> None:
+        print("draw_fat_segment", (a, b, radius, outline_color, fill_color))
+
+    def draw_polygon(
+        self,
+        verts: Sequence[Vec2d],
+        radius: float,
+        outline_color: SpaceDebugColor,
+        fill_color: SpaceDebugColor,
+    ) -> None:
+        print("draw_polygon", (verts, radius, outline_color, fill_color))
+
+    def draw_dot(self, size: float, pos: Vec2d, color: SpaceDebugColor) -> None:
+        print("draw_dot", (size, pos, color))
+
+    def draw_shape(self, shape: "Shape") -> None:
+        print("draw_shape", shape)
+
+    def color_for_shape(self, shape: "Shape") -> SpaceDebugColor:
+        if hasattr(shape, "color"):
+            return SpaceDebugColor(*shape.color)
+
+        color = self.shape_dynamic_color
+        if shape.body != None:
+            if shape.body.body_type == Body.STATIC:
+                color = self.shape_static_color
+            elif shape.body.body_type == Body.KINEMATIC:
+                color = self.shape_kinematic_color
+            elif shape.body.is_sleeping:
+                color = self.shape_sleeping_color
+
+        return color
```

## Comparing `pymunk-6.5.0/pymunk/util.py` & `pymunk/util.py`

 * *Files identical despite different names*

## Comparing `pymunk-6.5.0/pymunk/vec2d.py` & `pymunk/vec2d.py`

 * *Files identical despite different names*

## Comparing `pymunk-6.5.0/pymunk/_callbacks.py` & `pymunk/_callbacks.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,300 +1,300 @@
-import logging
-import math
-import warnings
-
-from ._chipmunk_cffi import ffi, lib
-from .arbiter import Arbiter
-from .contact_point_set import ContactPointSet
-from .query_info import PointQueryInfo, SegmentQueryInfo, ShapeQueryInfo
-from .vec2d import Vec2d
-
-_logger = logging.getLogger(__name__)
-
-# Space query callbacks
-
-
-@ffi.def_extern()
-def ext_cpSpacePointQueryFunc(_shape, point, distance, gradient, data):  # type: ignore
-    self, query_hits = ffi.from_handle(data)
-    shape = self._get_shape(_shape)
-    p = PointQueryInfo(
-        shape, Vec2d(point.x, point.y), distance, Vec2d(gradient.x, gradient.y)
-    )
-    query_hits.append(p)
-
-
-@ffi.def_extern()
-def ext_cpSpaceSegmentQueryFunc(_shape, point, normal, alpha, data):  # type: ignore
-    self, query_hits = ffi.from_handle(data)
-    shape = self._get_shape(_shape)
-    p = SegmentQueryInfo(
-        shape, Vec2d(point.x, point.y), Vec2d(normal.x, normal.y), alpha
-    )
-    query_hits.append(p)
-
-
-@ffi.def_extern()
-def ext_cpSpaceBBQueryFunc(_shape, data):  # type: ignore
-    self, query_hits = ffi.from_handle(data)
-    shape = self._get_shape(_shape)
-    assert shape is not None
-    query_hits.append(shape)
-
-
-@ffi.def_extern()
-def ext_cpSpaceShapeQueryFunc(_shape, _points, data):  # type: ignore
-    self, query_hits = ffi.from_handle(data)
-    found_shape = self._get_shape(_shape)
-    point_set = ContactPointSet._from_cp(_points)
-    info = ShapeQueryInfo(found_shape, point_set)
-    query_hits.append(info)
-
-
-# space iterator funcs
-
-
-@ffi.def_extern()
-def ext_cpSpaceShapeIteratorFunc(cp_shape, data):  # type: ignore
-    cp_shapes = ffi.from_handle(data)
-    cp_shapes.append(cp_shape)
-
-
-@ffi.def_extern()
-def ext_cpSpaceConstraintIteratorFunc(cp_constraint, data):  # type: ignore
-    cp_constraints = ffi.from_handle(data)
-    cp_constraints.append(cp_constraint)
-
-
-@ffi.def_extern()
-def ext_cpSpaceBodyIteratorFunc(cp_body, data):  # type:ignore
-    cp_bodys = ffi.from_handle(data)
-    cp_bodys.append(cp_body)
-
-
-# debug draw callbacks
-
-
-@ffi.def_extern()
-def ext_cpSpaceDebugDrawCircleImpl(pos, angle, radius, outline_color, fill_color, data):  # type: ignore
-    options, _ = ffi.from_handle(data)
-    options.draw_circle(
-        Vec2d(pos.x, pos.y),
-        angle,
-        radius,
-        options._c(outline_color),
-        options._c(fill_color),
-    )
-
-
-@ffi.def_extern()
-def ext_cpSpaceDebugDrawSegmentImpl(a, b, color, data):  # type: ignore
-    # sometimes a and/or b can be nan. For example if both endpoints
-    # of a spring is at the same position. In those cases skip calling
-    # the drawing method.
-    if math.isnan(a.x) or math.isnan(a.y) or math.isnan(b.x) or math.isnan(b.y):
-        return
-    options, _ = ffi.from_handle(data)
-    options.draw_segment(
-        Vec2d(a.x, a.y),
-        Vec2d(b.x, b.y),
-        options._c(color),
-    )
-
-
-@ffi.def_extern()
-def ext_cpSpaceDebugDrawFatSegmentImpl(a, b, radius, outline_color, fill_color, data):  # type: ignore
-    options, _ = ffi.from_handle(data)
-    options.draw_fat_segment(
-        Vec2d(a.x, a.y),
-        Vec2d(b.x, b.y),
-        radius,
-        options._c(outline_color),
-        options._c(fill_color),
-    )
-
-
-@ffi.def_extern()
-def ext_cpSpaceDebugDrawPolygonImpl(count, verts, radius, outline_color, fill_color, data):  # type: ignore
-    options, _ = ffi.from_handle(data)
-    vs = []
-    for i in range(count):
-        vs.append(Vec2d(verts[i].x, verts[i].y))
-    options.draw_polygon(vs, radius, options._c(outline_color), options._c(fill_color))
-
-
-@ffi.def_extern()
-def ext_cpSpaceDebugDrawDotImpl(size, pos, color, data):  # type: ignore
-    options, _ = ffi.from_handle(data)
-    options.draw_dot(size, Vec2d(pos.x, pos.y), options._c(color))
-
-
-@ffi.def_extern()
-def ext_cpSpaceDebugDrawColorForShapeImpl(_shape, data):  # type: ignore
-    options, space = ffi.from_handle(data)
-    shape = space._get_shape(_shape)
-    return options.color_for_shape(shape)
-
-
-# autogeometry.py
-
-
-@ffi.def_extern()
-def ext_cpMarchSegmentFunc(v0: ffi.CData, v1: ffi.CData, data: ffi.CData) -> None:
-    pl_set = ffi.from_handle(data)
-    pl_set.collect_segment((v0.x, v0.y), (v1.x, v1.y))
-
-
-@ffi.def_extern()
-def ext_cpMarchSampleFunc(point: ffi.CData, data: ffi.CData) -> float:
-    # print("SAMPLE", point.x, point.y)
-    sample_func = ffi.from_handle(data)
-    return sample_func((point.x, point.y))
-
-
-# collision_handler.py
-
-
-@ffi.def_extern()
-def ext_cpCollisionBeginFunc(
-    _arb: ffi.CData, _space: ffi.CData, data: ffi.CData
-) -> bool:
-    handler = ffi.from_handle(data)
-    x = handler._begin(Arbiter(_arb, handler._space), handler._space, handler.data)
-    if isinstance(x, bool):
-        return x
-
-    func_name = handler._begin.__code__.co_name
-    filename = handler._begin.__code__.co_filename
-    lineno = handler._begin.__code__.co_firstlineno
-
-    warnings.warn_explicit(
-        "Function '" + func_name + "' should return a bool to"
-        " indicate if the collision should be processed or not when"
-        " used as 'begin' or 'pre_solve' collision callback.",
-        UserWarning,
-        filename,
-        lineno,
-        handler._begin.__module__,
-    )
-    return True
-
-
-@ffi.def_extern()
-def ext_cpCollisionPreSolveFunc(
-    _arb: ffi.CData, _space: ffi.CData, data: ffi.CData
-) -> bool:
-    handler = ffi.from_handle(data)
-    x = handler._pre_solve(Arbiter(_arb, handler._space), handler._space, handler.data)
-    if isinstance(x, bool):
-        return x
-
-    func_name = handler._pre_solve.__code__.co_name
-    filename = handler._pre_solve.__code__.co_filename
-    lineno = handler._pre_solve.__code__.co_firstlineno
-
-    warnings.warn_explicit(
-        "Function '" + func_name + "' should return a bool to"
-        " indicate if the collision should be processed or not when"
-        " used as 'begin' or 'pre_solve' collision callback.",
-        UserWarning,
-        filename,
-        lineno,
-        handler._pre_solve.__module__,
-    )
-    return True
-
-
-@ffi.def_extern()
-def ext_cpCollisionPostSolveFunc(
-    _arb: ffi.CData, _space: ffi.CData, data: ffi.CData
-) -> None:
-    handler = ffi.from_handle(data)
-    handler._post_solve(Arbiter(_arb, handler._space), handler._space, handler.data)
-
-
-@ffi.def_extern()
-def ext_cpCollisionSeparateFunc(
-    _arb: ffi.CData, _space: ffi.CData, data: ffi.CData
-) -> None:
-    handler = ffi.from_handle(data)
-    try:
-        # this try is needed since a separate callback will be called
-        # if a colliding object is removed, regardless if its in a
-        # step or not.
-        handler._space._locked = True
-        handler._separate(Arbiter(_arb, handler._space), handler._space, handler.data)
-    finally:
-        handler._space._locked = False
-
-
-# body.py
-@ffi.def_extern()
-def ext_cpBodyPositionFunc(_body: ffi.CData, dt: float) -> None:
-    body = ffi.from_handle(lib.cpBodyGetUserData(_body))
-    body._position_func(body, dt)
-
-
-@ffi.def_extern()
-def ext_cpBodyVelocityFunc(
-    _body: ffi.CData, gravity: ffi.CData, damping: float, dt: float
-) -> None:
-    body = ffi.from_handle(lib.cpBodyGetUserData(_body))
-    body._velocity_func(body, Vec2d(gravity.x, gravity.y), damping, dt)
-
-
-@ffi.def_extern()
-def ext_cpBodyArbiterIteratorFunc(
-    _body: ffi.CData, _arbiter: ffi.CData, data: ffi.CData
-) -> None:
-    body, func, args, kwargs = ffi.from_handle(data)
-    assert body._space is not None
-    arbiter = Arbiter(_arbiter, body._space)
-    func(arbiter, *args, **kwargs)
-
-
-@ffi.def_extern()
-def ext_cpBodyConstraintIteratorFunc(
-    cp_body: ffi.CData, cp_constraint: ffi.CData, _: ffi.CData
-) -> None:
-    _logger.debug("bodyfree remove constraint %s %s", cp_body, cp_constraint)
-    cp_space = lib.cpConstraintGetSpace(cp_constraint)
-    if cp_space != ffi.NULL:
-        lib.cpSpaceRemoveConstraint(cp_space, cp_constraint)
-
-
-@ffi.def_extern()
-def ext_cpBodyShapeIteratorFunc(
-    cp_body: ffi.CData, cp_shape: ffi.CData, _: ffi.CData
-) -> None:
-    _logger.debug("bodyfree remove shape %s %s", cp_body, cp_shape)
-    cp_space = lib.cpShapeGetSpace(cp_shape)
-    if cp_space != ffi.NULL:
-        lib.cpSpaceRemoveShape(cp_space, cp_shape)
-    lib.cpShapeSetBody(cp_shape, ffi.NULL)
-
-
-# constraint.py
-
-
-@ffi.def_extern()
-def ext_cpConstraintPreSolveFunc(cp_constraint: ffi.CData, cp_space: ffi.CData) -> None:
-    constraint = ffi.from_handle(lib.cpConstraintGetUserData(cp_constraint))
-    assert constraint.a.space is not None
-    constraint._pre_solve_func(constraint, constraint.a.space)
-
-
-@ffi.def_extern()
-def ext_cpConstraintPostSolveFunc(
-    cp_constraint: ffi.CData, cp_space: ffi.CData
-) -> None:
-    constraint = ffi.from_handle(lib.cpConstraintGetUserData(cp_constraint))
-    assert constraint.a.space is not None
-    constraint._post_solve_func(constraint, constraint.a.space)
-
-
-
-# Pickle of Arbiters
-@ffi.def_extern()
-def ext_cpArbiterIteratorFunc(_arbiter, data):  # type: ignore
-    arbiters = ffi.from_handle(data)
+import logging
+import math
+import warnings
+
+from ._chipmunk_cffi import ffi, lib
+from .arbiter import Arbiter
+from .contact_point_set import ContactPointSet
+from .query_info import PointQueryInfo, SegmentQueryInfo, ShapeQueryInfo
+from .vec2d import Vec2d
+
+_logger = logging.getLogger(__name__)
+
+# Space query callbacks
+
+
+@ffi.def_extern()
+def ext_cpSpacePointQueryFunc(_shape, point, distance, gradient, data):  # type: ignore
+    self, query_hits = ffi.from_handle(data)
+    shape = self._get_shape(_shape)
+    p = PointQueryInfo(
+        shape, Vec2d(point.x, point.y), distance, Vec2d(gradient.x, gradient.y)
+    )
+    query_hits.append(p)
+
+
+@ffi.def_extern()
+def ext_cpSpaceSegmentQueryFunc(_shape, point, normal, alpha, data):  # type: ignore
+    self, query_hits = ffi.from_handle(data)
+    shape = self._get_shape(_shape)
+    p = SegmentQueryInfo(
+        shape, Vec2d(point.x, point.y), Vec2d(normal.x, normal.y), alpha
+    )
+    query_hits.append(p)
+
+
+@ffi.def_extern()
+def ext_cpSpaceBBQueryFunc(_shape, data):  # type: ignore
+    self, query_hits = ffi.from_handle(data)
+    shape = self._get_shape(_shape)
+    assert shape is not None
+    query_hits.append(shape)
+
+
+@ffi.def_extern()
+def ext_cpSpaceShapeQueryFunc(_shape, _points, data):  # type: ignore
+    self, query_hits = ffi.from_handle(data)
+    found_shape = self._get_shape(_shape)
+    point_set = ContactPointSet._from_cp(_points)
+    info = ShapeQueryInfo(found_shape, point_set)
+    query_hits.append(info)
+
+
+# space iterator funcs
+
+
+@ffi.def_extern()
+def ext_cpSpaceShapeIteratorFunc(cp_shape, data):  # type: ignore
+    cp_shapes = ffi.from_handle(data)
+    cp_shapes.append(cp_shape)
+
+
+@ffi.def_extern()
+def ext_cpSpaceConstraintIteratorFunc(cp_constraint, data):  # type: ignore
+    cp_constraints = ffi.from_handle(data)
+    cp_constraints.append(cp_constraint)
+
+
+@ffi.def_extern()
+def ext_cpSpaceBodyIteratorFunc(cp_body, data):  # type:ignore
+    cp_bodys = ffi.from_handle(data)
+    cp_bodys.append(cp_body)
+
+
+# debug draw callbacks
+
+
+@ffi.def_extern()
+def ext_cpSpaceDebugDrawCircleImpl(pos, angle, radius, outline_color, fill_color, data):  # type: ignore
+    options, _ = ffi.from_handle(data)
+    options.draw_circle(
+        Vec2d(pos.x, pos.y),
+        angle,
+        radius,
+        options._c(outline_color),
+        options._c(fill_color),
+    )
+
+
+@ffi.def_extern()
+def ext_cpSpaceDebugDrawSegmentImpl(a, b, color, data):  # type: ignore
+    # sometimes a and/or b can be nan. For example if both endpoints
+    # of a spring is at the same position. In those cases skip calling
+    # the drawing method.
+    if math.isnan(a.x) or math.isnan(a.y) or math.isnan(b.x) or math.isnan(b.y):
+        return
+    options, _ = ffi.from_handle(data)
+    options.draw_segment(
+        Vec2d(a.x, a.y),
+        Vec2d(b.x, b.y),
+        options._c(color),
+    )
+
+
+@ffi.def_extern()
+def ext_cpSpaceDebugDrawFatSegmentImpl(a, b, radius, outline_color, fill_color, data):  # type: ignore
+    options, _ = ffi.from_handle(data)
+    options.draw_fat_segment(
+        Vec2d(a.x, a.y),
+        Vec2d(b.x, b.y),
+        radius,
+        options._c(outline_color),
+        options._c(fill_color),
+    )
+
+
+@ffi.def_extern()
+def ext_cpSpaceDebugDrawPolygonImpl(count, verts, radius, outline_color, fill_color, data):  # type: ignore
+    options, _ = ffi.from_handle(data)
+    vs = []
+    for i in range(count):
+        vs.append(Vec2d(verts[i].x, verts[i].y))
+    options.draw_polygon(vs, radius, options._c(outline_color), options._c(fill_color))
+
+
+@ffi.def_extern()
+def ext_cpSpaceDebugDrawDotImpl(size, pos, color, data):  # type: ignore
+    options, _ = ffi.from_handle(data)
+    options.draw_dot(size, Vec2d(pos.x, pos.y), options._c(color))
+
+
+@ffi.def_extern()
+def ext_cpSpaceDebugDrawColorForShapeImpl(_shape, data):  # type: ignore
+    options, space = ffi.from_handle(data)
+    shape = space._get_shape(_shape)
+    return options.color_for_shape(shape)
+
+
+# autogeometry.py
+
+
+@ffi.def_extern()
+def ext_cpMarchSegmentFunc(v0: ffi.CData, v1: ffi.CData, data: ffi.CData) -> None:
+    pl_set = ffi.from_handle(data)
+    pl_set.collect_segment((v0.x, v0.y), (v1.x, v1.y))
+
+
+@ffi.def_extern()
+def ext_cpMarchSampleFunc(point: ffi.CData, data: ffi.CData) -> float:
+    # print("SAMPLE", point.x, point.y)
+    sample_func = ffi.from_handle(data)
+    return sample_func((point.x, point.y))
+
+
+# collision_handler.py
+
+
+@ffi.def_extern()
+def ext_cpCollisionBeginFunc(
+    _arb: ffi.CData, _space: ffi.CData, data: ffi.CData
+) -> bool:
+    handler = ffi.from_handle(data)
+    x = handler._begin(Arbiter(_arb, handler._space), handler._space, handler.data)
+    if isinstance(x, bool):
+        return x
+
+    func_name = handler._begin.__code__.co_name
+    filename = handler._begin.__code__.co_filename
+    lineno = handler._begin.__code__.co_firstlineno
+
+    warnings.warn_explicit(
+        "Function '" + func_name + "' should return a bool to"
+        " indicate if the collision should be processed or not when"
+        " used as 'begin' or 'pre_solve' collision callback.",
+        UserWarning,
+        filename,
+        lineno,
+        handler._begin.__module__,
+    )
+    return True
+
+
+@ffi.def_extern()
+def ext_cpCollisionPreSolveFunc(
+    _arb: ffi.CData, _space: ffi.CData, data: ffi.CData
+) -> bool:
+    handler = ffi.from_handle(data)
+    x = handler._pre_solve(Arbiter(_arb, handler._space), handler._space, handler.data)
+    if isinstance(x, bool):
+        return x
+
+    func_name = handler._pre_solve.__code__.co_name
+    filename = handler._pre_solve.__code__.co_filename
+    lineno = handler._pre_solve.__code__.co_firstlineno
+
+    warnings.warn_explicit(
+        "Function '" + func_name + "' should return a bool to"
+        " indicate if the collision should be processed or not when"
+        " used as 'begin' or 'pre_solve' collision callback.",
+        UserWarning,
+        filename,
+        lineno,
+        handler._pre_solve.__module__,
+    )
+    return True
+
+
+@ffi.def_extern()
+def ext_cpCollisionPostSolveFunc(
+    _arb: ffi.CData, _space: ffi.CData, data: ffi.CData
+) -> None:
+    handler = ffi.from_handle(data)
+    handler._post_solve(Arbiter(_arb, handler._space), handler._space, handler.data)
+
+
+@ffi.def_extern()
+def ext_cpCollisionSeparateFunc(
+    _arb: ffi.CData, _space: ffi.CData, data: ffi.CData
+) -> None:
+    handler = ffi.from_handle(data)
+    try:
+        # this try is needed since a separate callback will be called
+        # if a colliding object is removed, regardless if its in a
+        # step or not.
+        handler._space._locked = True
+        handler._separate(Arbiter(_arb, handler._space), handler._space, handler.data)
+    finally:
+        handler._space._locked = False
+
+
+# body.py
+@ffi.def_extern()
+def ext_cpBodyPositionFunc(_body: ffi.CData, dt: float) -> None:
+    body = ffi.from_handle(lib.cpBodyGetUserData(_body))
+    body._position_func(body, dt)
+
+
+@ffi.def_extern()
+def ext_cpBodyVelocityFunc(
+    _body: ffi.CData, gravity: ffi.CData, damping: float, dt: float
+) -> None:
+    body = ffi.from_handle(lib.cpBodyGetUserData(_body))
+    body._velocity_func(body, Vec2d(gravity.x, gravity.y), damping, dt)
+
+
+@ffi.def_extern()
+def ext_cpBodyArbiterIteratorFunc(
+    _body: ffi.CData, _arbiter: ffi.CData, data: ffi.CData
+) -> None:
+    body, func, args, kwargs = ffi.from_handle(data)
+    assert body._space is not None
+    arbiter = Arbiter(_arbiter, body._space)
+    func(arbiter, *args, **kwargs)
+
+
+@ffi.def_extern()
+def ext_cpBodyConstraintIteratorFunc(
+    cp_body: ffi.CData, cp_constraint: ffi.CData, _: ffi.CData
+) -> None:
+    _logger.debug("bodyfree remove constraint %s %s", cp_body, cp_constraint)
+    cp_space = lib.cpConstraintGetSpace(cp_constraint)
+    if cp_space != ffi.NULL:
+        lib.cpSpaceRemoveConstraint(cp_space, cp_constraint)
+
+
+@ffi.def_extern()
+def ext_cpBodyShapeIteratorFunc(
+    cp_body: ffi.CData, cp_shape: ffi.CData, _: ffi.CData
+) -> None:
+    _logger.debug("bodyfree remove shape %s %s", cp_body, cp_shape)
+    cp_space = lib.cpShapeGetSpace(cp_shape)
+    if cp_space != ffi.NULL:
+        lib.cpSpaceRemoveShape(cp_space, cp_shape)
+    lib.cpShapeSetBody(cp_shape, ffi.NULL)
+
+
+# constraint.py
+
+
+@ffi.def_extern()
+def ext_cpConstraintPreSolveFunc(cp_constraint: ffi.CData, cp_space: ffi.CData) -> None:
+    constraint = ffi.from_handle(lib.cpConstraintGetUserData(cp_constraint))
+    assert constraint.a.space is not None
+    constraint._pre_solve_func(constraint, constraint.a.space)
+
+
+@ffi.def_extern()
+def ext_cpConstraintPostSolveFunc(
+    cp_constraint: ffi.CData, cp_space: ffi.CData
+) -> None:
+    constraint = ffi.from_handle(lib.cpConstraintGetUserData(cp_constraint))
+    assert constraint.a.space is not None
+    constraint._post_solve_func(constraint, constraint.a.space)
+
+
+
+# Pickle of Arbiters
+@ffi.def_extern()
+def ext_cpArbiterIteratorFunc(_arbiter, data):  # type: ignore
+    arbiters = ffi.from_handle(data)
     arbiters.append(_arbiter)
```

## Comparing `pymunk-6.5.0/pymunk/_pyglet15_util.py` & `pymunk/_pyglet15_util.py`

 * *Ordering differences only*

 * *Files 11% similar despite different names*

```diff
@@ -1,202 +1,202 @@
-# ----------------------------------------------------------------------------
-# pymunk
-# Copyright (c) 2007-2016 Victor Blomqvist
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice shall be included in
-# all copies or substantial portions of the Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-# ----------------------------------------------------------------------------
-
-"""This submodule contains helper functions to help with quick prototyping 
-using pymunk together with pyglet.
-
-Intended to help with debugging and prototyping, not for actual production use
-in a full application. The methods contained in this module is opinionated 
-about your coordinate system and not very optimized (they use batched 
-drawing, but there is probably room for optimizations still). 
-"""
-
-__docformat__ = "reStructuredText"
-
-import math
-import warnings
-from typing import TYPE_CHECKING, Any, List, Optional, Sequence, Type
-
-import pyglet  # type: ignore
-
-import pymunk
-from pymunk.space_debug_draw_options import SpaceDebugColor
-from pymunk.vec2d import Vec2d
-
-if TYPE_CHECKING:
-    from types import TracebackType
-
-warnings.simplefilter("always", DeprecationWarning)
-warnings.warn(
-    "Use of pyglet < 2 is deprecated. Please upgrade.",
-    category=DeprecationWarning,
-    stacklevel=3,
-)
-warnings.simplefilter("default", DeprecationWarning)
-
-
-class DrawOptions(pymunk.SpaceDebugDrawOptions):
-    def __init__(self, **kwargs: Any) -> None:
-        """Draw a pymunk.Space.
-
-        Typical usage::
-
-        >>> import pymunk
-        >>> import pymunk.pygame_util
-        >>> s = pymunk.Space()
-        >>> options = pymunk.pyglet_util.DrawOptions()
-        >>> s.debug_draw(options)
-
-        You can control the color of a Shape by setting shape.color to the color
-        you want it drawn in.
-
-        >>> c = pymunk.Circle(None, 10)
-        >>> c.color = (255, 0, 0, 255) # will draw my_shape in red
-
-        You can optionally pass in a batch to use for drawing. Just
-        remember that you need to call draw yourself.
-
-        >>> my_batch = pyglet.graphics.Batch()
-        >>> s = pymunk.Space()
-        >>> options = pymunk.pyglet_util.DrawOptions(batch=my_batch)
-        >>> s.debug_draw(options)
-        >>> my_batch.draw()
-
-        See pyglet_util.demo.py for a full example
-
-        :Param:
-                kwargs : You can optionally pass in a pyglet.graphics.Batch
-                    If a batch is given all drawing will use this batch to draw
-                    on. If no batch is given a a new batch will be used for the
-                    drawing. Remember that if you pass in your own batch you
-                    need to call draw on it yourself.
-
-        """
-        self.new_batch = False
-        self.draw_shapes: List[Any] = []
-
-        if "batch" not in kwargs:
-            self.new_batch = True
-        else:
-            self.batch = kwargs["batch"]
-
-        super(DrawOptions, self).__init__()
-
-    def __enter__(self) -> None:
-        self.draw_shapes = []
-        if self.new_batch:
-            self.batch = pyglet.graphics.Batch()
-
-    def __exit__(
-        self,
-        type: Optional[Type[BaseException]],
-        value: Optional[BaseException],
-        traceback: Optional["TracebackType"],
-    ) -> None:
-        if self.new_batch:
-            self.batch.draw()
-
-    def draw_circle(
-        self,
-        pos: Vec2d,
-        angle: float,
-        radius: float,
-        outline_color: SpaceDebugColor,
-        fill_color: SpaceDebugColor,
-    ) -> None:
-
-        bg = pyglet.graphics.OrderedGroup(0)
-        fg = pyglet.graphics.OrderedGroup(1)
-
-        color = fill_color.as_int()
-        c = pyglet.shapes.Circle(
-            pos.x, pos.y, radius, color=color[:3], batch=self.batch, group=bg
-        )
-        c.opacity = color[3]
-        self.draw_shapes.append(c)
-        cc = pos + Vec2d(radius, 0).rotated(angle)
-        c = outline_color.as_int()
-        l = pyglet.shapes.Line(
-            pos.x, pos.y, cc.x, cc.y, width=1, color=c[:3], batch=self.batch, group=fg
-        )
-        self.draw_shapes.append(l)
-
-    def draw_segment(self, a: Vec2d, b: Vec2d, color: SpaceDebugColor) -> None:
-        c = color.as_int()
-        l = pyglet.shapes.Line(
-            a.x, a.y, b.x, b.y, width=1, color=c[:3], batch=self.batch
-        )
-        self.draw_shapes.append(l)
-
-    def draw_fat_segment(
-        self,
-        a: Vec2d,
-        b: Vec2d,
-        radius: float,
-        outline_color: SpaceDebugColor,
-        fill_color: SpaceDebugColor,
-    ) -> None:
-
-        c = fill_color.as_int()
-        pv1 = a
-        pv2 = b
-        d = pv2 - pv1
-        atan = -math.atan2(d.x, d.y)
-        radius = max(radius, 1)
-        dx = radius * math.cos(atan)
-        dy = radius * math.sin(atan)
-
-        p1 = pv1 + Vec2d(dx, dy)
-        p2 = pv1 - Vec2d(dx, dy)
-        p3 = pv2 - Vec2d(dx, dy)
-        p4 = pv2 + Vec2d(dx, dy)
-
-        s = pyglet.shapes.Polygon(p1, p2, p3, p4, color=c[:3], batch=self.batch)
-        self.draw_shapes.append(s)
-
-        self.draw_circle(a, 0, radius, fill_color, fill_color)
-        self.draw_circle(b, 0, radius, fill_color, fill_color)
-
-    def draw_polygon(
-        self,
-        verts: Sequence[Vec2d],
-        radius: float,
-        outline_color: SpaceDebugColor,
-        fill_color: SpaceDebugColor,
-    ) -> None:
-
-        c = fill_color.as_int()
-        s = pyglet.shapes.Polygon(*verts, color=c[:3], batch=self.batch)
-        self.draw_shapes.append(s)
-
-        if radius > 0:
-            for i in range(len(verts)):
-                a = verts[i]
-                b = verts[(i + 1) % len(verts)]
-                self.draw_fat_segment(a, b, radius, outline_color, outline_color)
-
-    def draw_dot(self, size: float, pos: Vec2d, color: SpaceDebugColor) -> None:
-        # todo: optimize this functions
-        c = color.as_int()
-        s = pyglet.shapes.Circle(pos.x, pos.y, size, color=c[:3], batch=self.batch)
-        s.opacity = c[3]
-        self.draw_shapes.append(s)
+# ----------------------------------------------------------------------------
+# pymunk
+# Copyright (c) 2007-2016 Victor Blomqvist
+#
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+#
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+# SOFTWARE.
+# ----------------------------------------------------------------------------
+
+"""This submodule contains helper functions to help with quick prototyping 
+using pymunk together with pyglet.
+
+Intended to help with debugging and prototyping, not for actual production use
+in a full application. The methods contained in this module is opinionated 
+about your coordinate system and not very optimized (they use batched 
+drawing, but there is probably room for optimizations still). 
+"""
+
+__docformat__ = "reStructuredText"
+
+import math
+import warnings
+from typing import TYPE_CHECKING, Any, List, Optional, Sequence, Type
+
+import pyglet  # type: ignore
+
+import pymunk
+from pymunk.space_debug_draw_options import SpaceDebugColor
+from pymunk.vec2d import Vec2d
+
+if TYPE_CHECKING:
+    from types import TracebackType
+
+warnings.simplefilter("always", DeprecationWarning)
+warnings.warn(
+    "Use of pyglet < 2 is deprecated. Please upgrade.",
+    category=DeprecationWarning,
+    stacklevel=3,
+)
+warnings.simplefilter("default", DeprecationWarning)
+
+
+class DrawOptions(pymunk.SpaceDebugDrawOptions):
+    def __init__(self, **kwargs: Any) -> None:
+        """Draw a pymunk.Space.
+
+        Typical usage::
+
+        >>> import pymunk
+        >>> import pymunk.pygame_util
+        >>> s = pymunk.Space()
+        >>> options = pymunk.pyglet_util.DrawOptions()
+        >>> s.debug_draw(options)
+
+        You can control the color of a Shape by setting shape.color to the color
+        you want it drawn in.
+
+        >>> c = pymunk.Circle(None, 10)
+        >>> c.color = (255, 0, 0, 255) # will draw my_shape in red
+
+        You can optionally pass in a batch to use for drawing. Just
+        remember that you need to call draw yourself.
+
+        >>> my_batch = pyglet.graphics.Batch()
+        >>> s = pymunk.Space()
+        >>> options = pymunk.pyglet_util.DrawOptions(batch=my_batch)
+        >>> s.debug_draw(options)
+        >>> my_batch.draw()
+
+        See pyglet_util.demo.py for a full example
+
+        :Param:
+                kwargs : You can optionally pass in a pyglet.graphics.Batch
+                    If a batch is given all drawing will use this batch to draw
+                    on. If no batch is given a a new batch will be used for the
+                    drawing. Remember that if you pass in your own batch you
+                    need to call draw on it yourself.
+
+        """
+        self.new_batch = False
+        self.draw_shapes: List[Any] = []
+
+        if "batch" not in kwargs:
+            self.new_batch = True
+        else:
+            self.batch = kwargs["batch"]
+
+        super(DrawOptions, self).__init__()
+
+    def __enter__(self) -> None:
+        self.draw_shapes = []
+        if self.new_batch:
+            self.batch = pyglet.graphics.Batch()
+
+    def __exit__(
+        self,
+        type: Optional[Type[BaseException]],
+        value: Optional[BaseException],
+        traceback: Optional["TracebackType"],
+    ) -> None:
+        if self.new_batch:
+            self.batch.draw()
+
+    def draw_circle(
+        self,
+        pos: Vec2d,
+        angle: float,
+        radius: float,
+        outline_color: SpaceDebugColor,
+        fill_color: SpaceDebugColor,
+    ) -> None:
+
+        bg = pyglet.graphics.OrderedGroup(0)
+        fg = pyglet.graphics.OrderedGroup(1)
+
+        color = fill_color.as_int()
+        c = pyglet.shapes.Circle(
+            pos.x, pos.y, radius, color=color[:3], batch=self.batch, group=bg
+        )
+        c.opacity = color[3]
+        self.draw_shapes.append(c)
+        cc = pos + Vec2d(radius, 0).rotated(angle)
+        c = outline_color.as_int()
+        l = pyglet.shapes.Line(
+            pos.x, pos.y, cc.x, cc.y, width=1, color=c[:3], batch=self.batch, group=fg
+        )
+        self.draw_shapes.append(l)
+
+    def draw_segment(self, a: Vec2d, b: Vec2d, color: SpaceDebugColor) -> None:
+        c = color.as_int()
+        l = pyglet.shapes.Line(
+            a.x, a.y, b.x, b.y, width=1, color=c[:3], batch=self.batch
+        )
+        self.draw_shapes.append(l)
+
+    def draw_fat_segment(
+        self,
+        a: Vec2d,
+        b: Vec2d,
+        radius: float,
+        outline_color: SpaceDebugColor,
+        fill_color: SpaceDebugColor,
+    ) -> None:
+
+        c = fill_color.as_int()
+        pv1 = a
+        pv2 = b
+        d = pv2 - pv1
+        atan = -math.atan2(d.x, d.y)
+        radius = max(radius, 1)
+        dx = radius * math.cos(atan)
+        dy = radius * math.sin(atan)
+
+        p1 = pv1 + Vec2d(dx, dy)
+        p2 = pv1 - Vec2d(dx, dy)
+        p3 = pv2 - Vec2d(dx, dy)
+        p4 = pv2 + Vec2d(dx, dy)
+
+        s = pyglet.shapes.Polygon(p1, p2, p3, p4, color=c[:3], batch=self.batch)
+        self.draw_shapes.append(s)
+
+        self.draw_circle(a, 0, radius, fill_color, fill_color)
+        self.draw_circle(b, 0, radius, fill_color, fill_color)
+
+    def draw_polygon(
+        self,
+        verts: Sequence[Vec2d],
+        radius: float,
+        outline_color: SpaceDebugColor,
+        fill_color: SpaceDebugColor,
+    ) -> None:
+
+        c = fill_color.as_int()
+        s = pyglet.shapes.Polygon(*verts, color=c[:3], batch=self.batch)
+        self.draw_shapes.append(s)
+
+        if radius > 0:
+            for i in range(len(verts)):
+                a = verts[i]
+                b = verts[(i + 1) % len(verts)]
+                self.draw_fat_segment(a, b, radius, outline_color, outline_color)
+
+    def draw_dot(self, size: float, pos: Vec2d, color: SpaceDebugColor) -> None:
+        # todo: optimize this functions
+        c = color.as_int()
+        s = pyglet.shapes.Circle(pos.x, pos.y, size, color=c[:3], batch=self.batch)
+        s.opacity = c[3]
+        self.draw_shapes.append(s)
```

## Comparing `pymunk-6.5.0/pymunk/__init__.py` & `pymunk/__init__.py`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,192 +1,192 @@
-# ----------------------------------------------------------------------------
-# pymunk
-# Copyright (c) 2007-2023 Victor Blomqvist
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice shall be included in
-# all copies or substantial portions of the Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-# ----------------------------------------------------------------------------
-
-"""
-Pymunk is a easy-to-use pythonic 2d physics library that can be used whenever
-you need 2d rigid body physics from Python.
-
-Homepage: http://www.pymunk.org
-
-This is the main containing module of Pymunk. It contains among other things
-the very central Space, Body and Shape classes.
-
-"""
-
-__docformat__ = "reStructuredText"
-
-
-__all__ = [
-    "version",
-    "chipmunk_version",
-    "Space",
-    "Body",
-    "Shape",
-    "Circle",
-    "Poly",
-    "Segment",
-    "moment_for_circle",
-    "moment_for_poly",
-    "moment_for_segment",
-    "moment_for_box",
-    "SegmentQueryInfo",
-    "ContactPoint",
-    "ContactPointSet",
-    "Arbiter",
-    "CollisionHandler",
-    "BB",
-    "ShapeFilter",
-    "Transform",
-    "PointQueryInfo",
-    "ShapeQueryInfo",
-    "SpaceDebugDrawOptions",
-    "Vec2d",
-]
-
-from typing import Sequence, Tuple, cast
-
-from . import _chipmunk_cffi
-
-cp = _chipmunk_cffi.lib
-ffi = _chipmunk_cffi.ffi
-
-import logging
-
-logging.getLogger(__name__).addHandler(logging.NullHandler())
-# logging.basicConfig(level=0)
-
-from . import _version
-from .arbiter import Arbiter
-from .bb import BB
-from .body import Body
-from .collision_handler import CollisionHandler
-from .constraints import *
-from .contact_point_set import ContactPoint, ContactPointSet
-from .query_info import PointQueryInfo, SegmentQueryInfo, ShapeQueryInfo
-from .shape_filter import ShapeFilter
-from .shapes import Circle, Poly, Segment, Shape
-from .space import Space
-from .space_debug_draw_options import SpaceDebugDrawOptions
-from .transform import Transform
-from .vec2d import Vec2d
-
-version: str = _version.version
-"""The release version of this pymunk installation.
-Valid only if pymunk was installed from a source or binary
-distribution (i.e. not in a checked-out copy from git).
-"""
-
-chipmunk_version: str = _version.chipmunk_version
-"""The Chipmunk version used with this Pymunk version.
-
-This property does not show a valid value in the compiled documentation, only
-when you actually import pymunk and do pymunk.chipmunk_version
-
-The string is in the following format:
-<cpVersionString>R<github commit of chipmunk>
-where cpVersionString is a version string set by Chipmunk and the git commit
-hash corresponds to the git hash of the chipmunk source from
-github.com/viblo/Chipmunk2D included with Pymunk.
-"""
-
-
-def moment_for_circle(
-    mass: float,
-    inner_radius: float,
-    outer_radius: float,
-    offset: Tuple[float, float] = (0, 0),
-) -> float:
-    """Calculate the moment of inertia for a hollow circle
-
-    (A solid circle has an inner radius of 0)
-    """
-    assert len(offset) == 2
-
-    return cp.cpMomentForCircle(mass, inner_radius, outer_radius, offset)
-
-
-def moment_for_segment(
-    mass: float, a: Tuple[float, float], b: Tuple[float, float], radius: float
-) -> float:
-    """Calculate the moment of inertia for a line segment
-
-    The endpoints a and b are relative to the body
-    """
-    assert len(a) == 2
-    assert len(b) == 2
-
-    return cp.cpMomentForSegment(mass, a, b, radius)
-
-
-def moment_for_box(mass: float, size: Tuple[float, float]) -> float:
-    """Calculate the moment of inertia for a solid box centered on the body.
-
-    size should be a tuple of (width, height)
-    """
-    assert len(size) == 2
-    return cp.cpMomentForBox(mass, size[0], size[1])
-
-
-def moment_for_poly(
-    mass: float,
-    vertices: Sequence[Tuple[float, float]],
-    offset: Tuple[float, float] = (0, 0),
-    radius: float = 0,
-) -> float:
-    """Calculate the moment of inertia for a solid polygon shape.
-
-    Assumes the polygon center of gravity is at its centroid. The offset is
-    added to each vertex.
-    """
-    assert len(offset) == 2
-    vs = list(vertices)
-    return cp.cpMomentForPoly(mass, len(vs), vs, offset, radius)
-
-
-def area_for_circle(inner_radius: float, outer_radius: float) -> float:
-    """Area of a hollow circle."""
-    return cast(float, cp.cpAreaForCircle(inner_radius, outer_radius))
-
-
-def area_for_segment(
-    a: Tuple[float, float], b: Tuple[float, float], radius: float
-) -> float:
-    """Area of a beveled segment.
-
-    (Will always be zero if radius is zero)
-    """
-    assert len(a) == 2
-    assert len(b) == 2
-
-    return cp.cpAreaForSegment(a, b, radius)
-
-
-def area_for_poly(vertices: Sequence[Tuple[float, float]], radius: float = 0) -> float:
-    """Signed area of a polygon shape.
-
-    Returns a negative number for polygons with a clockwise winding.
-    """
-    vs = list(vertices)
-    return cp.cpAreaForPoly(len(vs), vs, radius)
-
-
-# del cp, ct, u
+# ----------------------------------------------------------------------------
+# pymunk
+# Copyright (c) 2007-2023 Victor Blomqvist
+#
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+#
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+# SOFTWARE.
+# ----------------------------------------------------------------------------
+
+"""
+Pymunk is a easy-to-use pythonic 2d physics library that can be used whenever
+you need 2d rigid body physics from Python.
+
+Homepage: http://www.pymunk.org
+
+This is the main containing module of Pymunk. It contains among other things
+the very central Space, Body and Shape classes.
+
+"""
+
+__docformat__ = "reStructuredText"
+
+
+__all__ = [
+    "version",
+    "chipmunk_version",
+    "Space",
+    "Body",
+    "Shape",
+    "Circle",
+    "Poly",
+    "Segment",
+    "moment_for_circle",
+    "moment_for_poly",
+    "moment_for_segment",
+    "moment_for_box",
+    "SegmentQueryInfo",
+    "ContactPoint",
+    "ContactPointSet",
+    "Arbiter",
+    "CollisionHandler",
+    "BB",
+    "ShapeFilter",
+    "Transform",
+    "PointQueryInfo",
+    "ShapeQueryInfo",
+    "SpaceDebugDrawOptions",
+    "Vec2d",
+]
+
+from typing import Sequence, Tuple, cast
+
+from . import _chipmunk_cffi
+
+cp = _chipmunk_cffi.lib
+ffi = _chipmunk_cffi.ffi
+
+import logging
+
+logging.getLogger(__name__).addHandler(logging.NullHandler())
+# logging.basicConfig(level=0)
+
+from . import _version
+from .arbiter import Arbiter
+from .bb import BB
+from .body import Body
+from .collision_handler import CollisionHandler
+from .constraints import *
+from .contact_point_set import ContactPoint, ContactPointSet
+from .query_info import PointQueryInfo, SegmentQueryInfo, ShapeQueryInfo
+from .shape_filter import ShapeFilter
+from .shapes import Circle, Poly, Segment, Shape
+from .space import Space
+from .space_debug_draw_options import SpaceDebugDrawOptions
+from .transform import Transform
+from .vec2d import Vec2d
+
+version: str = _version.version
+"""The release version of this pymunk installation.
+Valid only if pymunk was installed from a source or binary
+distribution (i.e. not in a checked-out copy from git).
+"""
+
+chipmunk_version: str = _version.chipmunk_version
+"""The Chipmunk version used with this Pymunk version.
+
+This property does not show a valid value in the compiled documentation, only
+when you actually import pymunk and do pymunk.chipmunk_version
+
+The string is in the following format:
+<cpVersionString>R<github commit of chipmunk>
+where cpVersionString is a version string set by Chipmunk and the git commit
+hash corresponds to the git hash of the chipmunk source from
+github.com/viblo/Chipmunk2D included with Pymunk.
+"""
+
+
+def moment_for_circle(
+    mass: float,
+    inner_radius: float,
+    outer_radius: float,
+    offset: Tuple[float, float] = (0, 0),
+) -> float:
+    """Calculate the moment of inertia for a hollow circle
+
+    (A solid circle has an inner radius of 0)
+    """
+    assert len(offset) == 2
+
+    return cp.cpMomentForCircle(mass, inner_radius, outer_radius, offset)
+
+
+def moment_for_segment(
+    mass: float, a: Tuple[float, float], b: Tuple[float, float], radius: float
+) -> float:
+    """Calculate the moment of inertia for a line segment
+
+    The endpoints a and b are relative to the body
+    """
+    assert len(a) == 2
+    assert len(b) == 2
+
+    return cp.cpMomentForSegment(mass, a, b, radius)
+
+
+def moment_for_box(mass: float, size: Tuple[float, float]) -> float:
+    """Calculate the moment of inertia for a solid box centered on the body.
+
+    size should be a tuple of (width, height)
+    """
+    assert len(size) == 2
+    return cp.cpMomentForBox(mass, size[0], size[1])
+
+
+def moment_for_poly(
+    mass: float,
+    vertices: Sequence[Tuple[float, float]],
+    offset: Tuple[float, float] = (0, 0),
+    radius: float = 0,
+) -> float:
+    """Calculate the moment of inertia for a solid polygon shape.
+
+    Assumes the polygon center of gravity is at its centroid. The offset is
+    added to each vertex.
+    """
+    assert len(offset) == 2
+    vs = list(vertices)
+    return cp.cpMomentForPoly(mass, len(vs), vs, offset, radius)
+
+
+def area_for_circle(inner_radius: float, outer_radius: float) -> float:
+    """Area of a hollow circle."""
+    return cast(float, cp.cpAreaForCircle(inner_radius, outer_radius))
+
+
+def area_for_segment(
+    a: Tuple[float, float], b: Tuple[float, float], radius: float
+) -> float:
+    """Area of a beveled segment.
+
+    (Will always be zero if radius is zero)
+    """
+    assert len(a) == 2
+    assert len(b) == 2
+
+    return cp.cpAreaForSegment(a, b, radius)
+
+
+def area_for_poly(vertices: Sequence[Tuple[float, float]], radius: float = 0) -> float:
+    """Signed area of a polygon shape.
+
+    Returns a negative number for polygons with a clockwise winding.
+    """
+    vs = list(vertices)
+    return cp.cpAreaForPoly(len(vs), vs, radius)
+
+
+# del cp, ct, u
```

## Comparing `pymunk-6.5.0/pymunk/examples/arrows.py` & `pymunk/examples/arrows.py`

 * *Ordering differences only*

 * *Files 11% similar despite different names*

```diff
@@ -1,225 +1,225 @@
-"""Showcase of flying arrows that can stick to objects in a somewhat 
-realistic looking way.
-"""
-import sys
-from typing import List
-
-import pygame
-
-import pymunk
-import pymunk.pygame_util
-from pymunk.vec2d import Vec2d
-
-
-def create_arrow():
-    vs = [(-30, 0), (0, 3), (10, 0), (0, -3)]
-    # mass = 1
-    # moment = pymunk.moment_for_poly(mass, vs)
-    arrow_body = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
-
-    arrow_shape = pymunk.Poly(arrow_body, vs)
-    arrow_shape.friction = 0.5
-    arrow_shape.collision_type = 1
-    arrow_shape.density = 0.1
-    return arrow_body, arrow_shape
-
-
-def stick_arrow_to_target(space, arrow_body, target_body, position, flying_arrows):
-    pivot_joint = pymunk.PivotJoint(arrow_body, target_body, position)
-    phase = target_body.angle - arrow_body.angle
-    gear_joint = pymunk.GearJoint(arrow_body, target_body, phase, 1)
-    space.add(pivot_joint)
-    space.add(gear_joint)
-    try:
-        flying_arrows.remove(arrow_body)
-    except:
-        pass
-
-
-def post_solve_arrow_hit(arbiter, space, data):
-    if arbiter.total_impulse.length > 300:
-        a, b = arbiter.shapes
-        position = arbiter.contact_point_set.points[0].point_a
-        b.collision_type = 0
-        b.group = 1
-        other_body = a.body
-        arrow_body = b.body
-        space.add_post_step_callback(
-            stick_arrow_to_target,
-            arrow_body,
-            other_body,
-            position,
-            data["flying_arrows"],
-        )
-
-
-width, height = 690, 600
-
-
-def main():
-    ### PyGame init
-    pygame.init()
-    screen = pygame.display.set_mode((width, height))
-    clock = pygame.time.Clock()
-    running = True
-    font = pygame.font.SysFont("Arial", 16)
-
-    ### Physics stuff
-    space = pymunk.Space()
-    space.gravity = 0, 1000
-    draw_options = pymunk.pygame_util.DrawOptions(screen)
-
-    # walls - the left-top-right walls
-    static: List[pymunk.Shape] = [
-        pymunk.Segment(space.static_body, (50, 550), (50, 50), 5),
-        pymunk.Segment(space.static_body, (50, 50), (650, 50), 5),
-        pymunk.Segment(space.static_body, (650, 50), (650, 550), 5),
-        pymunk.Segment(space.static_body, (50, 550), (650, 550), 5),
-    ]
-
-    b2 = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
-    static.append(pymunk.Circle(b2, 30))
-    b2.position = 300, 200
-
-    for s in static:
-        s.friction = 1.0
-        s.group = 1
-    space.add(b2, *static)
-
-    # "Cannon" that can fire arrows
-    cannon_body = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
-    cannon_shape = pymunk.Circle(cannon_body, 25)
-    cannon_shape.sensor = True
-    cannon_shape.color = (255, 50, 50, 255)
-    cannon_body.position = 100, 500
-    space.add(cannon_body, cannon_shape)
-
-    arrow_body, arrow_shape = create_arrow()
-    space.add(arrow_body, arrow_shape)
-
-    flying_arrows: List[pymunk.Body] = []
-    handler = space.add_collision_handler(0, 1)
-    handler.data["flying_arrows"] = flying_arrows
-    handler.post_solve = post_solve_arrow_hit
-
-    start_time = 0
-    while running:
-        for event in pygame.event.get():
-            if (
-                event.type == pygame.QUIT
-                or event.type == pygame.KEYDOWN
-                and (event.key in [pygame.K_ESCAPE, pygame.K_q])
-            ):
-                running = False
-            elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
-                start_time = pygame.time.get_ticks()
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
-                pygame.image.save(screen, "arrows.png")
-            elif event.type == pygame.MOUSEBUTTONUP and event.button == 1:
-                end_time = pygame.time.get_ticks()
-
-                diff = end_time - start_time
-                power = max(min(diff, 1000), 10) * 13.5
-                impulse = power * Vec2d(1, 0)
-                impulse = impulse.rotated(arrow_body.angle)
-                arrow_body.body_type = pymunk.Body.DYNAMIC
-                arrow_body.apply_impulse_at_world_point(impulse, arrow_body.position)
-
-                # space.add(arrow_body)
-                flying_arrows.append(arrow_body)
-
-                arrow_body, arrow_shape = create_arrow()
-                space.add(arrow_body, arrow_shape)
-
-        keys = pygame.key.get_pressed()
-
-        speed = 2.5
-        if keys[pygame.K_UP]:
-            cannon_body.position += Vec2d(0, 1) * speed
-        if keys[pygame.K_DOWN]:
-            cannon_body.position += Vec2d(0, -1) * speed
-        if keys[pygame.K_LEFT]:
-            cannon_body.position += Vec2d(-1, 0) * speed
-        if keys[pygame.K_RIGHT]:
-            cannon_body.position += Vec2d(1, 0) * speed
-
-        mouse_position = pymunk.pygame_util.from_pygame(
-            Vec2d(*pygame.mouse.get_pos()), screen
-        )
-        cannon_body.angle = (mouse_position - cannon_body.position).angle
-        # move the unfired arrow together with the cannon
-        arrow_body.position = cannon_body.position + Vec2d(
-            cannon_shape.radius + 40, 0
-        ).rotated(cannon_body.angle)
-        arrow_body.angle = cannon_body.angle
-        # print(arrow_body.angle)
-
-        for flying_arrow in flying_arrows:
-            drag_constant = 0.0002
-
-            pointing_direction = Vec2d(1, 0).rotated(flying_arrow.angle)
-            # print(pointing_direction.angle, flying_arrow.angle)
-            flight_direction = Vec2d(*flying_arrow.velocity)
-            flight_direction, flight_speed = flight_direction.normalized_and_length()
-
-            dot = flight_direction.dot(pointing_direction)
-            # (1-abs(dot)) can be replaced with (1-dot) to make arrows turn
-            # around even when fired straight up. Might not be as accurate, but
-            # maybe look better.
-            drag_force_magnitude = (
-                (1 - abs(dot)) * flight_speed ** 2 * drag_constant * flying_arrow.mass
-            )
-            arrow_tail_position = flying_arrow.position + Vec2d(-50, 0).rotated(
-                flying_arrow.angle
-            )
-            flying_arrow.apply_impulse_at_world_point(
-                drag_force_magnitude * -flight_direction, arrow_tail_position
-            )
-
-            flying_arrow.angular_velocity *= 0.5
-
-        ### Clear screen
-        screen.fill(pygame.Color("black"))
-
-        ### Draw stuff
-        space.debug_draw(draw_options)
-        # draw(screen, space)
-
-        # Power meter
-        if pygame.mouse.get_pressed()[0]:
-            current_time = pygame.time.get_ticks()
-            diff = current_time - start_time
-            power = max(min(diff, 1000), 10)
-            h = power // 2
-            pygame.draw.line(screen, pygame.Color("red"), (30, 550), (30, 550 - h), 10)
-
-        # Info and flip screen
-        screen.blit(
-            font.render("fps: " + str(clock.get_fps()), True, pygame.Color("white")),
-            (0, 0),
-        )
-        screen.blit(
-            font.render(
-                "Aim with mouse, hold LMB to powerup, release to fire",
-                True,
-                pygame.Color("darkgrey"),
-            ),
-            (5, height - 35),
-        )
-        screen.blit(
-            font.render("Press ESC or Q to quit", True, pygame.Color("darkgrey")),
-            (5, height - 20),
-        )
-
-        pygame.display.flip()
-
-        ### Update physics
-        fps = 60
-        dt = 1.0 / fps
-        space.step(dt)
-
-        clock.tick(fps)
-
-
-if __name__ == "__main__":
-    sys.exit(main())
+"""Showcase of flying arrows that can stick to objects in a somewhat 
+realistic looking way.
+"""
+import sys
+from typing import List
+
+import pygame
+
+import pymunk
+import pymunk.pygame_util
+from pymunk.vec2d import Vec2d
+
+
+def create_arrow():
+    vs = [(-30, 0), (0, 3), (10, 0), (0, -3)]
+    # mass = 1
+    # moment = pymunk.moment_for_poly(mass, vs)
+    arrow_body = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
+
+    arrow_shape = pymunk.Poly(arrow_body, vs)
+    arrow_shape.friction = 0.5
+    arrow_shape.collision_type = 1
+    arrow_shape.density = 0.1
+    return arrow_body, arrow_shape
+
+
+def stick_arrow_to_target(space, arrow_body, target_body, position, flying_arrows):
+    pivot_joint = pymunk.PivotJoint(arrow_body, target_body, position)
+    phase = target_body.angle - arrow_body.angle
+    gear_joint = pymunk.GearJoint(arrow_body, target_body, phase, 1)
+    space.add(pivot_joint)
+    space.add(gear_joint)
+    try:
+        flying_arrows.remove(arrow_body)
+    except:
+        pass
+
+
+def post_solve_arrow_hit(arbiter, space, data):
+    if arbiter.total_impulse.length > 300:
+        a, b = arbiter.shapes
+        position = arbiter.contact_point_set.points[0].point_a
+        b.collision_type = 0
+        b.group = 1
+        other_body = a.body
+        arrow_body = b.body
+        space.add_post_step_callback(
+            stick_arrow_to_target,
+            arrow_body,
+            other_body,
+            position,
+            data["flying_arrows"],
+        )
+
+
+width, height = 690, 600
+
+
+def main():
+    ### PyGame init
+    pygame.init()
+    screen = pygame.display.set_mode((width, height))
+    clock = pygame.time.Clock()
+    running = True
+    font = pygame.font.SysFont("Arial", 16)
+
+    ### Physics stuff
+    space = pymunk.Space()
+    space.gravity = 0, 1000
+    draw_options = pymunk.pygame_util.DrawOptions(screen)
+
+    # walls - the left-top-right walls
+    static: List[pymunk.Shape] = [
+        pymunk.Segment(space.static_body, (50, 550), (50, 50), 5),
+        pymunk.Segment(space.static_body, (50, 50), (650, 50), 5),
+        pymunk.Segment(space.static_body, (650, 50), (650, 550), 5),
+        pymunk.Segment(space.static_body, (50, 550), (650, 550), 5),
+    ]
+
+    b2 = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
+    static.append(pymunk.Circle(b2, 30))
+    b2.position = 300, 200
+
+    for s in static:
+        s.friction = 1.0
+        s.group = 1
+    space.add(b2, *static)
+
+    # "Cannon" that can fire arrows
+    cannon_body = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
+    cannon_shape = pymunk.Circle(cannon_body, 25)
+    cannon_shape.sensor = True
+    cannon_shape.color = (255, 50, 50, 255)
+    cannon_body.position = 100, 500
+    space.add(cannon_body, cannon_shape)
+
+    arrow_body, arrow_shape = create_arrow()
+    space.add(arrow_body, arrow_shape)
+
+    flying_arrows: List[pymunk.Body] = []
+    handler = space.add_collision_handler(0, 1)
+    handler.data["flying_arrows"] = flying_arrows
+    handler.post_solve = post_solve_arrow_hit
+
+    start_time = 0
+    while running:
+        for event in pygame.event.get():
+            if (
+                event.type == pygame.QUIT
+                or event.type == pygame.KEYDOWN
+                and (event.key in [pygame.K_ESCAPE, pygame.K_q])
+            ):
+                running = False
+            elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
+                start_time = pygame.time.get_ticks()
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
+                pygame.image.save(screen, "arrows.png")
+            elif event.type == pygame.MOUSEBUTTONUP and event.button == 1:
+                end_time = pygame.time.get_ticks()
+
+                diff = end_time - start_time
+                power = max(min(diff, 1000), 10) * 13.5
+                impulse = power * Vec2d(1, 0)
+                impulse = impulse.rotated(arrow_body.angle)
+                arrow_body.body_type = pymunk.Body.DYNAMIC
+                arrow_body.apply_impulse_at_world_point(impulse, arrow_body.position)
+
+                # space.add(arrow_body)
+                flying_arrows.append(arrow_body)
+
+                arrow_body, arrow_shape = create_arrow()
+                space.add(arrow_body, arrow_shape)
+
+        keys = pygame.key.get_pressed()
+
+        speed = 2.5
+        if keys[pygame.K_UP]:
+            cannon_body.position += Vec2d(0, 1) * speed
+        if keys[pygame.K_DOWN]:
+            cannon_body.position += Vec2d(0, -1) * speed
+        if keys[pygame.K_LEFT]:
+            cannon_body.position += Vec2d(-1, 0) * speed
+        if keys[pygame.K_RIGHT]:
+            cannon_body.position += Vec2d(1, 0) * speed
+
+        mouse_position = pymunk.pygame_util.from_pygame(
+            Vec2d(*pygame.mouse.get_pos()), screen
+        )
+        cannon_body.angle = (mouse_position - cannon_body.position).angle
+        # move the unfired arrow together with the cannon
+        arrow_body.position = cannon_body.position + Vec2d(
+            cannon_shape.radius + 40, 0
+        ).rotated(cannon_body.angle)
+        arrow_body.angle = cannon_body.angle
+        # print(arrow_body.angle)
+
+        for flying_arrow in flying_arrows:
+            drag_constant = 0.0002
+
+            pointing_direction = Vec2d(1, 0).rotated(flying_arrow.angle)
+            # print(pointing_direction.angle, flying_arrow.angle)
+            flight_direction = Vec2d(*flying_arrow.velocity)
+            flight_direction, flight_speed = flight_direction.normalized_and_length()
+
+            dot = flight_direction.dot(pointing_direction)
+            # (1-abs(dot)) can be replaced with (1-dot) to make arrows turn
+            # around even when fired straight up. Might not be as accurate, but
+            # maybe look better.
+            drag_force_magnitude = (
+                (1 - abs(dot)) * flight_speed ** 2 * drag_constant * flying_arrow.mass
+            )
+            arrow_tail_position = flying_arrow.position + Vec2d(-50, 0).rotated(
+                flying_arrow.angle
+            )
+            flying_arrow.apply_impulse_at_world_point(
+                drag_force_magnitude * -flight_direction, arrow_tail_position
+            )
+
+            flying_arrow.angular_velocity *= 0.5
+
+        ### Clear screen
+        screen.fill(pygame.Color("black"))
+
+        ### Draw stuff
+        space.debug_draw(draw_options)
+        # draw(screen, space)
+
+        # Power meter
+        if pygame.mouse.get_pressed()[0]:
+            current_time = pygame.time.get_ticks()
+            diff = current_time - start_time
+            power = max(min(diff, 1000), 10)
+            h = power // 2
+            pygame.draw.line(screen, pygame.Color("red"), (30, 550), (30, 550 - h), 10)
+
+        # Info and flip screen
+        screen.blit(
+            font.render("fps: " + str(clock.get_fps()), True, pygame.Color("white")),
+            (0, 0),
+        )
+        screen.blit(
+            font.render(
+                "Aim with mouse, hold LMB to powerup, release to fire",
+                True,
+                pygame.Color("darkgrey"),
+            ),
+            (5, height - 35),
+        )
+        screen.blit(
+            font.render("Press ESC or Q to quit", True, pygame.Color("darkgrey")),
+            (5, height - 20),
+        )
+
+        pygame.display.flip()
+
+        ### Update physics
+        fps = 60
+        dt = 1.0 / fps
+        space.step(dt)
+
+        clock.tick(fps)
+
+
+if __name__ == "__main__":
+    sys.exit(main())
```

## Comparing `pymunk-6.5.0/pymunk/examples/balls_and_lines.py` & `pymunk/examples/balls_and_lines.py`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,170 +1,170 @@
-"""This example lets you dynamically create static walls and dynamic balls
-
-"""
-__docformat__ = "reStructuredText"
-
-import pygame
-
-import pymunk
-from pymunk import Vec2d
-
-X, Y = 0, 1
-### Physics collision types
-COLLTYPE_DEFAULT = 0
-COLLTYPE_MOUSE = 1
-COLLTYPE_BALL = 2
-
-
-def flipy(y):
-    """Small hack to convert chipmunk physics to pygame coordinates"""
-    return -y + 600
-
-
-def mouse_coll_func(arbiter, space, data):
-    """Simple callback that increases the radius of circles touching the mouse"""
-    s1, s2 = arbiter.shapes
-    s2.unsafe_set_radius(s2.radius + 0.15)
-    return False
-
-
-def main():
-
-    pygame.init()
-    screen = pygame.display.set_mode((600, 600))
-    clock = pygame.time.Clock()
-    running = True
-
-    ### Physics stuff
-    space = pymunk.Space()
-    space.gravity = 0.0, -900.0
-
-    ## Balls
-    balls = []
-
-    ### Mouse
-    mouse_body = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
-    mouse_shape = pymunk.Circle(mouse_body, 3, (0, 0))
-    mouse_shape.collision_type = COLLTYPE_MOUSE
-    space.add(mouse_body, mouse_shape)
-
-    space.add_collision_handler(
-        COLLTYPE_MOUSE, COLLTYPE_BALL
-    ).pre_solve = mouse_coll_func
-
-    ### Static line
-    line_point1 = None
-    static_lines = []
-    run_physics = True
-
-    while running:
-        for event in pygame.event.get():
-            if event.type == pygame.QUIT:
-                running = False
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
-                running = False
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
-                pygame.image.save(screen, "balls_and_lines.png")
-            elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
-                p = event.pos[X], flipy(event.pos[Y])
-                body = pymunk.Body(10, 100)
-                body.position = p
-                shape = pymunk.Circle(body, 10, (0, 0))
-                shape.friction = 0.5
-                shape.collision_type = COLLTYPE_BALL
-                space.add(body, shape)
-                balls.append(shape)
-
-            elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 3:
-                if line_point1 is None:
-                    line_point1 = Vec2d(event.pos[X], flipy(event.pos[Y]))
-            elif event.type == pygame.MOUSEBUTTONUP and event.button == 3:
-                if line_point1 is not None:
-
-                    line_point2 = Vec2d(event.pos[X], flipy(event.pos[Y]))
-                    shape = pymunk.Segment(
-                        space.static_body, line_point1, line_point2, 0.0
-                    )
-                    shape.friction = 0.99
-                    space.add(shape)
-                    static_lines.append(shape)
-                    line_point1 = None
-
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_SPACE:
-                run_physics = not run_physics
-
-        p = pygame.mouse.get_pos()
-        mouse_pos = Vec2d(p[X], flipy(p[Y]))
-        mouse_body.position = mouse_pos
-
-        if pygame.key.get_mods() & pygame.KMOD_SHIFT and pygame.mouse.get_pressed()[0]:
-            body = pymunk.Body(10, 10)
-            body.position = mouse_pos
-            shape = pymunk.Circle(body, 10, (0, 0))
-            shape.collision_type = COLLTYPE_BALL
-            space.add(body, shape)
-            balls.append(shape)
-
-        ### Update physics
-        if run_physics:
-            dt = 1.0 / 60.0
-            for x in range(1):
-                space.step(dt)
-
-        ### Draw stuff
-        screen.fill(pygame.Color("white"))
-
-        # Display some text
-        font = pygame.font.Font(None, 16)
-        text = """LMB: Create ball
-LMB + Shift: Create many balls
-RMB: Drag to create wall, release to finish
-Space: Pause physics simulation"""
-        y = 5
-        for line in text.splitlines():
-            text = font.render(line, True, pygame.Color("black"))
-            screen.blit(text, (5, y))
-            y += 10
-
-        for ball in balls:
-            r = ball.radius
-            v = ball.body.position
-            rot = ball.body.rotation_vector
-            p = int(v.x), int(flipy(v.y))
-            p2 = p + Vec2d(rot.x, -rot.y) * r * 0.9
-            p2 = int(p2.x), int(p2.y)
-            pygame.draw.circle(screen, pygame.Color("blue"), p, int(r), 2)
-            pygame.draw.line(screen, pygame.Color("red"), p, p2)
-
-        if line_point1 is not None:
-            p1 = int(line_point1.x), int(flipy(line_point1.y))
-            p2 = mouse_pos.x, flipy(mouse_pos.y)
-            pygame.draw.lines(screen, pygame.Color("black"), False, [p1, p2])
-
-        for line in static_lines:
-            body = line.body
-
-            pv1 = body.position + line.a.rotated(body.angle)
-            pv2 = body.position + line.b.rotated(body.angle)
-            p1 = int(pv1.x), int(flipy(pv1.y))
-            p2 = int(pv2.x), int(flipy(pv2.y))
-            pygame.draw.lines(screen, pygame.Color("lightgray"), False, [p1, p2])
-
-        ### Flip screen
-        pygame.display.flip()
-        clock.tick(50)
-        pygame.display.set_caption("fps: " + str(clock.get_fps()))
-
-
-if __name__ == "__main__":
-    doprof = 0
-    if not doprof:
-        main()
-    else:
-        import cProfile
-        import pstats
-
-        prof = cProfile.run("main()", "profile.prof")
-        stats = pstats.Stats("profile.prof")
-        stats.strip_dirs()
-        stats.sort_stats("cumulative", "time", "calls")
-        stats.print_stats(30)
+"""This example lets you dynamically create static walls and dynamic balls
+
+"""
+__docformat__ = "reStructuredText"
+
+import pygame
+
+import pymunk
+from pymunk import Vec2d
+
+X, Y = 0, 1
+### Physics collision types
+COLLTYPE_DEFAULT = 0
+COLLTYPE_MOUSE = 1
+COLLTYPE_BALL = 2
+
+
+def flipy(y):
+    """Small hack to convert chipmunk physics to pygame coordinates"""
+    return -y + 600
+
+
+def mouse_coll_func(arbiter, space, data):
+    """Simple callback that increases the radius of circles touching the mouse"""
+    s1, s2 = arbiter.shapes
+    s2.unsafe_set_radius(s2.radius + 0.15)
+    return False
+
+
+def main():
+
+    pygame.init()
+    screen = pygame.display.set_mode((600, 600))
+    clock = pygame.time.Clock()
+    running = True
+
+    ### Physics stuff
+    space = pymunk.Space()
+    space.gravity = 0.0, -900.0
+
+    ## Balls
+    balls = []
+
+    ### Mouse
+    mouse_body = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
+    mouse_shape = pymunk.Circle(mouse_body, 3, (0, 0))
+    mouse_shape.collision_type = COLLTYPE_MOUSE
+    space.add(mouse_body, mouse_shape)
+
+    space.add_collision_handler(
+        COLLTYPE_MOUSE, COLLTYPE_BALL
+    ).pre_solve = mouse_coll_func
+
+    ### Static line
+    line_point1 = None
+    static_lines = []
+    run_physics = True
+
+    while running:
+        for event in pygame.event.get():
+            if event.type == pygame.QUIT:
+                running = False
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
+                running = False
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
+                pygame.image.save(screen, "balls_and_lines.png")
+            elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
+                p = event.pos[X], flipy(event.pos[Y])
+                body = pymunk.Body(10, 100)
+                body.position = p
+                shape = pymunk.Circle(body, 10, (0, 0))
+                shape.friction = 0.5
+                shape.collision_type = COLLTYPE_BALL
+                space.add(body, shape)
+                balls.append(shape)
+
+            elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 3:
+                if line_point1 is None:
+                    line_point1 = Vec2d(event.pos[X], flipy(event.pos[Y]))
+            elif event.type == pygame.MOUSEBUTTONUP and event.button == 3:
+                if line_point1 is not None:
+
+                    line_point2 = Vec2d(event.pos[X], flipy(event.pos[Y]))
+                    shape = pymunk.Segment(
+                        space.static_body, line_point1, line_point2, 0.0
+                    )
+                    shape.friction = 0.99
+                    space.add(shape)
+                    static_lines.append(shape)
+                    line_point1 = None
+
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_SPACE:
+                run_physics = not run_physics
+
+        p = pygame.mouse.get_pos()
+        mouse_pos = Vec2d(p[X], flipy(p[Y]))
+        mouse_body.position = mouse_pos
+
+        if pygame.key.get_mods() & pygame.KMOD_SHIFT and pygame.mouse.get_pressed()[0]:
+            body = pymunk.Body(10, 10)
+            body.position = mouse_pos
+            shape = pymunk.Circle(body, 10, (0, 0))
+            shape.collision_type = COLLTYPE_BALL
+            space.add(body, shape)
+            balls.append(shape)
+
+        ### Update physics
+        if run_physics:
+            dt = 1.0 / 60.0
+            for x in range(1):
+                space.step(dt)
+
+        ### Draw stuff
+        screen.fill(pygame.Color("white"))
+
+        # Display some text
+        font = pygame.font.Font(None, 16)
+        text = """LMB: Create ball
+LMB + Shift: Create many balls
+RMB: Drag to create wall, release to finish
+Space: Pause physics simulation"""
+        y = 5
+        for line in text.splitlines():
+            text = font.render(line, True, pygame.Color("black"))
+            screen.blit(text, (5, y))
+            y += 10
+
+        for ball in balls:
+            r = ball.radius
+            v = ball.body.position
+            rot = ball.body.rotation_vector
+            p = int(v.x), int(flipy(v.y))
+            p2 = p + Vec2d(rot.x, -rot.y) * r * 0.9
+            p2 = int(p2.x), int(p2.y)
+            pygame.draw.circle(screen, pygame.Color("blue"), p, int(r), 2)
+            pygame.draw.line(screen, pygame.Color("red"), p, p2)
+
+        if line_point1 is not None:
+            p1 = int(line_point1.x), int(flipy(line_point1.y))
+            p2 = mouse_pos.x, flipy(mouse_pos.y)
+            pygame.draw.lines(screen, pygame.Color("black"), False, [p1, p2])
+
+        for line in static_lines:
+            body = line.body
+
+            pv1 = body.position + line.a.rotated(body.angle)
+            pv2 = body.position + line.b.rotated(body.angle)
+            p1 = int(pv1.x), int(flipy(pv1.y))
+            p2 = int(pv2.x), int(flipy(pv2.y))
+            pygame.draw.lines(screen, pygame.Color("lightgray"), False, [p1, p2])
+
+        ### Flip screen
+        pygame.display.flip()
+        clock.tick(50)
+        pygame.display.set_caption("fps: " + str(clock.get_fps()))
+
+
+if __name__ == "__main__":
+    doprof = 0
+    if not doprof:
+        main()
+    else:
+        import cProfile
+        import pstats
+
+        prof = cProfile.run("main()", "profile.prof")
+        stats = pstats.Stats("profile.prof")
+        stats.strip_dirs()
+        stats.sort_stats("cumulative", "time", "calls")
+        stats.print_stats(30)
```

## Comparing `pymunk-6.5.0/pymunk/examples/bouncing_balls.py` & `pymunk/examples/bouncing_balls.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,155 +1,155 @@
-"""This example spawns (bouncing) balls randomly on a L-shape constructed of 
-two segment shapes. Not interactive.
-"""
-
-__version__ = "$Id:$"
-__docformat__ = "reStructuredText"
-
-# Python imports
-import random
-from typing import List
-
-# Library imports
-import pygame
-
-# pymunk imports
-import pymunk
-import pymunk.pygame_util
-
-
-class BouncyBalls(object):
-    """
-    This class implements a simple scene in which there is a static platform (made up of a couple of lines)
-    that don't move. Balls appear occasionally and drop onto the platform. They bounce around.
-    """
-
-    def __init__(self) -> None:
-        # Space
-        self._space = pymunk.Space()
-        self._space.gravity = (0.0, 900.0)
-
-        # Physics
-        # Time step
-        self._dt = 1.0 / 60.0
-        # Number of physics steps per screen frame
-        self._physics_steps_per_frame = 1
-
-        # pygame
-        pygame.init()
-        self._screen = pygame.display.set_mode((600, 600))
-        self._clock = pygame.time.Clock()
-
-        self._draw_options = pymunk.pygame_util.DrawOptions(self._screen)
-
-        # Static barrier walls (lines) that the balls bounce off of
-        self._add_static_scenery()
-
-        # Balls that exist in the world
-        self._balls: List[pymunk.Circle] = []
-
-        # Execution control and time until the next ball spawns
-        self._running = True
-        self._ticks_to_next_ball = 10
-
-    def run(self) -> None:
-        """
-        The main loop of the game.
-        :return: None
-        """
-        # Main loop
-        while self._running:
-            # Progress time forward
-            for x in range(self._physics_steps_per_frame):
-                self._space.step(self._dt)
-
-            self._process_events()
-            self._update_balls()
-            self._clear_screen()
-            self._draw_objects()
-            pygame.display.flip()
-            # Delay fixed time between frames
-            self._clock.tick(50)
-            pygame.display.set_caption("fps: " + str(self._clock.get_fps()))
-
-    def _add_static_scenery(self) -> None:
-        """
-        Create the static bodies.
-        :return: None
-        """
-        static_body = self._space.static_body
-        static_lines = [
-            pymunk.Segment(static_body, (111.0, 600 - 280), (407.0, 600 - 246), 0.0),
-            pymunk.Segment(static_body, (407.0, 600 - 246), (407.0, 600 - 343), 0.0),
-        ]
-        for line in static_lines:
-            line.elasticity = 0.95
-            line.friction = 0.9
-        self._space.add(*static_lines)
-
-    def _process_events(self) -> None:
-        """
-        Handle game and events like keyboard input. Call once per frame only.
-        :return: None
-        """
-        for event in pygame.event.get():
-            if event.type == pygame.QUIT:
-                self._running = False
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
-                self._running = False
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
-                pygame.image.save(self._screen, "bouncing_balls.png")
-
-    def _update_balls(self) -> None:
-        """
-        Create/remove balls as necessary. Call once per frame only.
-        :return: None
-        """
-        self._ticks_to_next_ball -= 1
-        if self._ticks_to_next_ball <= 0:
-            self._create_ball()
-            self._ticks_to_next_ball = 100
-        # Remove balls that fall below 100 vertically
-        balls_to_remove = [ball for ball in self._balls if ball.body.position.y > 500]
-        for ball in balls_to_remove:
-            self._space.remove(ball, ball.body)
-            self._balls.remove(ball)
-
-    def _create_ball(self) -> None:
-        """
-        Create a ball.
-        :return:
-        """
-        mass = 10
-        radius = 25
-        inertia = pymunk.moment_for_circle(mass, 0, radius, (0, 0))
-        body = pymunk.Body(mass, inertia)
-        x = random.randint(115, 350)
-        body.position = x, 200
-        shape = pymunk.Circle(body, radius, (0, 0))
-        shape.elasticity = 0.95
-        shape.friction = 0.9
-        self._space.add(body, shape)
-        self._balls.append(shape)
-
-    def _clear_screen(self) -> None:
-        """
-        Clears the screen.
-        :return: None
-        """
-        self._screen.fill(pygame.Color("white"))
-
-    def _draw_objects(self) -> None:
-        """
-        Draw the objects.
-        :return: None
-        """
-        self._space.debug_draw(self._draw_options)
-
-
-def main():
-    game = BouncyBalls()
-    game.run()
-
-
-if __name__ == "__main__":
-    main()
+"""This example spawns (bouncing) balls randomly on a L-shape constructed of 
+two segment shapes. Not interactive.
+"""
+
+__version__ = "$Id:$"
+__docformat__ = "reStructuredText"
+
+# Python imports
+import random
+from typing import List
+
+# Library imports
+import pygame
+
+# pymunk imports
+import pymunk
+import pymunk.pygame_util
+
+
+class BouncyBalls(object):
+    """
+    This class implements a simple scene in which there is a static platform (made up of a couple of lines)
+    that don't move. Balls appear occasionally and drop onto the platform. They bounce around.
+    """
+
+    def __init__(self) -> None:
+        # Space
+        self._space = pymunk.Space()
+        self._space.gravity = (0.0, 900.0)
+
+        # Physics
+        # Time step
+        self._dt = 1.0 / 60.0
+        # Number of physics steps per screen frame
+        self._physics_steps_per_frame = 1
+
+        # pygame
+        pygame.init()
+        self._screen = pygame.display.set_mode((600, 600))
+        self._clock = pygame.time.Clock()
+
+        self._draw_options = pymunk.pygame_util.DrawOptions(self._screen)
+
+        # Static barrier walls (lines) that the balls bounce off of
+        self._add_static_scenery()
+
+        # Balls that exist in the world
+        self._balls: List[pymunk.Circle] = []
+
+        # Execution control and time until the next ball spawns
+        self._running = True
+        self._ticks_to_next_ball = 10
+
+    def run(self) -> None:
+        """
+        The main loop of the game.
+        :return: None
+        """
+        # Main loop
+        while self._running:
+            # Progress time forward
+            for x in range(self._physics_steps_per_frame):
+                self._space.step(self._dt)
+
+            self._process_events()
+            self._update_balls()
+            self._clear_screen()
+            self._draw_objects()
+            pygame.display.flip()
+            # Delay fixed time between frames
+            self._clock.tick(50)
+            pygame.display.set_caption("fps: " + str(self._clock.get_fps()))
+
+    def _add_static_scenery(self) -> None:
+        """
+        Create the static bodies.
+        :return: None
+        """
+        static_body = self._space.static_body
+        static_lines = [
+            pymunk.Segment(static_body, (111.0, 600 - 280), (407.0, 600 - 246), 0.0),
+            pymunk.Segment(static_body, (407.0, 600 - 246), (407.0, 600 - 343), 0.0),
+        ]
+        for line in static_lines:
+            line.elasticity = 0.95
+            line.friction = 0.9
+        self._space.add(*static_lines)
+
+    def _process_events(self) -> None:
+        """
+        Handle game and events like keyboard input. Call once per frame only.
+        :return: None
+        """
+        for event in pygame.event.get():
+            if event.type == pygame.QUIT:
+                self._running = False
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
+                self._running = False
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
+                pygame.image.save(self._screen, "bouncing_balls.png")
+
+    def _update_balls(self) -> None:
+        """
+        Create/remove balls as necessary. Call once per frame only.
+        :return: None
+        """
+        self._ticks_to_next_ball -= 1
+        if self._ticks_to_next_ball <= 0:
+            self._create_ball()
+            self._ticks_to_next_ball = 100
+        # Remove balls that fall below 100 vertically
+        balls_to_remove = [ball for ball in self._balls if ball.body.position.y > 500]
+        for ball in balls_to_remove:
+            self._space.remove(ball, ball.body)
+            self._balls.remove(ball)
+
+    def _create_ball(self) -> None:
+        """
+        Create a ball.
+        :return:
+        """
+        mass = 10
+        radius = 25
+        inertia = pymunk.moment_for_circle(mass, 0, radius, (0, 0))
+        body = pymunk.Body(mass, inertia)
+        x = random.randint(115, 350)
+        body.position = x, 200
+        shape = pymunk.Circle(body, radius, (0, 0))
+        shape.elasticity = 0.95
+        shape.friction = 0.9
+        self._space.add(body, shape)
+        self._balls.append(shape)
+
+    def _clear_screen(self) -> None:
+        """
+        Clears the screen.
+        :return: None
+        """
+        self._screen.fill(pygame.Color("white"))
+
+    def _draw_objects(self) -> None:
+        """
+        Draw the objects.
+        :return: None
+        """
+        self._space.debug_draw(self._draw_options)
+
+
+def main():
+    game = BouncyBalls()
+    game.run()
+
+
+if __name__ == "__main__":
+    main()
```

## Comparing `pymunk-6.5.0/pymunk/examples/box2d_pyramid.py` & `pymunk/examples/box2d_pyramid.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,98 +1,98 @@
-"""
-Remake of the pyramid demo from the box2d testbed.
-"""
-
-import pygame
-
-import pymunk
-import pymunk.pygame_util
-from pymunk import Vec2d
-
-
-class PyramidDemo:
-    def __init__(self):
-        self.running = True
-        self.drawing = True
-        self.w, self.h = 600, 600
-        self.screen = pygame.display.set_mode((self.w, self.h))
-        self.clock = pygame.time.Clock()
-
-        ### Init pymunk and create space
-        self.space = pymunk.Space()
-        self.space.gravity = (0.0, -900.0)
-        self.space.sleep_time_threshold = 0.3
-        ### ground
-        shape = pymunk.Segment(self.space.static_body, (5, 100), (595, 100), 1.0)
-        shape.friction = 1.0
-        self.space.add(shape)
-
-        ### pyramid
-        x = Vec2d(-270, 7.5) + (300, 100)
-        y = Vec2d(0, 0)
-        deltaX = Vec2d(0.5625, 1.1) * 20
-        deltaY = Vec2d(1.125, 0.0) * 20
-
-        for i in range(25):
-            y = Vec2d(*x)
-            for j in range(i, 25):
-                size = 10
-                points = [(-size, -size), (-size, size), (size, size), (size, -size)]
-                mass = 1.0
-                moment = pymunk.moment_for_poly(mass, points, (0, 0))
-                body = pymunk.Body(mass, moment)
-                body.position = y
-                shape = pymunk.Poly(body, points)
-                shape.friction = 1
-                self.space.add(body, shape)
-
-                y += deltaY
-
-            x += deltaX
-
-        ### draw options for drawing
-        pymunk.pygame_util.positive_y_is_up = True
-        self.draw_options = pymunk.pygame_util.DrawOptions(self.screen)
-
-    def run(self):
-        while self.running:
-            self.loop()
-
-    def loop(self):
-        for event in pygame.event.get():
-            if event.type == pygame.QUIT:
-                self.running = False
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
-                self.running = False
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
-                pygame.image.save(self.screen, "box2d_pyramid.png")
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_d:
-                self.drawing = not self.drawing
-
-        fps = 30.0
-        dt = 1.0 / fps / 5
-        self.space.step(dt)
-        if self.drawing:
-            self.draw()
-
-        ### Tick clock and update fps in title
-        self.clock.tick(fps)
-        pygame.display.set_caption("fps: " + str(self.clock.get_fps()))
-
-    def draw(self):
-        ### Clear the screen
-        self.screen.fill(pygame.Color("white"))
-
-        ### Draw space
-        self.space.debug_draw(self.draw_options)
-
-        ### All done, lets flip the display
-        pygame.display.flip()
-
-
-def main():
-    demo = PyramidDemo()
-    demo.run()
-
-
-if __name__ == "__main__":
-    main()
+"""
+Remake of the pyramid demo from the box2d testbed.
+"""
+
+import pygame
+
+import pymunk
+import pymunk.pygame_util
+from pymunk import Vec2d
+
+
+class PyramidDemo:
+    def __init__(self):
+        self.running = True
+        self.drawing = True
+        self.w, self.h = 600, 600
+        self.screen = pygame.display.set_mode((self.w, self.h))
+        self.clock = pygame.time.Clock()
+
+        ### Init pymunk and create space
+        self.space = pymunk.Space()
+        self.space.gravity = (0.0, -900.0)
+        self.space.sleep_time_threshold = 0.3
+        ### ground
+        shape = pymunk.Segment(self.space.static_body, (5, 100), (595, 100), 1.0)
+        shape.friction = 1.0
+        self.space.add(shape)
+
+        ### pyramid
+        x = Vec2d(-270, 7.5) + (300, 100)
+        y = Vec2d(0, 0)
+        deltaX = Vec2d(0.5625, 1.1) * 20
+        deltaY = Vec2d(1.125, 0.0) * 20
+
+        for i in range(25):
+            y = Vec2d(*x)
+            for j in range(i, 25):
+                size = 10
+                points = [(-size, -size), (-size, size), (size, size), (size, -size)]
+                mass = 1.0
+                moment = pymunk.moment_for_poly(mass, points, (0, 0))
+                body = pymunk.Body(mass, moment)
+                body.position = y
+                shape = pymunk.Poly(body, points)
+                shape.friction = 1
+                self.space.add(body, shape)
+
+                y += deltaY
+
+            x += deltaX
+
+        ### draw options for drawing
+        pymunk.pygame_util.positive_y_is_up = True
+        self.draw_options = pymunk.pygame_util.DrawOptions(self.screen)
+
+    def run(self):
+        while self.running:
+            self.loop()
+
+    def loop(self):
+        for event in pygame.event.get():
+            if event.type == pygame.QUIT:
+                self.running = False
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
+                self.running = False
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
+                pygame.image.save(self.screen, "box2d_pyramid.png")
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_d:
+                self.drawing = not self.drawing
+
+        fps = 30.0
+        dt = 1.0 / fps / 5
+        self.space.step(dt)
+        if self.drawing:
+            self.draw()
+
+        ### Tick clock and update fps in title
+        self.clock.tick(fps)
+        pygame.display.set_caption("fps: " + str(self.clock.get_fps()))
+
+    def draw(self):
+        ### Clear the screen
+        self.screen.fill(pygame.Color("white"))
+
+        ### Draw space
+        self.space.debug_draw(self.draw_options)
+
+        ### All done, lets flip the display
+        pygame.display.flip()
+
+
+def main():
+    demo = PyramidDemo()
+    demo.run()
+
+
+if __name__ == "__main__":
+    main()
```

## Comparing `pymunk-6.5.0/pymunk/examples/breakout.py` & `pymunk/examples/breakout.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,230 +1,230 @@
-"""Very simple breakout clone. A circle shape serves as the paddle, then 
-breakable bricks constructed of Poly-shapes. 
-
-The code showcases several pymunk concepts such as elasitcity, impulses, 
-constant object speed, joints, collision handlers and post step callbacks.
-"""
-
-import random
-import sys
-
-import pygame
-
-import pymunk
-import pymunk.pygame_util
-from pymunk import Vec2d
-
-width, height = 600, 600
-
-
-collision_types = {
-    "ball": 1,
-    "brick": 2,
-    "bottom": 3,
-    "player": 4,
-}
-
-
-def spawn_ball(space, position, direction):
-    ball_body = pymunk.Body(1, float("inf"))
-    ball_body.position = position
-
-    ball_shape = pymunk.Circle(ball_body, 5)
-    ball_shape.color = pygame.Color("green")
-    ball_shape.elasticity = 1.0
-    ball_shape.collision_type = collision_types["ball"]
-
-    ball_body.apply_impulse_at_local_point(Vec2d(*direction))
-
-    # Keep ball velocity at a static value
-    def constant_velocity(body, gravity, damping, dt):
-        body.velocity = body.velocity.normalized() * 400
-
-    ball_body.velocity_func = constant_velocity
-
-    space.add(ball_body, ball_shape)
-
-
-def setup_level(space, player_body):
-
-    # Remove balls and bricks
-    for s in space.shapes[:]:
-        if s.body.body_type == pymunk.Body.DYNAMIC and s.body not in [player_body]:
-            space.remove(s.body, s)
-
-    # Spawn a ball for the player to have something to play with
-    spawn_ball(
-        space, player_body.position + (0, 40), random.choice([(1, 10), (-1, 10)])
-    )
-
-    # Spawn bricks
-    for x in range(0, 21):
-        x = x * 20 + 100
-        for y in range(0, 5):
-            y = y * 10 + 400
-            brick_body = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
-            brick_body.position = x, y
-            brick_shape = pymunk.Poly.create_box(brick_body, (20, 10))
-            brick_shape.elasticity = 1.0
-            brick_shape.color = pygame.Color("blue")
-            brick_shape.group = 1
-            brick_shape.collision_type = collision_types["brick"]
-            space.add(brick_body, brick_shape)
-
-    # Make bricks be removed when hit by ball
-    def remove_brick(arbiter, space, data):
-        brick_shape = arbiter.shapes[0]
-        space.remove(brick_shape, brick_shape.body)
-
-    h = space.add_collision_handler(collision_types["brick"], collision_types["ball"])
-    h.separate = remove_brick
-
-
-def main():
-    ### PyGame init
-    pygame.init()
-    screen = pygame.display.set_mode((width, height))
-    clock = pygame.time.Clock()
-    running = True
-    font = pygame.font.SysFont("Arial", 16)
-    ### Physics stuff
-    space = pymunk.Space()
-    pymunk.pygame_util.positive_y_is_up = True
-    draw_options = pymunk.pygame_util.DrawOptions(screen)
-
-    ### Game area
-    # walls - the left-top-right walls
-    static_lines = [
-        pymunk.Segment(space.static_body, (50, 50), (50, 550), 2),
-        pymunk.Segment(space.static_body, (50, 550), (550, 550), 2),
-        pymunk.Segment(space.static_body, (550, 550), (550, 50), 2),
-    ]
-    for line in static_lines:
-        line.color = pygame.Color("lightgray")
-        line.elasticity = 1.0
-
-    space.add(*static_lines)
-
-    # bottom - a sensor that removes anything touching it
-    bottom = pymunk.Segment(space.static_body, (50, 50), (550, 50), 2)
-    bottom.sensor = True
-    bottom.collision_type = collision_types["bottom"]
-    bottom.color = pygame.Color("red")
-
-    def remove_first(arbiter, space, data):
-        ball_shape = arbiter.shapes[0]
-        space.remove(ball_shape, ball_shape.body)
-        return True
-
-    h = space.add_collision_handler(collision_types["ball"], collision_types["bottom"])
-    h.begin = remove_first
-    space.add(bottom)
-
-    ### Player ship
-    player_body = pymunk.Body(500, float("inf"))
-    player_body.position = 300, 100
-
-    player_shape = pymunk.Segment(player_body, (-50, 0), (50, 0), 8)
-    player_shape.color = pygame.Color("red")
-    player_shape.elasticity = 1.0
-    player_shape.collision_type = collision_types["player"]
-
-    def pre_solve(arbiter, space, data):
-        # We want to update the collision normal to make the bounce direction
-        # dependent of where on the paddle the ball hits. Note that this
-        # calculation isn't perfect, but just a quick example.
-        set_ = arbiter.contact_point_set
-        if len(set_.points) > 0:
-            player_shape = arbiter.shapes[0]
-            width = (player_shape.b - player_shape.a).x
-            delta = (player_shape.body.position - set_.points[0].point_a).x
-            normal = Vec2d(0, 1).rotated(delta / width / 2)
-            set_.normal = normal
-            set_.points[0].distance = 0
-        arbiter.contact_point_set = set_
-        return True
-
-    h = space.add_collision_handler(collision_types["player"], collision_types["ball"])
-    h.pre_solve = pre_solve
-
-    # restrict movement of player to a straigt line
-    move_joint = pymunk.GrooveJoint(
-        space.static_body, player_body, (100, 100), (500, 100), (0, 0)
-    )
-    space.add(player_body, player_shape, move_joint)
-    global state
-    # Start game
-    setup_level(space, player_body)
-
-    while running:
-        for event in pygame.event.get():
-            if event.type == pygame.QUIT:
-                running = False
-            elif event.type == pygame.KEYDOWN and (
-                event.key in [pygame.K_ESCAPE, pygame.K_q]
-            ):
-                running = False
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
-                pygame.image.save(screen, "breakout.png")
-
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_LEFT:
-                player_body.velocity = (-600, 0)
-            elif event.type == pygame.KEYUP and event.key == pygame.K_LEFT:
-                player_body.velocity = 0, 0
-
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_RIGHT:
-                player_body.velocity = (600, 0)
-            elif event.type == pygame.KEYUP and event.key == pygame.K_RIGHT:
-                player_body.velocity = 0, 0
-
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_r:
-                setup_level(space, player_body)
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_SPACE:
-                spawn_ball(
-                    space,
-                    player_body.position + (0, 40),
-                    random.choice([(1, 10), (-1, 10)]),
-                )
-
-        ### Clear screen
-        screen.fill(pygame.Color("black"))
-
-        ### Draw stuff
-        space.debug_draw(draw_options)
-
-        state = []
-        for x in space.shapes:
-            s = "%s %s %s" % (x, x.body.position, x.body.velocity)
-            state.append(s)
-
-        ### Update physics
-        fps = 60
-        dt = 1.0 / fps
-        space.step(dt)
-
-        ### Info and flip screen
-        screen.blit(
-            font.render("fps: " + str(clock.get_fps()), 1, pygame.Color("white")),
-            (0, 0),
-        )
-        screen.blit(
-            font.render(
-                "Move with left/right arrows, space to spawn a ball",
-                1,
-                pygame.Color("darkgrey"),
-            ),
-            (5, height - 35),
-        )
-        screen.blit(
-            font.render(
-                "Press R to reset, ESC or Q to quit", 1, pygame.Color("darkgrey")
-            ),
-            (5, height - 20),
-        )
-
-        pygame.display.flip()
-        clock.tick(fps)
-
-
-if __name__ == "__main__":
-    sys.exit(main())
+"""Very simple breakout clone. A circle shape serves as the paddle, then 
+breakable bricks constructed of Poly-shapes. 
+
+The code showcases several pymunk concepts such as elasitcity, impulses, 
+constant object speed, joints, collision handlers and post step callbacks.
+"""
+
+import random
+import sys
+
+import pygame
+
+import pymunk
+import pymunk.pygame_util
+from pymunk import Vec2d
+
+width, height = 600, 600
+
+
+collision_types = {
+    "ball": 1,
+    "brick": 2,
+    "bottom": 3,
+    "player": 4,
+}
+
+
+def spawn_ball(space, position, direction):
+    ball_body = pymunk.Body(1, float("inf"))
+    ball_body.position = position
+
+    ball_shape = pymunk.Circle(ball_body, 5)
+    ball_shape.color = pygame.Color("green")
+    ball_shape.elasticity = 1.0
+    ball_shape.collision_type = collision_types["ball"]
+
+    ball_body.apply_impulse_at_local_point(Vec2d(*direction))
+
+    # Keep ball velocity at a static value
+    def constant_velocity(body, gravity, damping, dt):
+        body.velocity = body.velocity.normalized() * 400
+
+    ball_body.velocity_func = constant_velocity
+
+    space.add(ball_body, ball_shape)
+
+
+def setup_level(space, player_body):
+
+    # Remove balls and bricks
+    for s in space.shapes[:]:
+        if s.body.body_type == pymunk.Body.DYNAMIC and s.body not in [player_body]:
+            space.remove(s.body, s)
+
+    # Spawn a ball for the player to have something to play with
+    spawn_ball(
+        space, player_body.position + (0, 40), random.choice([(1, 10), (-1, 10)])
+    )
+
+    # Spawn bricks
+    for x in range(0, 21):
+        x = x * 20 + 100
+        for y in range(0, 5):
+            y = y * 10 + 400
+            brick_body = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
+            brick_body.position = x, y
+            brick_shape = pymunk.Poly.create_box(brick_body, (20, 10))
+            brick_shape.elasticity = 1.0
+            brick_shape.color = pygame.Color("blue")
+            brick_shape.group = 1
+            brick_shape.collision_type = collision_types["brick"]
+            space.add(brick_body, brick_shape)
+
+    # Make bricks be removed when hit by ball
+    def remove_brick(arbiter, space, data):
+        brick_shape = arbiter.shapes[0]
+        space.remove(brick_shape, brick_shape.body)
+
+    h = space.add_collision_handler(collision_types["brick"], collision_types["ball"])
+    h.separate = remove_brick
+
+
+def main():
+    ### PyGame init
+    pygame.init()
+    screen = pygame.display.set_mode((width, height))
+    clock = pygame.time.Clock()
+    running = True
+    font = pygame.font.SysFont("Arial", 16)
+    ### Physics stuff
+    space = pymunk.Space()
+    pymunk.pygame_util.positive_y_is_up = True
+    draw_options = pymunk.pygame_util.DrawOptions(screen)
+
+    ### Game area
+    # walls - the left-top-right walls
+    static_lines = [
+        pymunk.Segment(space.static_body, (50, 50), (50, 550), 2),
+        pymunk.Segment(space.static_body, (50, 550), (550, 550), 2),
+        pymunk.Segment(space.static_body, (550, 550), (550, 50), 2),
+    ]
+    for line in static_lines:
+        line.color = pygame.Color("lightgray")
+        line.elasticity = 1.0
+
+    space.add(*static_lines)
+
+    # bottom - a sensor that removes anything touching it
+    bottom = pymunk.Segment(space.static_body, (50, 50), (550, 50), 2)
+    bottom.sensor = True
+    bottom.collision_type = collision_types["bottom"]
+    bottom.color = pygame.Color("red")
+
+    def remove_first(arbiter, space, data):
+        ball_shape = arbiter.shapes[0]
+        space.remove(ball_shape, ball_shape.body)
+        return True
+
+    h = space.add_collision_handler(collision_types["ball"], collision_types["bottom"])
+    h.begin = remove_first
+    space.add(bottom)
+
+    ### Player ship
+    player_body = pymunk.Body(500, float("inf"))
+    player_body.position = 300, 100
+
+    player_shape = pymunk.Segment(player_body, (-50, 0), (50, 0), 8)
+    player_shape.color = pygame.Color("red")
+    player_shape.elasticity = 1.0
+    player_shape.collision_type = collision_types["player"]
+
+    def pre_solve(arbiter, space, data):
+        # We want to update the collision normal to make the bounce direction
+        # dependent of where on the paddle the ball hits. Note that this
+        # calculation isn't perfect, but just a quick example.
+        set_ = arbiter.contact_point_set
+        if len(set_.points) > 0:
+            player_shape = arbiter.shapes[0]
+            width = (player_shape.b - player_shape.a).x
+            delta = (player_shape.body.position - set_.points[0].point_a).x
+            normal = Vec2d(0, 1).rotated(delta / width / 2)
+            set_.normal = normal
+            set_.points[0].distance = 0
+        arbiter.contact_point_set = set_
+        return True
+
+    h = space.add_collision_handler(collision_types["player"], collision_types["ball"])
+    h.pre_solve = pre_solve
+
+    # restrict movement of player to a straigt line
+    move_joint = pymunk.GrooveJoint(
+        space.static_body, player_body, (100, 100), (500, 100), (0, 0)
+    )
+    space.add(player_body, player_shape, move_joint)
+    global state
+    # Start game
+    setup_level(space, player_body)
+
+    while running:
+        for event in pygame.event.get():
+            if event.type == pygame.QUIT:
+                running = False
+            elif event.type == pygame.KEYDOWN and (
+                event.key in [pygame.K_ESCAPE, pygame.K_q]
+            ):
+                running = False
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
+                pygame.image.save(screen, "breakout.png")
+
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_LEFT:
+                player_body.velocity = (-600, 0)
+            elif event.type == pygame.KEYUP and event.key == pygame.K_LEFT:
+                player_body.velocity = 0, 0
+
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_RIGHT:
+                player_body.velocity = (600, 0)
+            elif event.type == pygame.KEYUP and event.key == pygame.K_RIGHT:
+                player_body.velocity = 0, 0
+
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_r:
+                setup_level(space, player_body)
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_SPACE:
+                spawn_ball(
+                    space,
+                    player_body.position + (0, 40),
+                    random.choice([(1, 10), (-1, 10)]),
+                )
+
+        ### Clear screen
+        screen.fill(pygame.Color("black"))
+
+        ### Draw stuff
+        space.debug_draw(draw_options)
+
+        state = []
+        for x in space.shapes:
+            s = "%s %s %s" % (x, x.body.position, x.body.velocity)
+            state.append(s)
+
+        ### Update physics
+        fps = 60
+        dt = 1.0 / fps
+        space.step(dt)
+
+        ### Info and flip screen
+        screen.blit(
+            font.render("fps: " + str(clock.get_fps()), 1, pygame.Color("white")),
+            (0, 0),
+        )
+        screen.blit(
+            font.render(
+                "Move with left/right arrows, space to spawn a ball",
+                1,
+                pygame.Color("darkgrey"),
+            ),
+            (5, height - 35),
+        )
+        screen.blit(
+            font.render(
+                "Press R to reset, ESC or Q to quit", 1, pygame.Color("darkgrey")
+            ),
+            (5, height - 20),
+        )
+
+        pygame.display.flip()
+        clock.tick(fps)
+
+
+if __name__ == "__main__":
+    sys.exit(main())
```

## Comparing `pymunk-6.5.0/pymunk/examples/camera.py` & `pymunk/examples/camera.py`

 * *Ordering differences only*

 * *Files 26% similar despite different names*

```diff
@@ -1,182 +1,182 @@
-"""Basic showcase on how the transform property on SpaceDebugDrawOptions can 
-be used as a camera to allow panning. Use arrows to move the camera.
-"""
-
-__docformat__ = "reStructuredText"
-
-import random
-import sys
-
-import pygame
-
-import pymunk
-import pymunk.pygame_util
-from pymunk.vec2d import Vec2d
-
-random.seed(0)
-
-
-def main():
-    pygame.init()
-    screen = pygame.display.set_mode((600, 600))
-    clock = pygame.time.Clock()
-    running = True
-    font = pygame.font.Font(None, 16)
-    text = font.render(
-        "Use Arrows (up, down, left, right) to move the camera, "
-        "a and z to zoom in / out and s and x to rotate.",
-        True,
-        pygame.Color("black"),
-    )
-
-    ### Physics stuff
-    space = pymunk.Space()
-    space.gravity = Vec2d(0.0, 900.0)
-    draw_options = pymunk.pygame_util.DrawOptions(screen)
-
-    ## Balls
-    balls = []
-
-    body = pymunk.Body()
-    body.position = pymunk.Vec2d(407, 354)
-    s1 = pymunk.Segment(body, Vec2d(-300, -30), Vec2d(0, 0), 1.0)
-    s2 = pymunk.Segment(body, Vec2d(0, 0), Vec2d(0, -100), 1.0)
-    s1.density = 0.1
-    s2.density = 0.1
-    s1.friction = 1
-    s2.friction = 1
-    space.add(body, s1, s2)
-
-    c1 = pymunk.constraints.DampedSpring(
-        space.static_body,
-        body,
-        (427, 200),
-        (0, -100),
-        Vec2d(407, 254).get_distance((427, 200)),
-        2000,
-        100,
-    )
-
-    c2 = pymunk.constraints.DampedSpring(
-        space.static_body,
-        body,
-        (87, 200),
-        (-300, -30),
-        Vec2d(107, 324).get_distance((87, 200)),
-        2000,
-        100,
-    )
-    space.add(c1, c2)
-
-    # extra to show how constraints are drawn when very small / large
-    body = pymunk.Body(1, 100)
-    body.position = 450, 305
-    c3 = pymunk.constraints.DampedSpring(
-        space.static_body, body, (450, 300), (0, 0), 5, 1000, 100
-    )
-    space.add(body, c3)
-    body = pymunk.Body(1, 100)
-    body.position = 500, 2025
-    c3 = pymunk.constraints.DampedSpring(
-        space.static_body, body, (500, 25), (0, 0), 2000, 1000, 100
-    )
-    space.add(body, c3)
-
-    ticks_to_next_ball = 10
-
-    translation = pymunk.Transform()
-    scaling = 1
-    rotation = 0
-
-    while running:
-        for event in pygame.event.get():
-            if (
-                event.type == pygame.QUIT
-                or event.type == pygame.KEYDOWN
-                and event.key == pygame.K_ESCAPE
-            ):
-                running = False
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
-                pygame.image.save(screen, "camera.png")
-
-        keys = pygame.key.get_pressed()
-        left = int(keys[pygame.K_LEFT])
-        up = int(keys[pygame.K_UP])
-        down = int(keys[pygame.K_DOWN])
-        right = int(keys[pygame.K_RIGHT])
-
-        zoom_in = int(keys[pygame.K_a])
-        zoom_out = int(keys[pygame.K_z])
-        rotate_left = int(keys[pygame.K_s])
-        rotate_right = int(keys[pygame.K_x])
-
-        translate_speed = 10
-        translation = translation.translated(
-            translate_speed * left - translate_speed * right,
-            translate_speed * up - translate_speed * down,
-        )
-
-        zoom_speed = 0.1
-        scaling *= 1 + (zoom_speed * zoom_in - zoom_speed * zoom_out)
-
-        rotation_speed = 0.1
-        rotation += rotation_speed * rotate_left - rotation_speed * rotate_right
-
-        # to zoom with center of screen as origin we need to offset with
-        # center of screen, scale, and then offset back
-        draw_options.transform = (
-            pymunk.Transform.translation(300, 300)
-            @ pymunk.Transform.scaling(scaling)
-            @ translation
-            @ pymunk.Transform.rotation(rotation)
-            @ pymunk.Transform.translation(-300, -300)
-        )
-
-        ticks_to_next_ball -= 1
-        if ticks_to_next_ball <= 0:
-            ticks_to_next_ball = 100
-            mass = 10
-            radius = 25
-            inertia = pymunk.moment_for_circle(mass, 0, radius, (0, 0))
-            body = pymunk.Body(mass, inertia)
-            x = random.randint(115, 350)
-            body.position = x, 100
-            if random.random() > 0.5:
-                shape = pymunk.Circle(body, radius)
-            else:
-                shape = pymunk.Poly.create_box(
-                    body, size=(radius * 2, radius * 2), radius=2
-                )
-            shape.friction = 1
-            space.add(body, shape)
-            balls.append(shape)
-
-        ### Clear screen
-        screen.fill(pygame.Color("white"))
-
-        ### Draw stuff
-        space.debug_draw(draw_options)
-
-        balls_to_remove = []
-        for ball in balls:
-            if ball.body.position.y > 500:
-                balls_to_remove.append(ball)
-
-        for ball in balls_to_remove:
-            space.remove(ball, ball.body)
-            balls.remove(ball)
-
-        screen.blit(text, (5, 5))
-
-        ### Update physics
-        dt = 1.0 / 60.0
-        space.step(dt)
-
-        ### Flip screen
-        pygame.display.flip()
-        clock.tick(50)
-        pygame.display.set_caption("fps: " + str(clock.get_fps()))
-
-
-if __name__ == "__main__":
-    sys.exit(main())
+"""Basic showcase on how the transform property on SpaceDebugDrawOptions can 
+be used as a camera to allow panning. Use arrows to move the camera.
+"""
+
+__docformat__ = "reStructuredText"
+
+import random
+import sys
+
+import pygame
+
+import pymunk
+import pymunk.pygame_util
+from pymunk.vec2d import Vec2d
+
+random.seed(0)
+
+
+def main():
+    pygame.init()
+    screen = pygame.display.set_mode((600, 600))
+    clock = pygame.time.Clock()
+    running = True
+    font = pygame.font.Font(None, 16)
+    text = font.render(
+        "Use Arrows (up, down, left, right) to move the camera, "
+        "a and z to zoom in / out and s and x to rotate.",
+        True,
+        pygame.Color("black"),
+    )
+
+    ### Physics stuff
+    space = pymunk.Space()
+    space.gravity = Vec2d(0.0, 900.0)
+    draw_options = pymunk.pygame_util.DrawOptions(screen)
+
+    ## Balls
+    balls = []
+
+    body = pymunk.Body()
+    body.position = pymunk.Vec2d(407, 354)
+    s1 = pymunk.Segment(body, Vec2d(-300, -30), Vec2d(0, 0), 1.0)
+    s2 = pymunk.Segment(body, Vec2d(0, 0), Vec2d(0, -100), 1.0)
+    s1.density = 0.1
+    s2.density = 0.1
+    s1.friction = 1
+    s2.friction = 1
+    space.add(body, s1, s2)
+
+    c1 = pymunk.constraints.DampedSpring(
+        space.static_body,
+        body,
+        (427, 200),
+        (0, -100),
+        Vec2d(407, 254).get_distance((427, 200)),
+        2000,
+        100,
+    )
+
+    c2 = pymunk.constraints.DampedSpring(
+        space.static_body,
+        body,
+        (87, 200),
+        (-300, -30),
+        Vec2d(107, 324).get_distance((87, 200)),
+        2000,
+        100,
+    )
+    space.add(c1, c2)
+
+    # extra to show how constraints are drawn when very small / large
+    body = pymunk.Body(1, 100)
+    body.position = 450, 305
+    c3 = pymunk.constraints.DampedSpring(
+        space.static_body, body, (450, 300), (0, 0), 5, 1000, 100
+    )
+    space.add(body, c3)
+    body = pymunk.Body(1, 100)
+    body.position = 500, 2025
+    c3 = pymunk.constraints.DampedSpring(
+        space.static_body, body, (500, 25), (0, 0), 2000, 1000, 100
+    )
+    space.add(body, c3)
+
+    ticks_to_next_ball = 10
+
+    translation = pymunk.Transform()
+    scaling = 1
+    rotation = 0
+
+    while running:
+        for event in pygame.event.get():
+            if (
+                event.type == pygame.QUIT
+                or event.type == pygame.KEYDOWN
+                and event.key == pygame.K_ESCAPE
+            ):
+                running = False
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
+                pygame.image.save(screen, "camera.png")
+
+        keys = pygame.key.get_pressed()
+        left = int(keys[pygame.K_LEFT])
+        up = int(keys[pygame.K_UP])
+        down = int(keys[pygame.K_DOWN])
+        right = int(keys[pygame.K_RIGHT])
+
+        zoom_in = int(keys[pygame.K_a])
+        zoom_out = int(keys[pygame.K_z])
+        rotate_left = int(keys[pygame.K_s])
+        rotate_right = int(keys[pygame.K_x])
+
+        translate_speed = 10
+        translation = translation.translated(
+            translate_speed * left - translate_speed * right,
+            translate_speed * up - translate_speed * down,
+        )
+
+        zoom_speed = 0.1
+        scaling *= 1 + (zoom_speed * zoom_in - zoom_speed * zoom_out)
+
+        rotation_speed = 0.1
+        rotation += rotation_speed * rotate_left - rotation_speed * rotate_right
+
+        # to zoom with center of screen as origin we need to offset with
+        # center of screen, scale, and then offset back
+        draw_options.transform = (
+            pymunk.Transform.translation(300, 300)
+            @ pymunk.Transform.scaling(scaling)
+            @ translation
+            @ pymunk.Transform.rotation(rotation)
+            @ pymunk.Transform.translation(-300, -300)
+        )
+
+        ticks_to_next_ball -= 1
+        if ticks_to_next_ball <= 0:
+            ticks_to_next_ball = 100
+            mass = 10
+            radius = 25
+            inertia = pymunk.moment_for_circle(mass, 0, radius, (0, 0))
+            body = pymunk.Body(mass, inertia)
+            x = random.randint(115, 350)
+            body.position = x, 100
+            if random.random() > 0.5:
+                shape = pymunk.Circle(body, radius)
+            else:
+                shape = pymunk.Poly.create_box(
+                    body, size=(radius * 2, radius * 2), radius=2
+                )
+            shape.friction = 1
+            space.add(body, shape)
+            balls.append(shape)
+
+        ### Clear screen
+        screen.fill(pygame.Color("white"))
+
+        ### Draw stuff
+        space.debug_draw(draw_options)
+
+        balls_to_remove = []
+        for ball in balls:
+            if ball.body.position.y > 500:
+                balls_to_remove.append(ball)
+
+        for ball in balls_to_remove:
+            space.remove(ball, ball.body)
+            balls.remove(ball)
+
+        screen.blit(text, (5, 5))
+
+        ### Update physics
+        dt = 1.0 / 60.0
+        space.step(dt)
+
+        ### Flip screen
+        pygame.display.flip()
+        clock.tick(50)
+        pygame.display.set_caption("fps: " + str(clock.get_fps()))
+
+
+if __name__ == "__main__":
+    sys.exit(main())
```

## Comparing `pymunk-6.5.0/pymunk/examples/constraints.py` & `pymunk/examples/constraints.py`

 * *Ordering differences only*

 * *Files 19% similar despite different names*

```diff
@@ -1,252 +1,252 @@
-"""
-Pymunk constraints demo. Showcase of all the constraints included in Pymunk.
-
-Adapted from the Chipmunk Joints demo:
-https://github.com/slembcke/Chipmunk2D/blob/master/demo/Joints.c
-"""
-
-import inspect
-import math
-
-import pygame
-
-import pymunk
-import pymunk.pygame_util
-from pymunk.vec2d import Vec2d
-
-pygame.init()
-screen = pygame.display.set_mode((1200, 600))
-clock = pygame.time.Clock()
-font = pygame.font.Font(None, 24)
-
-
-help_txt = font.render(
-    "Pymunk constraints demo. Use mouse to drag/drop. Hover to see descr.",
-    True,
-    pygame.Color("darkgray"),
-)
-
-space = pymunk.Space()
-space.gravity = (0.0, 900.0)
-draw_options = pymunk.pygame_util.DrawOptions(screen)
-
-# containers
-box_size = 200
-w = screen.get_width()
-h = screen.get_height()
-for i in range(6):
-    sw = pymunk.Segment(space.static_body, (0, i * box_size), (w, i * box_size), 1)
-    sw.friction = 1
-    sw.elasticity = 1
-    sh = pymunk.Segment(
-        space.static_body, (i * box_size, 0), (i * box_size, h - box_size), 1
-    )
-    sh.friction = 1
-    sh.elasticity = 1
-    space.add(sw, sh)
-
-
-def add_ball(space, pos, box_offset):
-    body = pymunk.Body()
-    body.position = Vec2d(*pos) + box_offset
-    shape = pymunk.Circle(body, 20)
-    shape.mass = 1
-    shape.friction = 0.7
-    space.add(body, shape)
-    return body
-
-
-def add_bar(space, pos, box_offset):
-    body = pymunk.Body()
-    body.position = Vec2d(*pos) + box_offset
-    shape = pymunk.Segment(body, (0, 40), (0, -40), 6)
-    shape.mass = 2
-    shape.friction = 0.7
-    space.add(body, shape)
-    return body
-
-
-def add_lever(space, pos, box_offset):
-    body = pymunk.Body()
-    body.position = pos + Vec2d(*box_offset) + (0, -20)
-    shape = pymunk.Segment(body, (0, 20), (0, -20), 5)
-    shape.mass = 1
-    shape.friction = 0.7
-    space.add(body, shape)
-    return body
-
-
-def main():
-    txts = {}
-
-    box_offset = 0, 0
-    b1 = add_ball(space, (50, 60), box_offset)
-    b2 = add_ball(space, (150, 60), box_offset)
-    c: pymunk.Constraint = pymunk.PinJoint(b1, b2, (20, 0), (-20, 0))
-    txts[box_offset] = inspect.getdoc(c)
-    space.add(c)
-
-    box_offset = box_size, 0
-    b1 = add_ball(space, (50, 60), box_offset)
-    b2 = add_ball(space, (150, 60), box_offset)
-    c = pymunk.SlideJoint(b1, b2, (20, 0), (-20, 0), 40, 80)
-    txts[box_offset] = inspect.getdoc(c)
-    space.add(c)
-
-    box_offset = box_size * 2, 0
-    b1 = add_ball(space, (50, 60), box_offset)
-    b2 = add_ball(space, (150, 60), box_offset)
-    c = pymunk.PivotJoint(b1, b2, Vec2d(*box_offset) + (100, 60))
-    txts[box_offset] = inspect.getdoc(c)
-    space.add(c)
-
-    box_offset = box_size * 3, 0
-    b1 = add_ball(space, (50, 60), box_offset)
-    b2 = add_ball(space, (150, 60), box_offset)
-    c = pymunk.GrooveJoint(b1, b2, (50, 50), (50, -50), (-50, 0))
-    txts[box_offset] = inspect.getdoc(c)
-    space.add(c)
-
-    box_offset = box_size * 4, 0
-    b1 = add_ball(space, (50, 60), box_offset)
-    b2 = add_ball(space, (150, 60), box_offset)
-    c = pymunk.DampedSpring(b1, b2, (30, 0), (-30, 0), 20, 5, 0.3)
-    txts[box_offset] = inspect.getdoc(c)
-    space.add(c)
-
-    box_offset = box_size * 5, 0
-    b1 = add_bar(space, (50, 80), box_offset)
-    b2 = add_bar(space, (150, 80), box_offset)
-    # Add some joints to hold the circles in place.
-    space.add(pymunk.PivotJoint(b1, space.static_body, (50, 80) + Vec2d(*box_offset)))
-    space.add(pymunk.PivotJoint(b2, space.static_body, (150, 80) + Vec2d(*box_offset)))
-    c = pymunk.DampedRotarySpring(b1, b2, 0, 3000, 60)
-    txts[box_offset] = inspect.getdoc(c)
-    space.add(c)
-
-    box_offset = 0, box_size
-    b1 = add_lever(space, (50, 100), box_offset)
-    b2 = add_lever(space, (150, 100), box_offset)
-    # Add some joints to hold the circles in place.
-    space.add(pymunk.PivotJoint(b1, space.static_body, (50, 100) + Vec2d(*box_offset)))
-    space.add(pymunk.PivotJoint(b2, space.static_body, (150, 100) + Vec2d(*box_offset)))
-    # Hold their rotation within 90 degrees of each other.
-    c = pymunk.RotaryLimitJoint(b1, b2, math.pi / 2, math.pi / 2)
-    txts[box_offset] = inspect.getdoc(c)
-    space.add(c)
-
-    box_offset = box_size, box_size
-    b1 = add_lever(space, (50, 100), box_offset)
-    b2 = add_lever(space, (150, 100), box_offset)
-    # Add some pin joints to hold the circles in place.
-    space.add(pymunk.PivotJoint(b1, space.static_body, (50, 100) + Vec2d(*box_offset)))
-    space.add(pymunk.PivotJoint(b2, space.static_body, (150, 100) + Vec2d(*box_offset)))
-    # Ratchet every 90 degrees
-    c = pymunk.RatchetJoint(b1, b2, 0, math.pi / 2)
-    txts[box_offset] = inspect.getdoc(c)
-    space.add(c)
-
-    box_offset = box_size * 2, box_size
-    b1 = add_bar(space, (50, 100), box_offset)
-    b2 = add_bar(space, (150, 100), box_offset)
-    # Add some pin joints to hold the circles in place.
-    space.add(pymunk.PivotJoint(b1, space.static_body, (50, 100) + Vec2d(*box_offset)))
-    space.add(pymunk.PivotJoint(b2, space.static_body, (150, 100) + Vec2d(*box_offset)))
-    # Force one to sping 2x as fast as the other
-    c = pymunk.GearJoint(b1, b2, 0, 2)
-    txts[box_offset] = inspect.getdoc(c)
-    space.add(c)
-
-    box_offset = box_size * 3, box_size
-    b1 = add_bar(space, (50, 100), box_offset)
-    b2 = add_bar(space, (150, 100), box_offset)
-    # Add some pin joints to hold the circles in place.
-    space.add(pymunk.PivotJoint(b1, space.static_body, (50, 100) + Vec2d(*box_offset)))
-    space.add(pymunk.PivotJoint(b2, space.static_body, (150, 100) + Vec2d(*box_offset)))
-    # Make them spin at 1/2 revolution per second in relation to each other.
-    c = pymunk.SimpleMotor(b1, b2, math.pi)
-    txts[box_offset] = inspect.getdoc(c)
-    space.add(c)
-
-    # TODO add one or two advanced constraints examples, such as a car or rope
-
-    mouse_joint = None
-    mouse_body = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
-
-    # Build rendered help texts
-    box_texts = {}
-    for k in txts:
-        l = 0
-        box_texts[k] = []
-        # Only take the first 5 lines.
-        for line in txts[k].splitlines()[:5]:
-            txt = font.render(line, True, pygame.Color("black"))
-            box_texts[k].append(txt)
-
-    while True:
-        for event in pygame.event.get():
-            if event.type == pygame.QUIT:
-                exit()
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
-                exit()
-            elif event.type == pygame.MOUSEBUTTONDOWN:
-                if mouse_joint is not None:
-                    space.remove(mouse_joint)
-                    mouse_joint = None
-
-                p = Vec2d(*event.pos)
-                hit = space.point_query_nearest(p, 5, pymunk.ShapeFilter())
-                if hit is not None and hit.shape.body.body_type == pymunk.Body.DYNAMIC:
-                    shape = hit.shape
-                    # Use the closest point on the surface if the click is outside
-                    # of the shape.
-                    if hit.distance > 0:
-                        nearest = hit.point
-                    else:
-                        nearest = p
-                    mouse_joint = pymunk.PivotJoint(
-                        mouse_body,
-                        shape.body,
-                        (0, 0),
-                        shape.body.world_to_local(nearest),
-                    )
-                    mouse_joint.max_force = 50000
-                    mouse_joint.error_bias = (1 - 0.15) ** 60
-                    space.add(mouse_joint)
-
-            elif event.type == pygame.MOUSEBUTTONUP:
-                if mouse_joint is not None:
-                    space.remove(mouse_joint)
-                    mouse_joint = None
-
-        screen.fill(pygame.Color("white"))
-
-        screen.blit(help_txt, (5, screen.get_height() - 20))
-
-        mouse_pos = pygame.mouse.get_pos()
-
-        # Display help message
-        x = mouse_pos[0] // box_size * box_size
-        y = mouse_pos[1] // box_size * box_size
-
-        if (x, y) in box_texts:
-            txts = box_texts[(x, y)]
-            i = 0
-            for txt in txts:
-                pos = (5, box_size * 2 + 10 + i * 20)
-                screen.blit(txt, pos)
-                i += 1
-
-        mouse_body.position = mouse_pos
-
-        space.step(1.0 / 60)
-
-        space.debug_draw(draw_options)
-        pygame.display.flip()
-
-        clock.tick(60)
-        pygame.display.set_caption(f"fps: {clock.get_fps()}")
-
-
-if __name__ == "__main__":
+"""
+Pymunk constraints demo. Showcase of all the constraints included in Pymunk.
+
+Adapted from the Chipmunk Joints demo:
+https://github.com/slembcke/Chipmunk2D/blob/master/demo/Joints.c
+"""
+
+import inspect
+import math
+
+import pygame
+
+import pymunk
+import pymunk.pygame_util
+from pymunk.vec2d import Vec2d
+
+pygame.init()
+screen = pygame.display.set_mode((1200, 600))
+clock = pygame.time.Clock()
+font = pygame.font.Font(None, 24)
+
+
+help_txt = font.render(
+    "Pymunk constraints demo. Use mouse to drag/drop. Hover to see descr.",
+    True,
+    pygame.Color("darkgray"),
+)
+
+space = pymunk.Space()
+space.gravity = (0.0, 900.0)
+draw_options = pymunk.pygame_util.DrawOptions(screen)
+
+# containers
+box_size = 200
+w = screen.get_width()
+h = screen.get_height()
+for i in range(6):
+    sw = pymunk.Segment(space.static_body, (0, i * box_size), (w, i * box_size), 1)
+    sw.friction = 1
+    sw.elasticity = 1
+    sh = pymunk.Segment(
+        space.static_body, (i * box_size, 0), (i * box_size, h - box_size), 1
+    )
+    sh.friction = 1
+    sh.elasticity = 1
+    space.add(sw, sh)
+
+
+def add_ball(space, pos, box_offset):
+    body = pymunk.Body()
+    body.position = Vec2d(*pos) + box_offset
+    shape = pymunk.Circle(body, 20)
+    shape.mass = 1
+    shape.friction = 0.7
+    space.add(body, shape)
+    return body
+
+
+def add_bar(space, pos, box_offset):
+    body = pymunk.Body()
+    body.position = Vec2d(*pos) + box_offset
+    shape = pymunk.Segment(body, (0, 40), (0, -40), 6)
+    shape.mass = 2
+    shape.friction = 0.7
+    space.add(body, shape)
+    return body
+
+
+def add_lever(space, pos, box_offset):
+    body = pymunk.Body()
+    body.position = pos + Vec2d(*box_offset) + (0, -20)
+    shape = pymunk.Segment(body, (0, 20), (0, -20), 5)
+    shape.mass = 1
+    shape.friction = 0.7
+    space.add(body, shape)
+    return body
+
+
+def main():
+    txts = {}
+
+    box_offset = 0, 0
+    b1 = add_ball(space, (50, 60), box_offset)
+    b2 = add_ball(space, (150, 60), box_offset)
+    c: pymunk.Constraint = pymunk.PinJoint(b1, b2, (20, 0), (-20, 0))
+    txts[box_offset] = inspect.getdoc(c)
+    space.add(c)
+
+    box_offset = box_size, 0
+    b1 = add_ball(space, (50, 60), box_offset)
+    b2 = add_ball(space, (150, 60), box_offset)
+    c = pymunk.SlideJoint(b1, b2, (20, 0), (-20, 0), 40, 80)
+    txts[box_offset] = inspect.getdoc(c)
+    space.add(c)
+
+    box_offset = box_size * 2, 0
+    b1 = add_ball(space, (50, 60), box_offset)
+    b2 = add_ball(space, (150, 60), box_offset)
+    c = pymunk.PivotJoint(b1, b2, Vec2d(*box_offset) + (100, 60))
+    txts[box_offset] = inspect.getdoc(c)
+    space.add(c)
+
+    box_offset = box_size * 3, 0
+    b1 = add_ball(space, (50, 60), box_offset)
+    b2 = add_ball(space, (150, 60), box_offset)
+    c = pymunk.GrooveJoint(b1, b2, (50, 50), (50, -50), (-50, 0))
+    txts[box_offset] = inspect.getdoc(c)
+    space.add(c)
+
+    box_offset = box_size * 4, 0
+    b1 = add_ball(space, (50, 60), box_offset)
+    b2 = add_ball(space, (150, 60), box_offset)
+    c = pymunk.DampedSpring(b1, b2, (30, 0), (-30, 0), 20, 5, 0.3)
+    txts[box_offset] = inspect.getdoc(c)
+    space.add(c)
+
+    box_offset = box_size * 5, 0
+    b1 = add_bar(space, (50, 80), box_offset)
+    b2 = add_bar(space, (150, 80), box_offset)
+    # Add some joints to hold the circles in place.
+    space.add(pymunk.PivotJoint(b1, space.static_body, (50, 80) + Vec2d(*box_offset)))
+    space.add(pymunk.PivotJoint(b2, space.static_body, (150, 80) + Vec2d(*box_offset)))
+    c = pymunk.DampedRotarySpring(b1, b2, 0, 3000, 60)
+    txts[box_offset] = inspect.getdoc(c)
+    space.add(c)
+
+    box_offset = 0, box_size
+    b1 = add_lever(space, (50, 100), box_offset)
+    b2 = add_lever(space, (150, 100), box_offset)
+    # Add some joints to hold the circles in place.
+    space.add(pymunk.PivotJoint(b1, space.static_body, (50, 100) + Vec2d(*box_offset)))
+    space.add(pymunk.PivotJoint(b2, space.static_body, (150, 100) + Vec2d(*box_offset)))
+    # Hold their rotation within 90 degrees of each other.
+    c = pymunk.RotaryLimitJoint(b1, b2, math.pi / 2, math.pi / 2)
+    txts[box_offset] = inspect.getdoc(c)
+    space.add(c)
+
+    box_offset = box_size, box_size
+    b1 = add_lever(space, (50, 100), box_offset)
+    b2 = add_lever(space, (150, 100), box_offset)
+    # Add some pin joints to hold the circles in place.
+    space.add(pymunk.PivotJoint(b1, space.static_body, (50, 100) + Vec2d(*box_offset)))
+    space.add(pymunk.PivotJoint(b2, space.static_body, (150, 100) + Vec2d(*box_offset)))
+    # Ratchet every 90 degrees
+    c = pymunk.RatchetJoint(b1, b2, 0, math.pi / 2)
+    txts[box_offset] = inspect.getdoc(c)
+    space.add(c)
+
+    box_offset = box_size * 2, box_size
+    b1 = add_bar(space, (50, 100), box_offset)
+    b2 = add_bar(space, (150, 100), box_offset)
+    # Add some pin joints to hold the circles in place.
+    space.add(pymunk.PivotJoint(b1, space.static_body, (50, 100) + Vec2d(*box_offset)))
+    space.add(pymunk.PivotJoint(b2, space.static_body, (150, 100) + Vec2d(*box_offset)))
+    # Force one to sping 2x as fast as the other
+    c = pymunk.GearJoint(b1, b2, 0, 2)
+    txts[box_offset] = inspect.getdoc(c)
+    space.add(c)
+
+    box_offset = box_size * 3, box_size
+    b1 = add_bar(space, (50, 100), box_offset)
+    b2 = add_bar(space, (150, 100), box_offset)
+    # Add some pin joints to hold the circles in place.
+    space.add(pymunk.PivotJoint(b1, space.static_body, (50, 100) + Vec2d(*box_offset)))
+    space.add(pymunk.PivotJoint(b2, space.static_body, (150, 100) + Vec2d(*box_offset)))
+    # Make them spin at 1/2 revolution per second in relation to each other.
+    c = pymunk.SimpleMotor(b1, b2, math.pi)
+    txts[box_offset] = inspect.getdoc(c)
+    space.add(c)
+
+    # TODO add one or two advanced constraints examples, such as a car or rope
+
+    mouse_joint = None
+    mouse_body = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
+
+    # Build rendered help texts
+    box_texts = {}
+    for k in txts:
+        l = 0
+        box_texts[k] = []
+        # Only take the first 5 lines.
+        for line in txts[k].splitlines()[:5]:
+            txt = font.render(line, True, pygame.Color("black"))
+            box_texts[k].append(txt)
+
+    while True:
+        for event in pygame.event.get():
+            if event.type == pygame.QUIT:
+                exit()
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
+                exit()
+            elif event.type == pygame.MOUSEBUTTONDOWN:
+                if mouse_joint is not None:
+                    space.remove(mouse_joint)
+                    mouse_joint = None
+
+                p = Vec2d(*event.pos)
+                hit = space.point_query_nearest(p, 5, pymunk.ShapeFilter())
+                if hit is not None and hit.shape.body.body_type == pymunk.Body.DYNAMIC:
+                    shape = hit.shape
+                    # Use the closest point on the surface if the click is outside
+                    # of the shape.
+                    if hit.distance > 0:
+                        nearest = hit.point
+                    else:
+                        nearest = p
+                    mouse_joint = pymunk.PivotJoint(
+                        mouse_body,
+                        shape.body,
+                        (0, 0),
+                        shape.body.world_to_local(nearest),
+                    )
+                    mouse_joint.max_force = 50000
+                    mouse_joint.error_bias = (1 - 0.15) ** 60
+                    space.add(mouse_joint)
+
+            elif event.type == pygame.MOUSEBUTTONUP:
+                if mouse_joint is not None:
+                    space.remove(mouse_joint)
+                    mouse_joint = None
+
+        screen.fill(pygame.Color("white"))
+
+        screen.blit(help_txt, (5, screen.get_height() - 20))
+
+        mouse_pos = pygame.mouse.get_pos()
+
+        # Display help message
+        x = mouse_pos[0] // box_size * box_size
+        y = mouse_pos[1] // box_size * box_size
+
+        if (x, y) in box_texts:
+            txts = box_texts[(x, y)]
+            i = 0
+            for txt in txts:
+                pos = (5, box_size * 2 + 10 + i * 20)
+                screen.blit(txt, pos)
+                i += 1
+
+        mouse_body.position = mouse_pos
+
+        space.step(1.0 / 60)
+
+        space.debug_draw(draw_options)
+        pygame.display.flip()
+
+        clock.tick(60)
+        pygame.display.set_caption(f"fps: {clock.get_fps()}")
+
+
+if __name__ == "__main__":
     main()
```

## Comparing `pymunk-6.5.0/pymunk/examples/contact_and_no_flipy.py` & `pymunk/examples/contact_and_no_flipy.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,105 +1,105 @@
-"""This example spawns (bouncing) balls randomly on a L-shape constructed of 
-two segment shapes. For each collision it draws a red circle with size 
-depending on collision strength. Not interactive.
-"""
-
-import random
-import sys
-
-import pygame
-
-import pymunk as pm
-from pymunk import Vec2d
-
-
-def draw_collision(arbiter, space, data):
-    for c in arbiter.contact_point_set.points:
-        r = max(3, abs(c.distance * 5))
-        r = int(r)
-        p = tuple(map(int, c.point_a))
-        pygame.draw.circle(data["surface"], pygame.Color("red"), p, r, 0)
-
-
-def main():
-
-    pygame.init()
-    screen = pygame.display.set_mode((600, 600))
-    clock = pygame.time.Clock()
-    running = True
-
-    ### Physics stuff
-    space = pm.Space()
-    space.gravity = (0.0, 900.0)
-
-    ## Balls
-    balls = []
-
-    ### walls
-    static_lines = [
-        pm.Segment(space.static_body, (111.0, 320.0), (407.0, 354.0), 0.0),
-        pm.Segment(space.static_body, (407.0, 354.0), (407.0, 257.0), 0.0),
-    ]
-    space.add(*static_lines)
-
-    ticks_to_next_ball = 10
-
-    ch = space.add_collision_handler(0, 0)
-    ch.data["surface"] = screen
-    ch.post_solve = draw_collision
-
-    while running:
-        for event in pygame.event.get():
-            if event.type == pygame.QUIT:
-                running = False
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
-                running = False
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
-                pygame.image.save(screen, "contact_and_no_flipy.png")
-
-        ticks_to_next_ball -= 1
-        if ticks_to_next_ball <= 0:
-            ticks_to_next_ball = 100
-            mass = 10
-            radius = 25
-            inertia = pm.moment_for_circle(mass, 0, radius, (0, 0))
-            body = pm.Body(mass, inertia)
-            x = random.randint(115, 350)
-            body.position = x, 200
-            shape = pm.Circle(body, radius, (0, 0))
-            space.add(body, shape)
-            balls.append(shape)
-
-        ### Clear screen
-        screen.fill(pygame.Color("white"))
-
-        ### Draw stuff
-        balls_to_remove = []
-        for ball in balls:
-            if ball.body.position.y > 400:
-                balls_to_remove.append(ball)
-            p = tuple(map(int, ball.body.position))
-            pygame.draw.circle(screen, pygame.Color("blue"), p, int(ball.radius), 2)
-
-        for ball in balls_to_remove:
-            space.remove(ball, ball.body)
-            balls.remove(ball)
-
-        for line in static_lines:
-            body = line.body
-            p1 = tuple(map(int, body.position + line.a.rotated(body.angle)))
-            p2 = tuple(map(int, body.position + line.b.rotated(body.angle)))
-            pygame.draw.lines(screen, pygame.Color("lightgray"), False, [p1, p2])
-
-        ### Update physics
-        dt = 1.0 / 60.0
-        for x in range(1):
-            space.step(dt)
-
-        ### Flip screen
-        pygame.display.flip()
-        clock.tick(50)
-        pygame.display.set_caption("fps: " + str(clock.get_fps()))
-
-
-if __name__ == "__main__":
-    sys.exit(main())
+"""This example spawns (bouncing) balls randomly on a L-shape constructed of 
+two segment shapes. For each collision it draws a red circle with size 
+depending on collision strength. Not interactive.
+"""
+
+import random
+import sys
+
+import pygame
+
+import pymunk as pm
+from pymunk import Vec2d
+
+
+def draw_collision(arbiter, space, data):
+    for c in arbiter.contact_point_set.points:
+        r = max(3, abs(c.distance * 5))
+        r = int(r)
+        p = tuple(map(int, c.point_a))
+        pygame.draw.circle(data["surface"], pygame.Color("red"), p, r, 0)
+
+
+def main():
+
+    pygame.init()
+    screen = pygame.display.set_mode((600, 600))
+    clock = pygame.time.Clock()
+    running = True
+
+    ### Physics stuff
+    space = pm.Space()
+    space.gravity = (0.0, 900.0)
+
+    ## Balls
+    balls = []
+
+    ### walls
+    static_lines = [
+        pm.Segment(space.static_body, (111.0, 320.0), (407.0, 354.0), 0.0),
+        pm.Segment(space.static_body, (407.0, 354.0), (407.0, 257.0), 0.0),
+    ]
+    space.add(*static_lines)
+
+    ticks_to_next_ball = 10
+
+    ch = space.add_collision_handler(0, 0)
+    ch.data["surface"] = screen
+    ch.post_solve = draw_collision
+
+    while running:
+        for event in pygame.event.get():
+            if event.type == pygame.QUIT:
+                running = False
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
+                running = False
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
+                pygame.image.save(screen, "contact_and_no_flipy.png")
+
+        ticks_to_next_ball -= 1
+        if ticks_to_next_ball <= 0:
+            ticks_to_next_ball = 100
+            mass = 10
+            radius = 25
+            inertia = pm.moment_for_circle(mass, 0, radius, (0, 0))
+            body = pm.Body(mass, inertia)
+            x = random.randint(115, 350)
+            body.position = x, 200
+            shape = pm.Circle(body, radius, (0, 0))
+            space.add(body, shape)
+            balls.append(shape)
+
+        ### Clear screen
+        screen.fill(pygame.Color("white"))
+
+        ### Draw stuff
+        balls_to_remove = []
+        for ball in balls:
+            if ball.body.position.y > 400:
+                balls_to_remove.append(ball)
+            p = tuple(map(int, ball.body.position))
+            pygame.draw.circle(screen, pygame.Color("blue"), p, int(ball.radius), 2)
+
+        for ball in balls_to_remove:
+            space.remove(ball, ball.body)
+            balls.remove(ball)
+
+        for line in static_lines:
+            body = line.body
+            p1 = tuple(map(int, body.position + line.a.rotated(body.angle)))
+            p2 = tuple(map(int, body.position + line.b.rotated(body.angle)))
+            pygame.draw.lines(screen, pygame.Color("lightgray"), False, [p1, p2])
+
+        ### Update physics
+        dt = 1.0 / 60.0
+        for x in range(1):
+            space.step(dt)
+
+        ### Flip screen
+        pygame.display.flip()
+        clock.tick(50)
+        pygame.display.set_caption("fps: " + str(clock.get_fps()))
+
+
+if __name__ == "__main__":
+    sys.exit(main())
```

## Comparing `pymunk-6.5.0/pymunk/examples/contact_with_friction.py` & `pymunk/examples/contact_with_friction.py`

 * *Ordering differences only*

 * *Files 21% similar despite different names*

```diff
@@ -1,109 +1,109 @@
-"""This example spawns (bouncing) balls randomly on a L-shape constructed of 
-two segment shapes. Displays collsion strength and rotating balls thanks to 
-friction. Not interactive.
-"""
-
-import random
-import sys
-
-import pygame
-
-import pymunk
-import pymunk.pygame_util
-from pymunk import Vec2d
-
-pymunk.pygame_util.positive_y_is_up = True
-
-
-def draw_collision(arbiter, space, data):
-    for c in arbiter.contact_point_set.points:
-        r = max(3, abs(c.distance * 5))
-        r = int(r)
-
-        p = pymunk.pygame_util.to_pygame(c.point_a, data["surface"])
-        pygame.draw.circle(data["surface"], pygame.Color("black"), p, r, 1)
-
-
-def main():
-
-    pygame.init()
-    screen = pygame.display.set_mode((600, 600))
-    clock = pygame.time.Clock()
-    running = True
-
-    ### Physics stuff
-    space = pymunk.Space()
-    space.gravity = (0.0, -900.0)
-    draw_options = pymunk.pygame_util.DrawOptions(screen)
-    # disable the build in debug draw of collision point since we use our own code.
-    draw_options.flags = (
-        draw_options.flags ^ pymunk.pygame_util.DrawOptions.DRAW_COLLISION_POINTS
-    )
-    ## Balls
-    balls = []
-
-    ### walls
-    static_lines = [
-        pymunk.Segment(space.static_body, (11.0, 280.0), (407.0, 246.0), 0.0),
-        pymunk.Segment(space.static_body, (407.0, 246.0), (407.0, 343.0), 0.0),
-    ]
-    for l in static_lines:
-        l.friction = 0.5
-    space.add(*static_lines)
-
-    ticks_to_next_ball = 10
-
-    ch = space.add_collision_handler(0, 0)
-    ch.data["surface"] = screen
-    ch.post_solve = draw_collision
-
-    while running:
-        for event in pygame.event.get():
-            if event.type == pygame.QUIT:
-                running = False
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
-                running = False
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
-                pygame.image.save(screen, "contact_with_friction.png")
-
-        ticks_to_next_ball -= 1
-        if ticks_to_next_ball <= 0:
-            ticks_to_next_ball = 100
-            mass = 0.1
-            radius = 25
-            inertia = pymunk.moment_for_circle(mass, 0, radius, (0, 0))
-            body = pymunk.Body(mass, inertia)
-            x = random.randint(115, 350)
-            body.position = x, 400
-            shape = pymunk.Circle(body, radius, (0, 0))
-            shape.friction = 0.5
-            space.add(body, shape)
-            balls.append(shape)
-
-        ### Clear screen
-        screen.fill(pygame.Color("white"))
-
-        ### Draw stuff
-        space.debug_draw(draw_options)
-
-        balls_to_remove = []
-        for ball in balls:
-            if ball.body.position.y < 200:
-                balls_to_remove.append(ball)
-        for ball in balls_to_remove:
-            space.remove(ball, ball.body)
-            balls.remove(ball)
-
-        ### Update physics
-        dt = 1.0 / 60.0
-        for x in range(1):
-            space.step(dt)
-
-        ### Flip screen
-        pygame.display.flip()
-        clock.tick(50)
-        pygame.display.set_caption("fps: " + str(clock.get_fps()))
-
-
-if __name__ == "__main__":
-    sys.exit(main())
+"""This example spawns (bouncing) balls randomly on a L-shape constructed of 
+two segment shapes. Displays collsion strength and rotating balls thanks to 
+friction. Not interactive.
+"""
+
+import random
+import sys
+
+import pygame
+
+import pymunk
+import pymunk.pygame_util
+from pymunk import Vec2d
+
+pymunk.pygame_util.positive_y_is_up = True
+
+
+def draw_collision(arbiter, space, data):
+    for c in arbiter.contact_point_set.points:
+        r = max(3, abs(c.distance * 5))
+        r = int(r)
+
+        p = pymunk.pygame_util.to_pygame(c.point_a, data["surface"])
+        pygame.draw.circle(data["surface"], pygame.Color("black"), p, r, 1)
+
+
+def main():
+
+    pygame.init()
+    screen = pygame.display.set_mode((600, 600))
+    clock = pygame.time.Clock()
+    running = True
+
+    ### Physics stuff
+    space = pymunk.Space()
+    space.gravity = (0.0, -900.0)
+    draw_options = pymunk.pygame_util.DrawOptions(screen)
+    # disable the build in debug draw of collision point since we use our own code.
+    draw_options.flags = (
+        draw_options.flags ^ pymunk.pygame_util.DrawOptions.DRAW_COLLISION_POINTS
+    )
+    ## Balls
+    balls = []
+
+    ### walls
+    static_lines = [
+        pymunk.Segment(space.static_body, (11.0, 280.0), (407.0, 246.0), 0.0),
+        pymunk.Segment(space.static_body, (407.0, 246.0), (407.0, 343.0), 0.0),
+    ]
+    for l in static_lines:
+        l.friction = 0.5
+    space.add(*static_lines)
+
+    ticks_to_next_ball = 10
+
+    ch = space.add_collision_handler(0, 0)
+    ch.data["surface"] = screen
+    ch.post_solve = draw_collision
+
+    while running:
+        for event in pygame.event.get():
+            if event.type == pygame.QUIT:
+                running = False
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
+                running = False
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
+                pygame.image.save(screen, "contact_with_friction.png")
+
+        ticks_to_next_ball -= 1
+        if ticks_to_next_ball <= 0:
+            ticks_to_next_ball = 100
+            mass = 0.1
+            radius = 25
+            inertia = pymunk.moment_for_circle(mass, 0, radius, (0, 0))
+            body = pymunk.Body(mass, inertia)
+            x = random.randint(115, 350)
+            body.position = x, 400
+            shape = pymunk.Circle(body, radius, (0, 0))
+            shape.friction = 0.5
+            space.add(body, shape)
+            balls.append(shape)
+
+        ### Clear screen
+        screen.fill(pygame.Color("white"))
+
+        ### Draw stuff
+        space.debug_draw(draw_options)
+
+        balls_to_remove = []
+        for ball in balls:
+            if ball.body.position.y < 200:
+                balls_to_remove.append(ball)
+        for ball in balls_to_remove:
+            space.remove(ball, ball.body)
+            balls.remove(ball)
+
+        ### Update physics
+        dt = 1.0 / 60.0
+        for x in range(1):
+            space.step(dt)
+
+        ### Flip screen
+        pygame.display.flip()
+        clock.tick(50)
+        pygame.display.set_caption("fps: " + str(clock.get_fps()))
+
+
+if __name__ == "__main__":
+    sys.exit(main())
```

## Comparing `pymunk-6.5.0/pymunk/examples/copy_and_pickle.py` & `pymunk/examples/copy_and_pickle.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,139 +1,139 @@
-"""This example shows how you can copy, save and load a space using pickle.
-"""
-import pickle
-
-import pygame
-
-import pymunk
-import pymunk.pygame_util
-from pymunk import Vec2d
-
-width, height = 800, 600
-
-
-def main():
-    pygame.init()
-    screen = pygame.display.set_mode((width, height))
-    clock = pygame.time.Clock()
-    font = pygame.font.SysFont("Arial", 16)
-
-    # We will draw two versions of the Pymunk Space, each on a separate surface
-    # to make it easy to show both at the same time.
-    surf1 = pygame.Surface((300, 300))
-    surf2 = pygame.Surface((300, 300))
-
-    # Setup the base Pymunk Space.
-    space1 = pymunk.Space()
-    space1.gravity = 0, 1000
-    space1.sleep_time_threshold = 0.5
-
-    draw_options1 = pymunk.pygame_util.DrawOptions(surf1)
-    draw_options2 = pymunk.pygame_util.DrawOptions(surf2)
-
-    box = [(5, 5), (295, 5), (295, 295), (5, 295)]
-    for i, p1 in enumerate(box):
-        if i + 1 >= len(box):
-            p2 = box[0]
-        else:
-            p2 = box[i + 1]
-        l = pymunk.Segment(space1.static_body, p1, p2, 5)
-        l.elasticity = 0.5
-        l.friction = 1
-
-        space1.add(l)
-
-    template_box = pymunk.Poly.create_box(pymunk.Body(), (20, 20))
-    template_box.mass = 1
-    template_box.friction = 1
-
-    for x in range(3):
-        for y in range(7):
-            box = template_box.copy()
-            box.body.position = 200 + x * 30, 290 - y * 20
-            space1.add(box, box.body)
-
-    b = pymunk.Body()
-    b.position = 30, 270
-    ball = pymunk.Circle(b, 20)
-    ball.mass = 20
-    ball.friction = 1
-    ball.color = pygame.Color("red")
-    space1.add(ball, b)
-
-    # this is the same as space2 = copy.deepcopy(space1)
-    space2 = space1.copy()
-    space2.sleep_time_threshold = float("inf")
-
-    backup1 = space1.copy()
-    backup2 = space2.copy()
-
-    while True:
-        for event in pygame.event.get():
-            if event.type == pygame.QUIT:
-                sys.exit()
-            elif event.type == pygame.KEYDOWN and (
-                event.key in [pygame.K_ESCAPE, pygame.K_q]
-            ):
-                sys.exit()
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_s:
-                with open("copy_and_pickle.pickle", "wb") as f:
-                    pickle.dump([space1, space2], f)
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_l:
-                with open("copy_and_pickle.pickle", "rb") as f:
-                    (space1, space2) = pickle.load(f)
-
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_r:
-                space1 = backup1
-                space2 = backup2
-                backup1 = space1.copy()
-                backup2 = space2.copy()
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_SPACE:
-                # find all bodies with a circle shape in all spaces
-                for s in space1.shapes + space2.shapes:
-                    if isinstance(s, pymunk.Circle) and s.body != None:
-                        s.body.apply_impulse_at_local_point((20000, 0))
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
-                pygame.image.save(screen, "copy_and_pickle.png")
-
-        ### Clear screen
-        screen.fill(pygame.Color("white"))
-
-        ### Draw stuff
-        surf1.fill(pygame.Color("white"))
-        surf2.fill(pygame.Color("white"))
-
-        space1.debug_draw(draw_options1)
-        space2.debug_draw(draw_options2)
-
-        screen.blit(surf1, (50, 100))
-        screen.blit(surf2, (450, 100))
-
-        ### Update physics
-        fps = 60
-        dt = 1.0 / fps
-        space1.step(dt)
-        space2.step(dt)
-
-        ### Info and flip screen
-        def bt(txt, pos):
-            screen.blit(font.render(txt, True, pygame.Color("black")), pos)
-
-        bt("space.sleep_time_threshold set to 0.5 seconds", (50, 80))
-        bt("space.sleep_time_threshold set to inf (disabled)", (450, 80))
-
-        bt("fps: " + str(clock.get_fps()), (0, 0))
-        bt("Press SPACE to give an impulse to the ball.", (5, height - 50))
-        bt(
-            "Press S to save the current state to file, press L to load it.",
-            (5, height - 35),
-        )
-        bt("Press R to reset, ESC or Q to quit", (5, height - 20))
-
-        pygame.display.flip()
-        clock.tick(fps)
-
-
-if __name__ == "__main__":
-    import sys
-
-    sys.exit(main())
+"""This example shows how you can copy, save and load a space using pickle.
+"""
+import pickle
+
+import pygame
+
+import pymunk
+import pymunk.pygame_util
+from pymunk import Vec2d
+
+width, height = 800, 600
+
+
+def main():
+    pygame.init()
+    screen = pygame.display.set_mode((width, height))
+    clock = pygame.time.Clock()
+    font = pygame.font.SysFont("Arial", 16)
+
+    # We will draw two versions of the Pymunk Space, each on a separate surface
+    # to make it easy to show both at the same time.
+    surf1 = pygame.Surface((300, 300))
+    surf2 = pygame.Surface((300, 300))
+
+    # Setup the base Pymunk Space.
+    space1 = pymunk.Space()
+    space1.gravity = 0, 1000
+    space1.sleep_time_threshold = 0.5
+
+    draw_options1 = pymunk.pygame_util.DrawOptions(surf1)
+    draw_options2 = pymunk.pygame_util.DrawOptions(surf2)
+
+    box = [(5, 5), (295, 5), (295, 295), (5, 295)]
+    for i, p1 in enumerate(box):
+        if i + 1 >= len(box):
+            p2 = box[0]
+        else:
+            p2 = box[i + 1]
+        l = pymunk.Segment(space1.static_body, p1, p2, 5)
+        l.elasticity = 0.5
+        l.friction = 1
+
+        space1.add(l)
+
+    template_box = pymunk.Poly.create_box(pymunk.Body(), (20, 20))
+    template_box.mass = 1
+    template_box.friction = 1
+
+    for x in range(3):
+        for y in range(7):
+            box = template_box.copy()
+            box.body.position = 200 + x * 30, 290 - y * 20
+            space1.add(box, box.body)
+
+    b = pymunk.Body()
+    b.position = 30, 270
+    ball = pymunk.Circle(b, 20)
+    ball.mass = 20
+    ball.friction = 1
+    ball.color = pygame.Color("red")
+    space1.add(ball, b)
+
+    # this is the same as space2 = copy.deepcopy(space1)
+    space2 = space1.copy()
+    space2.sleep_time_threshold = float("inf")
+
+    backup1 = space1.copy()
+    backup2 = space2.copy()
+
+    while True:
+        for event in pygame.event.get():
+            if event.type == pygame.QUIT:
+                sys.exit()
+            elif event.type == pygame.KEYDOWN and (
+                event.key in [pygame.K_ESCAPE, pygame.K_q]
+            ):
+                sys.exit()
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_s:
+                with open("copy_and_pickle.pickle", "wb") as f:
+                    pickle.dump([space1, space2], f)
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_l:
+                with open("copy_and_pickle.pickle", "rb") as f:
+                    (space1, space2) = pickle.load(f)
+
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_r:
+                space1 = backup1
+                space2 = backup2
+                backup1 = space1.copy()
+                backup2 = space2.copy()
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_SPACE:
+                # find all bodies with a circle shape in all spaces
+                for s in space1.shapes + space2.shapes:
+                    if isinstance(s, pymunk.Circle) and s.body != None:
+                        s.body.apply_impulse_at_local_point((20000, 0))
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
+                pygame.image.save(screen, "copy_and_pickle.png")
+
+        ### Clear screen
+        screen.fill(pygame.Color("white"))
+
+        ### Draw stuff
+        surf1.fill(pygame.Color("white"))
+        surf2.fill(pygame.Color("white"))
+
+        space1.debug_draw(draw_options1)
+        space2.debug_draw(draw_options2)
+
+        screen.blit(surf1, (50, 100))
+        screen.blit(surf2, (450, 100))
+
+        ### Update physics
+        fps = 60
+        dt = 1.0 / fps
+        space1.step(dt)
+        space2.step(dt)
+
+        ### Info and flip screen
+        def bt(txt, pos):
+            screen.blit(font.render(txt, True, pygame.Color("black")), pos)
+
+        bt("space.sleep_time_threshold set to 0.5 seconds", (50, 80))
+        bt("space.sleep_time_threshold set to inf (disabled)", (450, 80))
+
+        bt("fps: " + str(clock.get_fps()), (0, 0))
+        bt("Press SPACE to give an impulse to the ball.", (5, height - 50))
+        bt(
+            "Press S to save the current state to file, press L to load it.",
+            (5, height - 35),
+        )
+        bt("Press R to reset, ESC or Q to quit", (5, height - 20))
+
+        pygame.display.flip()
+        clock.tick(fps)
+
+
+if __name__ == "__main__":
+    import sys
+
+    sys.exit(main())
```

## Comparing `pymunk-6.5.0/pymunk/examples/damped_rotary_spring_pointer.py` & `pymunk/examples/damped_rotary_spring_pointer.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,91 +1,91 @@
-"""This example showcase an arrow pointing or aiming towards the cursor.
-"""
-
-__version__ = "$Id:$"
-__docformat__ = "reStructuredText"
-
-import sys
-
-import pygame
-
-import pymunk
-import pymunk.constraints
-import pymunk.pygame_util
-from pymunk import Vec2d
-
-
-def main():
-    pygame.init()
-    screen = pygame.display.set_mode((600, 600))
-    clock = pygame.time.Clock()
-    running = True
-
-    ### Physics stuff
-    space = pymunk.Space()
-    draw_options = pymunk.pygame_util.DrawOptions(screen)
-
-    pointer_body = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
-
-    ps = [(80, 0), (0, 20), (0, -20)]
-    moment = pymunk.moment_for_poly(1, ps)
-    gun_body = pymunk.Body(1, moment)
-    gun_body.position = Vec2d(300, 300)
-    gun_shape = pymunk.Poly(gun_body, ps)
-
-    rest_angle = 0
-    stiffness = 125000.0
-    damping = 6000.0
-
-    rotary_spring = pymunk.constraints.DampedRotarySpring(
-        pointer_body, gun_body, rest_angle, stiffness, damping
-    )
-
-    space.add(gun_body, gun_shape, rotary_spring)
-
-    while running:
-        for event in pygame.event.get():
-            if event.type == pygame.QUIT:
-                running = False
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
-                running = False
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
-                pygame.image.save(screen, "damped_rotary_sprint_pointer.png")
-            elif event.type == pygame.MOUSEMOTION:
-                mouse_pos = pymunk.pygame_util.get_mouse_pos(screen)
-                pointer_body.position = mouse_pos
-                pointer_body.angle = (pointer_body.position - gun_body.position).angle
-
-            # to easily find good values for the damped rortary spring
-            # as with most simulations done with pymunk, the imporant thing
-            # is that it looks good, not the exact parameters
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_q:
-                rotary_spring.stiffness *= 0.5
-                print(rotary_spring.stiffness, rotary_spring.damping)
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_w:
-                rotary_spring.stiffness *= 2
-                print(rotary_spring.stiffness, rotary_spring.damping)
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_a:
-                rotary_spring.damping *= 0.5
-                print(rotary_spring.stiffness, rotary_spring.damping)
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_s:
-                rotary_spring.damping *= 2
-                print(rotary_spring.stiffness, rotary_spring.damping)
-
-        ### Clear screen
-        screen.fill(pygame.Color("white"))
-
-        ### Draw stuff
-        space.debug_draw(draw_options)
-
-        ### Update physics
-        dt = 1.0 / 60.0
-        for x in range(1):
-            space.step(dt)
-
-        ### Flip screen
-        pygame.display.flip()
-        clock.tick(50)
-
-
-if __name__ == "__main__":
-    sys.exit(main())
+"""This example showcase an arrow pointing or aiming towards the cursor.
+"""
+
+__version__ = "$Id:$"
+__docformat__ = "reStructuredText"
+
+import sys
+
+import pygame
+
+import pymunk
+import pymunk.constraints
+import pymunk.pygame_util
+from pymunk import Vec2d
+
+
+def main():
+    pygame.init()
+    screen = pygame.display.set_mode((600, 600))
+    clock = pygame.time.Clock()
+    running = True
+
+    ### Physics stuff
+    space = pymunk.Space()
+    draw_options = pymunk.pygame_util.DrawOptions(screen)
+
+    pointer_body = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
+
+    ps = [(80, 0), (0, 20), (0, -20)]
+    moment = pymunk.moment_for_poly(1, ps)
+    gun_body = pymunk.Body(1, moment)
+    gun_body.position = Vec2d(300, 300)
+    gun_shape = pymunk.Poly(gun_body, ps)
+
+    rest_angle = 0
+    stiffness = 125000.0
+    damping = 6000.0
+
+    rotary_spring = pymunk.constraints.DampedRotarySpring(
+        pointer_body, gun_body, rest_angle, stiffness, damping
+    )
+
+    space.add(gun_body, gun_shape, rotary_spring)
+
+    while running:
+        for event in pygame.event.get():
+            if event.type == pygame.QUIT:
+                running = False
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
+                running = False
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
+                pygame.image.save(screen, "damped_rotary_sprint_pointer.png")
+            elif event.type == pygame.MOUSEMOTION:
+                mouse_pos = pymunk.pygame_util.get_mouse_pos(screen)
+                pointer_body.position = mouse_pos
+                pointer_body.angle = (pointer_body.position - gun_body.position).angle
+
+            # to easily find good values for the damped rortary spring
+            # as with most simulations done with pymunk, the imporant thing
+            # is that it looks good, not the exact parameters
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_q:
+                rotary_spring.stiffness *= 0.5
+                print(rotary_spring.stiffness, rotary_spring.damping)
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_w:
+                rotary_spring.stiffness *= 2
+                print(rotary_spring.stiffness, rotary_spring.damping)
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_a:
+                rotary_spring.damping *= 0.5
+                print(rotary_spring.stiffness, rotary_spring.damping)
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_s:
+                rotary_spring.damping *= 2
+                print(rotary_spring.stiffness, rotary_spring.damping)
+
+        ### Clear screen
+        screen.fill(pygame.Color("white"))
+
+        ### Draw stuff
+        space.debug_draw(draw_options)
+
+        ### Update physics
+        dt = 1.0 / 60.0
+        for x in range(1):
+            space.step(dt)
+
+        ### Flip screen
+        pygame.display.flip()
+        clock.tick(50)
+
+
+if __name__ == "__main__":
+    sys.exit(main())
```

## Comparing `pymunk-6.5.0/pymunk/examples/deformable.py` & `pymunk/examples/deformable.py`

 * *Ordering differences only*

 * *Files 11% similar despite different names*

```diff
@@ -1,154 +1,154 @@
-"""This is an example on how the autogeometry can be used for deformable 
-terrain.
-"""
-__docformat__ = "reStructuredText"
-
-import sys
-
-import pygame
-
-import pymunk
-import pymunk.autogeometry
-import pymunk.pygame_util
-from pymunk import BB
-
-
-def draw_helptext(screen):
-    font = pygame.font.Font(None, 16)
-    text = [
-        "LMB(hold): Draw pink color",
-        "LMB(hold) + Shift: Create balls",
-        "g: Generate segments from pink color drawing",
-        "r: Reset",
-    ]
-    y = 5
-    for line in text:
-        text = font.render(line, 1, pygame.Color("black"))
-        screen.blit(text, (5, y))
-        y += 10
-
-
-def generate_geometry(surface, space):
-    for s in space.shapes:
-        if hasattr(s, "generated") and s.generated:
-            space.remove(s)
-
-    def sample_func(point):
-        try:
-            p = int(point[0]), int(point[1])
-            color = surface.get_at(p)
-            return color.hsla[2]  # use lightness
-        except Exception as e:
-            print(e)
-            return 0
-
-    line_set = pymunk.autogeometry.march_soft(
-        BB(0, 0, 599, 599), 60, 60, 90, sample_func
-    )
-
-    for polyline in line_set:
-        line = pymunk.autogeometry.simplify_curves(polyline, 1.0)
-
-        for i in range(len(line) - 1):
-            p1 = line[i]
-            p2 = line[i + 1]
-            shape = pymunk.Segment(space.static_body, p1, p2, 1)
-            shape.friction = 0.5
-            shape.color = pygame.Color("red")
-            shape.generated = True
-            space.add(shape)
-
-
-def main():
-    pygame.init()
-    screen = pygame.display.set_mode((600, 600))
-    clock = pygame.time.Clock()
-
-    space = pymunk.Space()
-    space.gravity = 0, 980
-    static = [
-        pymunk.Segment(space.static_body, (0, -50), (-50, 650), 5),
-        pymunk.Segment(space.static_body, (0, 650), (650, 650), 5),
-        pymunk.Segment(space.static_body, (650, 650), (650, -50), 5),
-        pymunk.Segment(space.static_body, (-50, -50), (650, -50), 5),
-    ]
-    for s in static:
-        s.collision_type = 1
-    space.add(*static)
-
-    def pre_solve(arb, space, data):
-        s = arb.shapes[0]
-        space.remove(s.body, s)
-        return False
-
-    space.add_collision_handler(0, 1).pre_solve = pre_solve
-
-    terrain_surface = pygame.Surface((600, 600))
-    terrain_surface.fill(pygame.Color("white"))
-
-    color = pygame.color.THECOLORS["pink"]
-    pygame.draw.circle(terrain_surface, color, (450, 120), 100)
-    generate_geometry(terrain_surface, space)
-    for x in range(25):
-        mass = 1
-        moment = pymunk.moment_for_circle(mass, 0, 10)
-        body = pymunk.Body(mass, moment)
-        body.position = 450, 120
-        shape = pymunk.Circle(body, 10)
-        shape.friction = 0.5
-        space.add(body, shape)
-
-    draw_options = pymunk.pygame_util.DrawOptions(screen)
-    pymunk.pygame_util.positive_y_is_up = False
-
-    fps = 60
-    while True:
-        for event in pygame.event.get():
-            if (
-                event.type == pygame.QUIT
-                or event.type == pygame.KEYDOWN
-                and (event.key in [pygame.K_ESCAPE, pygame.K_q])
-            ):
-                sys.exit(0)
-            elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 3:
-                pass
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_r:
-                terrain_surface.fill(pygame.Color("white"))
-                for s in space.shapes:
-                    if hasattr(s, "generated") and s.generated:
-                        space.remove(s)
-
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_g:
-                generate_geometry(terrain_surface, space)
-
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
-                pygame.image.save(screen, "deformable.png")
-
-        if pygame.mouse.get_pressed()[0]:
-            if pygame.key.get_mods() & pygame.KMOD_SHIFT:
-                mass = 1
-                moment = pymunk.moment_for_circle(mass, 0, 10)
-                body = pymunk.Body(mass, moment)
-                body.position = pygame.mouse.get_pos()
-                shape = pymunk.Circle(body, 10)
-                shape.friction = 0.5
-                space.add(body, shape)
-            else:
-                color = pygame.Color("pink")
-                pos = pygame.mouse.get_pos()
-                pygame.draw.circle(terrain_surface, color, pos, 25)
-
-        space.step(1.0 / fps)
-
-        screen.fill(pygame.Color("white"))
-        screen.blit(terrain_surface, (0, 0))
-        space.debug_draw(draw_options)
-        draw_helptext(screen)
-        pygame.display.flip()
-
-        clock.tick(fps)
-        pygame.display.set_caption("fps: " + str(clock.get_fps()))
-
-
-if __name__ == "__main__":
-    sys.exit(main())
+"""This is an example on how the autogeometry can be used for deformable 
+terrain.
+"""
+__docformat__ = "reStructuredText"
+
+import sys
+
+import pygame
+
+import pymunk
+import pymunk.autogeometry
+import pymunk.pygame_util
+from pymunk import BB
+
+
+def draw_helptext(screen):
+    font = pygame.font.Font(None, 16)
+    text = [
+        "LMB(hold): Draw pink color",
+        "LMB(hold) + Shift: Create balls",
+        "g: Generate segments from pink color drawing",
+        "r: Reset",
+    ]
+    y = 5
+    for line in text:
+        text = font.render(line, 1, pygame.Color("black"))
+        screen.blit(text, (5, y))
+        y += 10
+
+
+def generate_geometry(surface, space):
+    for s in space.shapes:
+        if hasattr(s, "generated") and s.generated:
+            space.remove(s)
+
+    def sample_func(point):
+        try:
+            p = int(point[0]), int(point[1])
+            color = surface.get_at(p)
+            return color.hsla[2]  # use lightness
+        except Exception as e:
+            print(e)
+            return 0
+
+    line_set = pymunk.autogeometry.march_soft(
+        BB(0, 0, 599, 599), 60, 60, 90, sample_func
+    )
+
+    for polyline in line_set:
+        line = pymunk.autogeometry.simplify_curves(polyline, 1.0)
+
+        for i in range(len(line) - 1):
+            p1 = line[i]
+            p2 = line[i + 1]
+            shape = pymunk.Segment(space.static_body, p1, p2, 1)
+            shape.friction = 0.5
+            shape.color = pygame.Color("red")
+            shape.generated = True
+            space.add(shape)
+
+
+def main():
+    pygame.init()
+    screen = pygame.display.set_mode((600, 600))
+    clock = pygame.time.Clock()
+
+    space = pymunk.Space()
+    space.gravity = 0, 980
+    static = [
+        pymunk.Segment(space.static_body, (0, -50), (-50, 650), 5),
+        pymunk.Segment(space.static_body, (0, 650), (650, 650), 5),
+        pymunk.Segment(space.static_body, (650, 650), (650, -50), 5),
+        pymunk.Segment(space.static_body, (-50, -50), (650, -50), 5),
+    ]
+    for s in static:
+        s.collision_type = 1
+    space.add(*static)
+
+    def pre_solve(arb, space, data):
+        s = arb.shapes[0]
+        space.remove(s.body, s)
+        return False
+
+    space.add_collision_handler(0, 1).pre_solve = pre_solve
+
+    terrain_surface = pygame.Surface((600, 600))
+    terrain_surface.fill(pygame.Color("white"))
+
+    color = pygame.color.THECOLORS["pink"]
+    pygame.draw.circle(terrain_surface, color, (450, 120), 100)
+    generate_geometry(terrain_surface, space)
+    for x in range(25):
+        mass = 1
+        moment = pymunk.moment_for_circle(mass, 0, 10)
+        body = pymunk.Body(mass, moment)
+        body.position = 450, 120
+        shape = pymunk.Circle(body, 10)
+        shape.friction = 0.5
+        space.add(body, shape)
+
+    draw_options = pymunk.pygame_util.DrawOptions(screen)
+    pymunk.pygame_util.positive_y_is_up = False
+
+    fps = 60
+    while True:
+        for event in pygame.event.get():
+            if (
+                event.type == pygame.QUIT
+                or event.type == pygame.KEYDOWN
+                and (event.key in [pygame.K_ESCAPE, pygame.K_q])
+            ):
+                sys.exit(0)
+            elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 3:
+                pass
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_r:
+                terrain_surface.fill(pygame.Color("white"))
+                for s in space.shapes:
+                    if hasattr(s, "generated") and s.generated:
+                        space.remove(s)
+
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_g:
+                generate_geometry(terrain_surface, space)
+
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
+                pygame.image.save(screen, "deformable.png")
+
+        if pygame.mouse.get_pressed()[0]:
+            if pygame.key.get_mods() & pygame.KMOD_SHIFT:
+                mass = 1
+                moment = pymunk.moment_for_circle(mass, 0, 10)
+                body = pymunk.Body(mass, moment)
+                body.position = pygame.mouse.get_pos()
+                shape = pymunk.Circle(body, 10)
+                shape.friction = 0.5
+                space.add(body, shape)
+            else:
+                color = pygame.Color("pink")
+                pos = pygame.mouse.get_pos()
+                pygame.draw.circle(terrain_surface, color, pos, 25)
+
+        space.step(1.0 / fps)
+
+        screen.fill(pygame.Color("white"))
+        screen.blit(terrain_surface, (0, 0))
+        space.debug_draw(draw_options)
+        draw_helptext(screen)
+        pygame.display.flip()
+
+        clock.tick(fps)
+        pygame.display.set_caption("fps: " + str(clock.get_fps()))
+
+
+if __name__ == "__main__":
+    sys.exit(main())
```

## Comparing `pymunk-6.5.0/pymunk/examples/flipper.py` & `pymunk/examples/flipper.py`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,147 +1,147 @@
-"""A very basic flipper game.
-"""
-__docformat__ = "reStructuredText"
-
-import random
-
-import pygame
-
-import pymunk
-import pymunk.pygame_util
-from pymunk import Vec2d
-
-
-def main():
-    pygame.init()
-    screen = pygame.display.set_mode((600, 600))
-    clock = pygame.time.Clock()
-    running = True
-
-    ### Physics stuff
-    space = pymunk.Space()
-    space.gravity = (0.0, 900.0)
-    draw_options = pymunk.pygame_util.DrawOptions(screen)
-
-    ## Balls
-    balls = []
-
-    ### walls
-    static_lines = [
-        pymunk.Segment(space.static_body, (150, 500), (50, 50), 1.0),
-        pymunk.Segment(space.static_body, (450, 500), (550, 50), 1.0),
-        pymunk.Segment(space.static_body, (50, 50), (300, 0), 1.0),
-        pymunk.Segment(space.static_body, (300, 0), (550, 50), 1.0),
-        pymunk.Segment(space.static_body, (300, 180), (400, 200), 1.0),
-    ]
-    for line in static_lines:
-        line.elasticity = 0.7
-        line.group = 1
-    space.add(*static_lines)
-
-    fp = [(20, -20), (-120, 0), (20, 20)]
-    mass = 100
-    moment = pymunk.moment_for_poly(mass, fp)
-
-    # right flipper
-    r_flipper_body = pymunk.Body(mass, moment)
-    r_flipper_body.position = 450, 500
-    r_flipper_shape = pymunk.Poly(r_flipper_body, fp)
-    space.add(r_flipper_body, r_flipper_shape)
-
-    r_flipper_joint_body = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
-    r_flipper_joint_body.position = r_flipper_body.position
-    j = pymunk.PinJoint(r_flipper_body, r_flipper_joint_body, (0, 0), (0, 0))
-    # todo: tweak values of spring better
-    s = pymunk.DampedRotarySpring(
-        r_flipper_body, r_flipper_joint_body, 0.15, 20000000, 900000
-    )
-    space.add(j, s)
-
-    # left flipper
-    l_flipper_body = pymunk.Body(mass, moment)
-    l_flipper_body.position = 150, 500
-    l_flipper_shape = pymunk.Poly(l_flipper_body, [(-x, y) for x, y in fp])
-    space.add(l_flipper_body, l_flipper_shape)
-
-    l_flipper_joint_body = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
-    l_flipper_joint_body.position = l_flipper_body.position
-    j = pymunk.PinJoint(l_flipper_body, l_flipper_joint_body, (0, 0), (0, 0))
-    s = pymunk.DampedRotarySpring(
-        l_flipper_body, l_flipper_joint_body, -0.15, 20000000, 900000
-    )
-    space.add(j, s)
-
-    r_flipper_shape.group = l_flipper_shape.group = 1
-    r_flipper_shape.elasticity = l_flipper_shape.elasticity = 0.4
-
-    # "bumpers"
-    for p in [(240, 100), (360, 100)]:
-        body = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
-        body.position = p
-        shape = pymunk.Circle(body, 10)
-        shape.elasticity = 1.5
-        space.add(body, shape)
-
-    while running:
-        for event in pygame.event.get():
-            if event.type == pygame.QUIT:
-                running = False
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
-                running = False
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
-                pygame.image.save(screen, "flipper.png")
-
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_j:
-                r_flipper_body.apply_impulse_at_local_point(
-                    Vec2d.unit() * -40000, (-100, 0)
-                )
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_f:
-                l_flipper_body.apply_impulse_at_local_point(
-                    Vec2d.unit() * 40000, (-100, 0)
-                )
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_b:
-
-                mass = 1
-                radius = 25
-                inertia = pymunk.moment_for_circle(mass, 0, radius, (0, 0))
-                body = pymunk.Body(mass, inertia)
-                x = random.randint(115, 350)
-                body.position = x, 200
-                shape = pymunk.Circle(body, radius, (0, 0))
-                shape.elasticity = 0.95
-                space.add(body, shape)
-                balls.append(shape)
-
-        ### Clear screen
-        screen.fill(pygame.Color("white"))
-
-        ### Draw stuff
-        space.debug_draw(draw_options)
-
-        r_flipper_body.position = 450, 500
-        l_flipper_body.position = 150, 500
-        r_flipper_body.velocity = l_flipper_body.velocity = 0, 0
-
-        ### Remove any balls outside
-        to_remove = []
-        for ball in balls:
-            if ball.body.position.get_distance((300, 300)) > 1000:
-                to_remove.append(ball)
-
-        for ball in to_remove:
-            space.remove(ball.body, ball)
-            balls.remove(ball)
-
-        ### Update physics
-        dt = 1.0 / 60.0 / 5.0
-        for x in range(5):
-            space.step(dt)
-
-        ### Flip screen
-        pygame.display.flip()
-        clock.tick(50)
-        pygame.display.set_caption("fps: " + str(clock.get_fps()))
-
-
-if __name__ == "__main__":
+"""A very basic flipper game.
+"""
+__docformat__ = "reStructuredText"
+
+import random
+
+import pygame
+
+import pymunk
+import pymunk.pygame_util
+from pymunk import Vec2d
+
+
+def main():
+    pygame.init()
+    screen = pygame.display.set_mode((600, 600))
+    clock = pygame.time.Clock()
+    running = True
+
+    ### Physics stuff
+    space = pymunk.Space()
+    space.gravity = (0.0, 900.0)
+    draw_options = pymunk.pygame_util.DrawOptions(screen)
+
+    ## Balls
+    balls = []
+
+    ### walls
+    static_lines = [
+        pymunk.Segment(space.static_body, (150, 500), (50, 50), 1.0),
+        pymunk.Segment(space.static_body, (450, 500), (550, 50), 1.0),
+        pymunk.Segment(space.static_body, (50, 50), (300, 0), 1.0),
+        pymunk.Segment(space.static_body, (300, 0), (550, 50), 1.0),
+        pymunk.Segment(space.static_body, (300, 180), (400, 200), 1.0),
+    ]
+    for line in static_lines:
+        line.elasticity = 0.7
+        line.group = 1
+    space.add(*static_lines)
+
+    fp = [(20, -20), (-120, 0), (20, 20)]
+    mass = 100
+    moment = pymunk.moment_for_poly(mass, fp)
+
+    # right flipper
+    r_flipper_body = pymunk.Body(mass, moment)
+    r_flipper_body.position = 450, 500
+    r_flipper_shape = pymunk.Poly(r_flipper_body, fp)
+    space.add(r_flipper_body, r_flipper_shape)
+
+    r_flipper_joint_body = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
+    r_flipper_joint_body.position = r_flipper_body.position
+    j = pymunk.PinJoint(r_flipper_body, r_flipper_joint_body, (0, 0), (0, 0))
+    # todo: tweak values of spring better
+    s = pymunk.DampedRotarySpring(
+        r_flipper_body, r_flipper_joint_body, 0.15, 20000000, 900000
+    )
+    space.add(j, s)
+
+    # left flipper
+    l_flipper_body = pymunk.Body(mass, moment)
+    l_flipper_body.position = 150, 500
+    l_flipper_shape = pymunk.Poly(l_flipper_body, [(-x, y) for x, y in fp])
+    space.add(l_flipper_body, l_flipper_shape)
+
+    l_flipper_joint_body = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
+    l_flipper_joint_body.position = l_flipper_body.position
+    j = pymunk.PinJoint(l_flipper_body, l_flipper_joint_body, (0, 0), (0, 0))
+    s = pymunk.DampedRotarySpring(
+        l_flipper_body, l_flipper_joint_body, -0.15, 20000000, 900000
+    )
+    space.add(j, s)
+
+    r_flipper_shape.group = l_flipper_shape.group = 1
+    r_flipper_shape.elasticity = l_flipper_shape.elasticity = 0.4
+
+    # "bumpers"
+    for p in [(240, 100), (360, 100)]:
+        body = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
+        body.position = p
+        shape = pymunk.Circle(body, 10)
+        shape.elasticity = 1.5
+        space.add(body, shape)
+
+    while running:
+        for event in pygame.event.get():
+            if event.type == pygame.QUIT:
+                running = False
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
+                running = False
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
+                pygame.image.save(screen, "flipper.png")
+
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_j:
+                r_flipper_body.apply_impulse_at_local_point(
+                    Vec2d.unit() * -40000, (-100, 0)
+                )
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_f:
+                l_flipper_body.apply_impulse_at_local_point(
+                    Vec2d.unit() * 40000, (-100, 0)
+                )
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_b:
+
+                mass = 1
+                radius = 25
+                inertia = pymunk.moment_for_circle(mass, 0, radius, (0, 0))
+                body = pymunk.Body(mass, inertia)
+                x = random.randint(115, 350)
+                body.position = x, 200
+                shape = pymunk.Circle(body, radius, (0, 0))
+                shape.elasticity = 0.95
+                space.add(body, shape)
+                balls.append(shape)
+
+        ### Clear screen
+        screen.fill(pygame.Color("white"))
+
+        ### Draw stuff
+        space.debug_draw(draw_options)
+
+        r_flipper_body.position = 450, 500
+        l_flipper_body.position = 150, 500
+        r_flipper_body.velocity = l_flipper_body.velocity = 0, 0
+
+        ### Remove any balls outside
+        to_remove = []
+        for ball in balls:
+            if ball.body.position.get_distance((300, 300)) > 1000:
+                to_remove.append(ball)
+
+        for ball in to_remove:
+            space.remove(ball.body, ball)
+            balls.remove(ball)
+
+        ### Update physics
+        dt = 1.0 / 60.0 / 5.0
+        for x in range(5):
+            space.step(dt)
+
+        ### Flip screen
+        pygame.display.flip()
+        clock.tick(50)
+        pygame.display.set_caption("fps: " + str(clock.get_fps()))
+
+
+if __name__ == "__main__":
     main()
```

## Comparing `pymunk-6.5.0/pymunk/examples/index_video.py` & `pymunk/examples/index_video.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,272 +1,272 @@
-"""Program used to generate the logo animation on the pymunk main page.
-
-This program will showcase several features of Pymunk, such as collisions, 
-debug drawing, automatic generation of shapes from images, motors, joints and
-sleeping bodies.
-"""
-__docformat__ = "reStructuredText"
-
-import random
-import sys
-import os.path
-
-random.seed(5)  # try keep difference the random factor the same each run.
-
-import pygame
-
-import pymunk
-import pymunk.autogeometry
-import pymunk.pygame_util
-from pymunk import Vec2d
-
-fps = 60
-pygame.init()
-screen = pygame.display.set_mode((690, 300))
-clock = pygame.time.Clock()
-
-clock.tick(1)
-
-### Physics stuff
-space = pymunk.Space()
-space.gravity = 0, 900
-space.sleep_time_threshold = 0.3
-
-draw_options = pymunk.pygame_util.DrawOptions(screen)
-pymunk.pygame_util.positive_y_is_up = False
-
-### Generate geometry from pymunk logo image
-logo_img = pygame.image.load(
-    os.path.join(os.path.dirname(os.path.abspath(__file__)), "pymunk_logo_sphinx.png")
-)
-logo_bb = pymunk.BB(0, 0, logo_img.get_width(), logo_img.get_height())
-
-
-def sample_func(point):
-    try:
-        p = pymunk.pygame_util.to_pygame(point, logo_img)
-        color = logo_img.get_at(p)
-
-        return color.a
-        # return color.hsla[2]
-    except:
-        return 0
-
-
-logo_img.lock()
-line_set = pymunk.autogeometry.march_soft(
-    logo_bb, logo_img.get_width(), logo_img.get_height(), 99, sample_func
-)
-logo_img.unlock()
-
-r = 10
-
-letter_group = 0
-for line in line_set:
-    line = pymunk.autogeometry.simplify_curves(line, 0.7)
-
-    max_x = 0
-    min_x = 1000
-    max_y = 0
-    min_y = 1000
-    for l in line:
-        max_x = max(max_x, l.x)
-        min_x = min(min_x, l.x)
-        max_y = max(max_y, l.y)
-        min_y = min(min_y, l.y)
-    w, h = max_x - min_x, max_y - min_y
-
-    # we skip the line which has less than 35 height, since its the "hole" in
-    # the p in pymunk, and we dont need it.
-    if h < 35:
-        continue
-
-    center = Vec2d(min_x + w / 2.0, min_y + h / 2.0)
-    t = pymunk.Transform(a=1.0, d=1.0, tx=-center.x, ty=-center.y)
-
-    r += 30
-    if r > 255:
-        r = 0
-
-    if True:
-        for i in range(len(line) - 1):
-            shape = pymunk.Segment(space.static_body, line[i], line[i + 1], 1)
-            shape.friction = 0.5
-            shape.color = (255, 255, 255, 255)
-            space.add(shape)
-
-
-floor = pymunk.Segment(space.static_body, (-100, 300), (1000, 220), 5)
-floor.friction = 1.0
-space.add(floor)
-
-### events
-def big_ball(space):
-    mass = 1000
-    radius = 50
-    moment = pymunk.moment_for_circle(mass, 0, radius)
-    b = pymunk.Body(mass, moment)
-    c = pymunk.Circle(b, radius)
-    c.friction = 1
-    c.color = 255, 0, 0, 255
-    b.position = 800, 100
-    b.apply_impulse_at_local_point((-10000, 0), (0, -1000))
-
-    space.add(b, c)
-
-
-def boxfloor(space):
-    mass = 10
-    vs = [(-50, 30), (60, 22), (-50, 22)]
-
-    moment = pymunk.moment_for_poly(mass, vs)
-    b = pymunk.Body(mass, moment)
-    s = pymunk.Poly(b, vs)
-    s.friction = 1
-    s.color = 0, 0, 0, 255
-    b.position = 600, 50
-
-    space.add(b, s)
-
-
-box_y = 150
-
-
-def box(space):
-    global box_y
-
-    mass = 10
-    moment = pymunk.moment_for_box(mass, (40, 20))
-    b = pymunk.Body(mass, moment)
-    s = pymunk.Poly.create_box(b, (40, 20))
-    s.friction = 1
-    b.position = 600, box_y
-    box_y -= 30
-    space.add(b, s)
-
-
-def car(space):
-    pos = Vec2d(100, 200)
-
-    wheel_color = 52, 219, 119, 255
-    shovel_color = 219, 119, 52, 255
-    mass = 100
-    radius = 25
-    moment = pymunk.moment_for_circle(mass, 20, radius)
-    wheel1_b = pymunk.Body(mass, moment)
-    wheel1_s = pymunk.Circle(wheel1_b, radius)
-    wheel1_s.friction = 1.5
-    wheel1_s.color = wheel_color
-    space.add(wheel1_b, wheel1_s)
-
-    mass = 100
-    radius = 25
-    moment = pymunk.moment_for_circle(mass, 20, radius)
-    wheel2_b = pymunk.Body(mass, moment)
-    wheel2_s = pymunk.Circle(wheel2_b, radius)
-    wheel2_s.friction = 1.5
-    wheel2_s.color = wheel_color
-    space.add(wheel2_b, wheel2_s)
-
-    mass = 100
-    size = (50, 30)
-    moment = pymunk.moment_for_box(mass, size)
-    chassi_b = pymunk.Body(mass, moment)
-    chassi_s = pymunk.Poly.create_box(chassi_b, size)
-    space.add(chassi_b, chassi_s)
-
-    vs = [(0, 0), (25, 45), (0, 45)]
-    shovel_s = pymunk.Poly(chassi_b, vs, transform=pymunk.Transform(tx=85))
-    shovel_s.friction = 0.5
-    shovel_s.color = shovel_color
-    space.add(shovel_s)
-
-    wheel1_b.position = pos - (55, 0)
-    wheel2_b.position = pos + (55, 0)
-    chassi_b.position = pos + (0, -25)
-
-    space.add(
-        pymunk.PinJoint(wheel1_b, chassi_b, (0, 0), (-25, -15)),
-        pymunk.PinJoint(wheel1_b, chassi_b, (0, 0), (-25, 15)),
-        pymunk.PinJoint(wheel2_b, chassi_b, (0, 0), (25, -15)),
-        pymunk.PinJoint(wheel2_b, chassi_b, (0, 0), (25, 15)),
-    )
-
-    speed = 4
-    space.add(
-        pymunk.SimpleMotor(wheel1_b, chassi_b, speed),
-        pymunk.SimpleMotor(wheel2_b, chassi_b, speed),
-    )
-
-
-def cannon(space):
-    mass = 100
-    radius = 15
-    moment = pymunk.moment_for_circle(mass, 0, radius)
-    b = pymunk.Body(mass, moment)
-    s = pymunk.Circle(b, radius)
-    s.color = 219, 52, 152, 255
-    b.position = 700, -50
-    space.add(b, s)
-    impulse = Vec2d(-200000, 75000)
-    b.apply_impulse_at_local_point((impulse))
-
-
-events = []
-events.append((0.1, big_ball))
-events.append((2, big_ball))
-events.append((3.5, boxfloor))
-for x in range(8):
-    events.append((4 + x * 0.2, box))
-events.append((6.5, car))
-events.append((8.5, cannon))
-
-events.sort(key=lambda x: x[0])
-
-SMALLBALL = pygame.USEREVENT + 1
-pygame.time.set_timer(SMALLBALL, 100)
-
-small_balls = 100
-total_time = 0
-while True:
-    for event in pygame.event.get():
-        if (
-            event.type == pygame.QUIT
-            or event.type == pygame.KEYDOWN
-            and (event.key in [pygame.K_ESCAPE, pygame.K_q])
-        ):
-            sys.exit(0)
-        elif event.type == SMALLBALL:
-            if small_balls <= 0:
-                pygame.time.set_timer(SMALLBALL, 0)
-            for x in range(10):
-                small_balls -= 1
-                mass = 3
-                radius = 8
-                moment = pymunk.moment_for_circle(mass, 0, radius)
-                b = pymunk.Body(mass, moment)
-                c = pymunk.Circle(b, radius)
-                c.friction = 1
-                x = random.randint(100, 400)
-                b.position = x, 0
-
-                space.add(b, c)
-
-    if len(events) > 0 and total_time > events[0][0]:
-        t, f = events.pop(0)
-
-        f(space)
-
-    space.step(1.0 / fps)
-
-    screen.fill(pygame.Color("white"))
-
-    space.debug_draw(draw_options)
-    screen.blit(logo_img, (0, 0))
-
-    for b in space.bodies:
-        p = pymunk.pygame_util.to_pygame(b.position, screen)
-
-    pygame.display.flip()
-
-    dt = clock.tick(fps)
-    total_time += dt / 1000.0
+"""Program used to generate the logo animation on the pymunk main page.
+
+This program will showcase several features of Pymunk, such as collisions, 
+debug drawing, automatic generation of shapes from images, motors, joints and
+sleeping bodies.
+"""
+__docformat__ = "reStructuredText"
+
+import random
+import sys
+import os.path
+
+random.seed(5)  # try keep difference the random factor the same each run.
+
+import pygame
+
+import pymunk
+import pymunk.autogeometry
+import pymunk.pygame_util
+from pymunk import Vec2d
+
+fps = 60
+pygame.init()
+screen = pygame.display.set_mode((690, 300))
+clock = pygame.time.Clock()
+
+clock.tick(1)
+
+### Physics stuff
+space = pymunk.Space()
+space.gravity = 0, 900
+space.sleep_time_threshold = 0.3
+
+draw_options = pymunk.pygame_util.DrawOptions(screen)
+pymunk.pygame_util.positive_y_is_up = False
+
+### Generate geometry from pymunk logo image
+logo_img = pygame.image.load(
+    os.path.join(os.path.dirname(os.path.abspath(__file__)), "pymunk_logo_sphinx.png")
+)
+logo_bb = pymunk.BB(0, 0, logo_img.get_width(), logo_img.get_height())
+
+
+def sample_func(point):
+    try:
+        p = pymunk.pygame_util.to_pygame(point, logo_img)
+        color = logo_img.get_at(p)
+
+        return color.a
+        # return color.hsla[2]
+    except:
+        return 0
+
+
+logo_img.lock()
+line_set = pymunk.autogeometry.march_soft(
+    logo_bb, logo_img.get_width(), logo_img.get_height(), 99, sample_func
+)
+logo_img.unlock()
+
+r = 10
+
+letter_group = 0
+for line in line_set:
+    line = pymunk.autogeometry.simplify_curves(line, 0.7)
+
+    max_x = 0
+    min_x = 1000
+    max_y = 0
+    min_y = 1000
+    for l in line:
+        max_x = max(max_x, l.x)
+        min_x = min(min_x, l.x)
+        max_y = max(max_y, l.y)
+        min_y = min(min_y, l.y)
+    w, h = max_x - min_x, max_y - min_y
+
+    # we skip the line which has less than 35 height, since its the "hole" in
+    # the p in pymunk, and we dont need it.
+    if h < 35:
+        continue
+
+    center = Vec2d(min_x + w / 2.0, min_y + h / 2.0)
+    t = pymunk.Transform(a=1.0, d=1.0, tx=-center.x, ty=-center.y)
+
+    r += 30
+    if r > 255:
+        r = 0
+
+    if True:
+        for i in range(len(line) - 1):
+            shape = pymunk.Segment(space.static_body, line[i], line[i + 1], 1)
+            shape.friction = 0.5
+            shape.color = (255, 255, 255, 255)
+            space.add(shape)
+
+
+floor = pymunk.Segment(space.static_body, (-100, 300), (1000, 220), 5)
+floor.friction = 1.0
+space.add(floor)
+
+### events
+def big_ball(space):
+    mass = 1000
+    radius = 50
+    moment = pymunk.moment_for_circle(mass, 0, radius)
+    b = pymunk.Body(mass, moment)
+    c = pymunk.Circle(b, radius)
+    c.friction = 1
+    c.color = 255, 0, 0, 255
+    b.position = 800, 100
+    b.apply_impulse_at_local_point((-10000, 0), (0, -1000))
+
+    space.add(b, c)
+
+
+def boxfloor(space):
+    mass = 10
+    vs = [(-50, 30), (60, 22), (-50, 22)]
+
+    moment = pymunk.moment_for_poly(mass, vs)
+    b = pymunk.Body(mass, moment)
+    s = pymunk.Poly(b, vs)
+    s.friction = 1
+    s.color = 0, 0, 0, 255
+    b.position = 600, 50
+
+    space.add(b, s)
+
+
+box_y = 150
+
+
+def box(space):
+    global box_y
+
+    mass = 10
+    moment = pymunk.moment_for_box(mass, (40, 20))
+    b = pymunk.Body(mass, moment)
+    s = pymunk.Poly.create_box(b, (40, 20))
+    s.friction = 1
+    b.position = 600, box_y
+    box_y -= 30
+    space.add(b, s)
+
+
+def car(space):
+    pos = Vec2d(100, 200)
+
+    wheel_color = 52, 219, 119, 255
+    shovel_color = 219, 119, 52, 255
+    mass = 100
+    radius = 25
+    moment = pymunk.moment_for_circle(mass, 20, radius)
+    wheel1_b = pymunk.Body(mass, moment)
+    wheel1_s = pymunk.Circle(wheel1_b, radius)
+    wheel1_s.friction = 1.5
+    wheel1_s.color = wheel_color
+    space.add(wheel1_b, wheel1_s)
+
+    mass = 100
+    radius = 25
+    moment = pymunk.moment_for_circle(mass, 20, radius)
+    wheel2_b = pymunk.Body(mass, moment)
+    wheel2_s = pymunk.Circle(wheel2_b, radius)
+    wheel2_s.friction = 1.5
+    wheel2_s.color = wheel_color
+    space.add(wheel2_b, wheel2_s)
+
+    mass = 100
+    size = (50, 30)
+    moment = pymunk.moment_for_box(mass, size)
+    chassi_b = pymunk.Body(mass, moment)
+    chassi_s = pymunk.Poly.create_box(chassi_b, size)
+    space.add(chassi_b, chassi_s)
+
+    vs = [(0, 0), (25, 45), (0, 45)]
+    shovel_s = pymunk.Poly(chassi_b, vs, transform=pymunk.Transform(tx=85))
+    shovel_s.friction = 0.5
+    shovel_s.color = shovel_color
+    space.add(shovel_s)
+
+    wheel1_b.position = pos - (55, 0)
+    wheel2_b.position = pos + (55, 0)
+    chassi_b.position = pos + (0, -25)
+
+    space.add(
+        pymunk.PinJoint(wheel1_b, chassi_b, (0, 0), (-25, -15)),
+        pymunk.PinJoint(wheel1_b, chassi_b, (0, 0), (-25, 15)),
+        pymunk.PinJoint(wheel2_b, chassi_b, (0, 0), (25, -15)),
+        pymunk.PinJoint(wheel2_b, chassi_b, (0, 0), (25, 15)),
+    )
+
+    speed = 4
+    space.add(
+        pymunk.SimpleMotor(wheel1_b, chassi_b, speed),
+        pymunk.SimpleMotor(wheel2_b, chassi_b, speed),
+    )
+
+
+def cannon(space):
+    mass = 100
+    radius = 15
+    moment = pymunk.moment_for_circle(mass, 0, radius)
+    b = pymunk.Body(mass, moment)
+    s = pymunk.Circle(b, radius)
+    s.color = 219, 52, 152, 255
+    b.position = 700, -50
+    space.add(b, s)
+    impulse = Vec2d(-200000, 75000)
+    b.apply_impulse_at_local_point((impulse))
+
+
+events = []
+events.append((0.1, big_ball))
+events.append((2, big_ball))
+events.append((3.5, boxfloor))
+for x in range(8):
+    events.append((4 + x * 0.2, box))
+events.append((6.5, car))
+events.append((8.5, cannon))
+
+events.sort(key=lambda x: x[0])
+
+SMALLBALL = pygame.USEREVENT + 1
+pygame.time.set_timer(SMALLBALL, 100)
+
+small_balls = 100
+total_time = 0
+while True:
+    for event in pygame.event.get():
+        if (
+            event.type == pygame.QUIT
+            or event.type == pygame.KEYDOWN
+            and (event.key in [pygame.K_ESCAPE, pygame.K_q])
+        ):
+            sys.exit(0)
+        elif event.type == SMALLBALL:
+            if small_balls <= 0:
+                pygame.time.set_timer(SMALLBALL, 0)
+            for x in range(10):
+                small_balls -= 1
+                mass = 3
+                radius = 8
+                moment = pymunk.moment_for_circle(mass, 0, radius)
+                b = pymunk.Body(mass, moment)
+                c = pymunk.Circle(b, radius)
+                c.friction = 1
+                x = random.randint(100, 400)
+                b.position = x, 0
+
+                space.add(b, c)
+
+    if len(events) > 0 and total_time > events[0][0]:
+        t, f = events.pop(0)
+
+        f(space)
+
+    space.step(1.0 / fps)
+
+    screen.fill(pygame.Color("white"))
+
+    space.debug_draw(draw_options)
+    screen.blit(logo_img, (0, 0))
+
+    for b in space.bodies:
+        p = pymunk.pygame_util.to_pygame(b.position, screen)
+
+    pygame.display.flip()
+
+    dt = clock.tick(fps)
+    total_time += dt / 1000.0
```

## Comparing `pymunk-6.5.0/pymunk/examples/newtons_cradle.py` & `pymunk/examples/newtons_cradle.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,254 +1,254 @@
-"""A screensaver version of Newton's Cradle with an interactive mode. 
-"""
-__docformat__ = "reStructuredText"
-
-import os
-import random
-import sys
-
-description = """
----- Newton's Cradle ----
-A screensaver version of Newton's Cradle with an interactive mode
-
-/s - Run in fullscreen screensaver mode
-/p #### - Display a preview of the screensaver using a window handler
-/i - Interactive mode
-"""
-
-if len(sys.argv) < 2:
-    print(description)
-    sys.exit()
-
-is_interactive = False
-display_flags = 0
-if sys.argv[1] == "/p":  # preview mode
-    os.environ["SDL_VIDEODRIVER"] = "windib"
-    os.environ["SDL_WINDOWID"] = sys.argv[2]
-    display_size = (100, 100)
-    is_interactive = False
-
-
-### We must set OS env before the pygame imports..
-import pygame
-
-if sys.argv[1] == "/s":  # fullscreen screensaver mode
-    display_size = (0, 0)
-    is_interactive = False
-    display_flags = (
-        display_flags | pygame.FULLSCREEN
-    )  # FULLSCREEN) # | DOUBLEBUF | HWSURFACE     )
-elif sys.argv[1] == "/i":  # interactive
-    display_size = (600, 600)
-    is_interactive = True
-
-
-import pymunk as pm
-from pymunk import Vec2d
-
-
-def drawcircle(image, colour, origin, radius, width=0):
-    if width == 0:
-        pygame.draw.circle(image, colour, origin, int(radius))
-    else:
-        if radius > 65534 / 5:
-            radius = 65534 / 5
-        circle = pygame.Surface(
-            [radius * 2 + width, radius * 2 + width]
-        ).convert_alpha()
-        circle.fill([0, 0, 0, 0])
-        pygame.draw.circle(
-            circle,
-            colour,
-            [circle.get_width() / 2, circle.get_height() / 2],
-            radius + (width / 2),
-        )
-        if int(radius - (width / 2)) > 0:
-            pygame.draw.circle(
-                circle,
-                [0, 0, 0, 0],
-                [circle.get_width() / 2, circle.get_height() / 2],
-                abs(int(radius - (width / 2))),
-            )
-        image.blit(
-            circle,
-            [
-                origin[0] - (circle.get_width() / 2),
-                origin[1] - (circle.get_height() / 2),
-            ],
-        )
-
-
-def reset_bodies(space):
-    for body in space.bodies:
-        body.position = Vec2d(*body.start_position)
-        body.force = 0, 0
-        body.torque = 0
-        body.velocity = 0, 0
-        body.angular_velocity = 0
-    color = pygame.Color(
-        random.randint(1, 255), random.randint(1, 255), random.randint(1, 255)
-    )
-    for shape in space.shapes:
-        shape.color = color
-
-
-def main():
-
-    pygame.init()
-    screen = pygame.display.set_mode(display_size, display_flags)
-    width, height = screen.get_size()
-
-    def to_pygame(p):
-        """Small hack to convert pymunk to pygame coordinates"""
-        return int(p.x), int(-p.y + height)
-
-    def from_pygame(p):
-        return to_pygame(p)
-
-    clock = pygame.time.Clock()
-    running = True
-    font = pygame.font.Font(None, 16)
-
-    ### Physics stuff
-    space = pm.Space()
-    space.gravity = (0.0, -1900.0)
-    space.damping = 0.999  # to prevent it from blowing up.
-    mouse_body = pm.Body(body_type=pm.Body.KINEMATIC)
-
-    bodies = []
-    for x in range(-100, 150, 50):
-        x += width / 2
-        offset_y = height / 2
-        mass = 10
-        radius = 25
-        moment = pm.moment_for_circle(mass, 0, radius, (0, 0))
-        body = pm.Body(mass, moment)
-        body.position = (x, -125 + offset_y)
-        body.start_position = Vec2d(*body.position)
-        shape = pm.Circle(body, radius)
-        shape.elasticity = 0.9999999
-        space.add(body, shape)
-        bodies.append(body)
-        pj = pm.PinJoint(space.static_body, body, (x, 125 + offset_y), (0, 0))
-        space.add(pj)
-
-    reset_bodies(space)
-    selected = None
-
-    if not is_interactive:
-        pygame.time.set_timer(pygame.USEREVENT + 1, 70000)  # apply force
-        pygame.time.set_timer(pygame.USEREVENT + 2, 120000)  # reset
-        pygame.event.post(pygame.event.Event(pygame.USEREVENT + 1))
-        pygame.mouse.set_visible(False)
-
-    while running:
-        for event in pygame.event.get():
-            if event.type == pygame.QUIT:
-                running = False
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
-                pygame.image.save(screen, "newtons_cradle.png")
-
-            if event.type == pygame.USEREVENT + 1:
-                r = random.randint(1, 4)
-                for body in bodies[0:r]:
-                    body.apply_impulse_at_local_point((-6000, 0))
-            if event.type == pygame.USEREVENT + 2:
-                reset_bodies(space)
-
-            elif (
-                event.type == pygame.KEYDOWN
-                and event.key == pygame.K_r
-                and is_interactive
-            ):
-                reset_bodies(space)
-            elif (
-                event.type == pygame.KEYDOWN
-                and event.key == pygame.K_f
-                and is_interactive
-            ):
-                r = random.randint(1, 4)
-                for body in bodies[0:r]:
-                    body.apply_impulse_at_local_point((-6000, 0))
-
-            elif event.type == pygame.MOUSEBUTTONDOWN and is_interactive:
-                if selected != None:
-                    space.remove(selected)
-                p = from_pygame(Vec2d(*event.pos))
-                hit = space.point_query_nearest(p, 0, pm.ShapeFilter())
-                if hit != None:
-                    shape = hit.shape
-                    rest_length = mouse_body.position.get_distance(shape.body.position)
-                    ds = pm.DampedSpring(
-                        mouse_body, shape.body, (0, 0), (0, 0), rest_length, 1000, 10
-                    )
-                    space.add(ds)
-                    selected = ds
-
-            elif event.type == pygame.MOUSEBUTTONUP and is_interactive:
-                if selected != None:
-                    space.remove(selected)
-                    selected = None
-
-            elif event.type == pygame.KEYDOWN:
-                running = False
-            elif event.type == pygame.MOUSEBUTTONDOWN:
-                running = False
-
-        mpos = pygame.mouse.get_pos()
-        p = from_pygame(Vec2d(*mpos))
-        mouse_body.position = p
-
-        ### Clear screen
-        screen.fill(pygame.Color("black"))
-
-        ### Draw stuff
-        for c in space.constraints:
-            pv1 = c.a.position + c.anchor_a
-            pv2 = c.b.position + c.anchor_b
-            p1 = to_pygame(pv1)
-            p2 = to_pygame(pv2)
-            pygame.draw.aalines(screen, pygame.Color("lightgray"), False, [p1, p2])
-
-        for ball in space.shapes:
-            p = to_pygame(ball.body.position)
-            drawcircle(screen, ball.color, p, int(ball.radius), 0)
-            # pygame.draw.circle(screen, ball.color, p, int(ball.radius), 0)
-
-        ### Update physics
-        fps = 50
-        iterations = 25
-        dt = 1.0 / float(fps) / float(iterations)
-        for x in range(iterations):  # 10 iterations to get a more stable simulation
-            space.step(dt)
-
-        ### Flip screen
-        if is_interactive:
-            screen.blit(
-                font.render(
-                    "fps: " + str(clock.get_fps()), True, pygame.Color("white")
-                ),
-                (0, 0),
-            )
-            screen.blit(
-                font.render(
-                    "Press left mouse button and drag to interact",
-                    True,
-                    pygame.Color("darkgrey"),
-                ),
-                (5, height - 35),
-            )
-            screen.blit(
-                font.render(
-                    "Press R to reset, any other key to quit",
-                    True,
-                    pygame.Color("darkgrey"),
-                ),
-                (5, height - 20),
-            )
-
-        pygame.display.flip()
-        clock.tick(fps)
-
-
-if __name__ == "__main__":
-    sys.exit(main())
+"""A screensaver version of Newton's Cradle with an interactive mode. 
+"""
+__docformat__ = "reStructuredText"
+
+import os
+import random
+import sys
+
+description = """
+---- Newton's Cradle ----
+A screensaver version of Newton's Cradle with an interactive mode
+
+/s - Run in fullscreen screensaver mode
+/p #### - Display a preview of the screensaver using a window handler
+/i - Interactive mode
+"""
+
+if len(sys.argv) < 2:
+    print(description)
+    sys.exit()
+
+is_interactive = False
+display_flags = 0
+if sys.argv[1] == "/p":  # preview mode
+    os.environ["SDL_VIDEODRIVER"] = "windib"
+    os.environ["SDL_WINDOWID"] = sys.argv[2]
+    display_size = (100, 100)
+    is_interactive = False
+
+
+### We must set OS env before the pygame imports..
+import pygame
+
+if sys.argv[1] == "/s":  # fullscreen screensaver mode
+    display_size = (0, 0)
+    is_interactive = False
+    display_flags = (
+        display_flags | pygame.FULLSCREEN
+    )  # FULLSCREEN) # | DOUBLEBUF | HWSURFACE     )
+elif sys.argv[1] == "/i":  # interactive
+    display_size = (600, 600)
+    is_interactive = True
+
+
+import pymunk as pm
+from pymunk import Vec2d
+
+
+def drawcircle(image, colour, origin, radius, width=0):
+    if width == 0:
+        pygame.draw.circle(image, colour, origin, int(radius))
+    else:
+        if radius > 65534 / 5:
+            radius = 65534 / 5
+        circle = pygame.Surface(
+            [radius * 2 + width, radius * 2 + width]
+        ).convert_alpha()
+        circle.fill([0, 0, 0, 0])
+        pygame.draw.circle(
+            circle,
+            colour,
+            [circle.get_width() / 2, circle.get_height() / 2],
+            radius + (width / 2),
+        )
+        if int(radius - (width / 2)) > 0:
+            pygame.draw.circle(
+                circle,
+                [0, 0, 0, 0],
+                [circle.get_width() / 2, circle.get_height() / 2],
+                abs(int(radius - (width / 2))),
+            )
+        image.blit(
+            circle,
+            [
+                origin[0] - (circle.get_width() / 2),
+                origin[1] - (circle.get_height() / 2),
+            ],
+        )
+
+
+def reset_bodies(space):
+    for body in space.bodies:
+        body.position = Vec2d(*body.start_position)
+        body.force = 0, 0
+        body.torque = 0
+        body.velocity = 0, 0
+        body.angular_velocity = 0
+    color = pygame.Color(
+        random.randint(1, 255), random.randint(1, 255), random.randint(1, 255)
+    )
+    for shape in space.shapes:
+        shape.color = color
+
+
+def main():
+
+    pygame.init()
+    screen = pygame.display.set_mode(display_size, display_flags)
+    width, height = screen.get_size()
+
+    def to_pygame(p):
+        """Small hack to convert pymunk to pygame coordinates"""
+        return int(p.x), int(-p.y + height)
+
+    def from_pygame(p):
+        return to_pygame(p)
+
+    clock = pygame.time.Clock()
+    running = True
+    font = pygame.font.Font(None, 16)
+
+    ### Physics stuff
+    space = pm.Space()
+    space.gravity = (0.0, -1900.0)
+    space.damping = 0.999  # to prevent it from blowing up.
+    mouse_body = pm.Body(body_type=pm.Body.KINEMATIC)
+
+    bodies = []
+    for x in range(-100, 150, 50):
+        x += width / 2
+        offset_y = height / 2
+        mass = 10
+        radius = 25
+        moment = pm.moment_for_circle(mass, 0, radius, (0, 0))
+        body = pm.Body(mass, moment)
+        body.position = (x, -125 + offset_y)
+        body.start_position = Vec2d(*body.position)
+        shape = pm.Circle(body, radius)
+        shape.elasticity = 0.9999999
+        space.add(body, shape)
+        bodies.append(body)
+        pj = pm.PinJoint(space.static_body, body, (x, 125 + offset_y), (0, 0))
+        space.add(pj)
+
+    reset_bodies(space)
+    selected = None
+
+    if not is_interactive:
+        pygame.time.set_timer(pygame.USEREVENT + 1, 70000)  # apply force
+        pygame.time.set_timer(pygame.USEREVENT + 2, 120000)  # reset
+        pygame.event.post(pygame.event.Event(pygame.USEREVENT + 1))
+        pygame.mouse.set_visible(False)
+
+    while running:
+        for event in pygame.event.get():
+            if event.type == pygame.QUIT:
+                running = False
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
+                pygame.image.save(screen, "newtons_cradle.png")
+
+            if event.type == pygame.USEREVENT + 1:
+                r = random.randint(1, 4)
+                for body in bodies[0:r]:
+                    body.apply_impulse_at_local_point((-6000, 0))
+            if event.type == pygame.USEREVENT + 2:
+                reset_bodies(space)
+
+            elif (
+                event.type == pygame.KEYDOWN
+                and event.key == pygame.K_r
+                and is_interactive
+            ):
+                reset_bodies(space)
+            elif (
+                event.type == pygame.KEYDOWN
+                and event.key == pygame.K_f
+                and is_interactive
+            ):
+                r = random.randint(1, 4)
+                for body in bodies[0:r]:
+                    body.apply_impulse_at_local_point((-6000, 0))
+
+            elif event.type == pygame.MOUSEBUTTONDOWN and is_interactive:
+                if selected != None:
+                    space.remove(selected)
+                p = from_pygame(Vec2d(*event.pos))
+                hit = space.point_query_nearest(p, 0, pm.ShapeFilter())
+                if hit != None:
+                    shape = hit.shape
+                    rest_length = mouse_body.position.get_distance(shape.body.position)
+                    ds = pm.DampedSpring(
+                        mouse_body, shape.body, (0, 0), (0, 0), rest_length, 1000, 10
+                    )
+                    space.add(ds)
+                    selected = ds
+
+            elif event.type == pygame.MOUSEBUTTONUP and is_interactive:
+                if selected != None:
+                    space.remove(selected)
+                    selected = None
+
+            elif event.type == pygame.KEYDOWN:
+                running = False
+            elif event.type == pygame.MOUSEBUTTONDOWN:
+                running = False
+
+        mpos = pygame.mouse.get_pos()
+        p = from_pygame(Vec2d(*mpos))
+        mouse_body.position = p
+
+        ### Clear screen
+        screen.fill(pygame.Color("black"))
+
+        ### Draw stuff
+        for c in space.constraints:
+            pv1 = c.a.position + c.anchor_a
+            pv2 = c.b.position + c.anchor_b
+            p1 = to_pygame(pv1)
+            p2 = to_pygame(pv2)
+            pygame.draw.aalines(screen, pygame.Color("lightgray"), False, [p1, p2])
+
+        for ball in space.shapes:
+            p = to_pygame(ball.body.position)
+            drawcircle(screen, ball.color, p, int(ball.radius), 0)
+            # pygame.draw.circle(screen, ball.color, p, int(ball.radius), 0)
+
+        ### Update physics
+        fps = 50
+        iterations = 25
+        dt = 1.0 / float(fps) / float(iterations)
+        for x in range(iterations):  # 10 iterations to get a more stable simulation
+            space.step(dt)
+
+        ### Flip screen
+        if is_interactive:
+            screen.blit(
+                font.render(
+                    "fps: " + str(clock.get_fps()), True, pygame.Color("white")
+                ),
+                (0, 0),
+            )
+            screen.blit(
+                font.render(
+                    "Press left mouse button and drag to interact",
+                    True,
+                    pygame.Color("darkgrey"),
+                ),
+                (5, height - 35),
+            )
+            screen.blit(
+                font.render(
+                    "Press R to reset, any other key to quit",
+                    True,
+                    pygame.Color("darkgrey"),
+                ),
+                (5, height - 20),
+            )
+
+        pygame.display.flip()
+        clock.tick(fps)
+
+
+if __name__ == "__main__":
+    sys.exit(main())
```

## Comparing `pymunk-6.5.0/pymunk/examples/planet.py` & `pymunk/examples/planet.py`

 * *Ordering differences only*

 * *Files 15% similar despite different names*

```diff
@@ -1,92 +1,92 @@
-"""
-Showcase of planets/satellites (small boxes) orbiting around a star. 
-
-Uses a custom velocity function to manually calculate the gravity, assuming 
-the star is in the middle and is massive enough that the satellites does not 
-affect it.
-
-This is a port of the Planet demo included in Chipmunk.
-"""
-
-import math
-import random
-
-random.seed(5)  # Feel free to adjust, this is just to make each run equal
-
-import pygame
-
-import pymunk
-import pymunk.pygame_util
-
-gravityStrength = 5.0e6
-
-
-def planetGravity(body, gravity, damping, dt):
-    # Gravitational acceleration is proportional to the inverse square of
-    # distance, and directed toward the origin. The central planet is assumed
-    # to be massive enough that it affects the satellites but not vice versa.
-    sq_dist = body.position.get_dist_sqrd((300, 300))
-    g = (
-        (body.position - pymunk.Vec2d(300, 300))
-        * -gravityStrength
-        / (sq_dist * math.sqrt(sq_dist))
-    )
-    pymunk.Body.update_velocity(body, g, damping, dt)
-
-
-def add_box(space):
-    body = pymunk.Body()
-    body.position = pymunk.Vec2d(random.randint(50, 550), random.randint(50, 550))
-    body.velocity_func = planetGravity
-
-    # Set the box's velocity to put it into a circular orbit from its
-    # starting position.
-    r = body.position.get_distance((300, 300))
-    v = math.sqrt(gravityStrength / r) / r
-    body.velocity = (body.position - pymunk.Vec2d(300, 300)).perpendicular() * v
-    # Set the box's angular velocity to match its orbital period and
-    # align its initial angle with its position.
-    body.angular_velocity = v
-    body.angle = math.atan2(body.position.y, body.position.x)
-
-    box = pymunk.Poly.create_box(body, size=(10, 10))
-    box.mass = 1
-    box.friction = 0.7
-    box.elasticity = 0
-    box.color = pygame.Color("white")
-    space.add(body, box)
-
-
-pygame.init()
-screen = pygame.display.set_mode((600, 600))
-clock = pygame.time.Clock()
-
-space = pymunk.Space()
-draw_options = pymunk.pygame_util.DrawOptions(screen)
-
-for x in range(30):
-    add_box(space)
-
-while True:
-    for event in pygame.event.get():
-        if (
-            event.type == pygame.QUIT
-            or event.type == pygame.KEYDOWN
-            and event.key == pygame.K_ESCAPE
-        ):
-            exit()
-        elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
-            pygame.image.save(screen, "planet.png")
-
-    screen.fill(pygame.Color("black"))
-
-    space.debug_draw(draw_options)
-
-    # 'Star' in the center of screen
-    pygame.draw.circle(screen, pygame.Color("yellow"), (300, 300), 10)
-
-    space.step(1 / 60)
-
-    pygame.display.flip()
-    clock.tick(60)
-    pygame.display.set_caption("fps: " + str(clock.get_fps()))
+"""
+Showcase of planets/satellites (small boxes) orbiting around a star. 
+
+Uses a custom velocity function to manually calculate the gravity, assuming 
+the star is in the middle and is massive enough that the satellites does not 
+affect it.
+
+This is a port of the Planet demo included in Chipmunk.
+"""
+
+import math
+import random
+
+random.seed(5)  # Feel free to adjust, this is just to make each run equal
+
+import pygame
+
+import pymunk
+import pymunk.pygame_util
+
+gravityStrength = 5.0e6
+
+
+def planetGravity(body, gravity, damping, dt):
+    # Gravitational acceleration is proportional to the inverse square of
+    # distance, and directed toward the origin. The central planet is assumed
+    # to be massive enough that it affects the satellites but not vice versa.
+    sq_dist = body.position.get_dist_sqrd((300, 300))
+    g = (
+        (body.position - pymunk.Vec2d(300, 300))
+        * -gravityStrength
+        / (sq_dist * math.sqrt(sq_dist))
+    )
+    pymunk.Body.update_velocity(body, g, damping, dt)
+
+
+def add_box(space):
+    body = pymunk.Body()
+    body.position = pymunk.Vec2d(random.randint(50, 550), random.randint(50, 550))
+    body.velocity_func = planetGravity
+
+    # Set the box's velocity to put it into a circular orbit from its
+    # starting position.
+    r = body.position.get_distance((300, 300))
+    v = math.sqrt(gravityStrength / r) / r
+    body.velocity = (body.position - pymunk.Vec2d(300, 300)).perpendicular() * v
+    # Set the box's angular velocity to match its orbital period and
+    # align its initial angle with its position.
+    body.angular_velocity = v
+    body.angle = math.atan2(body.position.y, body.position.x)
+
+    box = pymunk.Poly.create_box(body, size=(10, 10))
+    box.mass = 1
+    box.friction = 0.7
+    box.elasticity = 0
+    box.color = pygame.Color("white")
+    space.add(body, box)
+
+
+pygame.init()
+screen = pygame.display.set_mode((600, 600))
+clock = pygame.time.Clock()
+
+space = pymunk.Space()
+draw_options = pymunk.pygame_util.DrawOptions(screen)
+
+for x in range(30):
+    add_box(space)
+
+while True:
+    for event in pygame.event.get():
+        if (
+            event.type == pygame.QUIT
+            or event.type == pygame.KEYDOWN
+            and event.key == pygame.K_ESCAPE
+        ):
+            exit()
+        elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
+            pygame.image.save(screen, "planet.png")
+
+    screen.fill(pygame.Color("black"))
+
+    space.debug_draw(draw_options)
+
+    # 'Star' in the center of screen
+    pygame.draw.circle(screen, pygame.Color("yellow"), (300, 300), 10)
+
+    space.step(1 / 60)
+
+    pygame.display.flip()
+    clock.tick(60)
+    pygame.display.set_caption("fps: " + str(clock.get_fps()))
```

## Comparing `pymunk-6.5.0/pymunk/examples/platformer.py` & `pymunk/examples/platformer.py`

 * *Ordering differences only*

 * *Files 15% similar despite different names*

```diff
@@ -1,344 +1,344 @@
-"""Showcase of a very basic 2d platformer
-
-The red girl sprite is taken from Sithjester's RMXP Resources:
-http://untamed.wild-refuge.net/rmxpresources.php?characters
-
-.. note:: The code of this example is a bit messy. If you adapt this to your 
-    own code you might want to structure it a bit differently.
-"""
-
-__docformat__ = "reStructuredText"
-
-import math
-import sys
-import os.path
-
-import pygame
-
-import pymunk
-import pymunk.pygame_util
-from pymunk.vec2d import Vec2d
-
-
-def cpfclamp(f, min_, max_):
-    """Clamp f between min and max"""
-    return min(max(f, min_), max_)
-
-
-def cpflerpconst(f1, f2, d):
-    """Linearly interpolate from f1 to f2 by no more than d."""
-    return f1 + cpfclamp(f2 - f1, -d, d)
-
-
-width, height = 690, 400
-fps = 60
-dt = 1.0 / fps
-PLAYER_VELOCITY = 100.0 * 2.0
-PLAYER_GROUND_ACCEL_TIME = 0.05
-PLAYER_GROUND_ACCEL = PLAYER_VELOCITY / PLAYER_GROUND_ACCEL_TIME
-
-PLAYER_AIR_ACCEL_TIME = 0.25
-PLAYER_AIR_ACCEL = PLAYER_VELOCITY / PLAYER_AIR_ACCEL_TIME
-
-JUMP_HEIGHT = 16.0 * 3
-JUMP_BOOST_HEIGHT = 24.0
-JUMP_CUTOFF_VELOCITY = 100
-FALL_VELOCITY = 250.0
-
-JUMP_LENIENCY = 0.05
-
-HEAD_FRICTION = 0.7
-
-PLATFORM_SPEED = 1
-
-
-def main():
-
-    ### PyGame init
-    pygame.init()
-    screen = pygame.display.set_mode((width, height))
-
-    clock = pygame.time.Clock()
-    running = True
-    font = pygame.font.SysFont("Arial", 16)
-    sound = pygame.mixer.Sound(
-        os.path.join(os.path.dirname(os.path.abspath(__file__)), "sfx.wav")
-    )
-    img = pygame.image.load(
-        os.path.join(os.path.dirname(os.path.abspath(__file__)), "xmasgirl1.png")
-    )
-
-    ### Physics stuff
-    space = pymunk.Space()
-    space.gravity = Vec2d(0, -1000)
-    pymunk.pygame_util.positive_y_is_up = True
-    draw_options = pymunk.pygame_util.DrawOptions(screen)
-
-    # box walls
-    static = [
-        pymunk.Segment(space.static_body, (10, 50), (300, 50), 3),
-        pymunk.Segment(space.static_body, (300, 50), (325, 50), 3),
-        pymunk.Segment(space.static_body, (325, 50), (350, 50), 3),
-        pymunk.Segment(space.static_body, (350, 50), (375, 50), 3),
-        pymunk.Segment(space.static_body, (375, 50), (680, 50), 3),
-        pymunk.Segment(space.static_body, (680, 50), (680, 370), 3),
-        pymunk.Segment(space.static_body, (680, 370), (10, 370), 3),
-        pymunk.Segment(space.static_body, (10, 370), (10, 50), 3),
-    ]
-    static[1].color = pygame.Color("red")
-    static[2].color = pygame.Color("green")
-    static[3].color = pygame.Color("red")
-
-    # rounded shape
-    rounded = [
-        pymunk.Segment(space.static_body, (500, 50), (520, 60), 3),
-        pymunk.Segment(space.static_body, (520, 60), (540, 80), 3),
-        pymunk.Segment(space.static_body, (540, 80), (550, 100), 3),
-        pymunk.Segment(space.static_body, (550, 100), (550, 150), 3),
-    ]
-
-    # static platforms
-    platforms = [
-        pymunk.Segment(space.static_body, (170, 50), (270, 150), 3)
-        # , pymunk.Segment(space.static_body, (270, 100), (300, 100), 5)
-        ,
-        pymunk.Segment(space.static_body, (400, 150), (450, 150), 3),
-        pymunk.Segment(space.static_body, (400, 200), (450, 200), 3),
-        pymunk.Segment(space.static_body, (220, 200), (300, 200), 3),
-        pymunk.Segment(space.static_body, (50, 250), (200, 250), 3),
-        pymunk.Segment(space.static_body, (10, 370), (50, 250), 3),
-    ]
-
-    for s in static + platforms + rounded:
-        s.friction = 1.0
-        s.group = 1
-    space.add(*static, *platforms, *rounded)
-
-    # moving platform
-    platform_path = [(650, 100), (600, 200), (650, 300)]
-    platform_path_index = 0
-    platform_body = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
-    platform_body.position = 650, 100
-    s = pymunk.Segment(platform_body, (-25, 0), (25, 0), 5)
-    s.friction = 1.0
-    s.group = 1
-    s.color = pygame.Color("blue")
-    space.add(platform_body, s)
-
-    # pass through platform
-    passthrough = pymunk.Segment(space.static_body, (270, 100), (320, 100), 5)
-    passthrough.color = pygame.Color("yellow")
-    passthrough.friction = 1.0
-    passthrough.collision_type = 2
-    passthrough.filter = pymunk.ShapeFilter(categories=0b1000)
-    space.add(passthrough)
-
-    def passthrough_handler(arbiter, space, data):
-        if arbiter.shapes[0].body.velocity.y < 0:
-            return True
-        else:
-            return False
-
-    space.add_collision_handler(1, 2).begin = passthrough_handler
-
-    # player
-    body = pymunk.Body(5, float("inf"))
-    body.position = 100, 100
-
-    head = pymunk.Circle(body, 10, (0, 5))
-    head2 = pymunk.Circle(body, 10, (0, 13))
-    feet = pymunk.Circle(body, 10, (0, -5))
-    # Since we use the debug draw we need to hide these circles. To make it
-    # easy we just set their color to black.
-    feet.color = 0, 0, 0, 0
-    head.color = 0, 0, 0, 0
-    head2.color = 0, 0, 0, 0
-    mask = pymunk.ShapeFilter.ALL_MASKS() ^ passthrough.filter.categories
-    sf = pymunk.ShapeFilter(mask=mask)
-    head.filter = sf
-    head2.filter = sf
-    feet.collision_type = 1
-    feet.ignore_draw = head.ignore_draw = head2.ignore_draw = True
-
-    space.add(body, head, feet, head2)
-    direction = 1
-    remaining_jumps = 2
-    landing = {"p": Vec2d.zero(), "n": 0}
-    frame_number = 0
-
-    landed_previous = False
-
-    while running:
-
-        grounding = {
-            "normal": Vec2d.zero(),
-            "penetration": Vec2d.zero(),
-            "impulse": Vec2d.zero(),
-            "position": Vec2d.zero(),
-            "body": None,
-        }
-        # find out if player is standing on ground
-
-        def f(arbiter):
-            n = -arbiter.contact_point_set.normal
-            if n.y > grounding["normal"].y:
-                grounding["normal"] = n
-                grounding["penetration"] = -arbiter.contact_point_set.points[0].distance
-                grounding["body"] = arbiter.shapes[1].body
-                grounding["impulse"] = arbiter.total_impulse
-                grounding["position"] = arbiter.contact_point_set.points[0].point_b
-
-        body.each_arbiter(f)
-
-        well_grounded = False
-        if (
-            grounding["body"] != None
-            and abs(grounding["normal"].x / grounding["normal"].y) < feet.friction
-        ):
-            well_grounded = True
-            remaining_jumps = 2
-
-        ground_velocity = Vec2d.zero()
-        if well_grounded:
-            ground_velocity = grounding["body"].velocity
-
-        for event in pygame.event.get():
-            if (
-                event.type == pygame.QUIT
-                or event.type == pygame.KEYDOWN
-                and (event.key in [pygame.K_ESCAPE, pygame.K_q])
-            ):
-                running = False
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
-                pygame.image.save(screen, "platformer.png")
-
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_UP:
-                if well_grounded or remaining_jumps > 0:
-                    jump_v = math.sqrt(2.0 * JUMP_HEIGHT * abs(space.gravity.y))
-                    impulse = (0, body.mass * (ground_velocity.y + jump_v))
-                    body.apply_impulse_at_local_point(impulse)
-                    remaining_jumps -= 1
-            elif event.type == pygame.KEYUP and event.key == pygame.K_UP:
-                body.velocity = body.velocity.x, min(
-                    body.velocity.y, JUMP_CUTOFF_VELOCITY
-                )
-
-        # Target horizontal velocity of player
-        target_vx = 0
-
-        if body.velocity.x > 0.01:
-            direction = 1
-        elif body.velocity.x < -0.01:
-            direction = -1
-
-        keys = pygame.key.get_pressed()
-        if keys[pygame.K_LEFT]:
-            direction = -1
-            target_vx -= PLAYER_VELOCITY
-        if keys[pygame.K_RIGHT]:
-            direction = 1
-            target_vx += PLAYER_VELOCITY
-        if keys[pygame.K_DOWN]:
-            direction = -3
-
-        feet.surface_velocity = -target_vx, 0
-
-        if grounding["body"] != None:
-            feet.friction = -PLAYER_GROUND_ACCEL / space.gravity.y
-            head.friction = HEAD_FRICTION
-        else:
-            feet.friction, head.friction = 0, 0
-
-        # Air control
-        if grounding["body"] == None:
-            body.velocity = Vec2d(
-                cpflerpconst(
-                    body.velocity.x,
-                    target_vx + ground_velocity.x,
-                    PLAYER_AIR_ACCEL * dt,
-                ),
-                body.velocity.y,
-            )
-
-        body.velocity = body.velocity.x, max(
-            body.velocity.y, -FALL_VELOCITY
-        )  # clamp upwards as well?
-
-        # Move the moving platform
-        destination = platform_path[platform_path_index]
-        current = Vec2d(*platform_body.position)
-        distance = current.get_distance(destination)
-        if distance < PLATFORM_SPEED:
-            platform_path_index += 1
-            platform_path_index = platform_path_index % len(platform_path)
-            t = 1
-        else:
-            t = PLATFORM_SPEED / distance
-        new = current.interpolate_to(destination, t)
-        platform_body.position = new
-        platform_body.velocity = (new - current) / dt
-
-        ### Clear screen
-        screen.fill(pygame.Color("black"))
-
-        ### Helper lines
-        for y in [50, 100, 150, 200, 250, 300]:
-            color = pygame.Color("green")
-            pygame.draw.line(screen, color, (10, y), (680, y), 1)
-
-        ### Draw stuff
-        space.debug_draw(draw_options)
-
-        direction_offset = 48 + (1 * direction + 1) // 2 * 48
-        if grounding["body"] != None and abs(target_vx) > 1:
-            animation_offset = 32 * (frame_number // 8 % 4)
-        elif grounding["body"] is None:
-            animation_offset = 32 * 1
-        else:
-            animation_offset = 32 * 0
-        position = body.position + (-16, 28)
-        p = pymunk.pygame_util.to_pygame(position, screen)
-        screen.blit(img, p, (animation_offset, direction_offset, 32, 48))
-
-        # Did we land?
-        if abs(grounding["impulse"].y) / body.mass > 200 and not landed_previous:
-            sound.play()
-            landing = {"p": grounding["position"], "n": 5}
-            landed_previous = True
-        else:
-            landed_previous = False
-        if landing["n"] > 0:
-            p = pymunk.pygame_util.to_pygame(landing["p"], screen)
-            pygame.draw.circle(screen, pygame.Color("yellow"), p, 5)
-            landing["n"] -= 1
-
-        # Info and flip screen
-        screen.blit(
-            font.render("fps: " + str(clock.get_fps()), 1, pygame.Color("white")),
-            (0, 0),
-        )
-        screen.blit(
-            font.render(
-                "Move with Left/Right, jump with Up, press again to double jump",
-                1,
-                pygame.Color("darkgrey"),
-            ),
-            (5, height - 35),
-        )
-        screen.blit(
-            font.render("Press ESC or Q to quit", 1, pygame.Color("darkgrey")),
-            (5, height - 20),
-        )
-
-        pygame.display.flip()
-        frame_number += 1
-
-        ### Update physics
-
-        space.step(dt)
-
-        clock.tick(fps)
-
-
-if __name__ == "__main__":
-    sys.exit(main())
+"""Showcase of a very basic 2d platformer
+
+The red girl sprite is taken from Sithjester's RMXP Resources:
+http://untamed.wild-refuge.net/rmxpresources.php?characters
+
+.. note:: The code of this example is a bit messy. If you adapt this to your 
+    own code you might want to structure it a bit differently.
+"""
+
+__docformat__ = "reStructuredText"
+
+import math
+import sys
+import os.path
+
+import pygame
+
+import pymunk
+import pymunk.pygame_util
+from pymunk.vec2d import Vec2d
+
+
+def cpfclamp(f, min_, max_):
+    """Clamp f between min and max"""
+    return min(max(f, min_), max_)
+
+
+def cpflerpconst(f1, f2, d):
+    """Linearly interpolate from f1 to f2 by no more than d."""
+    return f1 + cpfclamp(f2 - f1, -d, d)
+
+
+width, height = 690, 400
+fps = 60
+dt = 1.0 / fps
+PLAYER_VELOCITY = 100.0 * 2.0
+PLAYER_GROUND_ACCEL_TIME = 0.05
+PLAYER_GROUND_ACCEL = PLAYER_VELOCITY / PLAYER_GROUND_ACCEL_TIME
+
+PLAYER_AIR_ACCEL_TIME = 0.25
+PLAYER_AIR_ACCEL = PLAYER_VELOCITY / PLAYER_AIR_ACCEL_TIME
+
+JUMP_HEIGHT = 16.0 * 3
+JUMP_BOOST_HEIGHT = 24.0
+JUMP_CUTOFF_VELOCITY = 100
+FALL_VELOCITY = 250.0
+
+JUMP_LENIENCY = 0.05
+
+HEAD_FRICTION = 0.7
+
+PLATFORM_SPEED = 1
+
+
+def main():
+
+    ### PyGame init
+    pygame.init()
+    screen = pygame.display.set_mode((width, height))
+
+    clock = pygame.time.Clock()
+    running = True
+    font = pygame.font.SysFont("Arial", 16)
+    sound = pygame.mixer.Sound(
+        os.path.join(os.path.dirname(os.path.abspath(__file__)), "sfx.wav")
+    )
+    img = pygame.image.load(
+        os.path.join(os.path.dirname(os.path.abspath(__file__)), "xmasgirl1.png")
+    )
+
+    ### Physics stuff
+    space = pymunk.Space()
+    space.gravity = Vec2d(0, -1000)
+    pymunk.pygame_util.positive_y_is_up = True
+    draw_options = pymunk.pygame_util.DrawOptions(screen)
+
+    # box walls
+    static = [
+        pymunk.Segment(space.static_body, (10, 50), (300, 50), 3),
+        pymunk.Segment(space.static_body, (300, 50), (325, 50), 3),
+        pymunk.Segment(space.static_body, (325, 50), (350, 50), 3),
+        pymunk.Segment(space.static_body, (350, 50), (375, 50), 3),
+        pymunk.Segment(space.static_body, (375, 50), (680, 50), 3),
+        pymunk.Segment(space.static_body, (680, 50), (680, 370), 3),
+        pymunk.Segment(space.static_body, (680, 370), (10, 370), 3),
+        pymunk.Segment(space.static_body, (10, 370), (10, 50), 3),
+    ]
+    static[1].color = pygame.Color("red")
+    static[2].color = pygame.Color("green")
+    static[3].color = pygame.Color("red")
+
+    # rounded shape
+    rounded = [
+        pymunk.Segment(space.static_body, (500, 50), (520, 60), 3),
+        pymunk.Segment(space.static_body, (520, 60), (540, 80), 3),
+        pymunk.Segment(space.static_body, (540, 80), (550, 100), 3),
+        pymunk.Segment(space.static_body, (550, 100), (550, 150), 3),
+    ]
+
+    # static platforms
+    platforms = [
+        pymunk.Segment(space.static_body, (170, 50), (270, 150), 3)
+        # , pymunk.Segment(space.static_body, (270, 100), (300, 100), 5)
+        ,
+        pymunk.Segment(space.static_body, (400, 150), (450, 150), 3),
+        pymunk.Segment(space.static_body, (400, 200), (450, 200), 3),
+        pymunk.Segment(space.static_body, (220, 200), (300, 200), 3),
+        pymunk.Segment(space.static_body, (50, 250), (200, 250), 3),
+        pymunk.Segment(space.static_body, (10, 370), (50, 250), 3),
+    ]
+
+    for s in static + platforms + rounded:
+        s.friction = 1.0
+        s.group = 1
+    space.add(*static, *platforms, *rounded)
+
+    # moving platform
+    platform_path = [(650, 100), (600, 200), (650, 300)]
+    platform_path_index = 0
+    platform_body = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
+    platform_body.position = 650, 100
+    s = pymunk.Segment(platform_body, (-25, 0), (25, 0), 5)
+    s.friction = 1.0
+    s.group = 1
+    s.color = pygame.Color("blue")
+    space.add(platform_body, s)
+
+    # pass through platform
+    passthrough = pymunk.Segment(space.static_body, (270, 100), (320, 100), 5)
+    passthrough.color = pygame.Color("yellow")
+    passthrough.friction = 1.0
+    passthrough.collision_type = 2
+    passthrough.filter = pymunk.ShapeFilter(categories=0b1000)
+    space.add(passthrough)
+
+    def passthrough_handler(arbiter, space, data):
+        if arbiter.shapes[0].body.velocity.y < 0:
+            return True
+        else:
+            return False
+
+    space.add_collision_handler(1, 2).begin = passthrough_handler
+
+    # player
+    body = pymunk.Body(5, float("inf"))
+    body.position = 100, 100
+
+    head = pymunk.Circle(body, 10, (0, 5))
+    head2 = pymunk.Circle(body, 10, (0, 13))
+    feet = pymunk.Circle(body, 10, (0, -5))
+    # Since we use the debug draw we need to hide these circles. To make it
+    # easy we just set their color to black.
+    feet.color = 0, 0, 0, 0
+    head.color = 0, 0, 0, 0
+    head2.color = 0, 0, 0, 0
+    mask = pymunk.ShapeFilter.ALL_MASKS() ^ passthrough.filter.categories
+    sf = pymunk.ShapeFilter(mask=mask)
+    head.filter = sf
+    head2.filter = sf
+    feet.collision_type = 1
+    feet.ignore_draw = head.ignore_draw = head2.ignore_draw = True
+
+    space.add(body, head, feet, head2)
+    direction = 1
+    remaining_jumps = 2
+    landing = {"p": Vec2d.zero(), "n": 0}
+    frame_number = 0
+
+    landed_previous = False
+
+    while running:
+
+        grounding = {
+            "normal": Vec2d.zero(),
+            "penetration": Vec2d.zero(),
+            "impulse": Vec2d.zero(),
+            "position": Vec2d.zero(),
+            "body": None,
+        }
+        # find out if player is standing on ground
+
+        def f(arbiter):
+            n = -arbiter.contact_point_set.normal
+            if n.y > grounding["normal"].y:
+                grounding["normal"] = n
+                grounding["penetration"] = -arbiter.contact_point_set.points[0].distance
+                grounding["body"] = arbiter.shapes[1].body
+                grounding["impulse"] = arbiter.total_impulse
+                grounding["position"] = arbiter.contact_point_set.points[0].point_b
+
+        body.each_arbiter(f)
+
+        well_grounded = False
+        if (
+            grounding["body"] != None
+            and abs(grounding["normal"].x / grounding["normal"].y) < feet.friction
+        ):
+            well_grounded = True
+            remaining_jumps = 2
+
+        ground_velocity = Vec2d.zero()
+        if well_grounded:
+            ground_velocity = grounding["body"].velocity
+
+        for event in pygame.event.get():
+            if (
+                event.type == pygame.QUIT
+                or event.type == pygame.KEYDOWN
+                and (event.key in [pygame.K_ESCAPE, pygame.K_q])
+            ):
+                running = False
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
+                pygame.image.save(screen, "platformer.png")
+
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_UP:
+                if well_grounded or remaining_jumps > 0:
+                    jump_v = math.sqrt(2.0 * JUMP_HEIGHT * abs(space.gravity.y))
+                    impulse = (0, body.mass * (ground_velocity.y + jump_v))
+                    body.apply_impulse_at_local_point(impulse)
+                    remaining_jumps -= 1
+            elif event.type == pygame.KEYUP and event.key == pygame.K_UP:
+                body.velocity = body.velocity.x, min(
+                    body.velocity.y, JUMP_CUTOFF_VELOCITY
+                )
+
+        # Target horizontal velocity of player
+        target_vx = 0
+
+        if body.velocity.x > 0.01:
+            direction = 1
+        elif body.velocity.x < -0.01:
+            direction = -1
+
+        keys = pygame.key.get_pressed()
+        if keys[pygame.K_LEFT]:
+            direction = -1
+            target_vx -= PLAYER_VELOCITY
+        if keys[pygame.K_RIGHT]:
+            direction = 1
+            target_vx += PLAYER_VELOCITY
+        if keys[pygame.K_DOWN]:
+            direction = -3
+
+        feet.surface_velocity = -target_vx, 0
+
+        if grounding["body"] != None:
+            feet.friction = -PLAYER_GROUND_ACCEL / space.gravity.y
+            head.friction = HEAD_FRICTION
+        else:
+            feet.friction, head.friction = 0, 0
+
+        # Air control
+        if grounding["body"] == None:
+            body.velocity = Vec2d(
+                cpflerpconst(
+                    body.velocity.x,
+                    target_vx + ground_velocity.x,
+                    PLAYER_AIR_ACCEL * dt,
+                ),
+                body.velocity.y,
+            )
+
+        body.velocity = body.velocity.x, max(
+            body.velocity.y, -FALL_VELOCITY
+        )  # clamp upwards as well?
+
+        # Move the moving platform
+        destination = platform_path[platform_path_index]
+        current = Vec2d(*platform_body.position)
+        distance = current.get_distance(destination)
+        if distance < PLATFORM_SPEED:
+            platform_path_index += 1
+            platform_path_index = platform_path_index % len(platform_path)
+            t = 1
+        else:
+            t = PLATFORM_SPEED / distance
+        new = current.interpolate_to(destination, t)
+        platform_body.position = new
+        platform_body.velocity = (new - current) / dt
+
+        ### Clear screen
+        screen.fill(pygame.Color("black"))
+
+        ### Helper lines
+        for y in [50, 100, 150, 200, 250, 300]:
+            color = pygame.Color("green")
+            pygame.draw.line(screen, color, (10, y), (680, y), 1)
+
+        ### Draw stuff
+        space.debug_draw(draw_options)
+
+        direction_offset = 48 + (1 * direction + 1) // 2 * 48
+        if grounding["body"] != None and abs(target_vx) > 1:
+            animation_offset = 32 * (frame_number // 8 % 4)
+        elif grounding["body"] is None:
+            animation_offset = 32 * 1
+        else:
+            animation_offset = 32 * 0
+        position = body.position + (-16, 28)
+        p = pymunk.pygame_util.to_pygame(position, screen)
+        screen.blit(img, p, (animation_offset, direction_offset, 32, 48))
+
+        # Did we land?
+        if abs(grounding["impulse"].y) / body.mass > 200 and not landed_previous:
+            sound.play()
+            landing = {"p": grounding["position"], "n": 5}
+            landed_previous = True
+        else:
+            landed_previous = False
+        if landing["n"] > 0:
+            p = pymunk.pygame_util.to_pygame(landing["p"], screen)
+            pygame.draw.circle(screen, pygame.Color("yellow"), p, 5)
+            landing["n"] -= 1
+
+        # Info and flip screen
+        screen.blit(
+            font.render("fps: " + str(clock.get_fps()), 1, pygame.Color("white")),
+            (0, 0),
+        )
+        screen.blit(
+            font.render(
+                "Move with Left/Right, jump with Up, press again to double jump",
+                1,
+                pygame.Color("darkgrey"),
+            ),
+            (5, height - 35),
+        )
+        screen.blit(
+            font.render("Press ESC or Q to quit", 1, pygame.Color("darkgrey")),
+            (5, height - 20),
+        )
+
+        pygame.display.flip()
+        frame_number += 1
+
+        ### Update physics
+
+        space.step(dt)
+
+        clock.tick(fps)
+
+
+if __name__ == "__main__":
+    sys.exit(main())
```

## Comparing `pymunk-6.5.0/pymunk/examples/playground.py` & `pymunk/examples/playground.py`

 * *Ordering differences only*

 * *Files 23% similar despite different names*

```diff
@@ -1,356 +1,356 @@
-"""A basic playground. Most interesting function is draw a shape, basically 
-move the mouse as you want and pymunk will approximate a Poly shape from the 
-drawing.
-"""
-__docformat__ = "reStructuredText"
-
-import pygame
-
-import pymunk as pm
-import pymunk.util as u
-from pymunk import Vec2d
-
-# TODO: Clean up code
-
-COLLTYPE_DEFAULT = 0
-COLLTYPE_MOUSE = 1
-
-
-class PhysicsDemo:
-    def flipyv(self, v):
-        return int(v.x), int(-v.y + self.h)
-
-    def __init__(self):
-        self.running = True
-        ### Init pygame and create screen
-        pygame.init()
-        self.w, self.h = 600, 600
-        self.screen = pygame.display.set_mode((self.w, self.h))
-        self.clock = pygame.time.Clock()
-
-        ### Init pymunk and create space
-        self.space = pm.Space()
-        self.space.gravity = (0.0, -900.0)
-
-        ### Walls
-        self.walls = []
-        self.create_wall_segments([(100, 50), (500, 50)])
-
-        ## Balls
-        # balls = [createBall(space, (100,300))]
-        self.balls = []
-
-        ### Polys
-        self.polys = []
-        h = 10
-        for y in range(1, h):
-            # for x in range(1, y):
-            x = 0
-            s = 10
-            p = Vec2d(300, 40) + Vec2d(0, y * s * 2)
-            self.polys.append(self.create_box(p, size=s, mass=1))
-
-        self.run_physics = True
-
-        ### Wall under construction
-        self.wall_points = []
-        ### Poly under construction
-        self.poly_points = []
-
-        self.shape_to_remove = None
-        self.mouse_contact = None
-
-    def draw_helptext(self):
-        font = pygame.font.Font(None, 16)
-        text = [
-            "LMB: Create ball",
-            "LMB + Shift: Create box",
-            "RMB on object: Remove object",
-            "RMB(hold) + Shift: Create polygon, release to finish (we be converted to a convex hull of the points)",
-            "RMB + Ctrl: Create wall, release to finish",
-            "Space: Stop physics simulation",
-            "k: Spawn a bunch of blocks",
-            "f: Fire a ball from the top left corner",
-        ]
-        y = 5
-        for line in text:
-            text = font.render(line, True, pygame.Color("black"))
-            self.screen.blit(text, (5, y))
-            y += 10
-
-    def create_ball(self, point, mass=1.0, radius=15.0):
-
-        moment = pm.moment_for_circle(mass, 0.0, radius)
-        ball_body = pm.Body(mass, moment)
-        ball_body.position = Vec2d(*point)
-
-        ball_shape = pm.Circle(ball_body, radius)
-        ball_shape.friction = 1.5
-        ball_shape.collision_type = COLLTYPE_DEFAULT
-        self.space.add(ball_body, ball_shape)
-        return ball_shape
-
-    def create_box(self, pos, size=10, mass=5.0):
-        box_points = [(-size, -size), (-size, size), (size, size), (size, -size)]
-        return self.create_poly(box_points, mass=mass, pos=pos)
-
-    def create_poly(self, points, mass=5.0, pos=(0, 0)):
-
-        moment = pm.moment_for_poly(mass, points)
-        # moment = 1000
-        body = pm.Body(mass, moment)
-        body.position = Vec2d(*pos)
-        shape = pm.Poly(body, points)
-        shape.friction = 0.5
-        shape.collision_type = COLLTYPE_DEFAULT
-        self.space.add(body, shape)
-        return shape
-
-    def create_wall_segments(self, points):
-        """Create a number of wall segments connecting the points"""
-        if len(points) < 2:
-            return []
-        points = [Vec2d(*p) for p in points]
-        for i in range(len(points) - 1):
-            v1 = Vec2d(points[i].x, points[i].y)
-            v2 = Vec2d(points[i + 1].x, points[i + 1].y)
-            wall_body = pm.Body(body_type=pm.Body.STATIC)
-            wall_shape = pm.Segment(wall_body, v1, v2, 0.0)
-            wall_shape.friction = 1.0
-            wall_shape.collision_type = COLLTYPE_DEFAULT
-            self.space.add(wall_body, wall_shape)
-            self.walls.append(wall_shape)
-
-    def run(self):
-        while self.running:
-            self.loop()
-
-    def draw_ball(self, ball):
-        body = ball.body
-        v = body.position + ball.offset.cpvrotate(body.rotation_vector)
-        p = self.flipyv(v)
-        r = ball.radius
-        pygame.draw.circle(self.screen, pygame.Color("blue"), p, int(r), 2)
-
-    def draw_wall(self, wall):
-        body = wall.body
-        pv1 = self.flipyv(body.position + wall.a.cpvrotate(body.rotation_vector))
-        pv2 = self.flipyv(body.position + wall.b.cpvrotate(body.rotation_vector))
-        pygame.draw.lines(self.screen, pygame.Color("lightgray"), False, [pv1, pv2])
-
-    def draw_poly(self, poly):
-        body = poly.body
-        ps = [p.rotated(body.angle) + body.position for p in poly.get_vertices()]
-        ps.append(ps[0])
-        ps = list(map(self.flipyv, ps))
-        if u.is_clockwise(ps):
-            color = pygame.Color("green")
-        else:
-            color = pygame.Color("red")
-        pygame.draw.lines(self.screen, color, False, ps)
-
-    def draw(self):
-
-        ### Clear the screen
-        self.screen.fill(pygame.Color("white"))
-
-        ### Display some text
-        self.draw_helptext()
-
-        ### Draw balls
-        for ball in self.balls:
-            self.draw_ball(ball)
-
-        ### Draw walls
-        for wall in self.walls:
-            self.draw_wall(wall)
-
-        ### Draw polys
-        for poly in self.polys:
-            self.draw_poly(poly)
-
-        ### Draw Uncompleted walls
-        if len(self.wall_points) > 1:
-            ps = [self.flipyv(Vec2d(*p)) for p in self.wall_points]
-            pygame.draw.lines(self.screen, pygame.Color("gray"), False, ps, 2)
-
-        ### Uncompleted poly
-        if len(self.poly_points) > 1:
-            ps = [self.flipyv(Vec2d(*p)) for p in self.poly_points]
-            pygame.draw.lines(self.screen, pygame.Color("red"), False, ps, 2)
-
-        ### Mouse Contact
-        if self.mouse_contact is not None:
-            p = self.flipyv(self.mouse_contact)
-            pygame.draw.circle(self.screen, pygame.Color("red"), p, 3)
-
-        ### All done, lets flip the display
-        pygame.display.flip()
-
-    def loop(self):
-        for event in pygame.event.get():
-            if event.type == pygame.QUIT:
-                self.running = False
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
-                self.running = False
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
-                pygame.image.save(self.screen, "playground.png")
-
-            elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:  # LMB
-                if pygame.key.get_mods() & pygame.KMOD_SHIFT:
-                    p = self.flipyv(Vec2d(*event.pos))
-                    self.polys.append(self.create_box(pos=p))
-                else:
-                    # t = -10000
-                    p = self.flipyv(Vec2d(*event.pos))
-                    self.balls.append(self.create_ball(p))
-
-            elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 3:  # RMB
-                if pygame.key.get_mods() & pygame.KMOD_SHIFT:
-                    pass
-
-                elif pygame.key.get_mods() & pygame.KMOD_CTRL:
-                    p = self.flipyv(Vec2d(*event.pos))
-                    self.wall_points.append(p)
-                elif self.shape_to_remove is not None:
-
-                    self.balls = list(
-                        filter(lambda a: a != self.shape_to_remove, self.balls)
-                    )
-                    self.walls = list(
-                        filter(lambda a: a != self.shape_to_remove, self.walls)
-                    )
-                    self.polys = list(
-                        filter(lambda a: a != self.shape_to_remove, self.polys)
-                    )
-                    self.space.remove(self.shape_to_remove.body, self.shape_to_remove)
-
-            elif event.type == pygame.KEYUP and event.key in (
-                pygame.K_RCTRL,
-                pygame.K_LCTRL,
-            ):
-                ### Create Wall
-                self.create_wall_segments(self.wall_points)
-                self.wall_points = []
-            elif event.type == pygame.KEYUP and event.key in (
-                pygame.K_RSHIFT,
-                pygame.K_LSHIFT,
-            ):
-                ### Create Polygon
-
-                if len(self.poly_points) > 0:
-                    self.poly_points = u.reduce_poly(self.poly_points, tolerance=5)
-                if len(self.poly_points) > 2:
-                    self.poly_points = u.convex_hull(self.poly_points)
-                    if not u.is_clockwise(self.poly_points):
-                        self.poly_points.reverse()
-
-                    center = u.calc_center(self.poly_points)
-                    self.poly_points = u.poly_vectors_around_center(self.poly_points)
-                    self.polys.append(self.create_poly(self.poly_points, pos=center))
-                self.poly_points = []
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_SPACE:
-                self.run_physics = not self.run_physics
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_k:
-                for x in range(-100, 100, 25):
-                    for y in range(-100, 100, 25):
-                        p = pygame.mouse.get_pos()
-                        p = Vec2d(*self.flipyv(Vec2d(*p))) + (x, y)
-                        self.polys.append(self.create_box(pos=p))
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_b:
-                p = self.flipyv(Vec2d(*pygame.mouse.get_pos()))
-                self.polys.append(self.create_box(p, size=10, mass=1))
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_f:
-                bp = Vec2d(100, 500)
-                p = self.flipyv(Vec2d(*pygame.mouse.get_pos())) - bp
-                ball = self.create_ball(bp)
-                p = p.normalized()
-                ball.body.apply_impulse_at_local_point(p * 1000, (0, 0))
-                self.balls.append(ball)
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_g:
-                g = self.space.gravity
-
-                self.space.gravity = g.rotated_degrees(45)
-
-        mpos = pygame.mouse.get_pos()
-
-        if pygame.key.get_mods() & pygame.KMOD_SHIFT and pygame.mouse.get_pressed()[2]:
-            p = self.flipyv(Vec2d(*mpos))
-            self.poly_points.append(p)
-        hit = self.space.point_query_nearest(
-            self.flipyv(Vec2d(*mpos)), 0, pm.ShapeFilter()
-        )
-        if hit != None:
-            self.shape_to_remove = hit.shape
-        else:
-            self.shape_to_remove = None
-
-        ### Update physics
-        if self.run_physics:
-            x = 1
-            dt = 1.0 / 60.0 / x
-            for x in range(x):
-                self.space.step(dt)
-                for ball in self.balls:
-                    # ball.body.reset_forces()
-                    pass
-                for poly in self.polys:
-                    # poly.body.reset_forces()
-                    pass
-
-        ### Draw stuff
-        self.draw()
-
-        ### Check for objects outside of the screen, we can remove those
-        # Balls
-        xs = []
-        for ball in self.balls:
-            if (
-                ball.body.position.x < -1000
-                or ball.body.position.x > 1000
-                or ball.body.position.y < -1000
-                or ball.body.position.y > 1000
-            ):
-                xs.append(ball)
-        for ball in xs:
-            self.space.remove(ball, ball.body)
-            self.balls.remove(ball)
-
-        # Polys
-        xs = []
-        for poly in self.polys:
-            if (
-                poly.body.position.x < -1000
-                or poly.body.position.x > 1000
-                or poly.body.position.y < -1000
-                or poly.body.position.y > 1000
-            ):
-                xs.append(poly)
-
-        for poly in xs:
-            self.space.remove(poly, poly.body)
-            self.polys.remove(poly)
-
-        ### Tick clock and update fps in title
-        self.clock.tick(50)
-        pygame.display.set_caption("fps: " + str(self.clock.get_fps()))
-
-
-def main():
-    demo = PhysicsDemo()
-    demo.run()
-
-
-if __name__ == "__main__":
-    doprof = 0
-    if not doprof:
-        main()
-    else:
-        import cProfile
-        import pstats
-
-        prof = cProfile.run("main()", "profile.prof")
-        stats = pstats.Stats("profile.prof")
-        stats.strip_dirs()
-        stats.sort_stats("cumulative", "time", "calls")
-        stats.print_stats(30)
+"""A basic playground. Most interesting function is draw a shape, basically 
+move the mouse as you want and pymunk will approximate a Poly shape from the 
+drawing.
+"""
+__docformat__ = "reStructuredText"
+
+import pygame
+
+import pymunk as pm
+import pymunk.util as u
+from pymunk import Vec2d
+
+# TODO: Clean up code
+
+COLLTYPE_DEFAULT = 0
+COLLTYPE_MOUSE = 1
+
+
+class PhysicsDemo:
+    def flipyv(self, v):
+        return int(v.x), int(-v.y + self.h)
+
+    def __init__(self):
+        self.running = True
+        ### Init pygame and create screen
+        pygame.init()
+        self.w, self.h = 600, 600
+        self.screen = pygame.display.set_mode((self.w, self.h))
+        self.clock = pygame.time.Clock()
+
+        ### Init pymunk and create space
+        self.space = pm.Space()
+        self.space.gravity = (0.0, -900.0)
+
+        ### Walls
+        self.walls = []
+        self.create_wall_segments([(100, 50), (500, 50)])
+
+        ## Balls
+        # balls = [createBall(space, (100,300))]
+        self.balls = []
+
+        ### Polys
+        self.polys = []
+        h = 10
+        for y in range(1, h):
+            # for x in range(1, y):
+            x = 0
+            s = 10
+            p = Vec2d(300, 40) + Vec2d(0, y * s * 2)
+            self.polys.append(self.create_box(p, size=s, mass=1))
+
+        self.run_physics = True
+
+        ### Wall under construction
+        self.wall_points = []
+        ### Poly under construction
+        self.poly_points = []
+
+        self.shape_to_remove = None
+        self.mouse_contact = None
+
+    def draw_helptext(self):
+        font = pygame.font.Font(None, 16)
+        text = [
+            "LMB: Create ball",
+            "LMB + Shift: Create box",
+            "RMB on object: Remove object",
+            "RMB(hold) + Shift: Create polygon, release to finish (we be converted to a convex hull of the points)",
+            "RMB + Ctrl: Create wall, release to finish",
+            "Space: Stop physics simulation",
+            "k: Spawn a bunch of blocks",
+            "f: Fire a ball from the top left corner",
+        ]
+        y = 5
+        for line in text:
+            text = font.render(line, True, pygame.Color("black"))
+            self.screen.blit(text, (5, y))
+            y += 10
+
+    def create_ball(self, point, mass=1.0, radius=15.0):
+
+        moment = pm.moment_for_circle(mass, 0.0, radius)
+        ball_body = pm.Body(mass, moment)
+        ball_body.position = Vec2d(*point)
+
+        ball_shape = pm.Circle(ball_body, radius)
+        ball_shape.friction = 1.5
+        ball_shape.collision_type = COLLTYPE_DEFAULT
+        self.space.add(ball_body, ball_shape)
+        return ball_shape
+
+    def create_box(self, pos, size=10, mass=5.0):
+        box_points = [(-size, -size), (-size, size), (size, size), (size, -size)]
+        return self.create_poly(box_points, mass=mass, pos=pos)
+
+    def create_poly(self, points, mass=5.0, pos=(0, 0)):
+
+        moment = pm.moment_for_poly(mass, points)
+        # moment = 1000
+        body = pm.Body(mass, moment)
+        body.position = Vec2d(*pos)
+        shape = pm.Poly(body, points)
+        shape.friction = 0.5
+        shape.collision_type = COLLTYPE_DEFAULT
+        self.space.add(body, shape)
+        return shape
+
+    def create_wall_segments(self, points):
+        """Create a number of wall segments connecting the points"""
+        if len(points) < 2:
+            return []
+        points = [Vec2d(*p) for p in points]
+        for i in range(len(points) - 1):
+            v1 = Vec2d(points[i].x, points[i].y)
+            v2 = Vec2d(points[i + 1].x, points[i + 1].y)
+            wall_body = pm.Body(body_type=pm.Body.STATIC)
+            wall_shape = pm.Segment(wall_body, v1, v2, 0.0)
+            wall_shape.friction = 1.0
+            wall_shape.collision_type = COLLTYPE_DEFAULT
+            self.space.add(wall_body, wall_shape)
+            self.walls.append(wall_shape)
+
+    def run(self):
+        while self.running:
+            self.loop()
+
+    def draw_ball(self, ball):
+        body = ball.body
+        v = body.position + ball.offset.cpvrotate(body.rotation_vector)
+        p = self.flipyv(v)
+        r = ball.radius
+        pygame.draw.circle(self.screen, pygame.Color("blue"), p, int(r), 2)
+
+    def draw_wall(self, wall):
+        body = wall.body
+        pv1 = self.flipyv(body.position + wall.a.cpvrotate(body.rotation_vector))
+        pv2 = self.flipyv(body.position + wall.b.cpvrotate(body.rotation_vector))
+        pygame.draw.lines(self.screen, pygame.Color("lightgray"), False, [pv1, pv2])
+
+    def draw_poly(self, poly):
+        body = poly.body
+        ps = [p.rotated(body.angle) + body.position for p in poly.get_vertices()]
+        ps.append(ps[0])
+        ps = list(map(self.flipyv, ps))
+        if u.is_clockwise(ps):
+            color = pygame.Color("green")
+        else:
+            color = pygame.Color("red")
+        pygame.draw.lines(self.screen, color, False, ps)
+
+    def draw(self):
+
+        ### Clear the screen
+        self.screen.fill(pygame.Color("white"))
+
+        ### Display some text
+        self.draw_helptext()
+
+        ### Draw balls
+        for ball in self.balls:
+            self.draw_ball(ball)
+
+        ### Draw walls
+        for wall in self.walls:
+            self.draw_wall(wall)
+
+        ### Draw polys
+        for poly in self.polys:
+            self.draw_poly(poly)
+
+        ### Draw Uncompleted walls
+        if len(self.wall_points) > 1:
+            ps = [self.flipyv(Vec2d(*p)) for p in self.wall_points]
+            pygame.draw.lines(self.screen, pygame.Color("gray"), False, ps, 2)
+
+        ### Uncompleted poly
+        if len(self.poly_points) > 1:
+            ps = [self.flipyv(Vec2d(*p)) for p in self.poly_points]
+            pygame.draw.lines(self.screen, pygame.Color("red"), False, ps, 2)
+
+        ### Mouse Contact
+        if self.mouse_contact is not None:
+            p = self.flipyv(self.mouse_contact)
+            pygame.draw.circle(self.screen, pygame.Color("red"), p, 3)
+
+        ### All done, lets flip the display
+        pygame.display.flip()
+
+    def loop(self):
+        for event in pygame.event.get():
+            if event.type == pygame.QUIT:
+                self.running = False
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
+                self.running = False
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
+                pygame.image.save(self.screen, "playground.png")
+
+            elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:  # LMB
+                if pygame.key.get_mods() & pygame.KMOD_SHIFT:
+                    p = self.flipyv(Vec2d(*event.pos))
+                    self.polys.append(self.create_box(pos=p))
+                else:
+                    # t = -10000
+                    p = self.flipyv(Vec2d(*event.pos))
+                    self.balls.append(self.create_ball(p))
+
+            elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 3:  # RMB
+                if pygame.key.get_mods() & pygame.KMOD_SHIFT:
+                    pass
+
+                elif pygame.key.get_mods() & pygame.KMOD_CTRL:
+                    p = self.flipyv(Vec2d(*event.pos))
+                    self.wall_points.append(p)
+                elif self.shape_to_remove is not None:
+
+                    self.balls = list(
+                        filter(lambda a: a != self.shape_to_remove, self.balls)
+                    )
+                    self.walls = list(
+                        filter(lambda a: a != self.shape_to_remove, self.walls)
+                    )
+                    self.polys = list(
+                        filter(lambda a: a != self.shape_to_remove, self.polys)
+                    )
+                    self.space.remove(self.shape_to_remove.body, self.shape_to_remove)
+
+            elif event.type == pygame.KEYUP and event.key in (
+                pygame.K_RCTRL,
+                pygame.K_LCTRL,
+            ):
+                ### Create Wall
+                self.create_wall_segments(self.wall_points)
+                self.wall_points = []
+            elif event.type == pygame.KEYUP and event.key in (
+                pygame.K_RSHIFT,
+                pygame.K_LSHIFT,
+            ):
+                ### Create Polygon
+
+                if len(self.poly_points) > 0:
+                    self.poly_points = u.reduce_poly(self.poly_points, tolerance=5)
+                if len(self.poly_points) > 2:
+                    self.poly_points = u.convex_hull(self.poly_points)
+                    if not u.is_clockwise(self.poly_points):
+                        self.poly_points.reverse()
+
+                    center = u.calc_center(self.poly_points)
+                    self.poly_points = u.poly_vectors_around_center(self.poly_points)
+                    self.polys.append(self.create_poly(self.poly_points, pos=center))
+                self.poly_points = []
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_SPACE:
+                self.run_physics = not self.run_physics
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_k:
+                for x in range(-100, 100, 25):
+                    for y in range(-100, 100, 25):
+                        p = pygame.mouse.get_pos()
+                        p = Vec2d(*self.flipyv(Vec2d(*p))) + (x, y)
+                        self.polys.append(self.create_box(pos=p))
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_b:
+                p = self.flipyv(Vec2d(*pygame.mouse.get_pos()))
+                self.polys.append(self.create_box(p, size=10, mass=1))
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_f:
+                bp = Vec2d(100, 500)
+                p = self.flipyv(Vec2d(*pygame.mouse.get_pos())) - bp
+                ball = self.create_ball(bp)
+                p = p.normalized()
+                ball.body.apply_impulse_at_local_point(p * 1000, (0, 0))
+                self.balls.append(ball)
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_g:
+                g = self.space.gravity
+
+                self.space.gravity = g.rotated_degrees(45)
+
+        mpos = pygame.mouse.get_pos()
+
+        if pygame.key.get_mods() & pygame.KMOD_SHIFT and pygame.mouse.get_pressed()[2]:
+            p = self.flipyv(Vec2d(*mpos))
+            self.poly_points.append(p)
+        hit = self.space.point_query_nearest(
+            self.flipyv(Vec2d(*mpos)), 0, pm.ShapeFilter()
+        )
+        if hit != None:
+            self.shape_to_remove = hit.shape
+        else:
+            self.shape_to_remove = None
+
+        ### Update physics
+        if self.run_physics:
+            x = 1
+            dt = 1.0 / 60.0 / x
+            for x in range(x):
+                self.space.step(dt)
+                for ball in self.balls:
+                    # ball.body.reset_forces()
+                    pass
+                for poly in self.polys:
+                    # poly.body.reset_forces()
+                    pass
+
+        ### Draw stuff
+        self.draw()
+
+        ### Check for objects outside of the screen, we can remove those
+        # Balls
+        xs = []
+        for ball in self.balls:
+            if (
+                ball.body.position.x < -1000
+                or ball.body.position.x > 1000
+                or ball.body.position.y < -1000
+                or ball.body.position.y > 1000
+            ):
+                xs.append(ball)
+        for ball in xs:
+            self.space.remove(ball, ball.body)
+            self.balls.remove(ball)
+
+        # Polys
+        xs = []
+        for poly in self.polys:
+            if (
+                poly.body.position.x < -1000
+                or poly.body.position.x > 1000
+                or poly.body.position.y < -1000
+                or poly.body.position.y > 1000
+            ):
+                xs.append(poly)
+
+        for poly in xs:
+            self.space.remove(poly, poly.body)
+            self.polys.remove(poly)
+
+        ### Tick clock and update fps in title
+        self.clock.tick(50)
+        pygame.display.set_caption("fps: " + str(self.clock.get_fps()))
+
+
+def main():
+    demo = PhysicsDemo()
+    demo.run()
+
+
+if __name__ == "__main__":
+    doprof = 0
+    if not doprof:
+        main()
+    else:
+        import cProfile
+        import pstats
+
+        prof = cProfile.run("main()", "profile.prof")
+        stats = pstats.Stats("profile.prof")
+        stats.strip_dirs()
+        stats.sort_stats("cumulative", "time", "calls")
+        stats.print_stats(30)
```

## Comparing `pymunk-6.5.0/pymunk/examples/point_query.py` & `pymunk/examples/point_query.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,100 +1,100 @@
-"""This example showcase point queries by highlighting the shape under the 
-mouse pointer.
-"""
-
-__version__ = "$Id:$"
-__docformat__ = "reStructuredText"
-
-import random
-import sys
-
-import pygame
-
-import pymunk
-import pymunk.pygame_util
-from pymunk import Vec2d
-
-
-def main():
-    pygame.init()
-    screen = pygame.display.set_mode((600, 600))
-    clock = pygame.time.Clock()
-    running = True
-
-    ### Physics stuff
-    space = pymunk.Space()
-    space.gravity = Vec2d(0.0, 900.0)
-    draw_options = pymunk.pygame_util.DrawOptions(screen)
-    ## Balls
-    balls = []
-
-    ### walls
-    static_lines = [
-        pymunk.Segment(space.static_body, Vec2d(111, 320), Vec2d(407, 354), 1.0),
-        pymunk.Segment(space.static_body, Vec2d(407, 354), Vec2d(407, 257), 1.0),
-    ]
-    space.add(*static_lines)
-
-    ticks_to_next_ball = 10
-
-    while running:
-        for event in pygame.event.get():
-            if event.type == pygame.QUIT:
-                running = False
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
-                running = False
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
-                pygame.image.save(screen, "point_query.png")
-
-        ticks_to_next_ball -= 1
-        if ticks_to_next_ball <= 0:
-            ticks_to_next_ball = 100
-            mass = 10
-            radius = 25
-            inertia = pymunk.moment_for_circle(mass, 0, radius, (0, 0))
-            body = pymunk.Body(mass, inertia)
-            x = random.randint(115, 350)
-            body.position = x, 200
-            shape = pymunk.Circle(body, radius, Vec2d(0, 0))
-            shape.color = pygame.Color("lightgrey")
-            space.add(body, shape)
-            balls.append(shape)
-
-        ### Clear screen
-        screen.fill(pygame.Color("white"))
-
-        ### Draw stuff
-        space.debug_draw(draw_options)
-
-        balls_to_remove = []
-        for ball in balls:
-            if ball.body.position.y > 400:
-                balls_to_remove.append(ball)
-
-        for ball in balls_to_remove:
-            space.remove(ball, ball.body)
-            balls.remove(ball)
-
-        mouse_pos = pymunk.pygame_util.get_mouse_pos(screen)
-
-        shape = space.point_query_nearest(
-            mouse_pos, float("inf"), pymunk.ShapeFilter()
-        ).shape
-        if shape is not None and isinstance(shape, pymunk.Circle):
-            r = shape.radius + 4
-            p = pymunk.pygame_util.to_pygame(shape.body.position, screen)
-            pygame.draw.circle(screen, pygame.Color("red"), p, int(r), 2)
-
-        ### Update physics
-        dt = 1.0 / 60.0
-        for x in range(1):
-            space.step(dt)
-
-        ### Flip screen
-        pygame.display.flip()
-        clock.tick(50)
-        pygame.display.set_caption("fps: " + str(clock.get_fps()))
-
-
-if __name__ == "__main__":
-    sys.exit(main())
+"""This example showcase point queries by highlighting the shape under the 
+mouse pointer.
+"""
+
+__version__ = "$Id:$"
+__docformat__ = "reStructuredText"
+
+import random
+import sys
+
+import pygame
+
+import pymunk
+import pymunk.pygame_util
+from pymunk import Vec2d
+
+
+def main():
+    pygame.init()
+    screen = pygame.display.set_mode((600, 600))
+    clock = pygame.time.Clock()
+    running = True
+
+    ### Physics stuff
+    space = pymunk.Space()
+    space.gravity = Vec2d(0.0, 900.0)
+    draw_options = pymunk.pygame_util.DrawOptions(screen)
+    ## Balls
+    balls = []
+
+    ### walls
+    static_lines = [
+        pymunk.Segment(space.static_body, Vec2d(111, 320), Vec2d(407, 354), 1.0),
+        pymunk.Segment(space.static_body, Vec2d(407, 354), Vec2d(407, 257), 1.0),
+    ]
+    space.add(*static_lines)
+
+    ticks_to_next_ball = 10
+
+    while running:
+        for event in pygame.event.get():
+            if event.type == pygame.QUIT:
+                running = False
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
+                running = False
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
+                pygame.image.save(screen, "point_query.png")
+
+        ticks_to_next_ball -= 1
+        if ticks_to_next_ball <= 0:
+            ticks_to_next_ball = 100
+            mass = 10
+            radius = 25
+            inertia = pymunk.moment_for_circle(mass, 0, radius, (0, 0))
+            body = pymunk.Body(mass, inertia)
+            x = random.randint(115, 350)
+            body.position = x, 200
+            shape = pymunk.Circle(body, radius, Vec2d(0, 0))
+            shape.color = pygame.Color("lightgrey")
+            space.add(body, shape)
+            balls.append(shape)
+
+        ### Clear screen
+        screen.fill(pygame.Color("white"))
+
+        ### Draw stuff
+        space.debug_draw(draw_options)
+
+        balls_to_remove = []
+        for ball in balls:
+            if ball.body.position.y > 400:
+                balls_to_remove.append(ball)
+
+        for ball in balls_to_remove:
+            space.remove(ball, ball.body)
+            balls.remove(ball)
+
+        mouse_pos = pymunk.pygame_util.get_mouse_pos(screen)
+
+        shape = space.point_query_nearest(
+            mouse_pos, float("inf"), pymunk.ShapeFilter()
+        ).shape
+        if shape is not None and isinstance(shape, pymunk.Circle):
+            r = shape.radius + 4
+            p = pymunk.pygame_util.to_pygame(shape.body.position, screen)
+            pygame.draw.circle(screen, pygame.Color("red"), p, int(r), 2)
+
+        ### Update physics
+        dt = 1.0 / 60.0
+        for x in range(1):
+            space.step(dt)
+
+        ### Flip screen
+        pygame.display.flip()
+        clock.tick(50)
+        pygame.display.set_caption("fps: " + str(clock.get_fps()))
+
+
+if __name__ == "__main__":
+    sys.exit(main())
```

## Comparing `pymunk-6.5.0/pymunk/examples/pygame_util_demo.py` & `pymunk/examples/pygame_util_demo.py`

 * *Ordering differences only*

 * *Files 10% similar despite different names*

```diff
@@ -1,63 +1,63 @@
-"""Showcase what the output of pymunk.pygame_util draw methods will look like.
-
-See pyglet_util_demo.py for a comparison to pyglet.
-"""
-
-__docformat__ = "reStructuredText"
-
-import sys
-
-import pygame
-
-import pymunk
-import pymunk.pygame_util
-
-from .shapes_for_draw_demos import fill_space
-
-
-def main():
-    pygame.init()
-    screen = pygame.display.set_mode((1000, 700))
-    clock = pygame.time.Clock()
-    font = pygame.font.SysFont("Arial", 16)
-
-    pymunk.pygame_util.positive_y_is_up = True
-    space = pymunk.Space()
-
-    captions = fill_space(space)
-
-    ### Draw it
-    screen.fill(pygame.Color("white"))
-
-    options = pymunk.pygame_util.DrawOptions(screen)
-    space.debug_draw(options)
-    # pymunk.pygame_util.draw(screen, space)
-
-    # Info
-    color = pygame.Color("black")
-    screen.blit(
-        font.render("Demo example of pygame_util.DrawOptions()", True, color),
-        (205, 680),
-    )
-    for caption in captions:
-        x, y = caption[0]
-        y = 700 - y
-        screen.blit(font.render(caption[1], True, color), (x, y))
-    pygame.display.flip()
-
-    while True:
-        for event in pygame.event.get():
-            if (
-                event.type == pygame.QUIT
-                or event.type == pygame.KEYDOWN
-                and (event.key in [pygame.K_ESCAPE, pygame.K_q])
-            ):
-                return
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
-                pygame.image.save(screen, "pygame_util_demo.png")
-
-        clock.tick(10)
-
-
-if __name__ == "__main__":
-    sys.exit(main())
+"""Showcase what the output of pymunk.pygame_util draw methods will look like.
+
+See pyglet_util_demo.py for a comparison to pyglet.
+"""
+
+__docformat__ = "reStructuredText"
+
+import sys
+
+import pygame
+
+import pymunk
+import pymunk.pygame_util
+
+from .shapes_for_draw_demos import fill_space
+
+
+def main():
+    pygame.init()
+    screen = pygame.display.set_mode((1000, 700))
+    clock = pygame.time.Clock()
+    font = pygame.font.SysFont("Arial", 16)
+
+    pymunk.pygame_util.positive_y_is_up = True
+    space = pymunk.Space()
+
+    captions = fill_space(space)
+
+    ### Draw it
+    screen.fill(pygame.Color("white"))
+
+    options = pymunk.pygame_util.DrawOptions(screen)
+    space.debug_draw(options)
+    # pymunk.pygame_util.draw(screen, space)
+
+    # Info
+    color = pygame.Color("black")
+    screen.blit(
+        font.render("Demo example of pygame_util.DrawOptions()", True, color),
+        (205, 680),
+    )
+    for caption in captions:
+        x, y = caption[0]
+        y = 700 - y
+        screen.blit(font.render(caption[1], True, color), (x, y))
+    pygame.display.flip()
+
+    while True:
+        for event in pygame.event.get():
+            if (
+                event.type == pygame.QUIT
+                or event.type == pygame.KEYDOWN
+                and (event.key in [pygame.K_ESCAPE, pygame.K_q])
+            ):
+                return
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
+                pygame.image.save(screen, "pygame_util_demo.png")
+
+        clock.tick(10)
+
+
+if __name__ == "__main__":
+    sys.exit(main())
```

## Comparing `pymunk-6.5.0/pymunk/examples/pymunk_logo_googlecode.png` & `pymunk/examples/pymunk_logo_googlecode.png`

 * *Files identical despite different names*

## Comparing `pymunk-6.5.0/pymunk/examples/sfx.wav` & `pymunk/examples/sfx.wav`

 * *Files identical despite different names*

## Comparing `pymunk-6.5.0/pymunk/examples/shapes_for_draw_demos.py` & `pymunk/examples/shapes_for_draw_demos.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,362 +1,362 @@
-""" Helper function fill_space for the draw demos. 
-Adds a lot of stuff to a space.
-"""
-
-import pymunk
-
-
-def fill_space(space, custom_color=(255, 255, 0, 255)):
-    captions = []
-
-    ### Static
-    captions.append(((50, 680), "Static Shapes"))
-
-    # Static Segments
-    segments = [
-        pymunk.Segment(space.static_body, (10, 400), (10, 600), 0),
-        pymunk.Segment(space.static_body, (20, 400), (20, 600), 1),
-        pymunk.Segment(space.static_body, (30, 400), (30, 600), 3),
-        pymunk.Segment(space.static_body, (50, 400), (50, 600), 5),
-    ]
-    space.add(*segments)
-
-    b = pymunk.Body(body_type=pymunk.Body.STATIC)
-    b.position = (40, 630)
-    b.angle = 3.14 / 7
-    s = pymunk.Segment(b, (-30, 0), (30, 0), 2)
-    space.add(b, s)
-
-    # Static Circles
-    b = pymunk.Body(body_type=pymunk.Body.STATIC)
-    b.position = (120, 630)
-    s = pymunk.Circle(b, 10)
-    space.add(b, s)
-
-    b = pymunk.Body(body_type=pymunk.Body.STATIC)
-    b.position = (120, 630)
-    s = pymunk.Circle(b, 10, (-30, 0))
-    space.add(b, s)
-
-    b = pymunk.Body(body_type=pymunk.Body.STATIC)
-    b.position = (120, 560)
-    b.angle = 3.14 / 4
-    s = pymunk.Circle(b, 40)
-    space.add(b, s)
-
-    # Static Polys
-    b = pymunk.Body(body_type=pymunk.Body.STATIC)
-    b.position = (120, 460)
-    b.angle = 3.14 / 4
-    s = pymunk.Poly(b, [(0, -25), (30, 25), (-30, 25)])
-    space.add(b, s)
-
-    b = pymunk.Body(body_type=pymunk.Body.STATIC)
-    b.position = (120, 500)
-    t = pymunk.Transform(ty=-100)
-    s = pymunk.Poly(b, [(0, -25), (30, 25), (-30, 25)], t, radius=1)
-    space.add(b, s)
-
-    b = pymunk.Body(body_type=pymunk.Body.STATIC)
-    b.position = (50, 430)
-    t = pymunk.Transform(ty=-100)
-    s = pymunk.Poly(
-        b,
-        [
-            (0.0, -30.0),
-            (19.0, -23.0),
-            (30.0, -5.0),
-            (26.0, 15.0),
-            (10.0, 28.0),
-            (-10.0, 28.0),
-            (-26.0, 15.0),
-            (-30.0, -5.0),
-            (-19.0, -23.0),
-        ],
-        t,
-    )
-    space.add(b, s)
-
-    ### Kinematic
-    captions.append(((220, 680), "Kinematic Shapes"))
-
-    # Kinematic Segments
-    b = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
-    segments = [
-        pymunk.Segment(b, (180, 400), (180, 600), 0),
-        pymunk.Segment(b, (190, 400), (190, 600), 1),
-        pymunk.Segment(b, (200, 400), (200, 600), 3),
-        pymunk.Segment(b, (220, 400), (220, 600), 5),
-    ]
-    space.add(b, *segments)
-
-    b = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
-    b.position = (210, 630)
-    b.angle = 3.14 / 7
-    s = pymunk.Segment(b, (-30, 0), (30, 0), 2)
-    space.add(b, s)
-
-    # Kinematic Circles
-    b = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
-    b.position = (290, 630)
-    s = pymunk.Circle(b, 10)
-    space.add(b, s)
-
-    b = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
-    b.position = (290, 630)
-    s = pymunk.Circle(b, 10, (-30, 0))
-    space.add(b, s)
-
-    b = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
-    b.position = (290, 560)
-    b.angle = 3.14 / 4
-    s = pymunk.Circle(b, 40)
-    space.add(b, s)
-
-    # Kinematic Polys
-    b = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
-    b.position = (290, 460)
-    b.angle = 3.14 / 4
-    s = pymunk.Poly(b, [(0, -25), (30, 25), (-30, 25)])
-    space.add(b, s)
-
-    b = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
-    b.position = (290, 500)
-    t = pymunk.Transform(ty=-100)
-    s = pymunk.Poly(b, [(0, -25), (30, 25), (-30, 25)], t, radius=3)
-    space.add(b, s)
-
-    b = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
-    b.position = (230, 430)
-    t = pymunk.Transform(ty=-100)
-    s = pymunk.Poly(
-        b,
-        [
-            (19.0, -50.0),
-            (30.0, -5.0),
-            (26.0, 15.0),
-            (10.0, 38.0),
-            (-10.0, 38.0),
-            (-26.0, 15.0),
-            (-30.0, -5.0),
-            (-19.0, -50.0),
-        ],
-        t,
-    )
-    space.add(b, s)
-
-    ### Dynamic
-    captions.append(((390, 680), "Dynamic Shapes"))
-
-    # Dynamic Segments
-    b = pymunk.Body(1, 1)
-    segments = [
-        pymunk.Segment(b, (350, 400), (350, 600), 0),
-        pymunk.Segment(b, (360, 400), (360, 600), 1),
-        pymunk.Segment(b, (370, 400), (370, 600), 3),
-        pymunk.Segment(b, (390, 400), (390, 600), 5),
-    ]
-    space.add(b, *segments)
-
-    b = pymunk.Body(1, 1)
-    b.position = (380, 630)
-    b.angle = 3.14 / 7
-    s = pymunk.Segment(b, (-30, 0), (30, 0), 7)
-    space.add(b, s)
-
-    # Dynamic Circles
-    b = pymunk.Body(1, 1)
-    b.position = (460, 630)
-    s = pymunk.Circle(b, 10)
-    space.add(b, s)
-
-    b = pymunk.Body(1, 1)
-    b.position = (460, 630)
-    s = pymunk.Circle(b, 10, (-30, 0))
-    space.add(b, s)
-
-    b = pymunk.Body(1, 1)
-    b.position = (460, 560)
-    b.angle = 3.14 / 4
-    s = pymunk.Circle(b, 40)
-    space.add(b, s)
-
-    # Dynamic Polys
-
-    b = pymunk.Body(1, 1)
-    b.position = (460, 460)
-    b.angle = 3.14 / 4
-    s = pymunk.Poly(b, [(0, -25), (30, 25), (-30, 25)])
-    space.add(b, s)
-
-    b = pymunk.Body(1, 1)
-    b.position = (460, 500)
-    s = pymunk.Poly(
-        b, [(0, -25), (30, 25), (-30, 25)], pymunk.Transform(ty=-100), radius=5
-    )
-    space.add(b, s)
-
-    b = pymunk.Body(1, 1)
-    b.position = (400, 430)
-    s = pymunk.Poly(
-        b, [(0, -50), (50, 0), (30, 50), (-30, 50), (-50, 0)], pymunk.Transform(ty=-100)
-    )
-    space.add(b, s)
-
-    ###Constraints
-
-    # PinJoints
-    captions.append(((560, 660), "Pin Joint"))
-    a = pymunk.Body(1, 1)
-    a.position = (550, 600)
-    sa = pymunk.Circle(a, 20)
-    b = pymunk.Body(1, 1)
-    b.position = (650, 620)
-    sb = pymunk.Circle(b, 20)
-    j = pymunk.PinJoint(a, b, anchor_a=(0, 0), anchor_b=(0, -20))
-    space.add(sa, sb, a, b, j)
-
-    # SlideJoints
-    captions.append(((560, 560), "Slide Joint"))
-    a = pymunk.Body(1, 1)
-    a.position = (550, 500)
-    sa = pymunk.Circle(a, 20)
-    b = pymunk.Body(1, 1)
-    b.position = (650, 520)
-    sb = pymunk.Circle(b, 20)
-    j = pymunk.SlideJoint(a, b, anchor_a=(0, 20), anchor_b=(0, -20), min=10, max=30)
-    space.add(sa, sb, a, b, j)
-
-    # PivotJoints
-    captions.append(((560, 460), "Pivot Joint"))
-    a = pymunk.Body(1, 1)
-    a.position = (550, 400)
-    sa = pymunk.Circle(a, 20)
-    b = pymunk.Body(1, 1)
-    b.position = (650, 420)
-    sb = pymunk.Circle(b, 20)
-    j = pymunk.PivotJoint(a, b, (600, 390))
-    space.add(sa, sb, a, b, j)
-
-    # GrooveJoints
-    captions.append(((760, 660), "Groove Joint"))
-    a = pymunk.Body(1, 1)
-    a.position = (750, 600)
-    sa = pymunk.Circle(a, 20)
-    b = pymunk.Body(1, 1)
-    b.position = (850, 620)
-    sb = pymunk.Circle(b, 20)
-    j = pymunk.GrooveJoint(a, b, (40, 40), (40, -40), (-60, 0))
-    space.add(sa, sb, a, b, j)
-
-    # DampedSpring
-    captions.append(((760, 550), "Damped Spring"))
-    a = pymunk.Body(1, 1)
-    a.position = (750, 480)
-    sa = pymunk.Circle(a, 20)
-    b = pymunk.Body(1, 1)
-    b.position = (850, 500)
-    sb = pymunk.Circle(b, 20)
-    j = pymunk.DampedSpring(a, b, (0, 0), (0, 10), 100, 1, 1)
-    space.add(sa, sb, a, b, j)
-
-    # DampedRotarySpring
-    captions.append(((740, 430), "Damped Rotary Spring"))
-    a = pymunk.Body(1, 1)
-    a.position = (750, 350)
-    sa = pymunk.Circle(a, 20)
-    b = pymunk.Body(1, 1)
-    b.position = (850, 380)
-    sb = pymunk.Circle(b, 20)
-    j = pymunk.DampedRotarySpring(a, b, 10, 1, 1)
-    space.add(sa, sb, a, b, j)
-
-    # RotaryLimitJoint
-    captions.append(((740, 300), "Rotary Limit Joint"))
-    a = pymunk.Body(1, 1)
-    a.position = (750, 220)
-    sa = pymunk.Circle(a, 20)
-    b = pymunk.Body(1, 1)
-    b.position = (850, 250)
-    sb = pymunk.Circle(b, 20)
-    j = pymunk.RotaryLimitJoint(a, b, 1, 2)
-    b.angle = 3
-    space.add(sa, sb, a, b, j)
-
-    # RatchetJoint
-    captions.append(((740, 170), "Ratchet Joint"))
-    a = pymunk.Body(1, 1)
-    a.position = (750, 100)
-    sa = pymunk.Circle(a, 20)
-    b = pymunk.Body(1, 1)
-    b.position = (850, 120)
-    sb = pymunk.Circle(b, 20)
-    j = pymunk.RatchetJoint(a, b, 1, 0.1)
-    b.angle = 3
-    space.add(sa, sb, a, b, j)
-
-    # GearJoint and SimpleMotor omitted since they are similar to the already
-    # added joints
-
-    # TODO: more stuff here :)
-
-    ### Other
-
-    # Objects in custom color
-    captions.append(((150, 150), "Custom Color (static, kinematic & dynamic)"))
-    b = pymunk.Body(body_type=pymunk.Body.STATIC)
-    b.position = (200, 200)
-    s = pymunk.Circle(b, 30)
-    s.color = custom_color
-    space.add(b, s)
-
-    b = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
-    b.position = (300, 200)
-    s = pymunk.Circle(b, 30)
-    s.color = custom_color
-    space.add(b, s)
-
-    b = pymunk.Body(1, 1)
-    b.position = (400, 200)
-    s = pymunk.Circle(b, 30)
-    s.color = custom_color
-    space.add(b, s)
-
-    # Collision
-    captions.append(((550, 150), "Collisions"))
-    b = pymunk.Body(body_type=pymunk.Body.STATIC)
-    b.position = (570, 200)
-    s = pymunk.Circle(b, 40)
-    space.add(b, s)
-
-    b = pymunk.Body(1, 1)
-    b.position = (590, 250)
-    s = pymunk.Circle(b, 40)
-    space.add(b, s)
-
-    # Sleeping
-    captions.append(((50, 150), "Sleeping"))
-    b = pymunk.Body(1, 1)
-    b.position = (75, 200)
-    space.sleep_time_threshold = 0.01
-    s = pymunk.Circle(b, 40)
-    space.add(s, b)
-    b.sleep()
-    space.step(0.000001)
-
-    return captions
-
-
-def main():
-    space = pymunk.Space()
-    fill_space(space)
-
-    options = pymunk.SpaceDebugDrawOptions()
-    space.step(1)
-    space.step(2)
-    space.debug_draw(options)
-
-
-if __name__ == "__main__":
-    import sys
-
-    sys.exit(main())
+""" Helper function fill_space for the draw demos. 
+Adds a lot of stuff to a space.
+"""
+
+import pymunk
+
+
+def fill_space(space, custom_color=(255, 255, 0, 255)):
+    captions = []
+
+    ### Static
+    captions.append(((50, 680), "Static Shapes"))
+
+    # Static Segments
+    segments = [
+        pymunk.Segment(space.static_body, (10, 400), (10, 600), 0),
+        pymunk.Segment(space.static_body, (20, 400), (20, 600), 1),
+        pymunk.Segment(space.static_body, (30, 400), (30, 600), 3),
+        pymunk.Segment(space.static_body, (50, 400), (50, 600), 5),
+    ]
+    space.add(*segments)
+
+    b = pymunk.Body(body_type=pymunk.Body.STATIC)
+    b.position = (40, 630)
+    b.angle = 3.14 / 7
+    s = pymunk.Segment(b, (-30, 0), (30, 0), 2)
+    space.add(b, s)
+
+    # Static Circles
+    b = pymunk.Body(body_type=pymunk.Body.STATIC)
+    b.position = (120, 630)
+    s = pymunk.Circle(b, 10)
+    space.add(b, s)
+
+    b = pymunk.Body(body_type=pymunk.Body.STATIC)
+    b.position = (120, 630)
+    s = pymunk.Circle(b, 10, (-30, 0))
+    space.add(b, s)
+
+    b = pymunk.Body(body_type=pymunk.Body.STATIC)
+    b.position = (120, 560)
+    b.angle = 3.14 / 4
+    s = pymunk.Circle(b, 40)
+    space.add(b, s)
+
+    # Static Polys
+    b = pymunk.Body(body_type=pymunk.Body.STATIC)
+    b.position = (120, 460)
+    b.angle = 3.14 / 4
+    s = pymunk.Poly(b, [(0, -25), (30, 25), (-30, 25)])
+    space.add(b, s)
+
+    b = pymunk.Body(body_type=pymunk.Body.STATIC)
+    b.position = (120, 500)
+    t = pymunk.Transform(ty=-100)
+    s = pymunk.Poly(b, [(0, -25), (30, 25), (-30, 25)], t, radius=1)
+    space.add(b, s)
+
+    b = pymunk.Body(body_type=pymunk.Body.STATIC)
+    b.position = (50, 430)
+    t = pymunk.Transform(ty=-100)
+    s = pymunk.Poly(
+        b,
+        [
+            (0.0, -30.0),
+            (19.0, -23.0),
+            (30.0, -5.0),
+            (26.0, 15.0),
+            (10.0, 28.0),
+            (-10.0, 28.0),
+            (-26.0, 15.0),
+            (-30.0, -5.0),
+            (-19.0, -23.0),
+        ],
+        t,
+    )
+    space.add(b, s)
+
+    ### Kinematic
+    captions.append(((220, 680), "Kinematic Shapes"))
+
+    # Kinematic Segments
+    b = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
+    segments = [
+        pymunk.Segment(b, (180, 400), (180, 600), 0),
+        pymunk.Segment(b, (190, 400), (190, 600), 1),
+        pymunk.Segment(b, (200, 400), (200, 600), 3),
+        pymunk.Segment(b, (220, 400), (220, 600), 5),
+    ]
+    space.add(b, *segments)
+
+    b = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
+    b.position = (210, 630)
+    b.angle = 3.14 / 7
+    s = pymunk.Segment(b, (-30, 0), (30, 0), 2)
+    space.add(b, s)
+
+    # Kinematic Circles
+    b = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
+    b.position = (290, 630)
+    s = pymunk.Circle(b, 10)
+    space.add(b, s)
+
+    b = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
+    b.position = (290, 630)
+    s = pymunk.Circle(b, 10, (-30, 0))
+    space.add(b, s)
+
+    b = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
+    b.position = (290, 560)
+    b.angle = 3.14 / 4
+    s = pymunk.Circle(b, 40)
+    space.add(b, s)
+
+    # Kinematic Polys
+    b = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
+    b.position = (290, 460)
+    b.angle = 3.14 / 4
+    s = pymunk.Poly(b, [(0, -25), (30, 25), (-30, 25)])
+    space.add(b, s)
+
+    b = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
+    b.position = (290, 500)
+    t = pymunk.Transform(ty=-100)
+    s = pymunk.Poly(b, [(0, -25), (30, 25), (-30, 25)], t, radius=3)
+    space.add(b, s)
+
+    b = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
+    b.position = (230, 430)
+    t = pymunk.Transform(ty=-100)
+    s = pymunk.Poly(
+        b,
+        [
+            (19.0, -50.0),
+            (30.0, -5.0),
+            (26.0, 15.0),
+            (10.0, 38.0),
+            (-10.0, 38.0),
+            (-26.0, 15.0),
+            (-30.0, -5.0),
+            (-19.0, -50.0),
+        ],
+        t,
+    )
+    space.add(b, s)
+
+    ### Dynamic
+    captions.append(((390, 680), "Dynamic Shapes"))
+
+    # Dynamic Segments
+    b = pymunk.Body(1, 1)
+    segments = [
+        pymunk.Segment(b, (350, 400), (350, 600), 0),
+        pymunk.Segment(b, (360, 400), (360, 600), 1),
+        pymunk.Segment(b, (370, 400), (370, 600), 3),
+        pymunk.Segment(b, (390, 400), (390, 600), 5),
+    ]
+    space.add(b, *segments)
+
+    b = pymunk.Body(1, 1)
+    b.position = (380, 630)
+    b.angle = 3.14 / 7
+    s = pymunk.Segment(b, (-30, 0), (30, 0), 7)
+    space.add(b, s)
+
+    # Dynamic Circles
+    b = pymunk.Body(1, 1)
+    b.position = (460, 630)
+    s = pymunk.Circle(b, 10)
+    space.add(b, s)
+
+    b = pymunk.Body(1, 1)
+    b.position = (460, 630)
+    s = pymunk.Circle(b, 10, (-30, 0))
+    space.add(b, s)
+
+    b = pymunk.Body(1, 1)
+    b.position = (460, 560)
+    b.angle = 3.14 / 4
+    s = pymunk.Circle(b, 40)
+    space.add(b, s)
+
+    # Dynamic Polys
+
+    b = pymunk.Body(1, 1)
+    b.position = (460, 460)
+    b.angle = 3.14 / 4
+    s = pymunk.Poly(b, [(0, -25), (30, 25), (-30, 25)])
+    space.add(b, s)
+
+    b = pymunk.Body(1, 1)
+    b.position = (460, 500)
+    s = pymunk.Poly(
+        b, [(0, -25), (30, 25), (-30, 25)], pymunk.Transform(ty=-100), radius=5
+    )
+    space.add(b, s)
+
+    b = pymunk.Body(1, 1)
+    b.position = (400, 430)
+    s = pymunk.Poly(
+        b, [(0, -50), (50, 0), (30, 50), (-30, 50), (-50, 0)], pymunk.Transform(ty=-100)
+    )
+    space.add(b, s)
+
+    ###Constraints
+
+    # PinJoints
+    captions.append(((560, 660), "Pin Joint"))
+    a = pymunk.Body(1, 1)
+    a.position = (550, 600)
+    sa = pymunk.Circle(a, 20)
+    b = pymunk.Body(1, 1)
+    b.position = (650, 620)
+    sb = pymunk.Circle(b, 20)
+    j = pymunk.PinJoint(a, b, anchor_a=(0, 0), anchor_b=(0, -20))
+    space.add(sa, sb, a, b, j)
+
+    # SlideJoints
+    captions.append(((560, 560), "Slide Joint"))
+    a = pymunk.Body(1, 1)
+    a.position = (550, 500)
+    sa = pymunk.Circle(a, 20)
+    b = pymunk.Body(1, 1)
+    b.position = (650, 520)
+    sb = pymunk.Circle(b, 20)
+    j = pymunk.SlideJoint(a, b, anchor_a=(0, 20), anchor_b=(0, -20), min=10, max=30)
+    space.add(sa, sb, a, b, j)
+
+    # PivotJoints
+    captions.append(((560, 460), "Pivot Joint"))
+    a = pymunk.Body(1, 1)
+    a.position = (550, 400)
+    sa = pymunk.Circle(a, 20)
+    b = pymunk.Body(1, 1)
+    b.position = (650, 420)
+    sb = pymunk.Circle(b, 20)
+    j = pymunk.PivotJoint(a, b, (600, 390))
+    space.add(sa, sb, a, b, j)
+
+    # GrooveJoints
+    captions.append(((760, 660), "Groove Joint"))
+    a = pymunk.Body(1, 1)
+    a.position = (750, 600)
+    sa = pymunk.Circle(a, 20)
+    b = pymunk.Body(1, 1)
+    b.position = (850, 620)
+    sb = pymunk.Circle(b, 20)
+    j = pymunk.GrooveJoint(a, b, (40, 40), (40, -40), (-60, 0))
+    space.add(sa, sb, a, b, j)
+
+    # DampedSpring
+    captions.append(((760, 550), "Damped Spring"))
+    a = pymunk.Body(1, 1)
+    a.position = (750, 480)
+    sa = pymunk.Circle(a, 20)
+    b = pymunk.Body(1, 1)
+    b.position = (850, 500)
+    sb = pymunk.Circle(b, 20)
+    j = pymunk.DampedSpring(a, b, (0, 0), (0, 10), 100, 1, 1)
+    space.add(sa, sb, a, b, j)
+
+    # DampedRotarySpring
+    captions.append(((740, 430), "Damped Rotary Spring"))
+    a = pymunk.Body(1, 1)
+    a.position = (750, 350)
+    sa = pymunk.Circle(a, 20)
+    b = pymunk.Body(1, 1)
+    b.position = (850, 380)
+    sb = pymunk.Circle(b, 20)
+    j = pymunk.DampedRotarySpring(a, b, 10, 1, 1)
+    space.add(sa, sb, a, b, j)
+
+    # RotaryLimitJoint
+    captions.append(((740, 300), "Rotary Limit Joint"))
+    a = pymunk.Body(1, 1)
+    a.position = (750, 220)
+    sa = pymunk.Circle(a, 20)
+    b = pymunk.Body(1, 1)
+    b.position = (850, 250)
+    sb = pymunk.Circle(b, 20)
+    j = pymunk.RotaryLimitJoint(a, b, 1, 2)
+    b.angle = 3
+    space.add(sa, sb, a, b, j)
+
+    # RatchetJoint
+    captions.append(((740, 170), "Ratchet Joint"))
+    a = pymunk.Body(1, 1)
+    a.position = (750, 100)
+    sa = pymunk.Circle(a, 20)
+    b = pymunk.Body(1, 1)
+    b.position = (850, 120)
+    sb = pymunk.Circle(b, 20)
+    j = pymunk.RatchetJoint(a, b, 1, 0.1)
+    b.angle = 3
+    space.add(sa, sb, a, b, j)
+
+    # GearJoint and SimpleMotor omitted since they are similar to the already
+    # added joints
+
+    # TODO: more stuff here :)
+
+    ### Other
+
+    # Objects in custom color
+    captions.append(((150, 150), "Custom Color (static, kinematic & dynamic)"))
+    b = pymunk.Body(body_type=pymunk.Body.STATIC)
+    b.position = (200, 200)
+    s = pymunk.Circle(b, 30)
+    s.color = custom_color
+    space.add(b, s)
+
+    b = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
+    b.position = (300, 200)
+    s = pymunk.Circle(b, 30)
+    s.color = custom_color
+    space.add(b, s)
+
+    b = pymunk.Body(1, 1)
+    b.position = (400, 200)
+    s = pymunk.Circle(b, 30)
+    s.color = custom_color
+    space.add(b, s)
+
+    # Collision
+    captions.append(((550, 150), "Collisions"))
+    b = pymunk.Body(body_type=pymunk.Body.STATIC)
+    b.position = (570, 200)
+    s = pymunk.Circle(b, 40)
+    space.add(b, s)
+
+    b = pymunk.Body(1, 1)
+    b.position = (590, 250)
+    s = pymunk.Circle(b, 40)
+    space.add(b, s)
+
+    # Sleeping
+    captions.append(((50, 150), "Sleeping"))
+    b = pymunk.Body(1, 1)
+    b.position = (75, 200)
+    space.sleep_time_threshold = 0.01
+    s = pymunk.Circle(b, 40)
+    space.add(s, b)
+    b.sleep()
+    space.step(0.000001)
+
+    return captions
+
+
+def main():
+    space = pymunk.Space()
+    fill_space(space)
+
+    options = pymunk.SpaceDebugDrawOptions()
+    space.step(1)
+    space.step(2)
+    space.debug_draw(options)
+
+
+if __name__ == "__main__":
+    import sys
+
+    sys.exit(main())
```

## Comparing `pymunk-6.5.0/pymunk/examples/slide_and_pinjoint.py` & `pymunk/examples/slide_and_pinjoint.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,105 +1,105 @@
-"""A L shape attached with a joint and constrained to not tip over.
-
-This example is also used in the Get Started Tutorial. 
-"""
-
-__docformat__ = "reStructuredText"
-
-import random
-import sys
-
-import pygame
-
-import pymunk
-import pymunk.pygame_util
-
-random.seed(1)
-
-
-def add_ball(space):
-    """Add a ball to the given space at a random position"""
-    mass = 1
-    radius = 14
-    inertia = pymunk.moment_for_circle(mass, 0, radius, (0, 0))
-    body = pymunk.Body(mass, inertia)
-    x = random.randint(120, 380)
-    body.position = x, 50
-    shape = pymunk.Circle(body, radius, (0, 0))
-    shape.friction = 1
-    space.add(body, shape)
-    return shape
-
-
-def add_L(space):
-    """Add a inverted L shape with two joints"""
-    rotation_center_body = pymunk.Body(body_type=pymunk.Body.STATIC)
-    rotation_center_body.position = (300, 300)
-
-    rotation_limit_body = pymunk.Body(body_type=pymunk.Body.STATIC)
-    rotation_limit_body.position = (200, 300)
-
-    body = pymunk.Body(10, 10000)
-    body.position = (300, 300)
-    l1 = pymunk.Segment(body, (-145, 0), (255.0, 0.0), 1)
-    l2 = pymunk.Segment(body, (-145, 0), (-145.0, -25.0), 1)
-    l1.friction = 1
-    l2.friction = 1
-    rotation_center_joint = pymunk.PinJoint(body, rotation_center_body, (0, 0), (0, 0))
-    joint_limit = 25
-    rotation_limit_joint = pymunk.SlideJoint(
-        body, rotation_limit_body, (-100, 0), (0, 0), 0, joint_limit
-    )
-
-    space.add(l1, l2, body, rotation_center_joint, rotation_limit_joint)
-    return l1, l2
-
-
-def main():
-    pygame.init()
-    screen = pygame.display.set_mode((600, 600))
-    pygame.display.set_caption("Joints. Just wait and the L will tip over")
-    clock = pygame.time.Clock()
-
-    space = pymunk.Space()
-    space.gravity = (0.0, 900.0)
-
-    lines = add_L(space)
-    balls = []
-    draw_options = pymunk.pygame_util.DrawOptions(screen)
-
-    ticks_to_next_ball = 10
-    while True:
-        for event in pygame.event.get():
-            if event.type == pygame.QUIT:
-                sys.exit(0)
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
-                sys.exit(0)
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
-                pygame.image.save(screen, "slide_and_pinjoint.png")
-
-        ticks_to_next_ball -= 1
-        if ticks_to_next_ball <= 0:
-            ticks_to_next_ball = 25
-            ball_shape = add_ball(space)
-            balls.append(ball_shape)
-
-        balls_to_remove = []
-        for ball in balls:
-            if ball.body.position.y > 450:
-                balls_to_remove.append(ball)
-
-        for ball in balls_to_remove:
-            space.remove(ball, ball.body)
-            balls.remove(ball)
-
-        space.step(1 / 50.0)
-
-        screen.fill((255, 255, 255))
-        space.debug_draw(draw_options)
-
-        pygame.display.flip()
-        clock.tick(50)
-
-
-if __name__ == "__main__":
-    main()
+"""A L shape attached with a joint and constrained to not tip over.
+
+This example is also used in the Get Started Tutorial. 
+"""
+
+__docformat__ = "reStructuredText"
+
+import random
+import sys
+
+import pygame
+
+import pymunk
+import pymunk.pygame_util
+
+random.seed(1)
+
+
+def add_ball(space):
+    """Add a ball to the given space at a random position"""
+    mass = 1
+    radius = 14
+    inertia = pymunk.moment_for_circle(mass, 0, radius, (0, 0))
+    body = pymunk.Body(mass, inertia)
+    x = random.randint(120, 380)
+    body.position = x, 50
+    shape = pymunk.Circle(body, radius, (0, 0))
+    shape.friction = 1
+    space.add(body, shape)
+    return shape
+
+
+def add_L(space):
+    """Add a inverted L shape with two joints"""
+    rotation_center_body = pymunk.Body(body_type=pymunk.Body.STATIC)
+    rotation_center_body.position = (300, 300)
+
+    rotation_limit_body = pymunk.Body(body_type=pymunk.Body.STATIC)
+    rotation_limit_body.position = (200, 300)
+
+    body = pymunk.Body(10, 10000)
+    body.position = (300, 300)
+    l1 = pymunk.Segment(body, (-145, 0), (255.0, 0.0), 1)
+    l2 = pymunk.Segment(body, (-145, 0), (-145.0, -25.0), 1)
+    l1.friction = 1
+    l2.friction = 1
+    rotation_center_joint = pymunk.PinJoint(body, rotation_center_body, (0, 0), (0, 0))
+    joint_limit = 25
+    rotation_limit_joint = pymunk.SlideJoint(
+        body, rotation_limit_body, (-100, 0), (0, 0), 0, joint_limit
+    )
+
+    space.add(l1, l2, body, rotation_center_joint, rotation_limit_joint)
+    return l1, l2
+
+
+def main():
+    pygame.init()
+    screen = pygame.display.set_mode((600, 600))
+    pygame.display.set_caption("Joints. Just wait and the L will tip over")
+    clock = pygame.time.Clock()
+
+    space = pymunk.Space()
+    space.gravity = (0.0, 900.0)
+
+    lines = add_L(space)
+    balls = []
+    draw_options = pymunk.pygame_util.DrawOptions(screen)
+
+    ticks_to_next_ball = 10
+    while True:
+        for event in pygame.event.get():
+            if event.type == pygame.QUIT:
+                sys.exit(0)
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
+                sys.exit(0)
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
+                pygame.image.save(screen, "slide_and_pinjoint.png")
+
+        ticks_to_next_ball -= 1
+        if ticks_to_next_ball <= 0:
+            ticks_to_next_ball = 25
+            ball_shape = add_ball(space)
+            balls.append(ball_shape)
+
+        balls_to_remove = []
+        for ball in balls:
+            if ball.body.position.y > 450:
+                balls_to_remove.append(ball)
+
+        for ball in balls_to_remove:
+            space.remove(ball, ball.body)
+            balls.remove(ball)
+
+        space.step(1 / 50.0)
+
+        screen.fill((255, 255, 255))
+        space.debug_draw(draw_options)
+
+        pygame.display.flip()
+        clock.tick(50)
+
+
+if __name__ == "__main__":
+    main()
```

## Comparing `pymunk-6.5.0/pymunk/examples/spiderweb.py` & `pymunk/examples/spiderweb.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,188 +1,188 @@
-"""Showcase of a elastic spiderweb (drawing with pyglet)
-
-It is possible to grab one of the crossings with the mouse
-"""
-
-__version__ = "$Id:$"
-__docformat__ = "reStructuredText"
-
-import pyglet
-
-import pymunk
-from pymunk.vec2d import Vec2d
-
-window = pyglet.window.Window()
-space = pymunk.Space()
-
-space.gravity = 0, -900
-space.damping = 0.999
-c = Vec2d(window.width / 2.0, window.height / 2.0)
-
-### WEB
-web_group = 1
-bs = []
-dist = 0.3
-
-cb = pymunk.Body(1, 1)
-cb.position = c
-s = pymunk.Circle(cb, 15)  # to have something to grab
-s.filter = pymunk.ShapeFilter(group=web_group)
-s.ignore_draw = True
-space.add(cb, s)
-
-# generate each crossing in the net
-for x in range(0, 101):
-    b = pymunk.Body(1, 1)
-    v = Vec2d(1, 0).rotated_degrees(x * 18)
-    scale = window.height / 2.0 / 6.0 * 0.5
-
-    dist += 1 / 18.0
-    dist = dist ** 1.005
-
-    offset = 0.0
-    offset = [0.0, -0.80, -1.0, -0.80][((x * 18) % 360) // 18 % 4]
-    offset = 0.8 + offset
-
-    offset *= dist ** 2.8 / 100.0
-
-    v = v.scale_to_length(scale * (dist + offset))
-
-    b.position = c + v
-    s = pymunk.Circle(b, 15)
-    s.filter = pymunk.ShapeFilter(group=web_group)
-    s.ignore_draw = True
-    space.add(b, s)
-    bs.append(b)
-
-
-def add_joint(a, b):
-    rl = a.position.get_distance(b.position) * 0.9
-    stiffness = 5000.0
-    damping = 100
-    j = pymunk.DampedSpring(a, b, (0, 0), (0, 0), rl, stiffness, damping)
-    j.max_bias = 1000
-    # j.max_force = 50000
-    space.add(j)
-
-
-for b in bs[:20]:
-    add_joint(cb, b)
-
-for i in range(len(bs) - 1):
-    add_joint(bs[i], bs[i + 1])
-
-    i2 = i + 20
-    if len(bs) > i2:
-        add_joint(bs[i], bs[i2])
-
-
-### WEB ATTACH POINTS
-static_bs = []
-for b in bs[-17::4]:
-    static_body = pymunk.Body(body_type=pymunk.Body.STATIC)
-    static_body.position = b.position
-    static_bs.append(static_body)
-
-    # j = pymunk.PivotJoint(static_body, b, static_body.position)
-    j = pymunk.DampedSpring(static_body, b, (0, 0), (0, 0), 0, 0, 0)
-    j.damping = 100
-    j.stiffness = 20000
-    space.add(j)
-
-### ALL SETUP DONE
-
-
-def update(dt):
-    # Note that we dont use dt as input into step. That is because the
-    # simulation will behave much better if the step size doesnt change
-    # between frames.
-    r = 10
-    for x in range(r):
-        space.step(1.0 / 30.0 / r)
-
-
-pyglet.clock.schedule_interval(update, 1 / 30.0)
-
-selected = None
-selected_joint = None
-mouse_body = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
-
-
-@window.event
-def on_mouse_press(x, y, button, modifiers):
-    mouse_body.position = Vec2d(x, y)
-    hit = space.point_query_nearest((x, y), 10, pymunk.ShapeFilter())
-    if hit != None:
-        global selected
-        body = hit.shape.body
-        rest_length = mouse_body.position.get_distance(body.position)
-        stiffness = 1000
-        damping = 10
-        selected = pymunk.DampedSpring(
-            mouse_body, body, (0, 0), (0, 0), rest_length, stiffness, damping
-        )
-        space.add(selected)
-
-
-@window.event
-def on_mouse_release(x, y, button, modifiers):
-    global selected
-    if selected != None:
-        space.remove(selected)
-        selected = None
-
-
-@window.event
-def on_mouse_drag(x, y, dx, dy, buttons, modifiers):
-    mouse_body.position = x, y
-
-
-@window.event
-def on_key_press(symbol, modifiers):
-    if symbol == pyglet.window.key.P:
-        pyglet.image.get_buffer_manager().get_color_buffer().save("spiderweb.png")
-
-
-fps_display = pyglet.window.FPSDisplay(window)
-
-
-@window.event
-def on_draw():
-    window.clear()
-
-    fps_display.draw()
-    batch = pyglet.graphics.Batch()
-    # static attach points
-    shapes_to_draw = []
-    for b in static_bs:
-        shapes_to_draw.append(
-            pyglet.shapes.Circle(
-                b.position.x, b.position.y, 6, color=(255, 0, 255), batch=batch
-            )
-        )
-
-    # web crossings / bodies
-    for b in bs:
-        shapes_to_draw.append(
-            pyglet.shapes.Circle(
-                b.position.x, b.position.y, 4, color=(200, 200, 200), batch=batch
-            )
-        )
-
-    # web net / constraints
-    for j in space.constraints:
-        shapes_to_draw.append(
-            pyglet.shapes.Line(
-                j.a.position.x,
-                j.a.position.y,
-                j.b.position.x,
-                j.b.position.y,
-                color=(200, 200, 200),
-                batch=batch,
-            )
-        )
-
-    batch.draw()
-
-
-pyglet.app.run()
+"""Showcase of a elastic spiderweb (drawing with pyglet)
+
+It is possible to grab one of the crossings with the mouse
+"""
+
+__version__ = "$Id:$"
+__docformat__ = "reStructuredText"
+
+import pyglet
+
+import pymunk
+from pymunk.vec2d import Vec2d
+
+window = pyglet.window.Window()
+space = pymunk.Space()
+
+space.gravity = 0, -900
+space.damping = 0.999
+c = Vec2d(window.width / 2.0, window.height / 2.0)
+
+### WEB
+web_group = 1
+bs = []
+dist = 0.3
+
+cb = pymunk.Body(1, 1)
+cb.position = c
+s = pymunk.Circle(cb, 15)  # to have something to grab
+s.filter = pymunk.ShapeFilter(group=web_group)
+s.ignore_draw = True
+space.add(cb, s)
+
+# generate each crossing in the net
+for x in range(0, 101):
+    b = pymunk.Body(1, 1)
+    v = Vec2d(1, 0).rotated_degrees(x * 18)
+    scale = window.height / 2.0 / 6.0 * 0.5
+
+    dist += 1 / 18.0
+    dist = dist ** 1.005
+
+    offset = 0.0
+    offset = [0.0, -0.80, -1.0, -0.80][((x * 18) % 360) // 18 % 4]
+    offset = 0.8 + offset
+
+    offset *= dist ** 2.8 / 100.0
+
+    v = v.scale_to_length(scale * (dist + offset))
+
+    b.position = c + v
+    s = pymunk.Circle(b, 15)
+    s.filter = pymunk.ShapeFilter(group=web_group)
+    s.ignore_draw = True
+    space.add(b, s)
+    bs.append(b)
+
+
+def add_joint(a, b):
+    rl = a.position.get_distance(b.position) * 0.9
+    stiffness = 5000.0
+    damping = 100
+    j = pymunk.DampedSpring(a, b, (0, 0), (0, 0), rl, stiffness, damping)
+    j.max_bias = 1000
+    # j.max_force = 50000
+    space.add(j)
+
+
+for b in bs[:20]:
+    add_joint(cb, b)
+
+for i in range(len(bs) - 1):
+    add_joint(bs[i], bs[i + 1])
+
+    i2 = i + 20
+    if len(bs) > i2:
+        add_joint(bs[i], bs[i2])
+
+
+### WEB ATTACH POINTS
+static_bs = []
+for b in bs[-17::4]:
+    static_body = pymunk.Body(body_type=pymunk.Body.STATIC)
+    static_body.position = b.position
+    static_bs.append(static_body)
+
+    # j = pymunk.PivotJoint(static_body, b, static_body.position)
+    j = pymunk.DampedSpring(static_body, b, (0, 0), (0, 0), 0, 0, 0)
+    j.damping = 100
+    j.stiffness = 20000
+    space.add(j)
+
+### ALL SETUP DONE
+
+
+def update(dt):
+    # Note that we dont use dt as input into step. That is because the
+    # simulation will behave much better if the step size doesnt change
+    # between frames.
+    r = 10
+    for x in range(r):
+        space.step(1.0 / 30.0 / r)
+
+
+pyglet.clock.schedule_interval(update, 1 / 30.0)
+
+selected = None
+selected_joint = None
+mouse_body = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
+
+
+@window.event
+def on_mouse_press(x, y, button, modifiers):
+    mouse_body.position = Vec2d(x, y)
+    hit = space.point_query_nearest((x, y), 10, pymunk.ShapeFilter())
+    if hit != None:
+        global selected
+        body = hit.shape.body
+        rest_length = mouse_body.position.get_distance(body.position)
+        stiffness = 1000
+        damping = 10
+        selected = pymunk.DampedSpring(
+            mouse_body, body, (0, 0), (0, 0), rest_length, stiffness, damping
+        )
+        space.add(selected)
+
+
+@window.event
+def on_mouse_release(x, y, button, modifiers):
+    global selected
+    if selected != None:
+        space.remove(selected)
+        selected = None
+
+
+@window.event
+def on_mouse_drag(x, y, dx, dy, buttons, modifiers):
+    mouse_body.position = x, y
+
+
+@window.event
+def on_key_press(symbol, modifiers):
+    if symbol == pyglet.window.key.P:
+        pyglet.image.get_buffer_manager().get_color_buffer().save("spiderweb.png")
+
+
+fps_display = pyglet.window.FPSDisplay(window)
+
+
+@window.event
+def on_draw():
+    window.clear()
+
+    fps_display.draw()
+    batch = pyglet.graphics.Batch()
+    # static attach points
+    shapes_to_draw = []
+    for b in static_bs:
+        shapes_to_draw.append(
+            pyglet.shapes.Circle(
+                b.position.x, b.position.y, 6, color=(255, 0, 255), batch=batch
+            )
+        )
+
+    # web crossings / bodies
+    for b in bs:
+        shapes_to_draw.append(
+            pyglet.shapes.Circle(
+                b.position.x, b.position.y, 4, color=(200, 200, 200), batch=batch
+            )
+        )
+
+    # web net / constraints
+    for j in space.constraints:
+        shapes_to_draw.append(
+            pyglet.shapes.Line(
+                j.a.position.x,
+                j.a.position.y,
+                j.b.position.x,
+                j.b.position.y,
+                color=(200, 200, 200),
+                batch=batch,
+            )
+        )
+
+    batch.draw()
+
+
+pyglet.app.run()
```

## Comparing `pymunk-6.5.0/pymunk/examples/tank.py` & `pymunk/examples/tank.py`

 * *Ordering differences only*

 * *Files 10% similar despite different names*

```diff
@@ -1,152 +1,152 @@
-"""Port of the Chipmunk tank demo. Showcase a topdown tank driving towards the
-mouse, and hitting obstacles on the way.
-"""
-
-import random
-
-import pygame
-
-import pymunk
-import pymunk.pygame_util
-from pymunk.vec2d import Vec2d
-
-
-def update(space, dt, surface):
-    global tank_body
-    global tank_control_body
-
-    mpos = pygame.mouse.get_pos()
-    mouse_pos = pymunk.pygame_util.from_pygame(Vec2d(*mpos), surface)
-
-    mouse_delta = mouse_pos - tank_body.position
-    turn = tank_body.rotation_vector.cpvunrotate(mouse_delta).angle
-    tank_control_body.angle = tank_body.angle - turn
-
-    # drive the tank towards the mouse
-    if (mouse_pos - tank_body.position).get_length_sqrd() < 30 ** 2:
-        tank_control_body.velocity = 0, 0
-    else:
-        if mouse_delta.dot(tank_body.rotation_vector) > 0.0:
-            direction = 1.0
-        else:
-            direction = -1.0
-        dv = Vec2d(30.0 * direction, 0.0)
-        tank_control_body.velocity = tank_body.rotation_vector.cpvrotate(dv)
-
-    space.step(dt)
-
-
-def add_box(space, size, mass):
-    radius = Vec2d(size, size).length
-
-    body = pymunk.Body()
-    space.add(body)
-
-    body.position = Vec2d(
-        random.random() * (640 - 2 * radius) + radius,
-        random.random() * (480 - 2 * radius) + radius,
-    )
-
-    shape = pymunk.Poly.create_box(body, (size, size), 0.0)
-    shape.mass = mass
-    shape.friction = 0.7
-    space.add(shape)
-
-    return body
-
-
-def init():
-
-    space = pymunk.Space()
-    space.iterations = 10
-    space.sleep_time_threshold = 0.5
-
-    static_body = space.static_body
-
-    # Create segments around the edge of the screen.
-    shape = pymunk.Segment(static_body, (1, 1), (1, 480), 1.0)
-    space.add(shape)
-    shape.elasticity = 1
-    shape.friction = 1
-
-    shape = pymunk.Segment(static_body, (640, 1), (640, 480), 1.0)
-    space.add(shape)
-    shape.elasticity = 1
-    shape.friction = 1
-
-    shape = pymunk.Segment(static_body, (1, 1), (640, 1), 1.0)
-    space.add(shape)
-    shape.elasticity = 1
-    shape.friction = 1
-
-    shape = pymunk.Segment(static_body, (1, 480), (640, 480), 1.0)
-    space.add(shape)
-    shape.elasticity = 1
-    shape.friction = 1
-
-    for _ in range(50):
-        body = add_box(space, 20, 1)
-
-        pivot = pymunk.PivotJoint(static_body, body, (0, 0), (0, 0))
-        space.add(pivot)
-        pivot.max_bias = 0  # disable joint correction
-        pivot.max_force = 1000  # emulate linear friction
-
-        gear = pymunk.GearJoint(static_body, body, 0.0, 1.0)
-        space.add(gear)
-        gear.max_bias = 0  # disable joint correction
-        gear.max_force = 5000  # emulate angular friction
-
-    # We joint the tank to the control body and control the tank indirectly by modifying the control body.
-    global tank_control_body
-    tank_control_body = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
-    tank_control_body.position = 320, 240
-    space.add(tank_control_body)
-    global tank_body
-    tank_body = add_box(space, 30, 10)
-    tank_body.position = 320, 240
-    for s in tank_body.shapes:
-        s.color = (0, 255, 100, 255)
-
-    pivot = pymunk.PivotJoint(tank_control_body, tank_body, (0, 0), (0, 0))
-    space.add(pivot)
-    pivot.max_bias = 0  # disable joint correction
-    pivot.max_force = 10000  # emulate linear friction
-
-    gear = pymunk.GearJoint(tank_control_body, tank_body, 0.0, 1.0)
-    space.add(gear)
-    gear.error_bias = 0  # attempt to fully correct the joint each step
-    gear.max_bias = 1.2  # but limit it's angular correction rate
-    gear.max_force = 50000  # emulate angular friction
-
-    return space
-
-
-space = init()
-pygame.init()
-screen = pygame.display.set_mode((640, 480))
-clock = pygame.time.Clock()
-draw_options = pymunk.pygame_util.DrawOptions(screen)
-
-
-font = pygame.font.Font(None, 24)
-text = "Use the mouse to drive the tank, it will follow the cursor."
-text = font.render(text, True, pygame.Color("white"))
-
-while True:
-    for event in pygame.event.get():
-        if (
-            event.type == pygame.QUIT
-            or event.type == pygame.KEYDOWN
-            and (event.key in [pygame.K_ESCAPE, pygame.K_q])
-        ):
-            exit()
-
-    screen.fill(pygame.Color("black"))
-    space.debug_draw(draw_options)
-    screen.blit(text, (15, 15))
-    fps = 60
-    update(space, 1 / fps, screen)
-    pygame.display.flip()
-
-    clock.tick(fps)
+"""Port of the Chipmunk tank demo. Showcase a topdown tank driving towards the
+mouse, and hitting obstacles on the way.
+"""
+
+import random
+
+import pygame
+
+import pymunk
+import pymunk.pygame_util
+from pymunk.vec2d import Vec2d
+
+
+def update(space, dt, surface):
+    global tank_body
+    global tank_control_body
+
+    mpos = pygame.mouse.get_pos()
+    mouse_pos = pymunk.pygame_util.from_pygame(Vec2d(*mpos), surface)
+
+    mouse_delta = mouse_pos - tank_body.position
+    turn = tank_body.rotation_vector.cpvunrotate(mouse_delta).angle
+    tank_control_body.angle = tank_body.angle - turn
+
+    # drive the tank towards the mouse
+    if (mouse_pos - tank_body.position).get_length_sqrd() < 30 ** 2:
+        tank_control_body.velocity = 0, 0
+    else:
+        if mouse_delta.dot(tank_body.rotation_vector) > 0.0:
+            direction = 1.0
+        else:
+            direction = -1.0
+        dv = Vec2d(30.0 * direction, 0.0)
+        tank_control_body.velocity = tank_body.rotation_vector.cpvrotate(dv)
+
+    space.step(dt)
+
+
+def add_box(space, size, mass):
+    radius = Vec2d(size, size).length
+
+    body = pymunk.Body()
+    space.add(body)
+
+    body.position = Vec2d(
+        random.random() * (640 - 2 * radius) + radius,
+        random.random() * (480 - 2 * radius) + radius,
+    )
+
+    shape = pymunk.Poly.create_box(body, (size, size), 0.0)
+    shape.mass = mass
+    shape.friction = 0.7
+    space.add(shape)
+
+    return body
+
+
+def init():
+
+    space = pymunk.Space()
+    space.iterations = 10
+    space.sleep_time_threshold = 0.5
+
+    static_body = space.static_body
+
+    # Create segments around the edge of the screen.
+    shape = pymunk.Segment(static_body, (1, 1), (1, 480), 1.0)
+    space.add(shape)
+    shape.elasticity = 1
+    shape.friction = 1
+
+    shape = pymunk.Segment(static_body, (640, 1), (640, 480), 1.0)
+    space.add(shape)
+    shape.elasticity = 1
+    shape.friction = 1
+
+    shape = pymunk.Segment(static_body, (1, 1), (640, 1), 1.0)
+    space.add(shape)
+    shape.elasticity = 1
+    shape.friction = 1
+
+    shape = pymunk.Segment(static_body, (1, 480), (640, 480), 1.0)
+    space.add(shape)
+    shape.elasticity = 1
+    shape.friction = 1
+
+    for _ in range(50):
+        body = add_box(space, 20, 1)
+
+        pivot = pymunk.PivotJoint(static_body, body, (0, 0), (0, 0))
+        space.add(pivot)
+        pivot.max_bias = 0  # disable joint correction
+        pivot.max_force = 1000  # emulate linear friction
+
+        gear = pymunk.GearJoint(static_body, body, 0.0, 1.0)
+        space.add(gear)
+        gear.max_bias = 0  # disable joint correction
+        gear.max_force = 5000  # emulate angular friction
+
+    # We joint the tank to the control body and control the tank indirectly by modifying the control body.
+    global tank_control_body
+    tank_control_body = pymunk.Body(body_type=pymunk.Body.KINEMATIC)
+    tank_control_body.position = 320, 240
+    space.add(tank_control_body)
+    global tank_body
+    tank_body = add_box(space, 30, 10)
+    tank_body.position = 320, 240
+    for s in tank_body.shapes:
+        s.color = (0, 255, 100, 255)
+
+    pivot = pymunk.PivotJoint(tank_control_body, tank_body, (0, 0), (0, 0))
+    space.add(pivot)
+    pivot.max_bias = 0  # disable joint correction
+    pivot.max_force = 10000  # emulate linear friction
+
+    gear = pymunk.GearJoint(tank_control_body, tank_body, 0.0, 1.0)
+    space.add(gear)
+    gear.error_bias = 0  # attempt to fully correct the joint each step
+    gear.max_bias = 1.2  # but limit it's angular correction rate
+    gear.max_force = 50000  # emulate angular friction
+
+    return space
+
+
+space = init()
+pygame.init()
+screen = pygame.display.set_mode((640, 480))
+clock = pygame.time.Clock()
+draw_options = pymunk.pygame_util.DrawOptions(screen)
+
+
+font = pygame.font.Font(None, 24)
+text = "Use the mouse to drive the tank, it will follow the cursor."
+text = font.render(text, True, pygame.Color("white"))
+
+while True:
+    for event in pygame.event.get():
+        if (
+            event.type == pygame.QUIT
+            or event.type == pygame.KEYDOWN
+            and (event.key in [pygame.K_ESCAPE, pygame.K_q])
+        ):
+            exit()
+
+    screen.fill(pygame.Color("black"))
+    space.debug_draw(draw_options)
+    screen.blit(text, (15, 15))
+    fps = 60
+    update(space, 1 / fps, screen)
+    pygame.display.flip()
+
+    clock.tick(fps)
```

## Comparing `pymunk-6.5.0/pymunk/examples/threaded_space.py` & `pymunk/examples/threaded_space.py`

 * *Ordering differences only*

 * *Files 19% similar despite different names*

```diff
@@ -1,60 +1,60 @@
-import time
-
-import pymunk
-from pymunk.vec2d import Vec2d
-
-
-class PyramidDemo:
-    def __init__(self, threads=1):
-
-        ### Init pymunk and create space
-        if threads == 0:
-            self.space = pymunk.Space(threaded=False)
-        else:
-            self.space = pymunk.Space(threaded=True)
-        self.space.gravity = (0.0, -900.0)
-        self.space.threads = threads
-
-        ### ground
-        shape = pymunk.Segment(self.space.static_body, (5, 100), (595, 100), 1.0)
-        shape.friction = 1.0
-        self.space.add(shape)
-
-        ### pyramid
-        x = Vec2d(-270, 7.5) + (300, 100)
-        y = Vec2d(0, 0)
-        deltaX = Vec2d(0.5625, 1.1) * 20
-        deltaY = Vec2d(1.125, 0.0) * 20
-
-        for i in range(25):
-            y = Vec2d(*x)
-            for j in range(i, 25):
-                size = 10
-                points = [(-size, -size), (-size, size), (size, size), (size, -size)]
-                mass = 1.0
-                moment = pymunk.moment_for_poly(mass, points, (0, 0))
-                body = pymunk.Body(mass, moment)
-                body.position = y
-                shape = pymunk.Poly(body, points)
-                shape.friction = 1
-                self.space.add(body, shape)
-
-                y += deltaY
-
-            x += deltaX
-
-    def step(self, n=1):
-        for x in range(n):
-            dt = 1.0 / 150.0
-            self.space.step(dt)
-
-
-if __name__ == "__main__":
-
-    for num_threads in [0, 1, 2]:
-
-        demo = PyramidDemo(threads=num_threads)
-        start = time.time()
-        demo.step(10000)
-        end = time.time()
-        print("Threads {}, time {}".format(num_threads, end - start))
+import time
+
+import pymunk
+from pymunk.vec2d import Vec2d
+
+
+class PyramidDemo:
+    def __init__(self, threads=1):
+
+        ### Init pymunk and create space
+        if threads == 0:
+            self.space = pymunk.Space(threaded=False)
+        else:
+            self.space = pymunk.Space(threaded=True)
+        self.space.gravity = (0.0, -900.0)
+        self.space.threads = threads
+
+        ### ground
+        shape = pymunk.Segment(self.space.static_body, (5, 100), (595, 100), 1.0)
+        shape.friction = 1.0
+        self.space.add(shape)
+
+        ### pyramid
+        x = Vec2d(-270, 7.5) + (300, 100)
+        y = Vec2d(0, 0)
+        deltaX = Vec2d(0.5625, 1.1) * 20
+        deltaY = Vec2d(1.125, 0.0) * 20
+
+        for i in range(25):
+            y = Vec2d(*x)
+            for j in range(i, 25):
+                size = 10
+                points = [(-size, -size), (-size, size), (size, size), (size, -size)]
+                mass = 1.0
+                moment = pymunk.moment_for_poly(mass, points, (0, 0))
+                body = pymunk.Body(mass, moment)
+                body.position = y
+                shape = pymunk.Poly(body, points)
+                shape.friction = 1
+                self.space.add(body, shape)
+
+                y += deltaY
+
+            x += deltaX
+
+    def step(self, n=1):
+        for x in range(n):
+            dt = 1.0 / 150.0
+            self.space.step(dt)
+
+
+if __name__ == "__main__":
+
+    for num_threads in [0, 1, 2]:
+
+        demo = PyramidDemo(threads=num_threads)
+        start = time.time()
+        demo.step(10000)
+        end = time.time()
+        print("Threads {}, time {}".format(num_threads, end - start))
```

## Comparing `pymunk-6.5.0/pymunk/examples/using_sprites.py` & `pymunk/examples/using_sprites.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,129 +1,129 @@
-"""Very basic example of using a sprite image to draw a shape more similar 
-how you would do it in a real game instead of the simple line drawings used 
-by the other examples. 
-"""
-
-__version__ = "$Id:$"
-__docformat__ = "reStructuredText"
-
-import math
-import random
-from typing import List
-import os.path
-
-import pygame
-
-import pymunk
-from pymunk import Vec2d
-
-
-def flipy(y):
-    """Small hack to convert chipmunk physics to pygame coordinates"""
-    return -y + 600
-
-
-def main():
-
-    pygame.init()
-    screen = pygame.display.set_mode((600, 600))
-    clock = pygame.time.Clock()
-    running = True
-
-    ### Physics stuff
-    space = pymunk.Space()
-    space.gravity = Vec2d(0.0, -900.0)
-
-    ## logo
-    logo_img = pygame.image.load(
-        os.path.join(
-            os.path.dirname(os.path.abspath(__file__)), "pymunk_logo_googlecode.png"
-        )
-    )
-    logos: List[pymunk.Shape] = []
-
-    ### Static line
-    static_lines = [
-        pymunk.Segment(space.static_body, (11.0, 280.0), (407.0, 246.0), 0.0),
-        pymunk.Segment(space.static_body, (407.0, 246.0), (407.0, 343.0), 0.0),
-    ]
-    for l in static_lines:
-        l.friction = 0.5
-    space.add(*static_lines)
-
-    ticks_to_next_spawn = 10
-
-    while running:
-        for event in pygame.event.get():
-            if event.type == pygame.QUIT:
-                running = False
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
-                running = False
-            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
-                pygame.image.save(screen, "using_sprites.png")
-
-        ticks_to_next_spawn -= 1
-        if ticks_to_next_spawn <= 0:
-            ticks_to_next_spawn = 100
-            x = random.randint(20, 400)
-            y = 500
-            angle = random.random() * math.pi
-            vs = [(-23, 26), (23, 26), (0, -26)]
-            mass = 10
-            moment = pymunk.moment_for_poly(mass, vs)
-            body = pymunk.Body(mass, moment)
-            shape = pymunk.Poly(body, vs)
-            shape.friction = 0.5
-            body.position = x, y
-            body.angle = angle
-
-            space.add(body, shape)
-            logos.append(shape)
-
-        ### Update physics
-        dt = 1.0 / 60.0
-        for x in range(1):
-            space.step(dt)
-
-        ### Draw stuff
-        screen.fill(pygame.Color("black"))
-
-        for logo_shape in logos:
-            # image draw
-            p = logo_shape.body.position
-            p = Vec2d(p.x, flipy(p.y))
-
-            # we need to rotate 180 degrees because of the y coordinate flip
-            angle_degrees = math.degrees(logo_shape.body.angle) + 180
-            rotated_logo_img = pygame.transform.rotate(logo_img, angle_degrees)
-
-            offset = Vec2d(*rotated_logo_img.get_size()) / 2
-            p = p - offset
-
-            screen.blit(rotated_logo_img, (round(p.x), round(p.y)))
-
-            # debug draw
-            ps = [
-                p.rotated(logo_shape.body.angle) + logo_shape.body.position
-                for p in logo_shape.get_vertices()
-            ]
-            ps = [(round(p.x), round(flipy(p.y))) for p in ps]
-            ps += [ps[0]]
-            pygame.draw.lines(screen, pygame.Color("red"), False, ps, 1)
-
-        for line in static_lines:
-            body = line.body
-
-            pv1 = body.position + line.a.rotated(body.angle)
-            pv2 = body.position + line.b.rotated(body.angle)
-            p1 = round(pv1.x), round(flipy(pv1.y))
-            p2 = round(pv2.x), round(flipy(pv2.y))
-            pygame.draw.lines(screen, pygame.Color("lightgray"), False, [p1, p2], 2)
-
-        ### Flip screen
-        pygame.display.flip()
-        clock.tick(50)
-        pygame.display.set_caption("fps: " + str(clock.get_fps()))
-
-
-if __name__ == "__main__":
-    main()
+"""Very basic example of using a sprite image to draw a shape more similar 
+how you would do it in a real game instead of the simple line drawings used 
+by the other examples. 
+"""
+
+__version__ = "$Id:$"
+__docformat__ = "reStructuredText"
+
+import math
+import random
+from typing import List
+import os.path
+
+import pygame
+
+import pymunk
+from pymunk import Vec2d
+
+
+def flipy(y):
+    """Small hack to convert chipmunk physics to pygame coordinates"""
+    return -y + 600
+
+
+def main():
+
+    pygame.init()
+    screen = pygame.display.set_mode((600, 600))
+    clock = pygame.time.Clock()
+    running = True
+
+    ### Physics stuff
+    space = pymunk.Space()
+    space.gravity = Vec2d(0.0, -900.0)
+
+    ## logo
+    logo_img = pygame.image.load(
+        os.path.join(
+            os.path.dirname(os.path.abspath(__file__)), "pymunk_logo_googlecode.png"
+        )
+    )
+    logos: List[pymunk.Shape] = []
+
+    ### Static line
+    static_lines = [
+        pymunk.Segment(space.static_body, (11.0, 280.0), (407.0, 246.0), 0.0),
+        pymunk.Segment(space.static_body, (407.0, 246.0), (407.0, 343.0), 0.0),
+    ]
+    for l in static_lines:
+        l.friction = 0.5
+    space.add(*static_lines)
+
+    ticks_to_next_spawn = 10
+
+    while running:
+        for event in pygame.event.get():
+            if event.type == pygame.QUIT:
+                running = False
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
+                running = False
+            elif event.type == pygame.KEYDOWN and event.key == pygame.K_p:
+                pygame.image.save(screen, "using_sprites.png")
+
+        ticks_to_next_spawn -= 1
+        if ticks_to_next_spawn <= 0:
+            ticks_to_next_spawn = 100
+            x = random.randint(20, 400)
+            y = 500
+            angle = random.random() * math.pi
+            vs = [(-23, 26), (23, 26), (0, -26)]
+            mass = 10
+            moment = pymunk.moment_for_poly(mass, vs)
+            body = pymunk.Body(mass, moment)
+            shape = pymunk.Poly(body, vs)
+            shape.friction = 0.5
+            body.position = x, y
+            body.angle = angle
+
+            space.add(body, shape)
+            logos.append(shape)
+
+        ### Update physics
+        dt = 1.0 / 60.0
+        for x in range(1):
+            space.step(dt)
+
+        ### Draw stuff
+        screen.fill(pygame.Color("black"))
+
+        for logo_shape in logos:
+            # image draw
+            p = logo_shape.body.position
+            p = Vec2d(p.x, flipy(p.y))
+
+            # we need to rotate 180 degrees because of the y coordinate flip
+            angle_degrees = math.degrees(logo_shape.body.angle) + 180
+            rotated_logo_img = pygame.transform.rotate(logo_img, angle_degrees)
+
+            offset = Vec2d(*rotated_logo_img.get_size()) / 2
+            p = p - offset
+
+            screen.blit(rotated_logo_img, (round(p.x), round(p.y)))
+
+            # debug draw
+            ps = [
+                p.rotated(logo_shape.body.angle) + logo_shape.body.position
+                for p in logo_shape.get_vertices()
+            ]
+            ps = [(round(p.x), round(flipy(p.y))) for p in ps]
+            ps += [ps[0]]
+            pygame.draw.lines(screen, pygame.Color("red"), False, ps, 1)
+
+        for line in static_lines:
+            body = line.body
+
+            pv1 = body.position + line.a.rotated(body.angle)
+            pv2 = body.position + line.b.rotated(body.angle)
+            p1 = round(pv1.x), round(flipy(pv1.y))
+            p2 = round(pv2.x), round(flipy(pv2.y))
+            pygame.draw.lines(screen, pygame.Color("lightgray"), False, [p1, p2], 2)
+
+        ### Flip screen
+        pygame.display.flip()
+        clock.tick(50)
+        pygame.display.set_caption("fps: " + str(clock.get_fps()))
+
+
+if __name__ == "__main__":
+    main()
```

## Comparing `pymunk-6.5.0/pymunk/examples/using_sprites_pyglet.py` & `pymunk/examples/using_sprites_pyglet.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,129 +1,129 @@
-"""This example is a clone of the using_sprites example with the difference 
-that it uses pyglet instead of pygame to showcase sprite drawing. 
-"""
-
-__version__ = "$Id:$"
-__docformat__ = "reStructuredText"
-
-import math
-import random
-import os.path
-from typing import List
-
-import pyglet
-
-import pymunk
-from pymunk import Vec2d
-
-window = pyglet.window.Window(width=600, height=600)
-
-fps_display = pyglet.window.FPSDisplay(window)
-
-logo_img = pyglet.resource.image("pymunk_logo_googlecode.png")
-logo_img.anchor_x = logo_img.width / 2
-logo_img.anchor_y = logo_img.height / 2
-logos: List[pymunk.Shape] = []
-batch = pyglet.graphics.Batch()
-
-### Physics stuff
-space = pymunk.Space()
-space.gravity = Vec2d(0.0, -900.0)
-
-### Static line
-static_lines = [
-    pymunk.Segment(space.static_body, (11.0, 280.0), (407.0, 246.0), 0.0),
-    pymunk.Segment(space.static_body, (407.0, 246.0), (407.0, 343.0), 0.0),
-]
-for l in static_lines:
-    l.friction = 0.5
-space.add(*static_lines)
-
-
-@window.event
-def on_key_press(symbol, modifiers):
-    if symbol == pyglet.window.key.P:
-        pyglet.image.get_buffer_manager().get_color_buffer().save(
-            "using_sprites_pyglet.png"
-        )
-
-
-batch2 = pyglet.graphics.Batch()
-
-
-@window.event
-def on_draw():
-    window.clear()
-
-    fps_display.draw()
-    shapes_to_draw = []
-    for line in static_lines:
-        body = line.body
-
-        pv1 = body.position + line.a.rotated(body.angle)
-        pv2 = body.position + line.b.rotated(body.angle)
-        shapes_to_draw.append(
-            pyglet.shapes.Line(
-                pv1.x, pv1.y, pv2.x, pv2.y, color=(200, 200, 200), batch=batch2
-            )
-        )
-
-    batch.draw()
-
-    # debug draw
-    for logo_sprite in logos:
-
-        ps = logo_sprite.shape.get_vertices()
-        ps = [p.rotated(logo_sprite.body.angle) + logo_sprite.body.position for p in ps]
-        assert len(ps) == 3
-        # ps = [c for p in ps for c in p]
-
-        shapes_to_draw += [
-            pyglet.shapes.Line(
-                ps[0].x, ps[0].y, ps[1].x, ps[1].y, color=(255, 100, 100), batch=batch2
-            ),
-            pyglet.shapes.Line(
-                ps[1].x, ps[1].y, ps[2].x, ps[2].y, color=(255, 100, 100), batch=batch2
-            ),
-            pyglet.shapes.Line(
-                ps[2].x, ps[2].y, ps[0].x, ps[0].y, color=(255, 100, 100), batch=batch2
-            ),
-        ]
-    batch2.draw()
-
-
-def update(dt):
-    dt = 1.0 / 60.0  # override dt to keep physics simulation stable
-    space.step(dt)
-
-    for sprite in logos:
-        # We need to rotate the image 180 degrees because we have y pointing
-        # up in pymunk coords.
-        sprite.rotation = math.degrees(-sprite.body.angle) + 180
-        sprite.position = sprite.body.position.x, sprite.body.position.y, 0
-
-
-def spawn_logo(dt):
-    x = random.randint(20, 400)
-    y = 500
-    angle = random.random() * math.pi
-    vs = [(-23, 26), (23, 26), (0, -26)]
-    mass = 10
-    moment = pymunk.moment_for_poly(mass, vs)
-    body = pymunk.Body(mass, moment)
-    shape = pymunk.Poly(body, vs)
-    shape.friction = 0.5
-    body.position = x, y
-    body.angle = angle
-
-    space.add(body, shape)
-
-    sprite = pyglet.sprite.Sprite(logo_img, batch=batch)
-    sprite.shape = shape
-    sprite.body = body
-    logos.append(sprite)
-
-
-pyglet.clock.schedule_interval(update, 1 / 60.0)
-pyglet.clock.schedule_once(spawn_logo, 0.1)
-pyglet.clock.schedule_interval(spawn_logo, 10 / 6.0)
-pyglet.app.run()
+"""This example is a clone of the using_sprites example with the difference 
+that it uses pyglet instead of pygame to showcase sprite drawing. 
+"""
+
+__version__ = "$Id:$"
+__docformat__ = "reStructuredText"
+
+import math
+import random
+import os.path
+from typing import List
+
+import pyglet
+
+import pymunk
+from pymunk import Vec2d
+
+window = pyglet.window.Window(width=600, height=600)
+
+fps_display = pyglet.window.FPSDisplay(window)
+
+logo_img = pyglet.resource.image("pymunk_logo_googlecode.png")
+logo_img.anchor_x = logo_img.width / 2
+logo_img.anchor_y = logo_img.height / 2
+logos: List[pymunk.Shape] = []
+batch = pyglet.graphics.Batch()
+
+### Physics stuff
+space = pymunk.Space()
+space.gravity = Vec2d(0.0, -900.0)
+
+### Static line
+static_lines = [
+    pymunk.Segment(space.static_body, (11.0, 280.0), (407.0, 246.0), 0.0),
+    pymunk.Segment(space.static_body, (407.0, 246.0), (407.0, 343.0), 0.0),
+]
+for l in static_lines:
+    l.friction = 0.5
+space.add(*static_lines)
+
+
+@window.event
+def on_key_press(symbol, modifiers):
+    if symbol == pyglet.window.key.P:
+        pyglet.image.get_buffer_manager().get_color_buffer().save(
+            "using_sprites_pyglet.png"
+        )
+
+
+batch2 = pyglet.graphics.Batch()
+
+
+@window.event
+def on_draw():
+    window.clear()
+
+    fps_display.draw()
+    shapes_to_draw = []
+    for line in static_lines:
+        body = line.body
+
+        pv1 = body.position + line.a.rotated(body.angle)
+        pv2 = body.position + line.b.rotated(body.angle)
+        shapes_to_draw.append(
+            pyglet.shapes.Line(
+                pv1.x, pv1.y, pv2.x, pv2.y, color=(200, 200, 200), batch=batch2
+            )
+        )
+
+    batch.draw()
+
+    # debug draw
+    for logo_sprite in logos:
+
+        ps = logo_sprite.shape.get_vertices()
+        ps = [p.rotated(logo_sprite.body.angle) + logo_sprite.body.position for p in ps]
+        assert len(ps) == 3
+        # ps = [c for p in ps for c in p]
+
+        shapes_to_draw += [
+            pyglet.shapes.Line(
+                ps[0].x, ps[0].y, ps[1].x, ps[1].y, color=(255, 100, 100), batch=batch2
+            ),
+            pyglet.shapes.Line(
+                ps[1].x, ps[1].y, ps[2].x, ps[2].y, color=(255, 100, 100), batch=batch2
+            ),
+            pyglet.shapes.Line(
+                ps[2].x, ps[2].y, ps[0].x, ps[0].y, color=(255, 100, 100), batch=batch2
+            ),
+        ]
+    batch2.draw()
+
+
+def update(dt):
+    dt = 1.0 / 60.0  # override dt to keep physics simulation stable
+    space.step(dt)
+
+    for sprite in logos:
+        # We need to rotate the image 180 degrees because we have y pointing
+        # up in pymunk coords.
+        sprite.rotation = math.degrees(-sprite.body.angle) + 180
+        sprite.position = sprite.body.position.x, sprite.body.position.y, 0
+
+
+def spawn_logo(dt):
+    x = random.randint(20, 400)
+    y = 500
+    angle = random.random() * math.pi
+    vs = [(-23, 26), (23, 26), (0, -26)]
+    mass = 10
+    moment = pymunk.moment_for_poly(mass, vs)
+    body = pymunk.Body(mass, moment)
+    shape = pymunk.Poly(body, vs)
+    shape.friction = 0.5
+    body.position = x, y
+    body.angle = angle
+
+    space.add(body, shape)
+
+    sprite = pyglet.sprite.Sprite(logo_img, batch=batch)
+    sprite.shape = shape
+    sprite.body = body
+    logos.append(sprite)
+
+
+pyglet.clock.schedule_interval(update, 1 / 60.0)
+pyglet.clock.schedule_once(spawn_logo, 0.1)
+pyglet.clock.schedule_interval(spawn_logo, 10 / 6.0)
+pyglet.app.run()
```

## Comparing `pymunk-6.5.0/pymunk/examples/xmasgirl1.png` & `pymunk/examples/xmasgirl1.png`

 * *Files identical despite different names*

## Comparing `pymunk-6.5.0/pymunk/examples/__main__.py` & `pymunk/examples/__main__.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,72 +1,72 @@
-import argparse
-import importlib
-import os.path
-import pathlib
-import sys
-from typing import Iterable
-
-if sys.argv[0].endswith("__main__.py"):
-    # We change sys.argv[0] to make help message more useful
-    # use executable without path, unquoted
-    # (it's just a hint anyway)
-    # (if you have spaces in your executable you get what you deserve!)
-    executable = os.path.basename(sys.executable)
-    sys.argv[0] = executable + " -m pymunk.examples"
-
-desc = """
-Run examples showcasing different aspects of Pymunk. Each example is a module, 
-and you run them as you would any module. For example, to run the basic_test 
-example, do 
-
-    python -m pymunk.examples.basic_text
-
-"""
-
-
-def find_examples() -> Iterable[str]:
-    for f in pathlib.Path(__file__).parent.glob("*.py"):
-        if f.stem.startswith("__") or not f.is_file():
-            continue
-        yield f.stem
-
-
-def list_examples() -> None:
-    for e in find_examples():
-        print(f"python -m pymunk.examples.{e}")
-
-
-def run_examples() -> None:
-    for e in find_examples():
-        try:
-            m = importlib.import_module("pymunk.examples." + e)
-            m.main()
-        except Exception as err:
-            print(err)
-
-
-if __name__ == "__main__":
-    parser = argparse.ArgumentParser(
-        description=desc, formatter_class=argparse.RawDescriptionHelpFormatter
-    )
-    parser.add_argument(
-        "-l",
-        "--list",
-        help="list all examples as ready to run statements",
-        action="store_true",
-    )
-
-    # commented out for now since many examples cant handle beeing run in this way.
-    # parser.add_argument(
-    #     "-a",
-    #     "--run-all",
-    #     help="run all examples, one by one (useful when testing)",
-    #     action="store_true",
-    # )
-
-    args = parser.parse_args(args=None if sys.argv[1:] else ["--help"])
-    if args.list:
-        list_examples()
-    # elif args.run_all:
-    #     run_examples()
-    else:
-        parser.print_usage()
+import argparse
+import importlib
+import os.path
+import pathlib
+import sys
+from typing import Iterable
+
+if sys.argv[0].endswith("__main__.py"):
+    # We change sys.argv[0] to make help message more useful
+    # use executable without path, unquoted
+    # (it's just a hint anyway)
+    # (if you have spaces in your executable you get what you deserve!)
+    executable = os.path.basename(sys.executable)
+    sys.argv[0] = executable + " -m pymunk.examples"
+
+desc = """
+Run examples showcasing different aspects of Pymunk. Each example is a module, 
+and you run them as you would any module. For example, to run the basic_test 
+example, do 
+
+    python -m pymunk.examples.basic_text
+
+"""
+
+
+def find_examples() -> Iterable[str]:
+    for f in pathlib.Path(__file__).parent.glob("*.py"):
+        if f.stem.startswith("__") or not f.is_file():
+            continue
+        yield f.stem
+
+
+def list_examples() -> None:
+    for e in find_examples():
+        print(f"python -m pymunk.examples.{e}")
+
+
+def run_examples() -> None:
+    for e in find_examples():
+        try:
+            m = importlib.import_module("pymunk.examples." + e)
+            m.main()
+        except Exception as err:
+            print(err)
+
+
+if __name__ == "__main__":
+    parser = argparse.ArgumentParser(
+        description=desc, formatter_class=argparse.RawDescriptionHelpFormatter
+    )
+    parser.add_argument(
+        "-l",
+        "--list",
+        help="list all examples as ready to run statements",
+        action="store_true",
+    )
+
+    # commented out for now since many examples cant handle beeing run in this way.
+    # parser.add_argument(
+    #     "-a",
+    #     "--run-all",
+    #     help="run all examples, one by one (useful when testing)",
+    #     action="store_true",
+    # )
+
+    args = parser.parse_args(args=None if sys.argv[1:] else ["--help"])
+    if args.list:
+        list_examples()
+    # elif args.run_all:
+    #     run_examples()
+    else:
+        parser.print_usage()
```

## Comparing `pymunk-6.5.0/pymunk/tests/doctests.py` & `pymunk/tests/doctests.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,39 +1,39 @@
-import doctest
-import pkgutil
-import sys
-import unittest
-from typing import Any, List
-
-import pymunk
-
-ignores = ["pymunk_extension_build"]
-all_dependencies = ["pygame", "pyglet", "matplotlib", "_pyglet"]
-
-
-def load_tests(
-    tests: unittest.TestSuite, dependencies: List[str] = []
-) -> unittest.TestSuite:
-    for importer, modname, ispkg in pkgutil.iter_modules(pymunk.__path__):
-        # try:
-        skip = False
-        if modname in ignores:
-            skip = True
-        for dep in all_dependencies:
-            if modname.startswith(dep) and dep not in dependencies:
-                skip = True
-        if skip:
-            continue
-        tests.addTests(doctest.DocTestSuite("pymunk." + modname))
-
-        # except Exception as e:
-        #    print("Skipping " + modname, e)
-    tests.addTests(doctest.DocTestSuite(pymunk))
-    return tests
-
-
-if __name__ == "__main__":
-    print("running doctests")
-    suite = unittest.TestSuite()
-    load_tests(suite)
-    res = unittest.TextTestRunner().run(suite)
-    sys.exit(not res.wasSuccessful())
+import doctest
+import pkgutil
+import sys
+import unittest
+from typing import Any, List
+
+import pymunk
+
+ignores = ["pymunk_extension_build"]
+all_dependencies = ["pygame", "pyglet", "matplotlib", "_pyglet"]
+
+
+def load_tests(
+    tests: unittest.TestSuite, dependencies: List[str] = []
+) -> unittest.TestSuite:
+    for importer, modname, ispkg in pkgutil.iter_modules(pymunk.__path__):
+        # try:
+        skip = False
+        if modname in ignores:
+            skip = True
+        for dep in all_dependencies:
+            if modname.startswith(dep) and dep not in dependencies:
+                skip = True
+        if skip:
+            continue
+        tests.addTests(doctest.DocTestSuite("pymunk." + modname))
+
+        # except Exception as e:
+        #    print("Skipping " + modname, e)
+    tests.addTests(doctest.DocTestSuite(pymunk))
+    return tests
+
+
+if __name__ == "__main__":
+    print("running doctests")
+    suite = unittest.TestSuite()
+    load_tests(suite)
+    res = unittest.TextTestRunner().run(suite)
+    sys.exit(not res.wasSuccessful())
```

## Comparing `pymunk-6.5.0/pymunk/tests/test_arbiter.py` & `pymunk/tests/test_arbiter.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,339 +1,339 @@
-import unittest
-from typing import Any
-
-import pymunk as p
-from pymunk.vec2d import Vec2d
-
-
-class UnitTestArbiter(unittest.TestCase):
-    def testRestitution(self) -> None:
-        s = p.Space()
-        s.gravity = 0, -100
-
-        b1 = p.Body(1, 1)
-        c1 = p.Circle(b1, 10)
-        b1.position = Vec2d(0, 25)
-        c1.collision_type = 1
-        c1.elasticity = 0.6
-
-        b2 = p.Body(body_type=p.Body.STATIC)
-        c2 = p.Circle(b2, 10)
-        c2.collision_type = 2
-        c2.elasticity = 0.3
-
-        s.add(b1, c1, b2, c2)
-
-        def pre_solve(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
-            self.assertEqual(arb.restitution, 0.18)
-            arb.restitution = 1
-            return True
-
-        s.add_collision_handler(1, 2).pre_solve = pre_solve
-
-        for x in range(10):
-            s.step(0.1)
-
-        self.assertAlmostEqual(b1.position.y, 22.42170317, 6)
-
-    def testFriction(self) -> None:
-        s = p.Space()
-        s.gravity = 0, -100
-
-        b1 = p.Body(1, float("inf"))
-        c1 = p.Circle(b1, 10)
-        b1.position = Vec2d(10, 25)
-        c1.collision_type = 1
-        c1.friction = 0.6
-
-        b2 = p.Body(body_type=p.Body.STATIC)
-        c2 = p.Circle(b2, 10)
-        c2.collision_type = 2
-        c2.friction = 0.3
-
-        s.add(b1, c1, b2, c2)
-
-        def pre_solve(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
-            self.assertEqual(arb.friction, 0.18)
-            arb.friction = 1
-            return True
-
-        s.add_collision_handler(1, 2).pre_solve = pre_solve
-
-        for x in range(10):
-            s.step(0.1)
-
-        self.assertAlmostEqual(b1.position.x, 10.99450928394)
-
-    def testSurfaceVelocity(self) -> None:
-        s = p.Space()
-        s.gravity = 0, -100
-
-        b1 = p.Body(1, float("inf"))
-        c1 = p.Circle(b1, 10)
-        b1.position = 10, 25
-        c1.collision_type = 1
-        c1.surface_velocity = (3, 0)
-
-        b2 = p.Body(body_type=p.Body.STATIC)
-        c2 = p.Circle(b2, 10)
-        c2.collision_type = 2
-        c2.surface_velocity = (5, 0)
-
-        s.add(b1, c1, b2, c2)
-
-        def pre_solve(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
-            self.assertAlmostEqual(arb.surface_velocity.x, 1.38461538462)
-            self.assertAlmostEqual(arb.surface_velocity.y, -0.923076923077)
-
-            arb.surface_velocity = (10, 10)
-            # TODO: add assert check that setting surface_velocity has any effect
-            return True
-
-        s.add_collision_handler(1, 2).pre_solve = pre_solve
-        for x in range(5):
-            s.step(0.1)
-
-    def testContactPointSet(self) -> None:
-        s = p.Space()
-        s.gravity = 0, -100
-
-        b1 = p.Body(1, 30)
-        c1 = p.Circle(b1, 10)
-        b1.position = 5, 3
-        c1.collision_type = 1
-
-        b2 = p.Body(body_type=p.Body.STATIC)
-        c2 = p.Circle(b2, 10)
-        c2.collision_type = 2
-
-        s.add(b1, c1, b2, c2)
-
-        def pre_solve(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
-            # check inital values
-            ps: p.ContactPointSet = arb.contact_point_set
-            self.assertEqual(len(ps.points), 1)
-            self.assertAlmostEqual(ps.normal.x, 0.8574929257)
-            self.assertAlmostEqual(ps.normal.y, 0.5144957554)
-            p1 = ps.points[0]
-            self.assertAlmostEqual(p1.point_a.x, 8.574929257)
-            self.assertAlmostEqual(p1.point_a.y, 5.144957554)
-            self.assertAlmostEqual(p1.point_b.x, -3.574929257)
-            self.assertAlmostEqual(p1.point_b.y, -2.144957554)
-            self.assertAlmostEqual(p1.distance, -14.16904810)
-
-            # check that they can be changed
-            ps.normal = Vec2d(1, 0)
-            ps.points[0].point_a = Vec2d(9, 10)
-            ps.points[0].point_b = Vec2d(-2, -3)
-            ps.points[0].distance = -10
-
-            arb.contact_point_set = ps
-            ps2 = arb.contact_point_set
-
-            self.assertEqual(ps2.normal, (1, 0))
-            p1 = ps2.points[0]
-            self.assertAlmostEqual(p1.point_a, (9, 10))
-            self.assertAlmostEqual(p1.point_b, (-2, -3))
-            self.assertAlmostEqual(p1.distance, -11)
-
-            # check for length of points
-            ps2.points = []
-
-            def f() -> None:
-                arb.contact_point_set = ps2
-
-            self.assertRaises(Exception, f)
-
-            return True
-
-        s.add_default_collision_handler().pre_solve = pre_solve
-
-        s.step(0.1)
-
-    def testImpulse(self) -> None:
-        s = p.Space()
-        s.gravity = 0, -100
-
-        b1 = p.Body(1, 30)
-        c1 = p.Circle(b1, 10)
-        b1.position = 5, 3
-        c1.collision_type = 1
-        c1.friction = 0.5
-
-        b2 = p.Body(body_type=p.Body.STATIC)
-        c2 = p.Circle(b2, 10)
-        c2.collision_type = 2
-        c2.friction = 0.8
-
-        s.add(b1, c1, b2, c2)
-
-        self.post_solve_done = False
-
-        def post_solve(arb: p.Arbiter, space: p.Space, data: Any) -> None:
-            self.assertAlmostEqual(arb.total_impulse.x, 3.3936651583)
-            self.assertAlmostEqual(arb.total_impulse.y, 4.3438914027)
-            self.post_solve_done = True
-
-        s.add_collision_handler(1, 2).post_solve = post_solve
-
-        s.step(0.1)
-
-        self.assertTrue(self.post_solve_done)
-
-    def testTotalKE(self) -> None:
-        s = p.Space()
-        s.gravity = 0, -100
-
-        b1 = p.Body(1, 30)
-        c1 = p.Circle(b1, 10)
-        b1.position = 5, 3
-        c1.collision_type = 1
-        c1.friction = 0.5
-
-        b2 = p.Body(body_type=p.Body.STATIC)
-        c2 = p.Circle(b2, 10)
-        c2.collision_type = 2
-        c2.friction = 0.8
-
-        s.add(b1, c1, b2, c2)
-
-        def post_solve(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
-            self.assertAlmostEqual(arb.total_ke, 43.438914027)
-            return True
-
-        s.add_collision_handler(1, 2).post_solve = post_solve
-
-        s.step(0.1)
-
-    def testIsFirstContact(self) -> None:
-        s = p.Space()
-        s.gravity = 0, -100
-
-        b1 = p.Body(1, 30)
-        c1 = p.Circle(b1, 10)
-        b1.position = 5, 3
-        c1.collision_type = 1
-        c1.friction = 0.5
-
-        b2 = p.Body(body_type=p.Body.STATIC)
-        c2 = p.Circle(b2, 10)
-        c2.collision_type = 2
-        c2.friction = 0.8
-
-        s.add(b1, c1, b2, c2)
-
-        def pre_solve1(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
-            self.assertTrue(arb.is_first_contact)
-            return True
-
-        s.add_collision_handler(1, 2).pre_solve = pre_solve1
-
-        s.step(0.1)
-
-        def pre_solve2(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
-            self.assertFalse(arb.is_first_contact)
-            return True
-
-        s.add_collision_handler(1, 2).pre_solve = pre_solve2
-
-        s.step(0.1)
-
-    def testNormal(self) -> None:
-        s = p.Space()
-        s.gravity = 0, -100
-
-        b1 = p.Body(1, 30)
-        b1.position = 5, 10
-        c1 = p.Circle(b1, 10)
-        c2 = p.Circle(s.static_body, 10)
-
-        s.add(b1, c1, c2)
-
-        def pre_solve1(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
-            self.assertAlmostEqual(arb.normal.x, 0.44721359)
-            self.assertAlmostEqual(arb.normal.y, 0.89442719)
-            return True
-
-        s.add_default_collision_handler().pre_solve = pre_solve1
-
-        s.step(0.1)
-
-    def testIsRemoval(self) -> None:
-        s = p.Space()
-        s.gravity = 0, -100
-
-        b1 = p.Body(1, 30)
-        c1 = p.Circle(b1, 10)
-        b1.position = 5, 3
-        c1.collision_type = 1
-        c1.friction = 0.5
-
-        b2 = p.Body(body_type=p.Body.STATIC)
-        c2 = p.Circle(b2, 10)
-        c2.collision_type = 2
-        c2.friction = 0.8
-
-        s.add(b1, c1, b2, c2)
-
-        self.called1 = False
-
-        def separate1(arb: p.Arbiter, space: p.Space, data: Any) -> None:
-            self.called1 = True
-            self.assertFalse(arb.is_removal)
-
-        s.add_collision_handler(1, 2).separate = separate1
-
-        for x in range(10):
-            s.step(0.1)
-        self.assertTrue(self.called1)
-
-        b1.position = 5, 3
-        s.step(0.1)
-
-        self.called2 = False
-
-        def separate2(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
-            self.called2 = True
-            self.assertTrue(arb.is_removal)
-            return True
-
-        s.add_collision_handler(1, 2).separate = separate2
-        s.remove(b1, c1)
-
-        self.assertTrue(self.called2)
-
-    def testShapes(self) -> None:
-        s = p.Space()
-        s.gravity = 0, -100
-
-        b1 = p.Body(1, 30)
-        c1 = p.Circle(b1, 10)
-        b1.position = 5, 3
-        c1.collision_type = 1
-        c1.friction = 0.5
-
-        b2 = p.Body(body_type=p.Body.STATIC)
-        c2 = p.Circle(b2, 10)
-        c2.collision_type = 2
-        c2.friction = 0.8
-
-        s.add(b1, c1, b2, c2)
-
-        self.called = False
-
-        def pre_solve(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
-            self.called = True
-            self.assertEqual(len(arb.shapes), 2)
-            self.assertEqual(arb.shapes[0], c1)
-            self.assertEqual(arb.shapes[1], c2)
-            return True
-
-        s.add_collision_handler(1, 2).pre_solve = pre_solve
-
-        s.step(0.1)
-        self.assertTrue(self.called)
-
-
-if __name__ == "__main__":
-    print("testing pymunk version " + p.version)
-    unittest.main()
+import unittest
+from typing import Any
+
+import pymunk as p
+from pymunk.vec2d import Vec2d
+
+
+class UnitTestArbiter(unittest.TestCase):
+    def testRestitution(self) -> None:
+        s = p.Space()
+        s.gravity = 0, -100
+
+        b1 = p.Body(1, 1)
+        c1 = p.Circle(b1, 10)
+        b1.position = Vec2d(0, 25)
+        c1.collision_type = 1
+        c1.elasticity = 0.6
+
+        b2 = p.Body(body_type=p.Body.STATIC)
+        c2 = p.Circle(b2, 10)
+        c2.collision_type = 2
+        c2.elasticity = 0.3
+
+        s.add(b1, c1, b2, c2)
+
+        def pre_solve(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
+            self.assertEqual(arb.restitution, 0.18)
+            arb.restitution = 1
+            return True
+
+        s.add_collision_handler(1, 2).pre_solve = pre_solve
+
+        for x in range(10):
+            s.step(0.1)
+
+        self.assertAlmostEqual(b1.position.y, 22.42170317, 6)
+
+    def testFriction(self) -> None:
+        s = p.Space()
+        s.gravity = 0, -100
+
+        b1 = p.Body(1, float("inf"))
+        c1 = p.Circle(b1, 10)
+        b1.position = Vec2d(10, 25)
+        c1.collision_type = 1
+        c1.friction = 0.6
+
+        b2 = p.Body(body_type=p.Body.STATIC)
+        c2 = p.Circle(b2, 10)
+        c2.collision_type = 2
+        c2.friction = 0.3
+
+        s.add(b1, c1, b2, c2)
+
+        def pre_solve(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
+            self.assertEqual(arb.friction, 0.18)
+            arb.friction = 1
+            return True
+
+        s.add_collision_handler(1, 2).pre_solve = pre_solve
+
+        for x in range(10):
+            s.step(0.1)
+
+        self.assertAlmostEqual(b1.position.x, 10.99450928394)
+
+    def testSurfaceVelocity(self) -> None:
+        s = p.Space()
+        s.gravity = 0, -100
+
+        b1 = p.Body(1, float("inf"))
+        c1 = p.Circle(b1, 10)
+        b1.position = 10, 25
+        c1.collision_type = 1
+        c1.surface_velocity = (3, 0)
+
+        b2 = p.Body(body_type=p.Body.STATIC)
+        c2 = p.Circle(b2, 10)
+        c2.collision_type = 2
+        c2.surface_velocity = (5, 0)
+
+        s.add(b1, c1, b2, c2)
+
+        def pre_solve(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
+            self.assertAlmostEqual(arb.surface_velocity.x, 1.38461538462)
+            self.assertAlmostEqual(arb.surface_velocity.y, -0.923076923077)
+
+            arb.surface_velocity = (10, 10)
+            # TODO: add assert check that setting surface_velocity has any effect
+            return True
+
+        s.add_collision_handler(1, 2).pre_solve = pre_solve
+        for x in range(5):
+            s.step(0.1)
+
+    def testContactPointSet(self) -> None:
+        s = p.Space()
+        s.gravity = 0, -100
+
+        b1 = p.Body(1, 30)
+        c1 = p.Circle(b1, 10)
+        b1.position = 5, 3
+        c1.collision_type = 1
+
+        b2 = p.Body(body_type=p.Body.STATIC)
+        c2 = p.Circle(b2, 10)
+        c2.collision_type = 2
+
+        s.add(b1, c1, b2, c2)
+
+        def pre_solve(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
+            # check inital values
+            ps: p.ContactPointSet = arb.contact_point_set
+            self.assertEqual(len(ps.points), 1)
+            self.assertAlmostEqual(ps.normal.x, 0.8574929257)
+            self.assertAlmostEqual(ps.normal.y, 0.5144957554)
+            p1 = ps.points[0]
+            self.assertAlmostEqual(p1.point_a.x, 8.574929257)
+            self.assertAlmostEqual(p1.point_a.y, 5.144957554)
+            self.assertAlmostEqual(p1.point_b.x, -3.574929257)
+            self.assertAlmostEqual(p1.point_b.y, -2.144957554)
+            self.assertAlmostEqual(p1.distance, -14.16904810)
+
+            # check that they can be changed
+            ps.normal = Vec2d(1, 0)
+            ps.points[0].point_a = Vec2d(9, 10)
+            ps.points[0].point_b = Vec2d(-2, -3)
+            ps.points[0].distance = -10
+
+            arb.contact_point_set = ps
+            ps2 = arb.contact_point_set
+
+            self.assertEqual(ps2.normal, (1, 0))
+            p1 = ps2.points[0]
+            self.assertAlmostEqual(p1.point_a, (9, 10))
+            self.assertAlmostEqual(p1.point_b, (-2, -3))
+            self.assertAlmostEqual(p1.distance, -11)
+
+            # check for length of points
+            ps2.points = []
+
+            def f() -> None:
+                arb.contact_point_set = ps2
+
+            self.assertRaises(Exception, f)
+
+            return True
+
+        s.add_default_collision_handler().pre_solve = pre_solve
+
+        s.step(0.1)
+
+    def testImpulse(self) -> None:
+        s = p.Space()
+        s.gravity = 0, -100
+
+        b1 = p.Body(1, 30)
+        c1 = p.Circle(b1, 10)
+        b1.position = 5, 3
+        c1.collision_type = 1
+        c1.friction = 0.5
+
+        b2 = p.Body(body_type=p.Body.STATIC)
+        c2 = p.Circle(b2, 10)
+        c2.collision_type = 2
+        c2.friction = 0.8
+
+        s.add(b1, c1, b2, c2)
+
+        self.post_solve_done = False
+
+        def post_solve(arb: p.Arbiter, space: p.Space, data: Any) -> None:
+            self.assertAlmostEqual(arb.total_impulse.x, 3.3936651583)
+            self.assertAlmostEqual(arb.total_impulse.y, 4.3438914027)
+            self.post_solve_done = True
+
+        s.add_collision_handler(1, 2).post_solve = post_solve
+
+        s.step(0.1)
+
+        self.assertTrue(self.post_solve_done)
+
+    def testTotalKE(self) -> None:
+        s = p.Space()
+        s.gravity = 0, -100
+
+        b1 = p.Body(1, 30)
+        c1 = p.Circle(b1, 10)
+        b1.position = 5, 3
+        c1.collision_type = 1
+        c1.friction = 0.5
+
+        b2 = p.Body(body_type=p.Body.STATIC)
+        c2 = p.Circle(b2, 10)
+        c2.collision_type = 2
+        c2.friction = 0.8
+
+        s.add(b1, c1, b2, c2)
+
+        def post_solve(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
+            self.assertAlmostEqual(arb.total_ke, 43.438914027)
+            return True
+
+        s.add_collision_handler(1, 2).post_solve = post_solve
+
+        s.step(0.1)
+
+    def testIsFirstContact(self) -> None:
+        s = p.Space()
+        s.gravity = 0, -100
+
+        b1 = p.Body(1, 30)
+        c1 = p.Circle(b1, 10)
+        b1.position = 5, 3
+        c1.collision_type = 1
+        c1.friction = 0.5
+
+        b2 = p.Body(body_type=p.Body.STATIC)
+        c2 = p.Circle(b2, 10)
+        c2.collision_type = 2
+        c2.friction = 0.8
+
+        s.add(b1, c1, b2, c2)
+
+        def pre_solve1(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
+            self.assertTrue(arb.is_first_contact)
+            return True
+
+        s.add_collision_handler(1, 2).pre_solve = pre_solve1
+
+        s.step(0.1)
+
+        def pre_solve2(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
+            self.assertFalse(arb.is_first_contact)
+            return True
+
+        s.add_collision_handler(1, 2).pre_solve = pre_solve2
+
+        s.step(0.1)
+
+    def testNormal(self) -> None:
+        s = p.Space()
+        s.gravity = 0, -100
+
+        b1 = p.Body(1, 30)
+        b1.position = 5, 10
+        c1 = p.Circle(b1, 10)
+        c2 = p.Circle(s.static_body, 10)
+
+        s.add(b1, c1, c2)
+
+        def pre_solve1(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
+            self.assertAlmostEqual(arb.normal.x, 0.44721359)
+            self.assertAlmostEqual(arb.normal.y, 0.89442719)
+            return True
+
+        s.add_default_collision_handler().pre_solve = pre_solve1
+
+        s.step(0.1)
+
+    def testIsRemoval(self) -> None:
+        s = p.Space()
+        s.gravity = 0, -100
+
+        b1 = p.Body(1, 30)
+        c1 = p.Circle(b1, 10)
+        b1.position = 5, 3
+        c1.collision_type = 1
+        c1.friction = 0.5
+
+        b2 = p.Body(body_type=p.Body.STATIC)
+        c2 = p.Circle(b2, 10)
+        c2.collision_type = 2
+        c2.friction = 0.8
+
+        s.add(b1, c1, b2, c2)
+
+        self.called1 = False
+
+        def separate1(arb: p.Arbiter, space: p.Space, data: Any) -> None:
+            self.called1 = True
+            self.assertFalse(arb.is_removal)
+
+        s.add_collision_handler(1, 2).separate = separate1
+
+        for x in range(10):
+            s.step(0.1)
+        self.assertTrue(self.called1)
+
+        b1.position = 5, 3
+        s.step(0.1)
+
+        self.called2 = False
+
+        def separate2(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
+            self.called2 = True
+            self.assertTrue(arb.is_removal)
+            return True
+
+        s.add_collision_handler(1, 2).separate = separate2
+        s.remove(b1, c1)
+
+        self.assertTrue(self.called2)
+
+    def testShapes(self) -> None:
+        s = p.Space()
+        s.gravity = 0, -100
+
+        b1 = p.Body(1, 30)
+        c1 = p.Circle(b1, 10)
+        b1.position = 5, 3
+        c1.collision_type = 1
+        c1.friction = 0.5
+
+        b2 = p.Body(body_type=p.Body.STATIC)
+        c2 = p.Circle(b2, 10)
+        c2.collision_type = 2
+        c2.friction = 0.8
+
+        s.add(b1, c1, b2, c2)
+
+        self.called = False
+
+        def pre_solve(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
+            self.called = True
+            self.assertEqual(len(arb.shapes), 2)
+            self.assertEqual(arb.shapes[0], c1)
+            self.assertEqual(arb.shapes[1], c2)
+            return True
+
+        s.add_collision_handler(1, 2).pre_solve = pre_solve
+
+        s.step(0.1)
+        self.assertTrue(self.called)
+
+
+if __name__ == "__main__":
+    print("testing pymunk version " + p.version)
+    unittest.main()
```

## Comparing `pymunk-6.5.0/pymunk/tests/test_bb.py` & `pymunk/tests/test_bb.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,81 +1,81 @@
-import pickle
-import unittest
-
-import pymunk as p
-from pymunk.vec2d import Vec2d
-
-
-class UnitTestBB(unittest.TestCase):
-    def testCreation(self) -> None:
-        bb_empty = p.BB()
-
-        self.assertEqual(bb_empty.left, 0)
-        self.assertEqual(bb_empty.bottom, 0)
-        self.assertEqual(bb_empty.right, 0)
-        self.assertEqual(bb_empty.top, 0)
-
-        bb_defined = p.BB(-10, -5, 15, 20)
-
-        self.assertEqual(bb_defined.left, -10)
-        self.assertEqual(bb_defined.bottom, -5)
-        self.assertEqual(bb_defined.right, 15)
-        self.assertEqual(bb_defined.top, 20)
-
-        bb_circle = p.BB.newForCircle((3, 3), 3)
-        self.assertEqual(bb_circle.left, 0)
-        self.assertEqual(bb_circle.bottom, 0)
-        self.assertEqual(bb_circle.right, 6)
-        self.assertEqual(bb_circle.top, 6)
-
-    def testMerge(self) -> None:
-        bb1 = p.BB(0, 0, 10, 10)
-        bb2 = p.BB(2, 0, 10, 10)
-        bb3 = p.BB(10, 10, 15, 15)
-
-        self.assertEqual(bb1.merge(bb2), p.BB(0, 0, 10, 10))
-        self.assertEqual(bb2.merge(bb3).merge(bb1), p.BB(0, 0, 15, 15))
-
-    def testMethods(self) -> None:
-        bb1 = p.BB(0, 0, 10, 10)
-        bb2 = p.BB(10, 10, 20, 20)
-        bb3 = p.BB(4, 4, 5, 5)
-        bb4 = p.BB(2, 0, 10, 10)
-
-        v1 = Vec2d(1, 1)
-        v2 = Vec2d(100, 3)
-        self.assertTrue(bb1.intersects(bb2))
-        self.assertFalse(bb3.intersects(bb2))
-
-        self.assertTrue(bb1.intersects_segment(v1, v2))
-        self.assertFalse(bb3.intersects_segment(v1, v2))
-
-        self.assertTrue(bb1.contains(bb3))
-        self.assertFalse(bb1.contains(bb2))
-
-        self.assertTrue(bb1.contains_vect(v1))
-        self.assertFalse(bb1.contains_vect(v2))
-
-        self.assertEqual(bb1.expand(v1), bb1)
-        self.assertEqual(bb1.expand(-v2), p.BB(-100, -3, 10, 10))
-
-        self.assertEqual(bb1.center(), (5, 5))
-        self.assertEqual(bb1.area(), 100)
-
-        self.assertEqual(bb1.merged_area(bb2), 400)
-
-        self.assertEqual(bb2.segment_query(v1, v2), float("inf"))
-        self.assertEqual(bb1.segment_query((-1, 1), (99, 1)), 0.01)
-
-        self.assertEqual(bb1.clamp_vect(v2), Vec2d(10, 3))
-
-        # self.assertEqual(bb1.wrap_vect((11,11)), (1,1))
-
-    def testPickle(self) -> None:
-        x = p.BB(4, 4, 5, 5)
-
-        s = pickle.dumps(x, 2)
-        actual = pickle.loads(s)
-
-        self.assertEqual(x, actual)
-
-        self.assertEqual(p.BB(*x), x)
+import pickle
+import unittest
+
+import pymunk as p
+from pymunk.vec2d import Vec2d
+
+
+class UnitTestBB(unittest.TestCase):
+    def testCreation(self) -> None:
+        bb_empty = p.BB()
+
+        self.assertEqual(bb_empty.left, 0)
+        self.assertEqual(bb_empty.bottom, 0)
+        self.assertEqual(bb_empty.right, 0)
+        self.assertEqual(bb_empty.top, 0)
+
+        bb_defined = p.BB(-10, -5, 15, 20)
+
+        self.assertEqual(bb_defined.left, -10)
+        self.assertEqual(bb_defined.bottom, -5)
+        self.assertEqual(bb_defined.right, 15)
+        self.assertEqual(bb_defined.top, 20)
+
+        bb_circle = p.BB.newForCircle((3, 3), 3)
+        self.assertEqual(bb_circle.left, 0)
+        self.assertEqual(bb_circle.bottom, 0)
+        self.assertEqual(bb_circle.right, 6)
+        self.assertEqual(bb_circle.top, 6)
+
+    def testMerge(self) -> None:
+        bb1 = p.BB(0, 0, 10, 10)
+        bb2 = p.BB(2, 0, 10, 10)
+        bb3 = p.BB(10, 10, 15, 15)
+
+        self.assertEqual(bb1.merge(bb2), p.BB(0, 0, 10, 10))
+        self.assertEqual(bb2.merge(bb3).merge(bb1), p.BB(0, 0, 15, 15))
+
+    def testMethods(self) -> None:
+        bb1 = p.BB(0, 0, 10, 10)
+        bb2 = p.BB(10, 10, 20, 20)
+        bb3 = p.BB(4, 4, 5, 5)
+        bb4 = p.BB(2, 0, 10, 10)
+
+        v1 = Vec2d(1, 1)
+        v2 = Vec2d(100, 3)
+        self.assertTrue(bb1.intersects(bb2))
+        self.assertFalse(bb3.intersects(bb2))
+
+        self.assertTrue(bb1.intersects_segment(v1, v2))
+        self.assertFalse(bb3.intersects_segment(v1, v2))
+
+        self.assertTrue(bb1.contains(bb3))
+        self.assertFalse(bb1.contains(bb2))
+
+        self.assertTrue(bb1.contains_vect(v1))
+        self.assertFalse(bb1.contains_vect(v2))
+
+        self.assertEqual(bb1.expand(v1), bb1)
+        self.assertEqual(bb1.expand(-v2), p.BB(-100, -3, 10, 10))
+
+        self.assertEqual(bb1.center(), (5, 5))
+        self.assertEqual(bb1.area(), 100)
+
+        self.assertEqual(bb1.merged_area(bb2), 400)
+
+        self.assertEqual(bb2.segment_query(v1, v2), float("inf"))
+        self.assertEqual(bb1.segment_query((-1, 1), (99, 1)), 0.01)
+
+        self.assertEqual(bb1.clamp_vect(v2), Vec2d(10, 3))
+
+        # self.assertEqual(bb1.wrap_vect((11,11)), (1,1))
+
+    def testPickle(self) -> None:
+        x = p.BB(4, 4, 5, 5)
+
+        s = pickle.dumps(x, 2)
+        actual = pickle.loads(s)
+
+        self.assertEqual(x, actual)
+
+        self.assertEqual(p.BB(*x), x)
```

## Comparing `pymunk-6.5.0/pymunk/tests/test_body.py` & `pymunk/tests/test_body.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,317 +1,317 @@
-import pickle
-import unittest
-from typing import List, Tuple
-
-import pymunk as p
-from pymunk.arbiter import Arbiter
-from pymunk.constraints import *
-from pymunk.shapes import Shape
-from pymunk.vec2d import Vec2d
-
-####################################################################
-
-
-class UnitTestBody(unittest.TestCase):
-    def testProperties(self) -> None:
-        b = p.Body(10, 100)
-        self.assertEqual(b.mass, 10)
-        b.mass = 11
-        self.assertEqual(b.mass, 11)
-
-        self.assertEqual(b.moment, 100)
-        b.moment = 101
-        self.assertEqual(b.moment, 101)
-
-        self.assertEqual(b.position, (0, 0))
-        b.position = 1, 2
-        self.assertEqual(b.position, (1, 2))
-
-        self.assertEqual(b.center_of_gravity, (0, 0))
-        b.center_of_gravity = 2, 3
-        self.assertEqual(b.center_of_gravity, (2, 3))
-
-        self.assertEqual(b.velocity, (0, 0))
-        b.velocity = 3, 4
-        self.assertEqual(b.velocity, (3, 4))
-
-        self.assertEqual(b.force, (0, 0))
-        b.force = (4, 5)
-        self.assertEqual(b.force, (4, 5))
-
-        self.assertEqual(b.angle, 0)
-        b.angle = 1.2
-        self.assertEqual(b.angle, 1.2)
-
-        self.assertEqual(b.angular_velocity, 0)
-        b.angular_velocity = 1.3
-        self.assertEqual(b.angular_velocity, 1.3)
-
-        self.assertEqual(b.torque, 0)
-        b.torque = 1.4
-        self.assertEqual(b.torque, 1.4)
-
-        b.angle = 0
-        self.assertEqual(b.rotation_vector, (1, 0))
-        b.angle = Vec2d(1, 1).angle
-        self.assertAlmostEqual(b.rotation_vector.angle, Vec2d(1, 1).angle)
-
-        # self.assertGreater(b._id, 0)
-
-        self.assertEqual(b.space, None)
-        s = p.Space()
-        s.add(b)
-        self.assertEqual(b.space, s)
-
-    def testRepr(self) -> None:
-        b = p.Body(1, 2)
-        self.assertEqual(str(b), "Body(1.0, 2.0, Body.DYNAMIC)")
-        b = p.Body(body_type=p.Body.KINEMATIC)
-        self.assertEqual(str(b), "Body(Body.KINEMATIC)")
-        b = p.Body(body_type=p.Body.STATIC)
-        self.assertEqual(str(b), "Body(Body.STATIC)")
-
-    def testCoordinateConversion(self) -> None:
-        b = p.Body(body_type=p.Body.KINEMATIC)
-        v = 1, 2
-        self.assertEqual(b.local_to_world(v), v)
-        self.assertEqual(b.world_to_local(v), v)
-        b.position = 3, 4
-        self.assertEqual(b.local_to_world(v), (4, 6))
-        self.assertEqual(b.world_to_local(v), (-2, -2))
-
-    def testVelocityConversion(self) -> None:
-        b = p.Body(1, 2)
-        self.assertEqual(b.velocity_at_world_point((1, 1)), (0, 0))
-        self.assertEqual(b.velocity_at_local_point((1, 1)), (0, 0))
-        b.position = 1, 2
-        b.angular_velocity = 1.2
-        self.assertEqual(b.velocity_at_world_point((1, 1)), (1.2, 0))
-        self.assertEqual(b.velocity_at_local_point((1, 1)), (-1.2, 1.2))
-
-    def testForce(self) -> None:
-        b = p.Body(1, 2)
-        b.position = 3, 4
-        b.apply_force_at_world_point((10, 0), (0, 10))
-        self.assertEqual(b.force, (10, 0))
-        self.assertEqual(b.torque, -60)
-
-        b = p.Body(1, 2)
-        b.position = 3, 4
-        b.apply_force_at_local_point((10, 0), (0, 10))
-        self.assertEqual(b.force, (10, 0))
-        self.assertEqual(b.torque, -100)
-
-    def testImpulse(self) -> None:
-        b = p.Body(1, 2)
-        b.position = 3, 4
-        b.apply_impulse_at_world_point((10, 0), (0, 10))
-        self.assertEqual(b.velocity, (10, 0))
-        self.assertEqual(b.angular_velocity, -30)
-
-        b = p.Body(1, 2)
-        b.position = 3, 4
-        b.apply_impulse_at_local_point((10, 0), (0, 10))
-        self.assertEqual(b.velocity, (10, 0))
-        self.assertEqual(b.angular_velocity, -50)
-
-    def testSleep(self) -> None:
-        b = p.Body(1, 1)
-        s = p.Space()
-        s.sleep_time_threshold = 0.01
-
-        self.assertFalse(b.is_sleeping)
-
-        self.assertRaises(Exception, b.sleep)
-        s.add(b)
-        b.sleep()
-
-        self.assertTrue(b.is_sleeping)
-
-        b.activate()
-        self.assertFalse(b.is_sleeping)
-
-        b.sleep()
-        s.remove(b)
-        b.activate()
-
-    def testSleepWithGroup(self) -> None:
-        b1 = p.Body(1, 1)
-        b2 = p.Body(2, 2)
-        s = p.Space()
-        s.sleep_time_threshold = 0.01
-        s.add(b2)
-        b2.sleep()
-
-        with self.assertRaises(Exception):
-            b1.sleep_with_group(b2)
-
-        s.add(b1)
-        b1.sleep_with_group(b2)
-        self.assertTrue(b1.is_sleeping)
-        b2.activate()
-        self.assertFalse(b1.is_sleeping)
-
-    def testKineticEnergy(self) -> None:
-        b = p.Body(1, 10)
-        self.assertEqual(b.kinetic_energy, 0)
-        b.apply_impulse_at_local_point((10, 0))
-        self.assertEqual(b.kinetic_energy, 100)
-
-    def testDynamic(self) -> None:
-        b1 = p.Body(1, 1)
-        b2 = p.Body(1, 1, body_type=p.Body.DYNAMIC)
-        self.assertEqual(b1.body_type, p.Body.DYNAMIC)
-        self.assertEqual(b2.body_type, p.Body.DYNAMIC)
-
-    def testKinematic(self) -> None:
-        b = p.Body(body_type=p.Body.KINEMATIC)
-        self.assertEqual(b.body_type, p.Body.KINEMATIC)
-
-    def testStatic(self) -> None:
-        b = p.Body(body_type=p.Body.STATIC)
-        self.assertEqual(b.body_type, p.Body.STATIC)
-
-    def testMassMomentFromShape(self) -> None:
-        s = p.Space()
-
-        b = p.Body()
-        b.mass = 2
-        c = p.Circle(b, 10, (2, 3))
-        c.mass = 3
-
-        self.assertEqual(b.mass, 0)
-        s.add(b, c)
-        self.assertEqual(b.mass, 3)
-        c.mass = 4
-        self.assertEqual(b.mass, 4)
-        self.assertEqual(b.center_of_gravity.x, 2)
-        self.assertEqual(b.center_of_gravity.y, 3)
-        self.assertEqual(b.moment, 200)
-
-    def testPositionFunction(self) -> None:
-        s = p.Space()
-        b = p.Body(1, 1)
-
-        def f(body: p.Body, dt: float) -> None:
-            body.position += 0, dt
-
-        b.position_func = f
-        s.add(b)
-        s.step(10)
-        self.assertEqual(b.position, (0, 10))
-        s.step(1)
-        s.step(1)
-        self.assertEqual(b.position.y, 12)
-
-        b.position_func = p.Body.update_position
-        s.step(1)
-        self.assertEqual(b.position.y, 12)
-
-    def testVelocityFunction(self) -> None:
-        s = p.Space()
-        b = p.Body(1, 1)
-
-        def f(body: p.Body, gravity: Vec2d, damping: float, dt: float) -> None:
-            body.velocity += 5 * gravity
-
-        b.velocity_func = f
-        s.gravity = 1, 0
-        s.add(b)
-        s.step(10)
-        return
-        self.assertEqual(b.velocity.x, 5)
-        s.step(0.1)
-        s.step(0.1)
-        self.assertEqual(b.velocity.x, 15)
-
-        b.velocity_func = b.update_velocity
-        s.step(1)
-        self.assertEqual(b.velocity.x, 16)
-
-    def testEachArbiters(self) -> None:
-        s = p.Space()
-        b1 = p.Body(1, 1)
-        b2 = p.Body(1, 1)
-        c1 = p.Circle(b1, 10)
-        c2 = p.Circle(b2, 10)
-        s.add(b1, b2, c1, c2)
-        s.step(1)
-
-        shapes: List[Shape] = []
-
-        def f(arbiter: Arbiter, shapes: List[Shape]) -> None:
-            shapes += arbiter.shapes
-
-        b1.each_arbiter(f, shapes)
-        self.assertEqual(shapes[0], c1)
-        self.assertEqual(shapes[1], c2)
-
-    def testGetConstraints(self) -> None:
-        s = p.Space()
-        b1 = p.Body(1, 1)
-        b2 = p.Body(1, 1)
-        s.add(b1)
-        j1 = PivotJoint(b1, s.static_body, (0, 0))
-        j2 = PivotJoint(b2, s.static_body, (0, 0))
-
-        self.assertTrue(j1 in b1.constraints)
-        self.assertTrue(j1 not in b2.constraints)
-        self.assertTrue(j1 in s.static_body.constraints)
-        self.assertTrue(j2 in s.static_body.constraints)
-
-    def testGetShapes(self) -> None:
-        s = p.Space()
-        b1 = p.Body(1, 1)
-        s.add(b1)
-        s1 = p.Circle(b1, 3)
-        s2 = p.Segment(b1, (0, 0), (1, 2), 1)
-
-        self.assertTrue(s1 in b1.shapes)
-        self.assertTrue(s2 in b1.shapes)
-        self.assertTrue(s1 not in s.static_body.shapes)
-
-    def testPickle(self) -> None:
-        b = p.Body(1, 2)
-        b.custom = "test"
-        b.position = 3, 4
-        b.center_of_gravity = 5, 6
-        b.velocity = 7, 8
-        b.force = 9, 10
-        b.angle = 11
-        b.angular_velocity = 12
-        b.torque = 13
-
-        b.position_func = pf
-        b.velocity_func = vf
-
-        s = pickle.dumps(b)
-        b2 = pickle.loads(s)
-
-        self.assertEqual(b.mass, b2.mass)
-        self.assertEqual(b.moment, b2.moment)
-        self.assertEqual(b.body_type, b2.body_type)
-        self.assertEqual(b.custom, b2.custom)
-        self.assertEqual(b.position, b2.position)
-        self.assertEqual(b.center_of_gravity, b2.center_of_gravity)
-        self.assertEqual(b.velocity, b2.velocity)
-        self.assertEqual(b.force, b2.force)
-        self.assertEqual(b.angle, b2.angle)
-        self.assertEqual(b.angular_velocity, b2.angular_velocity)
-        self.assertEqual(b.torque, b2.torque)
-
-        space = p.Space()
-        space.add(b2)
-        space.step(0.1)
-
-        self.assertTrue(b2.pf)
-        self.assertTrue(b2.vf)
-        b2 = b.copy()
-
-
-# Needs to be here for the lowest pickle protocol to work
-def pf(body: p.Body, dt: float) -> None:
-    body.pf = True
-
-
-def vf(body: p.Body, gravity: Tuple[float, float], damping: float, dt: float) -> None:
-    body.vf = True
+import pickle
+import unittest
+from typing import List, Tuple
+
+import pymunk as p
+from pymunk.arbiter import Arbiter
+from pymunk.constraints import *
+from pymunk.shapes import Shape
+from pymunk.vec2d import Vec2d
+
+####################################################################
+
+
+class UnitTestBody(unittest.TestCase):
+    def testProperties(self) -> None:
+        b = p.Body(10, 100)
+        self.assertEqual(b.mass, 10)
+        b.mass = 11
+        self.assertEqual(b.mass, 11)
+
+        self.assertEqual(b.moment, 100)
+        b.moment = 101
+        self.assertEqual(b.moment, 101)
+
+        self.assertEqual(b.position, (0, 0))
+        b.position = 1, 2
+        self.assertEqual(b.position, (1, 2))
+
+        self.assertEqual(b.center_of_gravity, (0, 0))
+        b.center_of_gravity = 2, 3
+        self.assertEqual(b.center_of_gravity, (2, 3))
+
+        self.assertEqual(b.velocity, (0, 0))
+        b.velocity = 3, 4
+        self.assertEqual(b.velocity, (3, 4))
+
+        self.assertEqual(b.force, (0, 0))
+        b.force = (4, 5)
+        self.assertEqual(b.force, (4, 5))
+
+        self.assertEqual(b.angle, 0)
+        b.angle = 1.2
+        self.assertEqual(b.angle, 1.2)
+
+        self.assertEqual(b.angular_velocity, 0)
+        b.angular_velocity = 1.3
+        self.assertEqual(b.angular_velocity, 1.3)
+
+        self.assertEqual(b.torque, 0)
+        b.torque = 1.4
+        self.assertEqual(b.torque, 1.4)
+
+        b.angle = 0
+        self.assertEqual(b.rotation_vector, (1, 0))
+        b.angle = Vec2d(1, 1).angle
+        self.assertAlmostEqual(b.rotation_vector.angle, Vec2d(1, 1).angle)
+
+        # self.assertGreater(b._id, 0)
+
+        self.assertEqual(b.space, None)
+        s = p.Space()
+        s.add(b)
+        self.assertEqual(b.space, s)
+
+    def testRepr(self) -> None:
+        b = p.Body(1, 2)
+        self.assertEqual(str(b), "Body(1.0, 2.0, Body.DYNAMIC)")
+        b = p.Body(body_type=p.Body.KINEMATIC)
+        self.assertEqual(str(b), "Body(Body.KINEMATIC)")
+        b = p.Body(body_type=p.Body.STATIC)
+        self.assertEqual(str(b), "Body(Body.STATIC)")
+
+    def testCoordinateConversion(self) -> None:
+        b = p.Body(body_type=p.Body.KINEMATIC)
+        v = 1, 2
+        self.assertEqual(b.local_to_world(v), v)
+        self.assertEqual(b.world_to_local(v), v)
+        b.position = 3, 4
+        self.assertEqual(b.local_to_world(v), (4, 6))
+        self.assertEqual(b.world_to_local(v), (-2, -2))
+
+    def testVelocityConversion(self) -> None:
+        b = p.Body(1, 2)
+        self.assertEqual(b.velocity_at_world_point((1, 1)), (0, 0))
+        self.assertEqual(b.velocity_at_local_point((1, 1)), (0, 0))
+        b.position = 1, 2
+        b.angular_velocity = 1.2
+        self.assertEqual(b.velocity_at_world_point((1, 1)), (1.2, 0))
+        self.assertEqual(b.velocity_at_local_point((1, 1)), (-1.2, 1.2))
+
+    def testForce(self) -> None:
+        b = p.Body(1, 2)
+        b.position = 3, 4
+        b.apply_force_at_world_point((10, 0), (0, 10))
+        self.assertEqual(b.force, (10, 0))
+        self.assertEqual(b.torque, -60)
+
+        b = p.Body(1, 2)
+        b.position = 3, 4
+        b.apply_force_at_local_point((10, 0), (0, 10))
+        self.assertEqual(b.force, (10, 0))
+        self.assertEqual(b.torque, -100)
+
+    def testImpulse(self) -> None:
+        b = p.Body(1, 2)
+        b.position = 3, 4
+        b.apply_impulse_at_world_point((10, 0), (0, 10))
+        self.assertEqual(b.velocity, (10, 0))
+        self.assertEqual(b.angular_velocity, -30)
+
+        b = p.Body(1, 2)
+        b.position = 3, 4
+        b.apply_impulse_at_local_point((10, 0), (0, 10))
+        self.assertEqual(b.velocity, (10, 0))
+        self.assertEqual(b.angular_velocity, -50)
+
+    def testSleep(self) -> None:
+        b = p.Body(1, 1)
+        s = p.Space()
+        s.sleep_time_threshold = 0.01
+
+        self.assertFalse(b.is_sleeping)
+
+        self.assertRaises(Exception, b.sleep)
+        s.add(b)
+        b.sleep()
+
+        self.assertTrue(b.is_sleeping)
+
+        b.activate()
+        self.assertFalse(b.is_sleeping)
+
+        b.sleep()
+        s.remove(b)
+        b.activate()
+
+    def testSleepWithGroup(self) -> None:
+        b1 = p.Body(1, 1)
+        b2 = p.Body(2, 2)
+        s = p.Space()
+        s.sleep_time_threshold = 0.01
+        s.add(b2)
+        b2.sleep()
+
+        with self.assertRaises(Exception):
+            b1.sleep_with_group(b2)
+
+        s.add(b1)
+        b1.sleep_with_group(b2)
+        self.assertTrue(b1.is_sleeping)
+        b2.activate()
+        self.assertFalse(b1.is_sleeping)
+
+    def testKineticEnergy(self) -> None:
+        b = p.Body(1, 10)
+        self.assertEqual(b.kinetic_energy, 0)
+        b.apply_impulse_at_local_point((10, 0))
+        self.assertEqual(b.kinetic_energy, 100)
+
+    def testDynamic(self) -> None:
+        b1 = p.Body(1, 1)
+        b2 = p.Body(1, 1, body_type=p.Body.DYNAMIC)
+        self.assertEqual(b1.body_type, p.Body.DYNAMIC)
+        self.assertEqual(b2.body_type, p.Body.DYNAMIC)
+
+    def testKinematic(self) -> None:
+        b = p.Body(body_type=p.Body.KINEMATIC)
+        self.assertEqual(b.body_type, p.Body.KINEMATIC)
+
+    def testStatic(self) -> None:
+        b = p.Body(body_type=p.Body.STATIC)
+        self.assertEqual(b.body_type, p.Body.STATIC)
+
+    def testMassMomentFromShape(self) -> None:
+        s = p.Space()
+
+        b = p.Body()
+        b.mass = 2
+        c = p.Circle(b, 10, (2, 3))
+        c.mass = 3
+
+        self.assertEqual(b.mass, 0)
+        s.add(b, c)
+        self.assertEqual(b.mass, 3)
+        c.mass = 4
+        self.assertEqual(b.mass, 4)
+        self.assertEqual(b.center_of_gravity.x, 2)
+        self.assertEqual(b.center_of_gravity.y, 3)
+        self.assertEqual(b.moment, 200)
+
+    def testPositionFunction(self) -> None:
+        s = p.Space()
+        b = p.Body(1, 1)
+
+        def f(body: p.Body, dt: float) -> None:
+            body.position += 0, dt
+
+        b.position_func = f
+        s.add(b)
+        s.step(10)
+        self.assertEqual(b.position, (0, 10))
+        s.step(1)
+        s.step(1)
+        self.assertEqual(b.position.y, 12)
+
+        b.position_func = p.Body.update_position
+        s.step(1)
+        self.assertEqual(b.position.y, 12)
+
+    def testVelocityFunction(self) -> None:
+        s = p.Space()
+        b = p.Body(1, 1)
+
+        def f(body: p.Body, gravity: Vec2d, damping: float, dt: float) -> None:
+            body.velocity += 5 * gravity
+
+        b.velocity_func = f
+        s.gravity = 1, 0
+        s.add(b)
+        s.step(10)
+        return
+        self.assertEqual(b.velocity.x, 5)
+        s.step(0.1)
+        s.step(0.1)
+        self.assertEqual(b.velocity.x, 15)
+
+        b.velocity_func = b.update_velocity
+        s.step(1)
+        self.assertEqual(b.velocity.x, 16)
+
+    def testEachArbiters(self) -> None:
+        s = p.Space()
+        b1 = p.Body(1, 1)
+        b2 = p.Body(1, 1)
+        c1 = p.Circle(b1, 10)
+        c2 = p.Circle(b2, 10)
+        s.add(b1, b2, c1, c2)
+        s.step(1)
+
+        shapes: List[Shape] = []
+
+        def f(arbiter: Arbiter, shapes: List[Shape]) -> None:
+            shapes += arbiter.shapes
+
+        b1.each_arbiter(f, shapes)
+        self.assertEqual(shapes[0], c1)
+        self.assertEqual(shapes[1], c2)
+
+    def testGetConstraints(self) -> None:
+        s = p.Space()
+        b1 = p.Body(1, 1)
+        b2 = p.Body(1, 1)
+        s.add(b1)
+        j1 = PivotJoint(b1, s.static_body, (0, 0))
+        j2 = PivotJoint(b2, s.static_body, (0, 0))
+
+        self.assertTrue(j1 in b1.constraints)
+        self.assertTrue(j1 not in b2.constraints)
+        self.assertTrue(j1 in s.static_body.constraints)
+        self.assertTrue(j2 in s.static_body.constraints)
+
+    def testGetShapes(self) -> None:
+        s = p.Space()
+        b1 = p.Body(1, 1)
+        s.add(b1)
+        s1 = p.Circle(b1, 3)
+        s2 = p.Segment(b1, (0, 0), (1, 2), 1)
+
+        self.assertTrue(s1 in b1.shapes)
+        self.assertTrue(s2 in b1.shapes)
+        self.assertTrue(s1 not in s.static_body.shapes)
+
+    def testPickle(self) -> None:
+        b = p.Body(1, 2)
+        b.custom = "test"
+        b.position = 3, 4
+        b.center_of_gravity = 5, 6
+        b.velocity = 7, 8
+        b.force = 9, 10
+        b.angle = 11
+        b.angular_velocity = 12
+        b.torque = 13
+
+        b.position_func = pf
+        b.velocity_func = vf
+
+        s = pickle.dumps(b)
+        b2 = pickle.loads(s)
+
+        self.assertEqual(b.mass, b2.mass)
+        self.assertEqual(b.moment, b2.moment)
+        self.assertEqual(b.body_type, b2.body_type)
+        self.assertEqual(b.custom, b2.custom)
+        self.assertEqual(b.position, b2.position)
+        self.assertEqual(b.center_of_gravity, b2.center_of_gravity)
+        self.assertEqual(b.velocity, b2.velocity)
+        self.assertEqual(b.force, b2.force)
+        self.assertEqual(b.angle, b2.angle)
+        self.assertEqual(b.angular_velocity, b2.angular_velocity)
+        self.assertEqual(b.torque, b2.torque)
+
+        space = p.Space()
+        space.add(b2)
+        space.step(0.1)
+
+        self.assertTrue(b2.pf)
+        self.assertTrue(b2.vf)
+        b2 = b.copy()
+
+
+# Needs to be here for the lowest pickle protocol to work
+def pf(body: p.Body, dt: float) -> None:
+    body.pf = True
+
+
+def vf(body: p.Body, gravity: Tuple[float, float], damping: float, dt: float) -> None:
+    body.vf = True
```

## Comparing `pymunk-6.5.0/pymunk/tests/test_common.py` & `pymunk/tests/test_common.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,123 +1,123 @@
-import unittest
-from typing import Any, List
-
-import pymunk as p
-from pymunk.vec2d import Vec2d
-
-
-class UnitTestGeneral(unittest.TestCase):
-    def testGeneral(self) -> None:
-        p.version
-        p.chipmunk_version
-
-    def testMomentHelpers(self) -> None:
-        m = p.moment_for_circle(1, 2, 3, (1, 2))
-        self.assertAlmostEqual(m, 11.5)
-
-        m = p.moment_for_segment(1, (-10, 0), (10, 0), 1)
-        self.assertAlmostEqual(m, 40.6666666666)
-
-        m = p.moment_for_poly(1, [(0, 0), (10, 10), (10, 0)], (1, 2), 3)
-        self.assertAlmostEqual(m, 98.3333333333)
-
-        m = p.moment_for_box(1, (2, 3))
-        self.assertAlmostEqual(m, 1.08333333333)
-
-    def testAreaHelpers(self) -> None:
-        a = p.area_for_circle(1, 2)
-        self.assertAlmostEqual(a, 9.4247779607)
-
-        a = p.area_for_segment((-10, 0), (10, 0), 3)
-        self.assertAlmostEqual(a, 148.27433388)
-
-        a = p.area_for_poly([(0, 0), (10, 10), (10, 0)], 3)
-        self.assertAlmostEqual(a, 80.700740753)
-
-
-class UnitTestBugs(unittest.TestCase):
-    def testGC(self) -> None:
-
-        import gc
-        import logging
-
-        _logger = logging.getLogger(__name__)
-
-        def make() -> List[Any]:
-            s = p.Space()
-            b1 = p.Body(1, 2)
-            c1 = p.Circle(b1, 2)
-            c2 = p.Circle(b1, 2)
-            b2 = p.Body(1, 2)
-            c3 = p.Circle(b2, 2)
-            s.add(b1, c1, c2, b2, c3)
-            s.step(1)
-            return [s, b1, c1, c2, b2, c3]
-
-        import itertools
-
-        for order in itertools.permutations(range(6)):
-            objs = make()
-            _logger.debug("Order: %s", order)
-            for i in order:
-                o = objs[i]
-                if o is p.Space:
-                    del o._space
-                if o is p.Circle:
-                    del o._shape
-                if o is p.Body:
-                    del o._body
-            gc.collect()
-
-    def testManyBoxCrash(self) -> None:
-        space = p.Space()
-        for x in [1, 2]:
-            for y in range(16):
-                size = 10
-                box_points = [
-                    Vec2d(*p)
-                    for p in [
-                        (-size, -size),
-                        (-size, size),
-                        (size, size),
-                        (size, -size),
-                    ]
-                ]
-                body = p.Body(10, 20)
-                shape = p.Poly(body, box_points)
-                space.add(body, shape)
-            space.step(1 / 50.0)
-
-    def testNoStaticShape(self) -> None:
-        space = p.Space()
-
-        b1 = p.Body(1, float("inf"))
-        c1 = p.Circle(b1, 10)
-        c1.name = "c1"
-        c1.collision_type = 2
-
-        b2 = p.Body(1, float("inf"))
-        c2 = p.Circle(b2, 10)
-        c2.name = "c2"
-
-        b3 = p.Body(1, float("inf"))
-        c3 = p.Circle(b3, 10)
-        c3.name = "c3"
-
-        b1.position = 0, 0
-        b2.position = 9, 0
-        b3.position = -9, 0
-
-        space.add(b1, c1, b2, c2, b3, c3)
-
-        def remove_first(arbiter: p.Arbiter, space: p.Space, data: Any) -> None:
-            first_shape = arbiter.shapes[0]
-            if c1 in space.shapes:
-                space.remove(c1)
-            # space.add_post_step_callback(space.remove, first_shape, first_shape.body)
-            space.remove(c1)
-
-        space.add_collision_handler(2, 0).separate = remove_first
-
-        space.step(1.0 / 60)
-        b2.position = 22, 0
-        space.step(1.0 / 60)
+import unittest
+from typing import Any, List
+
+import pymunk as p
+from pymunk.vec2d import Vec2d
+
+
+class UnitTestGeneral(unittest.TestCase):
+    def testGeneral(self) -> None:
+        p.version
+        p.chipmunk_version
+
+    def testMomentHelpers(self) -> None:
+        m = p.moment_for_circle(1, 2, 3, (1, 2))
+        self.assertAlmostEqual(m, 11.5)
+
+        m = p.moment_for_segment(1, (-10, 0), (10, 0), 1)
+        self.assertAlmostEqual(m, 40.6666666666)
+
+        m = p.moment_for_poly(1, [(0, 0), (10, 10), (10, 0)], (1, 2), 3)
+        self.assertAlmostEqual(m, 98.3333333333)
+
+        m = p.moment_for_box(1, (2, 3))
+        self.assertAlmostEqual(m, 1.08333333333)
+
+    def testAreaHelpers(self) -> None:
+        a = p.area_for_circle(1, 2)
+        self.assertAlmostEqual(a, 9.4247779607)
+
+        a = p.area_for_segment((-10, 0), (10, 0), 3)
+        self.assertAlmostEqual(a, 148.27433388)
+
+        a = p.area_for_poly([(0, 0), (10, 10), (10, 0)], 3)
+        self.assertAlmostEqual(a, 80.700740753)
+
+
+class UnitTestBugs(unittest.TestCase):
+    def testGC(self) -> None:
+
+        import gc
+        import logging
+
+        _logger = logging.getLogger(__name__)
+
+        def make() -> List[Any]:
+            s = p.Space()
+            b1 = p.Body(1, 2)
+            c1 = p.Circle(b1, 2)
+            c2 = p.Circle(b1, 2)
+            b2 = p.Body(1, 2)
+            c3 = p.Circle(b2, 2)
+            s.add(b1, c1, c2, b2, c3)
+            s.step(1)
+            return [s, b1, c1, c2, b2, c3]
+
+        import itertools
+
+        for order in itertools.permutations(range(6)):
+            objs = make()
+            _logger.debug("Order: %s", order)
+            for i in order:
+                o = objs[i]
+                if o is p.Space:
+                    del o._space
+                if o is p.Circle:
+                    del o._shape
+                if o is p.Body:
+                    del o._body
+            gc.collect()
+
+    def testManyBoxCrash(self) -> None:
+        space = p.Space()
+        for x in [1, 2]:
+            for y in range(16):
+                size = 10
+                box_points = [
+                    Vec2d(*p)
+                    for p in [
+                        (-size, -size),
+                        (-size, size),
+                        (size, size),
+                        (size, -size),
+                    ]
+                ]
+                body = p.Body(10, 20)
+                shape = p.Poly(body, box_points)
+                space.add(body, shape)
+            space.step(1 / 50.0)
+
+    def testNoStaticShape(self) -> None:
+        space = p.Space()
+
+        b1 = p.Body(1, float("inf"))
+        c1 = p.Circle(b1, 10)
+        c1.name = "c1"
+        c1.collision_type = 2
+
+        b2 = p.Body(1, float("inf"))
+        c2 = p.Circle(b2, 10)
+        c2.name = "c2"
+
+        b3 = p.Body(1, float("inf"))
+        c3 = p.Circle(b3, 10)
+        c3.name = "c3"
+
+        b1.position = 0, 0
+        b2.position = 9, 0
+        b3.position = -9, 0
+
+        space.add(b1, c1, b2, c2, b3, c3)
+
+        def remove_first(arbiter: p.Arbiter, space: p.Space, data: Any) -> None:
+            first_shape = arbiter.shapes[0]
+            if c1 in space.shapes:
+                space.remove(c1)
+            # space.add_post_step_callback(space.remove, first_shape, first_shape.body)
+            space.remove(c1)
+
+        space.add_collision_handler(2, 0).separate = remove_first
+
+        space.step(1.0 / 60)
+        b2.position = 22, 0
+        space.step(1.0 / 60)
```

## Comparing `pymunk-6.5.0/pymunk/tests/test_constraint.py` & `pymunk/tests/test_constraint.py`

 * *Ordering differences only*

 * *Files 19% similar despite different names*

```diff
@@ -1,510 +1,510 @@
-import pickle
-import unittest
-
-import pymunk as p
-from pymunk.constraints import *
-
-
-class UnitTestConstraint(unittest.TestCase):
-    def testA(self) -> None:
-        a, b = p.Body(10, 10), p.Body(10, 10)
-        j = PivotJoint(a, b, (0, 0))
-        self.assertEqual(j.a, a)
-
-    def testB(self) -> None:
-        a, b = p.Body(10, 10), p.Body(10, 10)
-        j = PivotJoint(a, b, (0, 0))
-        self.assertEqual(j.b, b)
-
-    def testMaxForce(self) -> None:
-        a, b = p.Body(10, 10), p.Body(10, 10)
-        j = PivotJoint(a, b, (0, 0))
-        self.assertEqual(j.max_force, float("inf"))
-        j.max_force = 10
-        self.assertEqual(j.max_force, 10)
-
-    def testErrorBias(self) -> None:
-        a, b = p.Body(10, 10), p.Body(10, 10)
-        j = PivotJoint(a, b, (0, 0))
-        self.assertAlmostEqual(j.error_bias, pow(1.0 - 0.1, 60.0))
-        j.error_bias = 0.3
-        self.assertEqual(j.error_bias, 0.3)
-
-    def testMaxBias(self) -> None:
-        a, b = p.Body(10, 10), p.Body(10, 10)
-        j = PivotJoint(a, b, (0, 0))
-        self.assertEqual(j.max_bias, float("inf"))
-        j.max_bias = 10
-        self.assertEqual(j.max_bias, 10)
-
-    def testCollideBodies(self) -> None:
-        a, b = p.Body(10, 10), p.Body(10, 10)
-        j = PivotJoint(a, b, (0, 0))
-        self.assertEqual(j.collide_bodies, True)
-        j.collide_bodies = False
-        self.assertEqual(j.collide_bodies, False)
-
-    def testImpulse(self) -> None:
-        a, b = p.Body(10, 10), p.Body(10, 10)
-        b.position = 0, 10
-        j = PivotJoint(a, b, (0, 0))
-
-        s = p.Space()
-        s.gravity = 0, 10
-        s.add(b, j)
-        self.assertEqual(j.impulse, 0)
-        s.step(1)
-        self.assertAlmostEqual(j.impulse, 50)
-
-    def testActivate(self) -> None:
-        a, b = p.Body(4, 5), p.Body(10, 10)
-        j = PivotJoint(a, b, (0, 0))
-        s = p.Space()
-        s.sleep_time_threshold = 0.01
-        s.add(a, b)
-        a.sleep()
-        b.sleep()
-
-        j.activate_bodies()
-        self.assertFalse(a.is_sleeping)
-        self.assertFalse(b.is_sleeping)
-
-    def testPreSolve(self) -> None:
-        b = p.Body(1, 2)
-        s = p.Space()
-        j = PivotJoint(s.static_body, b, (0, 0))
-
-        s.add(b, j)
-        self.assertIsNone(j.pre_solve)
-        s.step(1)
-
-        actual_constraint = None
-        actual_space = None
-
-        def pre_solve(constraint: Constraint, space: p.Space) -> None:
-            nonlocal actual_constraint
-            nonlocal actual_space
-            actual_constraint = constraint
-            actual_space = space
-
-        j.pre_solve = pre_solve
-        s.step(1)
-
-        self.assertEqual(actual_constraint, j)
-        self.assertEqual(actual_space, s)
-
-    def testPostSolve(self) -> None:
-        b = p.Body(1, 2)
-        s = p.Space()
-        j = PivotJoint(s.static_body, b, (0, 0))
-
-        s.add(b, j)
-        self.assertIsNone(j.pre_solve)
-        s.step(1)
-
-        actual_constraint = None
-        actual_space = None
-
-        def post_solve(constraint: Constraint, space: p.Space) -> None:
-            nonlocal actual_constraint
-            nonlocal actual_space
-            actual_constraint = constraint
-            actual_space = space
-
-        j.post_solve = post_solve
-        s.step(1)
-
-        self.assertEqual(actual_constraint, j)
-        self.assertEqual(actual_space, s)
-
-    def testPrePostSolveOrder(self) -> None:
-        s = p.Space()
-        b = p.Body(1, 2)
-        j = PivotJoint(s.static_body, b, (0, 0))
-
-        s.add(b, j)
-
-        actual_order = []
-
-        def pre_solve(c: Constraint, s: p.Space) -> None:
-            nonlocal actual_order
-            actual_order.append(1)
-
-        def post_solve(c: Constraint, s: p.Space) -> None:
-            nonlocal actual_order
-            actual_order.append(2)
-
-        j.pre_solve = pre_solve
-        j.post_solve = post_solve
-        s.step(1)
-
-        self.assertEqual(actual_order, [1, 2])
-
-    def testPickle(self) -> None:
-        a, b = p.Body(4, 5), p.Body(10, 10)
-        a.custom = "a"
-        b.custom = "b"
-        j = PivotJoint(a, b, (1, 2))
-        j.custom = "test"
-        j.max_force = 2
-        j.error_bias = 3
-        j.max_bias = 4
-        j.collide_bodies = False
-
-        j.pre_solve = pre_solve
-
-        j.post_solve = post_solve
-
-        s = pickle.dumps(j)
-        j2 = pickle.loads(s)
-        self.assertEqual(j.custom, j2.custom)
-        self.assertEqual(j.max_force, j2.max_force)
-        self.assertEqual(j.error_bias, j2.error_bias)
-        self.assertEqual(j.max_bias, j2.max_bias)
-        self.assertEqual(j.collide_bodies, j2.collide_bodies)
-        self.assertEqual(j.a.custom, j2.a.custom)
-        self.assertEqual(j.b.custom, j2.b.custom)
-
-        self.assertEqual(j.pre_solve, j2.pre_solve)
-        self.assertEqual(j.post_solve, j2.post_solve)
-
-        j2 = j.copy()
-
-
-class UnitTestPinJoint(unittest.TestCase):
-    def testAnchor(self) -> None:
-        a, b = p.Body(10, 10), p.Body(20, 20)
-        j = PinJoint(a, b, (1, 2), (3, 4))
-        self.assertEqual(j.anchor_a, (1, 2))
-        self.assertEqual(j.anchor_b, (3, 4))
-        j.anchor_a = (5, 6)
-        j.anchor_b = (7, 8)
-        self.assertEqual(j.anchor_a, (5, 6))
-        self.assertEqual(j.anchor_b, (7, 8))
-
-    def testDistane(self) -> None:
-        a, b = p.Body(10, 10), p.Body(20, 20)
-        j = PinJoint(a, b, (0, 0), (10, 0))
-        self.assertEqual(j.distance, 10)
-        j.distance = 20
-        self.assertEqual(j.distance, 20)
-
-    def testPickle(self) -> None:
-        a, b = p.Body(10, 10), p.Body(20, 20)
-        j = PinJoint(a, b, (1, 2), (3, 4))
-
-        s = pickle.dumps(j)
-        j2 = pickle.loads(s)
-
-        self.assertEqual(j.anchor_a, j2.anchor_a)
-        self.assertEqual(j.anchor_b, j2.anchor_b)
-        self.assertEqual(j.distance, j2.distance)
-        self.assertEqual(j.a.mass, j2.a.mass)
-        self.assertEqual(j.b.mass, j2.b.mass)
-
-
-class UnitTestSlideJoint(unittest.TestCase):
-    def testAnchor(self) -> None:
-        a, b = p.Body(10, 10), p.Body(20, 20)
-        j = SlideJoint(a, b, (1, 2), (3, 4), 0, 10)
-        self.assertEqual(j.anchor_a, (1, 2))
-        self.assertEqual(j.anchor_b, (3, 4))
-        j.anchor_a = (5, 6)
-        j.anchor_b = (7, 8)
-        self.assertEqual(j.anchor_a, (5, 6))
-        self.assertEqual(j.anchor_b, (7, 8))
-
-    def testMin(self) -> None:
-        a, b = p.Body(10, 10), p.Body(20, 20)
-        j = SlideJoint(a, b, (0, 0), (0, 0), 1, 0)
-        self.assertEqual(j.min, 1)
-        j.min = 2
-        self.assertEqual(j.min, 2)
-
-    def testMax(self) -> None:
-        a, b = p.Body(10, 10), p.Body(20, 20)
-        j = SlideJoint(a, b, (0, 0), (0, 0), 0, 1)
-        self.assertEqual(j.max, 1)
-        j.max = 2
-        self.assertEqual(j.max, 2)
-
-    def testPickle(self) -> None:
-        a, b = p.Body(10, 10), p.Body(20, 20)
-        j = SlideJoint(a, b, (1, 2), (3, 4), 5, 6)
-
-        s = pickle.dumps(j)
-        j2 = pickle.loads(s)
-
-        self.assertEqual(j.anchor_a, j2.anchor_a)
-        self.assertEqual(j.anchor_b, j2.anchor_b)
-        self.assertEqual(j.min, j2.min)
-        self.assertEqual(j.max, j2.max)
-        self.assertEqual(j.a.mass, j2.a.mass)
-        self.assertEqual(j.b.mass, j2.b.mass)
-
-
-class UnitTestPivotJoint(unittest.TestCase):
-    def testAnchorByPivot(self) -> None:
-        a, b = p.Body(10, 10), p.Body(20, 20)
-        a.position = (5, 7)
-        j = PivotJoint(a, b, (1, 2))
-        self.assertEqual(j.anchor_a, (-4, -5))
-        self.assertEqual(j.anchor_b, (1, 2))
-
-    def testAnchorByAnchor(self) -> None:
-        a, b = p.Body(10, 10), p.Body(20, 20)
-        j = PivotJoint(a, b, (1, 2), (3, 4))
-        self.assertEqual(j.anchor_a, (1, 2))
-        self.assertEqual(j.anchor_b, (3, 4))
-        j.anchor_a = (5, 6)
-        j.anchor_b = (7, 8)
-        self.assertEqual(j.anchor_a, (5, 6))
-        self.assertEqual(j.anchor_b, (7, 8))
-
-    def testPickle(self) -> None:
-        a, b = p.Body(10, 10), p.Body(20, 20)
-        j = PivotJoint(a, b, (1, 2), (3, 4))
-
-        s = pickle.dumps(j)
-        j2 = pickle.loads(s)
-
-        self.assertEqual(j.anchor_a, j2.anchor_a)
-        self.assertEqual(j.anchor_b, j2.anchor_b)
-        self.assertEqual(j.a.mass, j2.a.mass)
-        self.assertEqual(j.b.mass, j2.b.mass)
-
-
-class UnitTestGrooveJoint(unittest.TestCase):
-    def testAnchor(self) -> None:
-        a, b = p.Body(10, 10), p.Body(20, 20)
-        j = GrooveJoint(a, b, (0, 0), (0, 0), (1, 2))
-        self.assertEqual(j.anchor_b, (1, 2))
-        j.anchor_b = (3, 4)
-        self.assertEqual(j.anchor_b, (3, 4))
-
-    def testGroove(self) -> None:
-        a, b = p.Body(10, 10), p.Body(20, 20)
-        j = GrooveJoint(a, b, (1, 2), (3, 4), (0, 0))
-        self.assertEqual(j.groove_a, (1, 2))
-        self.assertEqual(j.groove_b, (3, 4))
-        j.groove_a = (5, 6)
-        j.groove_b = (7, 8)
-        self.assertEqual(j.groove_a, (5, 6))
-        self.assertEqual(j.groove_b, (7, 8))
-
-    def testPickle(self) -> None:
-        a, b = p.Body(10, 10), p.Body(20, 20)
-        j = GrooveJoint(a, b, (1, 2), (3, 4), (5, 6))
-
-        s = pickle.dumps(j)
-        j2 = pickle.loads(s)
-
-        self.assertEqual(j.groove_a, j2.groove_a)
-        self.assertEqual(j.groove_b, j2.groove_b)
-        self.assertEqual(j.anchor_b, j2.anchor_b)
-        self.assertEqual(j.a.mass, j2.a.mass)
-        self.assertEqual(j.b.mass, j2.b.mass)
-
-
-class UnitTestDampedSpring(unittest.TestCase):
-    def testAnchor(self) -> None:
-        a, b = p.Body(10, 10), p.Body(20, 20)
-        j = DampedSpring(a, b, (1, 2), (3, 4), 0, 0, 0)
-        self.assertEqual(j.anchor_a, (1, 2))
-        self.assertEqual(j.anchor_b, (3, 4))
-        j.anchor_a = (5, 6)
-        j.anchor_b = (7, 8)
-        self.assertEqual(j.anchor_a, (5, 6))
-        self.assertEqual(j.anchor_b, (7, 8))
-
-    def testRestLength(self) -> None:
-        a, b = p.Body(10, 10), p.Body(20, 20)
-        j = DampedSpring(a, b, (0, 0), (0, 0), 1, 0, 0)
-        self.assertEqual(j.rest_length, 1)
-        j.rest_length = 2
-        self.assertEqual(j.rest_length, 2)
-
-    def testStiffness(self) -> None:
-        a, b = p.Body(10, 10), p.Body(20, 20)
-        j = DampedSpring(a, b, (0, 0), (0, 0), 0, 1, 0)
-        self.assertEqual(j.stiffness, 1)
-        j.stiffness = 2
-        self.assertEqual(j.stiffness, 2)
-
-    def testDamping(self) -> None:
-        a, b = p.Body(10, 10), p.Body(20, 20)
-        j = DampedSpring(a, b, (0, 0), (0, 0), 0, 0, 1)
-        self.assertEqual(j.damping, 1)
-        j.damping = 2
-        self.assertEqual(j.damping, 2)
-
-    def testPickle(self) -> None:
-        a, b = p.Body(10, 10), p.Body(20, 20)
-        j = DampedSpring(a, b, (1, 2), (3, 4), 5, 6, 7)
-
-        s = pickle.dumps(j)
-        j2 = pickle.loads(s)
-
-        self.assertEqual(j.anchor_a, j2.anchor_a)
-        self.assertEqual(j.anchor_b, j2.anchor_b)
-        self.assertEqual(j.rest_length, j2.rest_length)
-        self.assertEqual(j.stiffness, j2.stiffness)
-        self.assertEqual(j.damping, j2.damping)
-        self.assertEqual(j.a.mass, j2.a.mass)
-        self.assertEqual(j.b.mass, j2.b.mass)
-
-
-class UnitTestDampedRotarySpring(unittest.TestCase):
-    def testRestAngle(self) -> None:
-        a, b = p.Body(10, 10), p.Body(20, 20)
-        j = DampedRotarySpring(a, b, 1, 0, 0)
-        self.assertEqual(j.rest_angle, 1)
-        j.rest_angle = 2
-        self.assertEqual(j.rest_angle, 2)
-
-    def testStiffness(self) -> None:
-        a, b = p.Body(10, 10), p.Body(20, 20)
-        j = DampedRotarySpring(a, b, 0, 1, 0)
-        self.assertEqual(j.stiffness, 1)
-        j.stiffness = 2
-        self.assertEqual(j.stiffness, 2)
-
-    def testDamping(self) -> None:
-        a, b = p.Body(10, 10), p.Body(20, 20)
-        j = DampedRotarySpring(a, b, 0, 0, 1)
-        self.assertEqual(j.damping, 1)
-        j.damping = 2
-        self.assertEqual(j.damping, 2)
-
-    def testPickle(self) -> None:
-        a, b = p.Body(10, 10), p.Body(20, 20)
-        j = DampedRotarySpring(a, b, 1, 2, 3)
-
-        s = pickle.dumps(j)
-        j2 = pickle.loads(s)
-
-        self.assertEqual(j.rest_angle, j2.rest_angle)
-        self.assertEqual(j.stiffness, j2.stiffness)
-        self.assertEqual(j.damping, j2.damping)
-        self.assertEqual(j.a.mass, j2.a.mass)
-        self.assertEqual(j.b.mass, j2.b.mass)
-
-
-class UnitTestRotaryLimitJoint(unittest.TestCase):
-    def testMin(self) -> None:
-        a, b = p.Body(10, 10), p.Body(20, 20)
-        j = RotaryLimitJoint(a, b, 1, 0)
-        self.assertEqual(j.min, 1)
-        j.min = 2
-        self.assertEqual(j.min, 2)
-
-    def testMax(self) -> None:
-        a, b = p.Body(10, 10), p.Body(20, 20)
-        j = RotaryLimitJoint(a, b, 0, 1)
-        self.assertEqual(j.max, 1)
-        j.max = 2
-        self.assertEqual(j.max, 2)
-
-    def testPickle(self) -> None:
-        a, b = p.Body(10, 10), p.Body(20, 20)
-        j = RotaryLimitJoint(a, b, 1, 2)
-
-        s = pickle.dumps(j)
-        j2 = pickle.loads(s)
-
-        self.assertEqual(j.min, j2.min)
-        self.assertEqual(j.max, j2.max)
-        self.assertEqual(j.a.mass, j2.a.mass)
-        self.assertEqual(j.b.mass, j2.b.mass)
-
-
-class UnitTestRatchetJoint(unittest.TestCase):
-    def testAngle(self) -> None:
-        a, b = p.Body(10, 10), p.Body(20, 20)
-        j = RatchetJoint(a, b, 0, 0)
-        self.assertEqual(j.angle, 0)
-        j.angle = 1
-        self.assertEqual(j.angle, 1)
-
-    def testPhase(self) -> None:
-        a, b = p.Body(10, 10), p.Body(20, 20)
-        j = RatchetJoint(a, b, 1, 0)
-        self.assertEqual(j.phase, 1)
-        j.phase = 2
-        self.assertEqual(j.phase, 2)
-
-    def testRatchet(self) -> None:
-        a, b = p.Body(10, 10), p.Body(20, 20)
-        j = RatchetJoint(a, b, 0, 1)
-        self.assertEqual(j.ratchet, 1)
-        j.ratchet = 2
-        self.assertEqual(j.ratchet, 2)
-
-    def testPickle(self) -> None:
-        a, b = p.Body(10, 10), p.Body(20, 20)
-        j = RatchetJoint(a, b, 1, 2)
-
-        s = pickle.dumps(j)
-        j2 = pickle.loads(s)
-
-        self.assertEqual(j.phase, j2.phase)
-        self.assertEqual(j.ratchet, j2.ratchet)
-        self.assertEqual(j.a.mass, j2.a.mass)
-        self.assertEqual(j.b.mass, j2.b.mass)
-
-
-class UnitTestGearJoint(unittest.TestCase):
-    def testPhase(self) -> None:
-        a, b = p.Body(10, 10), p.Body(20, 20)
-        j = GearJoint(a, b, 1, 0)
-        self.assertEqual(j.phase, 1)
-        j.phase = 2
-        self.assertEqual(j.phase, 2)
-
-    def testRatio(self) -> None:
-        a, b = p.Body(10, 10), p.Body(20, 20)
-        j = GearJoint(a, b, 0, 1)
-        self.assertEqual(j.ratio, 1)
-        j.ratio = 2
-        self.assertEqual(j.ratio, 2)
-
-    def testPickle(self) -> None:
-        a, b = p.Body(10, 10), p.Body(20, 20)
-        j = GearJoint(a, b, 1, 2)
-
-        s = pickle.dumps(j)
-        j2 = pickle.loads(s)
-
-        self.assertEqual(j.phase, j2.phase)
-        self.assertEqual(j.ratio, j2.ratio)
-        self.assertEqual(j.a.mass, j2.a.mass)
-        self.assertEqual(j.b.mass, j2.b.mass)
-
-
-class UnitTestSimleMotor(unittest.TestCase):
-    def testSimpleMotor(self) -> None:
-        a, b = p.Body(10, 10), p.Body(20, 20)
-        j = SimpleMotor(a, b, 0.3)
-        self.assertEqual(j.rate, 0.3)
-        j.rate = 0.4
-        self.assertEqual(j.rate, 0.4)
-
-    def testPickle(self) -> None:
-        a, b = p.Body(10, 10), p.Body(20, 20)
-        j = SimpleMotor(a, b, 1)
-
-        s = pickle.dumps(j)
-        j2 = pickle.loads(s)
-
-        self.assertEqual(j.rate, j2.rate)
-        self.assertEqual(j.a.mass, j2.a.mass)
-        self.assertEqual(j.b.mass, j2.b.mass)
-
-
-# Needed to be able to pickle
-def pre_solve(c: Constraint, s: p.Space) -> None:
-    pass
-
-
-def post_solve(c: Constraint, s: p.Space) -> None:
-    pass
+import pickle
+import unittest
+
+import pymunk as p
+from pymunk.constraints import *
+
+
+class UnitTestConstraint(unittest.TestCase):
+    def testA(self) -> None:
+        a, b = p.Body(10, 10), p.Body(10, 10)
+        j = PivotJoint(a, b, (0, 0))
+        self.assertEqual(j.a, a)
+
+    def testB(self) -> None:
+        a, b = p.Body(10, 10), p.Body(10, 10)
+        j = PivotJoint(a, b, (0, 0))
+        self.assertEqual(j.b, b)
+
+    def testMaxForce(self) -> None:
+        a, b = p.Body(10, 10), p.Body(10, 10)
+        j = PivotJoint(a, b, (0, 0))
+        self.assertEqual(j.max_force, float("inf"))
+        j.max_force = 10
+        self.assertEqual(j.max_force, 10)
+
+    def testErrorBias(self) -> None:
+        a, b = p.Body(10, 10), p.Body(10, 10)
+        j = PivotJoint(a, b, (0, 0))
+        self.assertAlmostEqual(j.error_bias, pow(1.0 - 0.1, 60.0))
+        j.error_bias = 0.3
+        self.assertEqual(j.error_bias, 0.3)
+
+    def testMaxBias(self) -> None:
+        a, b = p.Body(10, 10), p.Body(10, 10)
+        j = PivotJoint(a, b, (0, 0))
+        self.assertEqual(j.max_bias, float("inf"))
+        j.max_bias = 10
+        self.assertEqual(j.max_bias, 10)
+
+    def testCollideBodies(self) -> None:
+        a, b = p.Body(10, 10), p.Body(10, 10)
+        j = PivotJoint(a, b, (0, 0))
+        self.assertEqual(j.collide_bodies, True)
+        j.collide_bodies = False
+        self.assertEqual(j.collide_bodies, False)
+
+    def testImpulse(self) -> None:
+        a, b = p.Body(10, 10), p.Body(10, 10)
+        b.position = 0, 10
+        j = PivotJoint(a, b, (0, 0))
+
+        s = p.Space()
+        s.gravity = 0, 10
+        s.add(b, j)
+        self.assertEqual(j.impulse, 0)
+        s.step(1)
+        self.assertAlmostEqual(j.impulse, 50)
+
+    def testActivate(self) -> None:
+        a, b = p.Body(4, 5), p.Body(10, 10)
+        j = PivotJoint(a, b, (0, 0))
+        s = p.Space()
+        s.sleep_time_threshold = 0.01
+        s.add(a, b)
+        a.sleep()
+        b.sleep()
+
+        j.activate_bodies()
+        self.assertFalse(a.is_sleeping)
+        self.assertFalse(b.is_sleeping)
+
+    def testPreSolve(self) -> None:
+        b = p.Body(1, 2)
+        s = p.Space()
+        j = PivotJoint(s.static_body, b, (0, 0))
+
+        s.add(b, j)
+        self.assertIsNone(j.pre_solve)
+        s.step(1)
+
+        actual_constraint = None
+        actual_space = None
+
+        def pre_solve(constraint: Constraint, space: p.Space) -> None:
+            nonlocal actual_constraint
+            nonlocal actual_space
+            actual_constraint = constraint
+            actual_space = space
+
+        j.pre_solve = pre_solve
+        s.step(1)
+
+        self.assertEqual(actual_constraint, j)
+        self.assertEqual(actual_space, s)
+
+    def testPostSolve(self) -> None:
+        b = p.Body(1, 2)
+        s = p.Space()
+        j = PivotJoint(s.static_body, b, (0, 0))
+
+        s.add(b, j)
+        self.assertIsNone(j.pre_solve)
+        s.step(1)
+
+        actual_constraint = None
+        actual_space = None
+
+        def post_solve(constraint: Constraint, space: p.Space) -> None:
+            nonlocal actual_constraint
+            nonlocal actual_space
+            actual_constraint = constraint
+            actual_space = space
+
+        j.post_solve = post_solve
+        s.step(1)
+
+        self.assertEqual(actual_constraint, j)
+        self.assertEqual(actual_space, s)
+
+    def testPrePostSolveOrder(self) -> None:
+        s = p.Space()
+        b = p.Body(1, 2)
+        j = PivotJoint(s.static_body, b, (0, 0))
+
+        s.add(b, j)
+
+        actual_order = []
+
+        def pre_solve(c: Constraint, s: p.Space) -> None:
+            nonlocal actual_order
+            actual_order.append(1)
+
+        def post_solve(c: Constraint, s: p.Space) -> None:
+            nonlocal actual_order
+            actual_order.append(2)
+
+        j.pre_solve = pre_solve
+        j.post_solve = post_solve
+        s.step(1)
+
+        self.assertEqual(actual_order, [1, 2])
+
+    def testPickle(self) -> None:
+        a, b = p.Body(4, 5), p.Body(10, 10)
+        a.custom = "a"
+        b.custom = "b"
+        j = PivotJoint(a, b, (1, 2))
+        j.custom = "test"
+        j.max_force = 2
+        j.error_bias = 3
+        j.max_bias = 4
+        j.collide_bodies = False
+
+        j.pre_solve = pre_solve
+
+        j.post_solve = post_solve
+
+        s = pickle.dumps(j)
+        j2 = pickle.loads(s)
+        self.assertEqual(j.custom, j2.custom)
+        self.assertEqual(j.max_force, j2.max_force)
+        self.assertEqual(j.error_bias, j2.error_bias)
+        self.assertEqual(j.max_bias, j2.max_bias)
+        self.assertEqual(j.collide_bodies, j2.collide_bodies)
+        self.assertEqual(j.a.custom, j2.a.custom)
+        self.assertEqual(j.b.custom, j2.b.custom)
+
+        self.assertEqual(j.pre_solve, j2.pre_solve)
+        self.assertEqual(j.post_solve, j2.post_solve)
+
+        j2 = j.copy()
+
+
+class UnitTestPinJoint(unittest.TestCase):
+    def testAnchor(self) -> None:
+        a, b = p.Body(10, 10), p.Body(20, 20)
+        j = PinJoint(a, b, (1, 2), (3, 4))
+        self.assertEqual(j.anchor_a, (1, 2))
+        self.assertEqual(j.anchor_b, (3, 4))
+        j.anchor_a = (5, 6)
+        j.anchor_b = (7, 8)
+        self.assertEqual(j.anchor_a, (5, 6))
+        self.assertEqual(j.anchor_b, (7, 8))
+
+    def testDistane(self) -> None:
+        a, b = p.Body(10, 10), p.Body(20, 20)
+        j = PinJoint(a, b, (0, 0), (10, 0))
+        self.assertEqual(j.distance, 10)
+        j.distance = 20
+        self.assertEqual(j.distance, 20)
+
+    def testPickle(self) -> None:
+        a, b = p.Body(10, 10), p.Body(20, 20)
+        j = PinJoint(a, b, (1, 2), (3, 4))
+
+        s = pickle.dumps(j)
+        j2 = pickle.loads(s)
+
+        self.assertEqual(j.anchor_a, j2.anchor_a)
+        self.assertEqual(j.anchor_b, j2.anchor_b)
+        self.assertEqual(j.distance, j2.distance)
+        self.assertEqual(j.a.mass, j2.a.mass)
+        self.assertEqual(j.b.mass, j2.b.mass)
+
+
+class UnitTestSlideJoint(unittest.TestCase):
+    def testAnchor(self) -> None:
+        a, b = p.Body(10, 10), p.Body(20, 20)
+        j = SlideJoint(a, b, (1, 2), (3, 4), 0, 10)
+        self.assertEqual(j.anchor_a, (1, 2))
+        self.assertEqual(j.anchor_b, (3, 4))
+        j.anchor_a = (5, 6)
+        j.anchor_b = (7, 8)
+        self.assertEqual(j.anchor_a, (5, 6))
+        self.assertEqual(j.anchor_b, (7, 8))
+
+    def testMin(self) -> None:
+        a, b = p.Body(10, 10), p.Body(20, 20)
+        j = SlideJoint(a, b, (0, 0), (0, 0), 1, 0)
+        self.assertEqual(j.min, 1)
+        j.min = 2
+        self.assertEqual(j.min, 2)
+
+    def testMax(self) -> None:
+        a, b = p.Body(10, 10), p.Body(20, 20)
+        j = SlideJoint(a, b, (0, 0), (0, 0), 0, 1)
+        self.assertEqual(j.max, 1)
+        j.max = 2
+        self.assertEqual(j.max, 2)
+
+    def testPickle(self) -> None:
+        a, b = p.Body(10, 10), p.Body(20, 20)
+        j = SlideJoint(a, b, (1, 2), (3, 4), 5, 6)
+
+        s = pickle.dumps(j)
+        j2 = pickle.loads(s)
+
+        self.assertEqual(j.anchor_a, j2.anchor_a)
+        self.assertEqual(j.anchor_b, j2.anchor_b)
+        self.assertEqual(j.min, j2.min)
+        self.assertEqual(j.max, j2.max)
+        self.assertEqual(j.a.mass, j2.a.mass)
+        self.assertEqual(j.b.mass, j2.b.mass)
+
+
+class UnitTestPivotJoint(unittest.TestCase):
+    def testAnchorByPivot(self) -> None:
+        a, b = p.Body(10, 10), p.Body(20, 20)
+        a.position = (5, 7)
+        j = PivotJoint(a, b, (1, 2))
+        self.assertEqual(j.anchor_a, (-4, -5))
+        self.assertEqual(j.anchor_b, (1, 2))
+
+    def testAnchorByAnchor(self) -> None:
+        a, b = p.Body(10, 10), p.Body(20, 20)
+        j = PivotJoint(a, b, (1, 2), (3, 4))
+        self.assertEqual(j.anchor_a, (1, 2))
+        self.assertEqual(j.anchor_b, (3, 4))
+        j.anchor_a = (5, 6)
+        j.anchor_b = (7, 8)
+        self.assertEqual(j.anchor_a, (5, 6))
+        self.assertEqual(j.anchor_b, (7, 8))
+
+    def testPickle(self) -> None:
+        a, b = p.Body(10, 10), p.Body(20, 20)
+        j = PivotJoint(a, b, (1, 2), (3, 4))
+
+        s = pickle.dumps(j)
+        j2 = pickle.loads(s)
+
+        self.assertEqual(j.anchor_a, j2.anchor_a)
+        self.assertEqual(j.anchor_b, j2.anchor_b)
+        self.assertEqual(j.a.mass, j2.a.mass)
+        self.assertEqual(j.b.mass, j2.b.mass)
+
+
+class UnitTestGrooveJoint(unittest.TestCase):
+    def testAnchor(self) -> None:
+        a, b = p.Body(10, 10), p.Body(20, 20)
+        j = GrooveJoint(a, b, (0, 0), (0, 0), (1, 2))
+        self.assertEqual(j.anchor_b, (1, 2))
+        j.anchor_b = (3, 4)
+        self.assertEqual(j.anchor_b, (3, 4))
+
+    def testGroove(self) -> None:
+        a, b = p.Body(10, 10), p.Body(20, 20)
+        j = GrooveJoint(a, b, (1, 2), (3, 4), (0, 0))
+        self.assertEqual(j.groove_a, (1, 2))
+        self.assertEqual(j.groove_b, (3, 4))
+        j.groove_a = (5, 6)
+        j.groove_b = (7, 8)
+        self.assertEqual(j.groove_a, (5, 6))
+        self.assertEqual(j.groove_b, (7, 8))
+
+    def testPickle(self) -> None:
+        a, b = p.Body(10, 10), p.Body(20, 20)
+        j = GrooveJoint(a, b, (1, 2), (3, 4), (5, 6))
+
+        s = pickle.dumps(j)
+        j2 = pickle.loads(s)
+
+        self.assertEqual(j.groove_a, j2.groove_a)
+        self.assertEqual(j.groove_b, j2.groove_b)
+        self.assertEqual(j.anchor_b, j2.anchor_b)
+        self.assertEqual(j.a.mass, j2.a.mass)
+        self.assertEqual(j.b.mass, j2.b.mass)
+
+
+class UnitTestDampedSpring(unittest.TestCase):
+    def testAnchor(self) -> None:
+        a, b = p.Body(10, 10), p.Body(20, 20)
+        j = DampedSpring(a, b, (1, 2), (3, 4), 0, 0, 0)
+        self.assertEqual(j.anchor_a, (1, 2))
+        self.assertEqual(j.anchor_b, (3, 4))
+        j.anchor_a = (5, 6)
+        j.anchor_b = (7, 8)
+        self.assertEqual(j.anchor_a, (5, 6))
+        self.assertEqual(j.anchor_b, (7, 8))
+
+    def testRestLength(self) -> None:
+        a, b = p.Body(10, 10), p.Body(20, 20)
+        j = DampedSpring(a, b, (0, 0), (0, 0), 1, 0, 0)
+        self.assertEqual(j.rest_length, 1)
+        j.rest_length = 2
+        self.assertEqual(j.rest_length, 2)
+
+    def testStiffness(self) -> None:
+        a, b = p.Body(10, 10), p.Body(20, 20)
+        j = DampedSpring(a, b, (0, 0), (0, 0), 0, 1, 0)
+        self.assertEqual(j.stiffness, 1)
+        j.stiffness = 2
+        self.assertEqual(j.stiffness, 2)
+
+    def testDamping(self) -> None:
+        a, b = p.Body(10, 10), p.Body(20, 20)
+        j = DampedSpring(a, b, (0, 0), (0, 0), 0, 0, 1)
+        self.assertEqual(j.damping, 1)
+        j.damping = 2
+        self.assertEqual(j.damping, 2)
+
+    def testPickle(self) -> None:
+        a, b = p.Body(10, 10), p.Body(20, 20)
+        j = DampedSpring(a, b, (1, 2), (3, 4), 5, 6, 7)
+
+        s = pickle.dumps(j)
+        j2 = pickle.loads(s)
+
+        self.assertEqual(j.anchor_a, j2.anchor_a)
+        self.assertEqual(j.anchor_b, j2.anchor_b)
+        self.assertEqual(j.rest_length, j2.rest_length)
+        self.assertEqual(j.stiffness, j2.stiffness)
+        self.assertEqual(j.damping, j2.damping)
+        self.assertEqual(j.a.mass, j2.a.mass)
+        self.assertEqual(j.b.mass, j2.b.mass)
+
+
+class UnitTestDampedRotarySpring(unittest.TestCase):
+    def testRestAngle(self) -> None:
+        a, b = p.Body(10, 10), p.Body(20, 20)
+        j = DampedRotarySpring(a, b, 1, 0, 0)
+        self.assertEqual(j.rest_angle, 1)
+        j.rest_angle = 2
+        self.assertEqual(j.rest_angle, 2)
+
+    def testStiffness(self) -> None:
+        a, b = p.Body(10, 10), p.Body(20, 20)
+        j = DampedRotarySpring(a, b, 0, 1, 0)
+        self.assertEqual(j.stiffness, 1)
+        j.stiffness = 2
+        self.assertEqual(j.stiffness, 2)
+
+    def testDamping(self) -> None:
+        a, b = p.Body(10, 10), p.Body(20, 20)
+        j = DampedRotarySpring(a, b, 0, 0, 1)
+        self.assertEqual(j.damping, 1)
+        j.damping = 2
+        self.assertEqual(j.damping, 2)
+
+    def testPickle(self) -> None:
+        a, b = p.Body(10, 10), p.Body(20, 20)
+        j = DampedRotarySpring(a, b, 1, 2, 3)
+
+        s = pickle.dumps(j)
+        j2 = pickle.loads(s)
+
+        self.assertEqual(j.rest_angle, j2.rest_angle)
+        self.assertEqual(j.stiffness, j2.stiffness)
+        self.assertEqual(j.damping, j2.damping)
+        self.assertEqual(j.a.mass, j2.a.mass)
+        self.assertEqual(j.b.mass, j2.b.mass)
+
+
+class UnitTestRotaryLimitJoint(unittest.TestCase):
+    def testMin(self) -> None:
+        a, b = p.Body(10, 10), p.Body(20, 20)
+        j = RotaryLimitJoint(a, b, 1, 0)
+        self.assertEqual(j.min, 1)
+        j.min = 2
+        self.assertEqual(j.min, 2)
+
+    def testMax(self) -> None:
+        a, b = p.Body(10, 10), p.Body(20, 20)
+        j = RotaryLimitJoint(a, b, 0, 1)
+        self.assertEqual(j.max, 1)
+        j.max = 2
+        self.assertEqual(j.max, 2)
+
+    def testPickle(self) -> None:
+        a, b = p.Body(10, 10), p.Body(20, 20)
+        j = RotaryLimitJoint(a, b, 1, 2)
+
+        s = pickle.dumps(j)
+        j2 = pickle.loads(s)
+
+        self.assertEqual(j.min, j2.min)
+        self.assertEqual(j.max, j2.max)
+        self.assertEqual(j.a.mass, j2.a.mass)
+        self.assertEqual(j.b.mass, j2.b.mass)
+
+
+class UnitTestRatchetJoint(unittest.TestCase):
+    def testAngle(self) -> None:
+        a, b = p.Body(10, 10), p.Body(20, 20)
+        j = RatchetJoint(a, b, 0, 0)
+        self.assertEqual(j.angle, 0)
+        j.angle = 1
+        self.assertEqual(j.angle, 1)
+
+    def testPhase(self) -> None:
+        a, b = p.Body(10, 10), p.Body(20, 20)
+        j = RatchetJoint(a, b, 1, 0)
+        self.assertEqual(j.phase, 1)
+        j.phase = 2
+        self.assertEqual(j.phase, 2)
+
+    def testRatchet(self) -> None:
+        a, b = p.Body(10, 10), p.Body(20, 20)
+        j = RatchetJoint(a, b, 0, 1)
+        self.assertEqual(j.ratchet, 1)
+        j.ratchet = 2
+        self.assertEqual(j.ratchet, 2)
+
+    def testPickle(self) -> None:
+        a, b = p.Body(10, 10), p.Body(20, 20)
+        j = RatchetJoint(a, b, 1, 2)
+
+        s = pickle.dumps(j)
+        j2 = pickle.loads(s)
+
+        self.assertEqual(j.phase, j2.phase)
+        self.assertEqual(j.ratchet, j2.ratchet)
+        self.assertEqual(j.a.mass, j2.a.mass)
+        self.assertEqual(j.b.mass, j2.b.mass)
+
+
+class UnitTestGearJoint(unittest.TestCase):
+    def testPhase(self) -> None:
+        a, b = p.Body(10, 10), p.Body(20, 20)
+        j = GearJoint(a, b, 1, 0)
+        self.assertEqual(j.phase, 1)
+        j.phase = 2
+        self.assertEqual(j.phase, 2)
+
+    def testRatio(self) -> None:
+        a, b = p.Body(10, 10), p.Body(20, 20)
+        j = GearJoint(a, b, 0, 1)
+        self.assertEqual(j.ratio, 1)
+        j.ratio = 2
+        self.assertEqual(j.ratio, 2)
+
+    def testPickle(self) -> None:
+        a, b = p.Body(10, 10), p.Body(20, 20)
+        j = GearJoint(a, b, 1, 2)
+
+        s = pickle.dumps(j)
+        j2 = pickle.loads(s)
+
+        self.assertEqual(j.phase, j2.phase)
+        self.assertEqual(j.ratio, j2.ratio)
+        self.assertEqual(j.a.mass, j2.a.mass)
+        self.assertEqual(j.b.mass, j2.b.mass)
+
+
+class UnitTestSimleMotor(unittest.TestCase):
+    def testSimpleMotor(self) -> None:
+        a, b = p.Body(10, 10), p.Body(20, 20)
+        j = SimpleMotor(a, b, 0.3)
+        self.assertEqual(j.rate, 0.3)
+        j.rate = 0.4
+        self.assertEqual(j.rate, 0.4)
+
+    def testPickle(self) -> None:
+        a, b = p.Body(10, 10), p.Body(20, 20)
+        j = SimpleMotor(a, b, 1)
+
+        s = pickle.dumps(j)
+        j2 = pickle.loads(s)
+
+        self.assertEqual(j.rate, j2.rate)
+        self.assertEqual(j.a.mass, j2.a.mass)
+        self.assertEqual(j.b.mass, j2.b.mass)
+
+
+# Needed to be able to pickle
+def pre_solve(c: Constraint, s: p.Space) -> None:
+    pass
+
+
+def post_solve(c: Constraint, s: p.Space) -> None:
+    pass
```

## Comparing `pymunk-6.5.0/pymunk/tests/test_shape.py` & `pymunk/tests/test_shape.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,397 +1,397 @@
-import pickle
-import unittest
-from typing import Any
-
-import pymunk as p
-
-
-class UnitTestShape(unittest.TestCase):
-    def testId(self) -> None:
-        c = p.Circle(None, 4)
-        self.assertGreater(c._id, 0)
-
-    def testPointQuery(self) -> None:
-        b = p.Body(10, 10)
-        c = p.Circle(b, 5)
-        c.cache_bb()
-
-        info = c.point_query((0, 0))
-
-        self.assertEqual(info.shape, c)
-        self.assertEqual(info.point, (0, 0))
-        self.assertEqual(info.distance, -5)
-        self.assertEqual(info.gradient, (0, 1))
-
-        info = c.point_query((11, 0))
-
-        self.assertEqual(info.shape, c)
-        self.assertEqual(info.point, (5, 0))
-        self.assertEqual(info.distance, 6)
-        self.assertEqual(info.gradient, (1, 0))
-
-    def testSegmentQuery(self) -> None:
-        s = p.Space()
-        b = p.Body(10, 10)
-        c = p.Circle(b, 5)
-        c.cache_bb()
-
-        info = c.segment_query((10, -50), (10, 50))
-        self.assertEqual(info.shape, None)
-        self.assertEqual(info.point, (10, 50))
-        self.assertEqual(info.normal, (0, 0))
-        self.assertEqual(info.alpha, 1.0)
-
-        info = c.segment_query((10, -50), (10, 50), 6)
-        self.assertEqual(info.shape, c)
-
-        info = c.segment_query((0, -50), (0, 50))
-        self.assertEqual(info.shape, c)
-        self.assertAlmostEqual(info.point.x, 0)
-        self.assertAlmostEqual(info.point.y, -5)
-        self.assertAlmostEqual(info.normal.x, 0)
-        self.assertAlmostEqual(info.normal.y, -1)
-        self.assertEqual(info.alpha, 0.45)
-
-    def testMass(self) -> None:
-        c = p.Circle(None, 1)
-        self.assertEqual(c.mass, 0)
-        c.mass = 2
-        self.assertEqual(c.mass, 2)
-
-    def testDensity(self) -> None:
-        c = p.Circle(None, 1)
-        self.assertEqual(c.density, 0)
-        c.density = 2
-        self.assertEqual(c.density, 2)
-
-    def testMoment(self) -> None:
-        c = p.Circle(None, 5)
-        self.assertEqual(c.moment, 0)
-        c.density = 2
-        self.assertAlmostEqual(c.moment, 1963.4954084936207)
-        c.density = 0
-        c.mass = 2
-        self.assertAlmostEqual(c.moment, 25)
-
-    def testArea(self) -> None:
-        c = p.Circle(None, 5)
-        self.assertEqual(c.area, 78.53981633974483)
-
-    def testCenterOfGravity(self) -> None:
-        c = p.Circle(None, 5)
-        self.assertEqual(c.center_of_gravity, (0, 0))
-        c = p.Circle(None, 5, (10, 5))
-        self.assertEqual(c.center_of_gravity.x, 10)
-        self.assertEqual(c.center_of_gravity.y, 5)
-
-    def testNoBody(self) -> None:
-        c = p.Circle(None, 1)
-        self.assertEqual(c.body, None)
-
-    def testRemoveBody(self) -> None:
-        b = p.Body(1, 1)
-        c = p.Circle(b, 1)
-        c.body = None
-
-        self.assertEqual(c.body, None)
-        self.assertEqual(len(b.shapes), 0)
-
-    def testSwitchBody(self) -> None:
-        b1 = p.Body(1, 1)
-        b2 = p.Body(1, 1)
-        c = p.Circle(b1, 1)
-        self.assertEqual(c.body, b1)
-        self.assertTrue(c in b1.shapes)
-        self.assertTrue(c not in b2.shapes)
-        c.body = b2
-        self.assertEqual(c.body, b2)
-        self.assertTrue(c not in b1.shapes)
-        self.assertTrue(c in b2.shapes)
-
-    def testSensor(self) -> None:
-        b1 = p.Body(1, 1)
-        c = p.Circle(b1, 1)
-        self.assertFalse(c.sensor)
-        c.sensor = True
-        self.assertTrue(c.sensor)
-
-    def testElasticity(self) -> None:
-        b1 = p.Body(1, 1)
-        c = p.Circle(b1, 1)
-        self.assertEqual(c.elasticity, 0)
-        c.elasticity = 1
-        self.assertEqual(c.elasticity, 1)
-
-    def testFriction(self) -> None:
-        b1 = p.Body(1, 1)
-        c = p.Circle(b1, 1)
-        self.assertEqual(c.friction, 0)
-        c.friction = 1
-        self.assertEqual(c.friction, 1)
-
-    def testSurfaceVelocity(self) -> None:
-        b1 = p.Body(1, 1)
-        c = p.Circle(b1, 1)
-        self.assertEqual(c.surface_velocity, (0, 0))
-        c.surface_velocity = (1, 2)
-        self.assertEqual(c.surface_velocity, (1, 2))
-
-    def testCollisionType(self) -> None:
-        b1 = p.Body(1, 1)
-        c = p.Circle(b1, 1)
-        self.assertEqual(c.collision_type, 0)
-        c.collision_type = 1
-        self.assertEqual(c.collision_type, 1)
-
-    def testFilter(self) -> None:
-        b1 = p.Body(1, 1)
-        c = p.Circle(b1, 1)
-        self.assertEqual(c.filter, p.ShapeFilter(0, 0xFFFFFFFF, 0xFFFFFFFF))
-        c.filter = p.ShapeFilter(1, 0xFFFFFFF2, 0xFFFFFFF3)
-        self.assertEqual(c.filter, p.ShapeFilter(1, 0xFFFFFFF2, 0xFFFFFFF3))
-
-    def testSpace(self) -> None:
-        b1 = p.Body(1, 1)
-        c = p.Circle(b1, 1)
-        self.assertEqual(c.space, None)
-        s = p.Space()
-        s.add(b1, c)
-        self.assertEqual(c.space, s)
-
-    def testShapesCollide(self) -> None:
-        b1 = p.Body(1, 1)
-        s1 = p.Circle(b1, 10)
-
-        b2 = p.Body(1, 1)
-        b2.position = 30, 30
-        s2 = p.Circle(b2, 10)
-
-        c = s1.shapes_collide(s2)
-        self.assertEqual(c.normal, (1, 0))
-        self.assertEqual(len(c.points), 1)
-        point = c.points[0]
-        self.assertEqual(point.point_a, (10, 0))
-        self.assertEqual(point.point_b, (-10, 0))
-        self.assertEqual(point.distance, -20)
-
-    def testPickle(self) -> None:
-        b = p.Body(1, 2)
-        c = p.Circle(b, 3, (4, 5))
-        c.sensor = True
-        c.collision_type = 6
-        c.filter = p.ShapeFilter()
-        c.elasticity = 7
-        c.friction = 8
-        c.surface_velocity = (9, 10)
-
-        s = pickle.dumps(c)
-        c2 = pickle.loads(s)
-
-        self.assertEqual(c.sensor, c2.sensor)
-        self.assertEqual(c.collision_type, c2.collision_type)
-        self.assertEqual(c.filter, c2.filter)
-        self.assertEqual(c.elasticity, c2.elasticity)
-        self.assertEqual(c.friction, c2.friction)
-        self.assertEqual(c.surface_velocity, c2.surface_velocity)
-        self.assertEqual(c.density, c2.density)
-        self.assertEqual(c.mass, c2.mass)
-        self.assertEqual(c.body.mass, c2.body.mass)
-
-        c = p.Circle(None, 1)
-        c.density = 3
-
-        s = pickle.dumps(c)
-        c2 = pickle.loads(s)
-
-        self.assertEqual(c.mass, c2.mass)
-        self.assertEqual(c.density, c2.density)
-
-        c2 = c.copy()
-
-
-class UnitTestCircle(unittest.TestCase):
-    def testCircleBB(self) -> None:
-        b = p.Body(10, 10)
-        c = p.Circle(b, 5)
-
-        c.cache_bb()
-
-        self.assertEqual(c.bb, p.BB(-5.0, -5.0, 5.0, 5.0))
-
-    def testCircleNoBody(self) -> None:
-        c = p.Circle(None, 5)
-
-        bb = c.update(p.Transform(1, 2, 3, 4, 5, 6))
-        self.assertEqual(c.bb, bb)
-        self.assertEqual(c.bb, p.BB(0, 1, 10, 11))
-
-    def testOffset(self) -> None:
-        c = p.Circle(None, 5, (1, 2))
-
-        self.assertEqual(c.offset, (1, 2))
-
-    def testOffsetUnsafe(self) -> None:
-        c = p.Circle(None, 5, (1, 2))
-
-        c.unsafe_set_offset((3, 4))
-
-        self.assertEqual(c.offset, (3, 4))
-
-    def testRadius(self) -> None:
-        c = p.Circle(None, 5)
-
-        self.assertEqual(c.radius, 5)
-
-    def testRadiusUnsafe(self) -> None:
-        c = p.Circle(None, 5)
-
-        c.unsafe_set_radius(3)
-
-        self.assertEqual(c.radius, 3)
-
-    def testPickle(self) -> None:
-        c = p.Circle(None, 3, (4, 5))
-
-        s = pickle.dumps(c)
-        c2 = pickle.loads(s)
-
-        self.assertEqual(c.radius, c2.radius)
-        self.assertEqual(c.offset, c2.offset)
-
-
-class UnitTestSegment(unittest.TestCase):
-    def testBB(self) -> None:
-        s = p.Space()
-        b = p.Body(10, 10)
-        c = p.Segment(b, (2, 2), (2, 3), 2)
-
-        c.cache_bb()
-
-        self.assertEqual(c.bb, p.BB(0, 0, 4.0, 5.0))
-
-    def testProperties(self) -> None:
-        c = p.Segment(None, (2, 2), (2, 3), 4)
-
-        self.assertEqual(c.a, (2, 2))
-        self.assertEqual(c.b, (2, 3))
-        self.assertEqual(c.normal, (1, 0))
-        self.assertEqual(c.radius, 4)
-
-    def testPropertiesUnsafe(self) -> None:
-        c = p.Segment(None, (2, 2), (2, 3), 4)
-
-        c.unsafe_set_endpoints((3, 4), (5, 6))
-        self.assertEqual(c.a, (3, 4))
-        self.assertEqual(c.b, (5, 6))
-
-        c.unsafe_set_radius(5)
-        self.assertEqual(c.radius, 5)
-
-    def testSetNeighbors(self) -> None:
-        c = p.Segment(None, (2, 2), (2, 3), 1)
-        c.set_neighbors((2, 2), (2, 3))
-
-    def testSegmentSegmentCollision(self) -> None:
-        s = p.Space()
-        b1 = p.Body(10, 10)
-        c1 = p.Segment(b1, (-1, -1), (1, 1), 1)
-        b2 = p.Body(10, 10)
-        c2 = p.Segment(b2, (1, -1), (-1, 1), 1)
-
-        s.add(b1, b2, c1, c2)
-
-        self.num_of_begins = 0
-
-        def begin(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
-            self.num_of_begins += 1
-            return True
-
-        s.add_default_collision_handler().begin = begin
-        s.step(0.1)
-
-        self.assertEqual(1, self.num_of_begins)
-
-    def testPickle(self) -> None:
-        c = p.Segment(None, (1, 2), (3, 4), 5)
-
-        s = pickle.dumps(c)
-        c2 = pickle.loads(s)
-
-        self.assertEqual(c.a, c2.a)
-        self.assertEqual(c.b, c2.b)
-        self.assertEqual(c.radius, c2.radius)
-
-
-class UnitTestPoly(unittest.TestCase):
-    def testInit(self) -> None:
-        c = p.Poly(None, [(0, 0), (10, 10), (20, 0), (-10, 10)], None, 0)
-
-        b = p.Body(1, 2)
-        c = p.Poly(b, [(0, 0), (10, 10), (20, 0), (-10, 10)], p.Transform.identity(), 6)
-
-    def testVertices(self) -> None:
-        vs = [(-10, 10), (0, 0), (20, 0), (10, 10)]
-        c = p.Poly(None, vs, None, 0)
-
-        self.assertEqual(c.get_vertices(), vs)
-
-        c = p.Poly(None, vs, p.Transform(1, 2, 3, 4, 5, 6), 0)
-
-        vs2 = [(5.0, 6.0), (25.0, 26.0), (45.0, 66.0), (25.0, 46.0)]
-        self.assertEqual(c.get_vertices(), vs2)
-
-    def testVerticesUnsafe(self) -> None:
-        vs = [(-10, 10), (0, 0), (20, 0), (10, 10)]
-        c = p.Poly(None, vs, None, 0)
-
-        vs2 = [(-3, 3), (0, 0), (3, 0)]
-        c.unsafe_set_vertices(vs2)
-        self.assertEqual(c.get_vertices(), vs2)
-
-        vs3 = [(-4, 4), (0, 0), (4, 0)]
-        c.unsafe_set_vertices(vs3, p.Transform.identity())
-        self.assertEqual(c.get_vertices(), vs3)
-
-    def testBB(self) -> None:
-        c = p.Poly(None, [(2, 2), (4, 3), (3, 5)])
-        bb = c.update(p.Transform.identity())
-        self.assertEqual(bb, c.bb)
-        self.assertEqual(c.bb, p.BB(2, 2, 4, 5))
-
-        b = p.Body(1, 2)
-        c = p.Poly(b, [(2, 2), (4, 3), (3, 5)])
-        c.cache_bb()
-        self.assertEqual(c.bb, p.BB(2, 2, 4, 5))
-
-        s = p.Space()
-        b = p.Body(1, 2)
-        c = p.Poly(b, [(2, 2), (4, 3), (3, 5)])
-        s.add(b, c)
-        self.assertEqual(c.bb, p.BB(2, 2, 4, 5))
-
-    def testRadius(self) -> None:
-        c = p.Poly(None, [(2, 2), (4, 3), (3, 5)], radius=10)
-        self.assertEqual(c.radius, 10)
-
-    def testRadiusUnsafe(self) -> None:
-        c = p.Poly(None, [(2, 2), (4, 3), (3, 5)], radius=10)
-
-        c.unsafe_set_radius(20)
-
-        self.assertEqual(c.radius, 20)
-
-    def testCreateBox(self) -> None:
-        c = p.Poly.create_box(None, (4, 2), 3)
-        self.assertEqual(c.get_vertices(), [(2, -1), (2, 1), (-2, 1), (-2, -1)])
-
-        c = p.Poly.create_box_bb(None, p.BB(1, 2, 3, 4), 3)
-        self.assertEqual(c.get_vertices(), [(3, 2), (3, 4), (1, 4), (1, 2)])
-
-    def testPickle(self) -> None:
-        c = p.Poly(None, [(1, 2), (3, 4), (5, 6)], radius=5)
-
-        s = pickle.dumps(c)
-        c2 = pickle.loads(s)
-
-        self.assertEqual(c.get_vertices(), c2.get_vertices())
-        self.assertEqual(c.radius, c2.radius)
+import pickle
+import unittest
+from typing import Any
+
+import pymunk as p
+
+
+class UnitTestShape(unittest.TestCase):
+    def testId(self) -> None:
+        c = p.Circle(None, 4)
+        self.assertGreater(c._id, 0)
+
+    def testPointQuery(self) -> None:
+        b = p.Body(10, 10)
+        c = p.Circle(b, 5)
+        c.cache_bb()
+
+        info = c.point_query((0, 0))
+
+        self.assertEqual(info.shape, c)
+        self.assertEqual(info.point, (0, 0))
+        self.assertEqual(info.distance, -5)
+        self.assertEqual(info.gradient, (0, 1))
+
+        info = c.point_query((11, 0))
+
+        self.assertEqual(info.shape, c)
+        self.assertEqual(info.point, (5, 0))
+        self.assertEqual(info.distance, 6)
+        self.assertEqual(info.gradient, (1, 0))
+
+    def testSegmentQuery(self) -> None:
+        s = p.Space()
+        b = p.Body(10, 10)
+        c = p.Circle(b, 5)
+        c.cache_bb()
+
+        info = c.segment_query((10, -50), (10, 50))
+        self.assertEqual(info.shape, None)
+        self.assertEqual(info.point, (10, 50))
+        self.assertEqual(info.normal, (0, 0))
+        self.assertEqual(info.alpha, 1.0)
+
+        info = c.segment_query((10, -50), (10, 50), 6)
+        self.assertEqual(info.shape, c)
+
+        info = c.segment_query((0, -50), (0, 50))
+        self.assertEqual(info.shape, c)
+        self.assertAlmostEqual(info.point.x, 0)
+        self.assertAlmostEqual(info.point.y, -5)
+        self.assertAlmostEqual(info.normal.x, 0)
+        self.assertAlmostEqual(info.normal.y, -1)
+        self.assertEqual(info.alpha, 0.45)
+
+    def testMass(self) -> None:
+        c = p.Circle(None, 1)
+        self.assertEqual(c.mass, 0)
+        c.mass = 2
+        self.assertEqual(c.mass, 2)
+
+    def testDensity(self) -> None:
+        c = p.Circle(None, 1)
+        self.assertEqual(c.density, 0)
+        c.density = 2
+        self.assertEqual(c.density, 2)
+
+    def testMoment(self) -> None:
+        c = p.Circle(None, 5)
+        self.assertEqual(c.moment, 0)
+        c.density = 2
+        self.assertAlmostEqual(c.moment, 1963.4954084936207)
+        c.density = 0
+        c.mass = 2
+        self.assertAlmostEqual(c.moment, 25)
+
+    def testArea(self) -> None:
+        c = p.Circle(None, 5)
+        self.assertEqual(c.area, 78.53981633974483)
+
+    def testCenterOfGravity(self) -> None:
+        c = p.Circle(None, 5)
+        self.assertEqual(c.center_of_gravity, (0, 0))
+        c = p.Circle(None, 5, (10, 5))
+        self.assertEqual(c.center_of_gravity.x, 10)
+        self.assertEqual(c.center_of_gravity.y, 5)
+
+    def testNoBody(self) -> None:
+        c = p.Circle(None, 1)
+        self.assertEqual(c.body, None)
+
+    def testRemoveBody(self) -> None:
+        b = p.Body(1, 1)
+        c = p.Circle(b, 1)
+        c.body = None
+
+        self.assertEqual(c.body, None)
+        self.assertEqual(len(b.shapes), 0)
+
+    def testSwitchBody(self) -> None:
+        b1 = p.Body(1, 1)
+        b2 = p.Body(1, 1)
+        c = p.Circle(b1, 1)
+        self.assertEqual(c.body, b1)
+        self.assertTrue(c in b1.shapes)
+        self.assertTrue(c not in b2.shapes)
+        c.body = b2
+        self.assertEqual(c.body, b2)
+        self.assertTrue(c not in b1.shapes)
+        self.assertTrue(c in b2.shapes)
+
+    def testSensor(self) -> None:
+        b1 = p.Body(1, 1)
+        c = p.Circle(b1, 1)
+        self.assertFalse(c.sensor)
+        c.sensor = True
+        self.assertTrue(c.sensor)
+
+    def testElasticity(self) -> None:
+        b1 = p.Body(1, 1)
+        c = p.Circle(b1, 1)
+        self.assertEqual(c.elasticity, 0)
+        c.elasticity = 1
+        self.assertEqual(c.elasticity, 1)
+
+    def testFriction(self) -> None:
+        b1 = p.Body(1, 1)
+        c = p.Circle(b1, 1)
+        self.assertEqual(c.friction, 0)
+        c.friction = 1
+        self.assertEqual(c.friction, 1)
+
+    def testSurfaceVelocity(self) -> None:
+        b1 = p.Body(1, 1)
+        c = p.Circle(b1, 1)
+        self.assertEqual(c.surface_velocity, (0, 0))
+        c.surface_velocity = (1, 2)
+        self.assertEqual(c.surface_velocity, (1, 2))
+
+    def testCollisionType(self) -> None:
+        b1 = p.Body(1, 1)
+        c = p.Circle(b1, 1)
+        self.assertEqual(c.collision_type, 0)
+        c.collision_type = 1
+        self.assertEqual(c.collision_type, 1)
+
+    def testFilter(self) -> None:
+        b1 = p.Body(1, 1)
+        c = p.Circle(b1, 1)
+        self.assertEqual(c.filter, p.ShapeFilter(0, 0xFFFFFFFF, 0xFFFFFFFF))
+        c.filter = p.ShapeFilter(1, 0xFFFFFFF2, 0xFFFFFFF3)
+        self.assertEqual(c.filter, p.ShapeFilter(1, 0xFFFFFFF2, 0xFFFFFFF3))
+
+    def testSpace(self) -> None:
+        b1 = p.Body(1, 1)
+        c = p.Circle(b1, 1)
+        self.assertEqual(c.space, None)
+        s = p.Space()
+        s.add(b1, c)
+        self.assertEqual(c.space, s)
+
+    def testShapesCollide(self) -> None:
+        b1 = p.Body(1, 1)
+        s1 = p.Circle(b1, 10)
+
+        b2 = p.Body(1, 1)
+        b2.position = 30, 30
+        s2 = p.Circle(b2, 10)
+
+        c = s1.shapes_collide(s2)
+        self.assertEqual(c.normal, (1, 0))
+        self.assertEqual(len(c.points), 1)
+        point = c.points[0]
+        self.assertEqual(point.point_a, (10, 0))
+        self.assertEqual(point.point_b, (-10, 0))
+        self.assertEqual(point.distance, -20)
+
+    def testPickle(self) -> None:
+        b = p.Body(1, 2)
+        c = p.Circle(b, 3, (4, 5))
+        c.sensor = True
+        c.collision_type = 6
+        c.filter = p.ShapeFilter()
+        c.elasticity = 7
+        c.friction = 8
+        c.surface_velocity = (9, 10)
+
+        s = pickle.dumps(c)
+        c2 = pickle.loads(s)
+
+        self.assertEqual(c.sensor, c2.sensor)
+        self.assertEqual(c.collision_type, c2.collision_type)
+        self.assertEqual(c.filter, c2.filter)
+        self.assertEqual(c.elasticity, c2.elasticity)
+        self.assertEqual(c.friction, c2.friction)
+        self.assertEqual(c.surface_velocity, c2.surface_velocity)
+        self.assertEqual(c.density, c2.density)
+        self.assertEqual(c.mass, c2.mass)
+        self.assertEqual(c.body.mass, c2.body.mass)
+
+        c = p.Circle(None, 1)
+        c.density = 3
+
+        s = pickle.dumps(c)
+        c2 = pickle.loads(s)
+
+        self.assertEqual(c.mass, c2.mass)
+        self.assertEqual(c.density, c2.density)
+
+        c2 = c.copy()
+
+
+class UnitTestCircle(unittest.TestCase):
+    def testCircleBB(self) -> None:
+        b = p.Body(10, 10)
+        c = p.Circle(b, 5)
+
+        c.cache_bb()
+
+        self.assertEqual(c.bb, p.BB(-5.0, -5.0, 5.0, 5.0))
+
+    def testCircleNoBody(self) -> None:
+        c = p.Circle(None, 5)
+
+        bb = c.update(p.Transform(1, 2, 3, 4, 5, 6))
+        self.assertEqual(c.bb, bb)
+        self.assertEqual(c.bb, p.BB(0, 1, 10, 11))
+
+    def testOffset(self) -> None:
+        c = p.Circle(None, 5, (1, 2))
+
+        self.assertEqual(c.offset, (1, 2))
+
+    def testOffsetUnsafe(self) -> None:
+        c = p.Circle(None, 5, (1, 2))
+
+        c.unsafe_set_offset((3, 4))
+
+        self.assertEqual(c.offset, (3, 4))
+
+    def testRadius(self) -> None:
+        c = p.Circle(None, 5)
+
+        self.assertEqual(c.radius, 5)
+
+    def testRadiusUnsafe(self) -> None:
+        c = p.Circle(None, 5)
+
+        c.unsafe_set_radius(3)
+
+        self.assertEqual(c.radius, 3)
+
+    def testPickle(self) -> None:
+        c = p.Circle(None, 3, (4, 5))
+
+        s = pickle.dumps(c)
+        c2 = pickle.loads(s)
+
+        self.assertEqual(c.radius, c2.radius)
+        self.assertEqual(c.offset, c2.offset)
+
+
+class UnitTestSegment(unittest.TestCase):
+    def testBB(self) -> None:
+        s = p.Space()
+        b = p.Body(10, 10)
+        c = p.Segment(b, (2, 2), (2, 3), 2)
+
+        c.cache_bb()
+
+        self.assertEqual(c.bb, p.BB(0, 0, 4.0, 5.0))
+
+    def testProperties(self) -> None:
+        c = p.Segment(None, (2, 2), (2, 3), 4)
+
+        self.assertEqual(c.a, (2, 2))
+        self.assertEqual(c.b, (2, 3))
+        self.assertEqual(c.normal, (1, 0))
+        self.assertEqual(c.radius, 4)
+
+    def testPropertiesUnsafe(self) -> None:
+        c = p.Segment(None, (2, 2), (2, 3), 4)
+
+        c.unsafe_set_endpoints((3, 4), (5, 6))
+        self.assertEqual(c.a, (3, 4))
+        self.assertEqual(c.b, (5, 6))
+
+        c.unsafe_set_radius(5)
+        self.assertEqual(c.radius, 5)
+
+    def testSetNeighbors(self) -> None:
+        c = p.Segment(None, (2, 2), (2, 3), 1)
+        c.set_neighbors((2, 2), (2, 3))
+
+    def testSegmentSegmentCollision(self) -> None:
+        s = p.Space()
+        b1 = p.Body(10, 10)
+        c1 = p.Segment(b1, (-1, -1), (1, 1), 1)
+        b2 = p.Body(10, 10)
+        c2 = p.Segment(b2, (1, -1), (-1, 1), 1)
+
+        s.add(b1, b2, c1, c2)
+
+        self.num_of_begins = 0
+
+        def begin(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
+            self.num_of_begins += 1
+            return True
+
+        s.add_default_collision_handler().begin = begin
+        s.step(0.1)
+
+        self.assertEqual(1, self.num_of_begins)
+
+    def testPickle(self) -> None:
+        c = p.Segment(None, (1, 2), (3, 4), 5)
+
+        s = pickle.dumps(c)
+        c2 = pickle.loads(s)
+
+        self.assertEqual(c.a, c2.a)
+        self.assertEqual(c.b, c2.b)
+        self.assertEqual(c.radius, c2.radius)
+
+
+class UnitTestPoly(unittest.TestCase):
+    def testInit(self) -> None:
+        c = p.Poly(None, [(0, 0), (10, 10), (20, 0), (-10, 10)], None, 0)
+
+        b = p.Body(1, 2)
+        c = p.Poly(b, [(0, 0), (10, 10), (20, 0), (-10, 10)], p.Transform.identity(), 6)
+
+    def testVertices(self) -> None:
+        vs = [(-10, 10), (0, 0), (20, 0), (10, 10)]
+        c = p.Poly(None, vs, None, 0)
+
+        self.assertEqual(c.get_vertices(), vs)
+
+        c = p.Poly(None, vs, p.Transform(1, 2, 3, 4, 5, 6), 0)
+
+        vs2 = [(5.0, 6.0), (25.0, 26.0), (45.0, 66.0), (25.0, 46.0)]
+        self.assertEqual(c.get_vertices(), vs2)
+
+    def testVerticesUnsafe(self) -> None:
+        vs = [(-10, 10), (0, 0), (20, 0), (10, 10)]
+        c = p.Poly(None, vs, None, 0)
+
+        vs2 = [(-3, 3), (0, 0), (3, 0)]
+        c.unsafe_set_vertices(vs2)
+        self.assertEqual(c.get_vertices(), vs2)
+
+        vs3 = [(-4, 4), (0, 0), (4, 0)]
+        c.unsafe_set_vertices(vs3, p.Transform.identity())
+        self.assertEqual(c.get_vertices(), vs3)
+
+    def testBB(self) -> None:
+        c = p.Poly(None, [(2, 2), (4, 3), (3, 5)])
+        bb = c.update(p.Transform.identity())
+        self.assertEqual(bb, c.bb)
+        self.assertEqual(c.bb, p.BB(2, 2, 4, 5))
+
+        b = p.Body(1, 2)
+        c = p.Poly(b, [(2, 2), (4, 3), (3, 5)])
+        c.cache_bb()
+        self.assertEqual(c.bb, p.BB(2, 2, 4, 5))
+
+        s = p.Space()
+        b = p.Body(1, 2)
+        c = p.Poly(b, [(2, 2), (4, 3), (3, 5)])
+        s.add(b, c)
+        self.assertEqual(c.bb, p.BB(2, 2, 4, 5))
+
+    def testRadius(self) -> None:
+        c = p.Poly(None, [(2, 2), (4, 3), (3, 5)], radius=10)
+        self.assertEqual(c.radius, 10)
+
+    def testRadiusUnsafe(self) -> None:
+        c = p.Poly(None, [(2, 2), (4, 3), (3, 5)], radius=10)
+
+        c.unsafe_set_radius(20)
+
+        self.assertEqual(c.radius, 20)
+
+    def testCreateBox(self) -> None:
+        c = p.Poly.create_box(None, (4, 2), 3)
+        self.assertEqual(c.get_vertices(), [(2, -1), (2, 1), (-2, 1), (-2, -1)])
+
+        c = p.Poly.create_box_bb(None, p.BB(1, 2, 3, 4), 3)
+        self.assertEqual(c.get_vertices(), [(3, 2), (3, 4), (1, 4), (1, 2)])
+
+    def testPickle(self) -> None:
+        c = p.Poly(None, [(1, 2), (3, 4), (5, 6)], radius=5)
+
+        s = pickle.dumps(c)
+        c2 = pickle.loads(s)
+
+        self.assertEqual(c.get_vertices(), c2.get_vertices())
+        self.assertEqual(c.radius, c2.radius)
```

## Comparing `pymunk-6.5.0/pymunk/tests/test_space.py` & `pymunk/tests/test_space.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,1032 +1,1032 @@
-from __future__ import with_statement
-
-import copy
-import io
-import pickle
-import sys
-import unittest
-import warnings
-from typing import Any, Callable, Sequence, cast
-
-import pymunk as p
-from pymunk import *
-from pymunk.constraints import *
-from pymunk.vec2d import Vec2d
-
-
-class UnitTestSpace(unittest.TestCase):
-    def _setUp(self) -> None:
-        self.s = p.Space()
-
-        self.b1, self.b2 = p.Body(1, 3), p.Body(10, 100)
-        self.s.add(self.b1, self.b2)
-        self.b1.position = 10, 0
-        self.b2.position = 20, 0
-
-        self.s1, self.s2 = p.Circle(self.b1, 5), p.Circle(self.b2, 10)
-        self.s.add(self.s1, self.s2)
-        pass
-
-    def _tearDown(self) -> None:
-        del self.s
-        del self.b1, self.b2
-        del self.s1, self.s2
-        pass
-
-    def testProperties(self) -> None:
-        s = p.Space()
-
-        self.assertEqual(s.iterations, 10)
-        s.iterations = 15
-        self.assertEqual(s.iterations, 15)
-
-        self.assertEqual(s.gravity, (0, 0))
-        s.gravity = Vec2d(10, 2)
-        self.assertEqual(s.gravity, (10, 2))
-        self.assertEqual(s.gravity.x, 10)
-
-        self.assertEqual(s.damping, 1)
-        s.damping = 3
-        self.assertEqual(s.damping, 3)
-
-        self.assertEqual(s.idle_speed_threshold, 0)
-        s.idle_speed_threshold = 4
-        self.assertEqual(s.idle_speed_threshold, 4)
-
-        self.assertEqual(str(s.sleep_time_threshold), "inf")
-        s.sleep_time_threshold = 5
-        self.assertEqual(s.sleep_time_threshold, 5)
-
-        self.assertAlmostEqual(s.collision_slop, 0.1)
-        s.collision_slop = 6
-        self.assertEqual(s.collision_slop, 6)
-
-        self.assertAlmostEqual(s.collision_bias, 0.0017970074436)
-        s.collision_bias = 0.2
-        self.assertEqual(s.collision_bias, 0.2)
-
-        self.assertEqual(s.collision_persistence, 3)
-        s.collision_persistence = 9
-        self.assertEqual(s.collision_persistence, 9)
-
-        self.assertEqual(s.current_time_step, 0)
-        s.step(0.1)
-        self.assertEqual(s.current_time_step, 0.1)
-
-        self.assertTrue(s.static_body != None)
-        self.assertEqual(s.static_body.body_type, p.Body.STATIC)
-
-        self.assertEqual(s.threads, 1)
-        s.threads = 2
-        self.assertEqual(s.threads, 1)
-
-    def testThreaded(self) -> None:
-        s = p.Space(threaded=True)
-        s.step(1)
-        s.threads = 2
-        import platform
-
-        if platform.system() == "Windows":
-            self.assertEqual(s.threads, 1)
-        else:
-            self.assertEqual(s.threads, 2)
-        s.step(1)
-
-    def testSpatialHash(self) -> None:
-        s = p.Space()
-        s.use_spatial_hash(10, 100)
-        s.step(1)
-        s.add(p.Body(1, 2))
-        s.step(1)
-
-    def testAddRemove(self) -> None:
-        s = p.Space()
-
-        self.assertEqual(s.bodies, [])
-        self.assertEqual(s.shapes, [])
-
-        b = p.Body(1, 2)
-        s.add(b)
-        self.assertEqual(s.bodies, [b])
-        self.assertEqual(s.shapes, [])
-
-        c1 = p.Circle(b, 10)
-        s.add(c1)
-        self.assertEqual(s.bodies, [b])
-        self.assertEqual(s.shapes, [c1])
-
-        c2 = p.Circle(b, 15)
-        s.add(c2)
-        self.assertEqual(len(s.shapes), 2)
-        self.assertTrue(c1 in s.shapes)
-        self.assertTrue(c2 in s.shapes)
-
-        s.remove(c1)
-        self.assertEqual(s.shapes, [c2])
-
-        s.remove(c2, b)
-        self.assertEqual(s.bodies, [])
-        self.assertEqual(s.shapes, [])
-
-        # note that shape is before the body, which is something to test
-        s.add(c2, b)
-        self.assertEqual(s.bodies, [b])
-        self.assertEqual(s.shapes, [c2])
-
-    def testAddRemoveInStep(self) -> None:
-        s = p.Space()
-
-        b1 = p.Body(1, 2)
-        c1 = p.Circle(b1, 2)
-
-        b2 = p.Body(1, 2)
-        c2 = p.Circle(b2, 2)
-
-        s.add(b1, b2, c1, c2)
-
-        b = p.Body(1, 2)
-        c = p.Circle(b, 2)
-
-        def pre_solve_add(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
-            space.add(b, c)
-            space.add(c, b)
-            self.assertTrue(b not in s.bodies)
-            self.assertTrue(c not in s.shapes)
-            return True
-
-        def pre_solve_remove(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
-            space.remove(b, c)
-            space.remove(c, b)
-            self.assertTrue(b in s.bodies)
-            self.assertTrue(c in s.shapes)
-            return True
-
-        s.add_collision_handler(0, 0).pre_solve = pre_solve_add
-
-        s.step(0.1)
-        return
-        self.assertTrue(b in s.bodies)
-        self.assertTrue(c in s.shapes)
-
-        s.add_collision_handler(0, 0).pre_solve = pre_solve_remove
-
-        s.step(0.1)
-
-        self.assertTrue(b not in s.bodies)
-        self.assertTrue(c not in s.shapes)
-
-    def testRemoveInStep(self) -> None:
-        self._setUp()
-        s = self.s
-
-        def pre_solve(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
-            space.remove(*arb.shapes)
-            return True
-
-        s.add_collision_handler(0, 0).pre_solve = pre_solve
-
-        s.step(0.1)
-
-        self.assertTrue(self.s1 not in s.shapes)
-        self.assertTrue(self.s2 not in s.shapes)
-        self._tearDown()
-
-    def testAddShapeAsserts(self) -> None:
-        s1 = p.Space()
-        s2 = p.Space()
-        c1 = p.Circle(s1.static_body, 10)
-        s1.add(c1)
-
-        self.assertRaises(AssertionError, s1.add, c1)
-        self.assertRaises(AssertionError, s2.add, c1)
-
-        c2 = p.Circle(None, 10)
-
-        self.assertRaises(AssertionError, s1.add, c2)
-
-        b = p.Body(1, 2)
-        c3 = p.Circle(b, 10)
-
-        self.assertRaises(AssertionError, s1.add, c3)
-
-    def testAddBodyAsserts(self) -> None:
-        s1 = p.Space()
-        s2 = p.Space()
-        c1 = p.Circle(s1.static_body, 10)
-
-        s1.add(c1)
-
-        self.assertRaises(AssertionError, s1.add, c1)
-        self.assertRaises(AssertionError, s2.add, c1)
-
-    def testAddConstraintAsserts(self) -> None:
-        s1 = p.Space()
-        b1 = p.Body(1, 2)
-        b2 = p.Body(1, 2)
-        c1 = p.PinJoint(b1, b2, (20, 0), (-20, 0))
-
-        s1.add(c1)
-
-        self.assertRaises(AssertionError, s1.add, c1)
-
-    def testPointQueryNearestWithShapeFilter(self) -> None:
-        s = p.Space()
-        b1 = p.Body(1, 1)
-        s1 = p.Circle(b1, 10)
-        s.add(b1, s1)
-
-        tests = [
-            {"c1": 0b00, "m1": 0b00, "c2": 0b00, "m2": 0b00, "hit": 0},
-            {"c1": 0b01, "m1": 0b01, "c2": 0b01, "m2": 0b01, "hit": 1},
-            {"c1": 0b10, "m1": 0b01, "c2": 0b01, "m2": 0b10, "hit": 1},
-            {"c1": 0b01, "m1": 0b01, "c2": 0b11, "m2": 0b11, "hit": 1},
-            {"c1": 0b11, "m1": 0b00, "c2": 0b11, "m2": 0b00, "hit": 0},
-            {"c1": 0b00, "m1": 0b11, "c2": 0b00, "m2": 0b11, "hit": 0},
-            {"c1": 0b01, "m1": 0b10, "c2": 0b10, "m2": 0b00, "hit": 0},
-            {"c1": 0b01, "m1": 0b10, "c2": 0b10, "m2": 0b10, "hit": 0},
-            {"c1": 0b01, "m1": 0b10, "c2": 0b10, "m2": 0b01, "hit": 1},
-            {"c1": 0b01, "m1": 0b11, "c2": 0b00, "m2": 0b10, "hit": 0},
-        ]
-
-        for test in tests:
-            f1 = p.ShapeFilter(categories=test["c1"], mask=test["m1"])
-            f2 = p.ShapeFilter(categories=test["c2"], mask=test["m2"])
-            s1.filter = f1
-            hit = s.point_query_nearest((0, 0), 0, f2)
-            self.assertEqual(
-                hit != None,
-                test["hit"],
-                "Got {}!=None, expected {} for test: {}".format(hit, test["hit"], test),
-            )
-
-    def testPointQuery(self) -> None:
-        s = p.Space()
-        b1 = p.Body(1, 1)
-        b1.position = 19, 0
-        s1 = p.Circle(b1, 10)
-        s.add(b1, s1)
-
-        b2 = p.Body(1, 1)
-        b2.position = 0, 0
-        s2 = p.Circle(b2, 10)
-        s.add(b2, s2)
-        s1.filter = p.ShapeFilter(categories=0b10, mask=0b01)
-        hits = s.point_query((23, 0), 0, p.ShapeFilter(categories=0b01, mask=0b10))
-
-        self.assertEqual(len(hits), 1)
-        self.assertEqual(hits[0].shape, s1)
-        self.assertEqual(hits[0].point, (29, 0))
-        self.assertEqual(hits[0].distance, -6)
-        self.assertEqual(hits[0].gradient, (1, 0))
-
-        hits = s.point_query((30, 0), 0, p.ShapeFilter())
-        self.assertEqual(len(hits), 0)
-
-        hits = s.point_query((30, 0), 30, p.ShapeFilter())
-        self.assertEqual(len(hits), 2)
-        self.assertEqual(hits[0].shape, s2)
-        self.assertEqual(hits[0].point, (10, 0))
-        self.assertEqual(hits[0].distance, 20)
-        self.assertEqual(hits[0].gradient, (1, 0))
-
-        self.assertEqual(hits[1].shape, s1)
-        self.assertEqual(hits[1].point, (29, 0))
-        self.assertEqual(hits[1].distance, 1)
-        self.assertEqual(hits[1].gradient, (1, 0))
-
-    def testPointQuerySensor(self) -> None:
-        s = p.Space()
-        c = p.Circle(s.static_body, 10)
-        c.sensor = True
-        s.add(c)
-        hits = s.point_query((0, 0), 100, p.ShapeFilter())
-        self.assertEqual(len(hits), 1)
-
-    def testPointQueryNearest(self) -> None:
-        s = p.Space()
-        b1 = p.Body(1, 1)
-        b1.position = 19, 0
-        s1 = p.Circle(b1, 10)
-        s.add(b1, s1)
-
-        hit = s.point_query_nearest((23, 0), 0, p.ShapeFilter())
-        assert hit is not None
-        self.assertEqual(hit.shape, s1)
-        self.assertEqual(hit.point, (29, 0))
-        self.assertEqual(hit.distance, -6)
-        self.assertEqual(hit.gradient, (1, 0))
-
-        hit = s.point_query_nearest((30, 0), 0, p.ShapeFilter())
-        self.assertEqual(hit, None)
-
-        hit = s.point_query_nearest((30, 0), 10, p.ShapeFilter())
-        assert hit is not None
-        self.assertEqual(hit.shape, s1)
-        self.assertEqual(hit.point, (29, 0))
-        self.assertEqual(hit.distance, 1)
-        self.assertEqual(hit.gradient, (1, 0))
-
-    def testPointQueryNearestSensor(self) -> None:
-        s = p.Space()
-        c = p.Circle(s.static_body, 10)
-        c.sensor = True
-        s.add(c)
-        hit = s.point_query_nearest((0, 0), 100, p.ShapeFilter())
-        self.assertEqual(hit, None)
-
-    def testBBQuery(self) -> None:
-        s = p.Space()
-
-        b1 = p.Body(1, 1)
-        b1.position = 19, 0
-        s1 = p.Circle(b1, 10)
-        s.add(b1, s1)
-
-        b2 = p.Body(1, 1)
-        b2.position = 0, 0
-        s2 = p.Circle(b2, 10)
-        s.add(b2, s2)
-
-        bb = p.BB(-7, -7, 7, 7)
-        hits = s.bb_query(bb, p.ShapeFilter())
-        self.assertEqual(len(hits), 1)
-        self.assertTrue(s2 in hits)
-        self.assertTrue(s1 not in hits)
-
-    def testBBQuerySensor(self) -> None:
-        s = p.Space()
-        c = p.Circle(s.static_body, 10)
-        c.sensor = True
-        s.add(c)
-        hits = s.bb_query(p.BB(0, 0, 10, 10), p.ShapeFilter())
-        self.assertEqual(len(hits), 1)
-
-    def testShapeQuery(self) -> None:
-        self._setUp()
-        b = p.Body(body_type=p.Body.KINEMATIC)
-        s = p.Circle(b, 2)
-        b.position = 20, 1
-
-        hits = self.s.shape_query(s)
-
-        self.assertEqual(len(hits), 1)
-        self.assertEqual(self.s2, hits[0].shape)
-        self._tearDown()
-
-    def testShapeQuerySensor(self) -> None:
-        s = p.Space()
-        c = p.Circle(s.static_body, 10)
-        c.sensor = True
-        s.add(c)
-        hits = s.shape_query(p.Circle(None, 200))
-        self.assertEqual(len(hits), 1)
-
-    def testStaticPointQueries(self) -> None:
-        self._setUp()
-        b = p.Body(body_type=p.Body.KINEMATIC)
-        c = p.Circle(b, 10)
-        b.position = -50, -50
-
-        self.s.add(b, c)
-
-        hit = self.s.point_query_nearest((-50, -55), 0, p.ShapeFilter())
-        assert hit is not None
-        self.assertEqual(hit.shape, c)
-
-        hits = self.s.point_query((-50, -55), 0, p.ShapeFilter())
-        self.assertEqual(hits[0].shape, c)
-        self._tearDown()
-
-    def testReindexShape(self) -> None:
-        s = p.Space()
-
-        b = p.Body(body_type=p.Body.KINEMATIC)
-        c = p.Circle(b, 10)
-
-        s.add(b, c)
-
-        b.position = -50, -50
-        hit = s.point_query_nearest((-50, -55), 0, p.ShapeFilter())
-        self.assertEqual(hit, None)
-        s.reindex_shape(c)
-        hit = s.point_query_nearest((-50, -55), 0, p.ShapeFilter())
-        assert hit is not None
-        self.assertEqual(hit.shape, c)
-
-    def testReindexShapesForBody(self) -> None:
-        s = p.Space()
-        b = p.Body(body_type=p.Body.STATIC)
-        c = p.Circle(b, 10)
-
-        s.add(b, c)
-
-        b.position = -50, -50
-        hit = s.point_query_nearest((-50, -55), 0, p.ShapeFilter())
-        self.assertEqual(hit, None)
-        s.reindex_shapes_for_body(b)
-
-        hit = s.point_query_nearest((-50, -55), 0, p.ShapeFilter())
-        assert hit is not None
-        self.assertEqual(hit.shape, c)
-
-    def testReindexStatic(self) -> None:
-        s = p.Space()
-        b = p.Body(body_type=p.Body.STATIC)
-        c = p.Circle(b, 10)
-
-        s.add(b, c)
-
-        b.position = -50, -50
-        hit = s.point_query_nearest((-50, -55), 0, p.ShapeFilter())
-        self.assertEqual(hit, None)
-        s.reindex_static()
-        hit = s.point_query_nearest((-50, -55), 0, p.ShapeFilter())
-        assert hit is not None
-        self.assertEqual(hit.shape, c)
-
-    def testReindexStaticCollision(self) -> None:
-        s = p.Space()
-        b1 = p.Body(10, 1000)
-        c1 = p.Circle(b1, 10)
-        b1.position = Vec2d(20, 20)
-
-        b2 = p.Body(body_type=p.Body.STATIC)
-        s2 = p.Segment(b2, (-10, 0), (10, 0), 1)
-
-        s.add(b1, c1)
-        s.add(b2, s2)
-
-        s2.unsafe_set_endpoints((-10, 0), (100, 0))
-        s.gravity = 0, -100
-
-        for _ in range(10):
-            s.step(0.1)
-
-        self.assertTrue(b1.position.y < 0)
-
-        b1.position = Vec2d(20, 20)
-        b1.velocity = 0, 0
-        s.reindex_static()
-
-        for _ in range(10):
-            s.step(0.1)
-
-        self.assertTrue(b1.position.y > 10)
-
-    def testSegmentQuery(self) -> None:
-        s = p.Space()
-
-        b1 = p.Body(1, 1)
-        b1.position = 19, 0
-        s1 = p.Circle(b1, 10)
-        s.add(b1, s1)
-
-        b2 = p.Body(1, 1)
-        b2.position = 0, 0
-        s2 = p.Circle(b2, 10)
-        s.add(b2, s2)
-
-        hits = s.segment_query((-13, 0), (131, 0), 0, p.ShapeFilter())
-
-        self.assertEqual(len(hits), 2)
-        self.assertEqual(hits[0].shape, s2)
-        self.assertEqual(hits[0].point, (-10, 0))
-        self.assertEqual(hits[0].normal, (-1, 0))
-        self.assertAlmostEqual(hits[0].alpha, 0.0208333333333)
-
-        self.assertEqual(hits[1].shape, s1)
-        self.assertEqual(hits[1].point, (9, 0))
-        self.assertEqual(hits[1].normal, (-1, 0))
-        self.assertAlmostEqual(hits[1].alpha, 0.1527777777777)
-
-        hits = s.segment_query((-13, 50), (131, 50), 0, p.ShapeFilter())
-        self.assertEqual(len(hits), 0)
-
-    def testSegmentQuerySensor(self) -> None:
-        s = p.Space()
-        c = p.Circle(s.static_body, 10)
-        c.sensor = True
-        s.add(c)
-        hits = s.segment_query((-20, 0), (20, 0), 1, p.ShapeFilter())
-        self.assertEqual(len(hits), 1)
-
-    def testSegmentQueryFirst(self) -> None:
-        s = p.Space()
-
-        b1 = p.Body(1, 1)
-        b1.position = 19, 0
-        s1 = p.Circle(b1, 10)
-        s.add(b1, s1)
-
-        b2 = p.Body(1, 1)
-        b2.position = 0, 0
-        s2 = p.Circle(b2, 10)
-        s.add(b2, s2)
-
-        hit = s.segment_query_first((-13, 0), (131, 0), 0, p.ShapeFilter())
-
-        assert hit is not None
-        self.assertEqual(hit.shape, s2)
-        self.assertEqual(hit.point, (-10, 0))
-        self.assertEqual(hit.normal, (-1, 0))
-        self.assertAlmostEqual(hit.alpha, 0.0208333333333)
-
-        hit = s.segment_query_first((-13, 50), (131, 50), 0, p.ShapeFilter())
-        self.assertEqual(hit, None)
-
-    def testSegmentQueryFirstSensor(self) -> None:
-        s = p.Space()
-        c = p.Circle(s.static_body, 10)
-        c.sensor = True
-        s.add(c)
-        hit = s.segment_query_first((-20, 0), (20, 0), 1, p.ShapeFilter())
-        self.assertIsNone(hit)
-
-    def testStaticSegmentQueries(self) -> None:
-        self._setUp()
-        b = p.Body(body_type=p.Body.KINEMATIC)
-        c = p.Circle(b, 10)
-        b.position = -50, -50
-
-        self.s.add(b, c)
-
-        hit = self.s.segment_query_first((-70, -50), (-30, -50), 0, p.ShapeFilter())
-        assert hit is not None
-        self.assertEqual(hit.shape, c)
-        hits = self.s.segment_query((-70, -50), (-30, -50), 0, p.ShapeFilter())
-        self.assertEqual(hits[0].shape, c)
-        self._tearDown()
-
-    def testCollisionHandlerBegin(self) -> None:
-        s = p.Space()
-        b1 = p.Body(1, 1)
-        c1 = p.Circle(b1, 10)
-        b2 = p.Body(1, 1)
-        c2 = p.Circle(b2, 10)
-        s.add(b1, c1, b2, c2)
-
-        self.hits = 0
-
-        def begin(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
-            self.hits += h.data["test"]
-            return True
-
-        h = s.add_collision_handler(0, 0)
-        h.data["test"] = 1
-        h.begin = begin
-
-        for x in range(10):
-            s.step(0.1)
-
-        self.assertEqual(self.hits, 1)
-
-    def testCollisionHandlerBeginNoReturn(self) -> None:
-        s = p.Space()
-        b1 = p.Body(1, 1)
-        c1 = p.Circle(b1, 10)
-        b2 = p.Body(1, 1)
-        c2 = p.Circle(b2, 10)
-        s.add(b1, c1, b2, c2)
-
-        with warnings.catch_warnings(record=True) as w:
-            warnings.simplefilter("always")
-
-            def begin(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
-                return  # type: ignore
-
-            s.add_collision_handler(0, 0).begin = begin
-            s.step(0.1)
-
-            assert w is not None
-            self.assertEqual(len(w), 1)
-            self.assertTrue(issubclass(w[-1].category, UserWarning))
-
-    def testCollisionHandlerPreSolve(self) -> None:
-        s = p.Space()
-        b1 = p.Body(1, 1)
-        c1 = p.Circle(b1, 10)
-        c1.collision_type = 1
-        b2 = p.Body(1, 1)
-        c2 = p.Circle(b2, 10)
-        s.add(b1, c1, b2, c2)
-
-        d = {}
-
-        def pre_solve(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
-            d["shapes"] = arb.shapes
-            d["space"] = space  # type: ignore
-            d["test"] = data["test"]
-            return True
-
-        h = s.add_collision_handler(0, 1)
-        h.data["test"] = 1
-        h.pre_solve = pre_solve
-        s.step(0.1)
-        self.assertEqual(c1, d["shapes"][1])
-        self.assertEqual(c2, d["shapes"][0])
-        self.assertEqual(s, d["space"])
-        self.assertEqual(1, d["test"])
-
-    def testCollisionHandlerPreSolveNoReturn(self) -> None:
-        s = p.Space()
-        b1 = p.Body(1, 1)
-        c1 = p.Circle(b1, 10)
-        b2 = p.Body(1, 1)
-        c2 = p.Circle(b2, 10)
-        s.add(b1, c1, b2, c2)
-
-        def pre_solve(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
-            return  # type: ignore
-
-        s.add_collision_handler(0, 0).pre_solve = pre_solve
-
-        with warnings.catch_warnings(record=True) as w:
-            warnings.simplefilter("always")
-
-            s.step(0.1)
-            assert w is not None
-            self.assertEqual(len(w), 1)
-            self.assertTrue(issubclass(w[-1].category, UserWarning))
-
-    def testCollisionHandlerPostSolve(self) -> None:
-        self._setUp()
-        self.hit = 0
-
-        def post_solve(arb: p.Arbiter, space: p.Space, data: Any) -> None:
-            self.hit += 1
-
-        self.s.add_collision_handler(0, 0).post_solve = post_solve
-        self.s.step(0.1)
-        self.assertEqual(self.hit, 1)
-        self._tearDown()
-
-    def testCollisionHandlerSeparate(self) -> None:
-        s = p.Space()
-
-        b1 = p.Body(1, 1)
-        c1 = p.Circle(b1, 10)
-        b1.position = 9, 11
-
-        b2 = p.Body(body_type=p.Body.STATIC)
-        c2 = p.Circle(b2, 10)
-        b2.position = 0, 0
-
-        s.add(b1, c1, b2, c2)
-        s.gravity = 0, -100
-
-        self.separated = False
-
-        def separate(arb: p.Arbiter, space: p.Space, data: Any) -> None:
-            self.separated = data["test"]
-
-        h = s.add_collision_handler(0, 0)
-        h.data["test"] = True
-        h.separate = separate
-
-        for x in range(10):
-            s.step(0.1)
-
-        self.assertTrue(self.separated)
-
-    def testCollisionHandlerRemoveSeparateAdd(self) -> None:
-        s = p.Space()
-        b1 = p.Body(1, 10)
-        c1 = p.Circle(b1, 10)
-        c2 = p.Circle(s.static_body, 5)
-
-        s.add(b1, c1, c2)
-
-        def separate(*_: Any) -> None:
-            s.add(p.Circle(s.static_body, 2))
-            s.remove(c1)
-
-        s.add_default_collision_handler().separate = separate
-
-        s.step(1)
-        s.remove(c1)
-
-    def testCollisionHandlerKeyOrder(self) -> None:
-        s = p.Space()
-        h1 = s.add_collision_handler(1, 2)
-        h2 = s.add_collision_handler(2, 1)
-
-        self.assertEqual(h1, h2)
-
-    def testWildcardCollisionHandler(self) -> None:
-        s = p.Space()
-        b1 = p.Body(1, 1)
-        c1 = p.Circle(b1, 10)
-        b2 = p.Body(1, 1)
-        c2 = p.Circle(b2, 10)
-        s.add(b1, c1, b2, c2)
-
-        d = {}
-
-        def pre_solve(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
-            d["shapes"] = arb.shapes
-            d["space"] = space  # type: ignore
-            return True
-
-        s.add_wildcard_collision_handler(1).pre_solve = pre_solve
-        s.step(0.1)
-
-        self.assertEqual({}, d)
-
-        c1.collision_type = 1
-        s.step(0.1)
-
-        self.assertEqual(c1, d["shapes"][0])
-        self.assertEqual(c2, d["shapes"][1])
-        self.assertEqual(s, d["space"])
-
-    def testDefaultCollisionHandler(self) -> None:
-        s = p.Space()
-        b1 = p.Body(1, 1)
-        c1 = p.Circle(b1, 10)
-        c1.collision_type = 1
-        b2 = p.Body(1, 1)
-        c2 = p.Circle(b2, 10)
-        c2.collision_type = 2
-        s.add(b1, c1, b2, c2)
-
-        d = {}
-
-        def pre_solve(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
-            d["shapes"] = arb.shapes
-            d["space"] = space  # type: ignore
-            return True
-
-        s.add_default_collision_handler().pre_solve = pre_solve
-        s.step(0.1)
-
-        self.assertEqual(c1, d["shapes"][1])
-        self.assertEqual(c2, d["shapes"][0])
-        self.assertEqual(s, d["space"])
-
-    def testPostStepCallback(self) -> None:
-        s = p.Space()
-        b1, b2 = p.Body(1, 3), p.Body(10, 100)
-        s.add(b1, b2)
-        b1.position = 10, 0
-        b2.position = 20, 0
-        s1, s2 = p.Circle(b1, 5), p.Circle(b2, 10)
-        s.add(s1, s2)
-
-        self.calls = 0
-
-        def callback(
-            space: p.Space,
-            key: Any,
-            shapes: Sequence[Shape],
-            test_self: "UnitTestSpace",
-        ) -> None:
-            for shape in shapes:
-                s.remove(shape)
-            test_self.calls += 1
-
-        def pre_solve(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
-            # note that we dont pass on the whole arbiters object, instead
-            # we take only the shapes.
-            space.add_post_step_callback(callback, 0, arb.shapes, test_self=self)
-            return True
-
-        ch = s.add_collision_handler(0, 0).pre_solve = pre_solve
-
-        s.step(0.1)
-        self.assertEqual([], s.shapes)
-        self.assertEqual(self.calls, 1)
-
-        s.step(0.1)
-
-        self.assertEqual(self.calls, 1)
-
-    def testDebugDraw(self) -> None:
-        s = p.Space()
-
-        b1 = p.Body(1, 3)
-        s1 = p.Circle(b1, 5)
-        s.add(b1, s1)
-        s.step(1)
-        o = p.SpaceDebugDrawOptions()
-
-        new_out = io.StringIO()
-        sys.stdout = new_out
-        try:
-            s.debug_draw(o)
-        finally:
-            sys.stdout = sys.__stdout__
-
-        msg = (
-            "draw_circle (Vec2d(0.0, 0.0), 0.0, 5.0, "
-            "SpaceDebugColor(r=44.0, g=62.0, b=80.0, a=255.0), "
-            "SpaceDebugColor(r=52.0, g=152.0, b=219.0, a=255.0))\n"
-        )
-        self.assertEqual(msg, new_out.getvalue())
-
-    @unittest.skip(
-        "Different behavior on windows sometimes. Expect it to be fixed in next major python version"
-    )
-    def testDebugDrawZeroLengthSpring(self) -> None:
-        if sys.version_info < (3, 0):
-            return
-        s = p.Space()
-
-        b1 = p.Body(1, 3)
-        c = DampedSpring(b1, s.static_body, (0, 0), (0, 0), 0, 10, 1)
-        s.add(b1, c)
-
-        s.step(1)
-        o = p.SpaceDebugDrawOptions()
-
-        new_out = io.StringIO()
-        sys.stdout = new_out
-        try:
-            s.debug_draw(o)
-        finally:
-            sys.stdout = sys.__stdout__
-
-        expected = (
-            "draw_dot (5.0, Vec2d(0.0, 0.0), SpaceDebugColor(r=142.0, g=68.0, b=173.0, a=255.0))\n"
-            "draw_dot (5.0, Vec2d(0.0, 0.0), SpaceDebugColor(r=142.0, g=68.0, b=173.0, a=255.0)) \n"
-            "draw_segment (Vec2d(0.0, 0.0), Vec2d(0.0, 0.0), SpaceDebugColor(r=142.0, g=68.0, b=173.0, a=255.0))\n"
-            "draw_segment (Vec2d(0.0, 0.0), Vec2d(0.0, 0.0), SpaceDebugColor(r=142.0, g=68.0, b=173.0, a=255.0))\n"
-        )
-
-        actual = new_out.getvalue()
-        try:
-            self.assertEqual(expected, actual)
-        except:
-            print("\nExpected", expected)
-            print("\nActual", actual)
-            raise
-
-    def testPicklePymunkVersionCheck(self) -> None:
-        pickle_string = b"\x80\x04\x95\xc5\x01\x00\x00\x00\x00\x00\x00\x8c\x0cpymunk.space\x94\x8c\x05Space\x94\x93\x94)\x81\x94}\x94(\x8c\x04init\x94]\x94\x8c\x08threaded\x94\x89\x86\x94a\x8c\x07general\x94]\x94(\x8c\niterations\x94K\n\x86\x94\x8c\x07gravity\x94\x8c\x0cpymunk.vec2d\x94\x8c\x05Vec2d\x94\x93\x94G\x00\x00\x00\x00\x00\x00\x00\x00G\x00\x00\x00\x00\x00\x00\x00\x00\x86\x94R\x94\x86\x94\x8c\x07damping\x94G?\xf0\x00\x00\x00\x00\x00\x00\x86\x94\x8c\x14idle_speed_threshold\x94G\x00\x00\x00\x00\x00\x00\x00\x00\x86\x94\x8c\x14sleep_time_threshold\x94G\x7f\xf0\x00\x00\x00\x00\x00\x00\x86\x94\x8c\x0ecollision_slop\x94G?\xb9\x99\x99\xa0\x00\x00\x00\x86\x94\x8c\x0ecollision_bias\x94G?]q2\x0c\xdfCc\x86\x94\x8c\x15collision_persistence\x94K\x03\x86\x94\x8c\x07threads\x94K\x01\x86\x94e\x8c\x06custom\x94]\x94h\x07\x89\x86\x94a\x8c\x07special\x94]\x94(\x8c\x0epymunk_version\x94\x8c\x050.0.1\x94\x86\x94\x8c\x06bodies\x94]\x94\x86\x94\x8c\x06shapes\x94]\x94\x86\x94\x8c\x0bconstraints\x94]\x94\x86\x94\x8c\t_handlers\x94]\x94\x86\x94eub."
-
-        with self.assertRaisesRegex(
-            AssertionError,
-            r"Pymunk version [0-9.]+ of pickled object does not match current Pymunk version [0-9.]+",
-        ):
-            pickle.loads(pickle_string)
-
-    def testCopyMethods(self) -> None:
-        self._testCopyMethod(lambda x: cast(Space, pickle.loads(pickle.dumps(x))))
-        self._testCopyMethod(lambda x: copy.deepcopy(x))
-        self._testCopyMethod(lambda x: x.copy())
-
-    def _testCopyMethod(self, copy_func: Callable[[Space], Space]) -> None:
-        s = p.Space(threaded=True)
-        s.iterations = 2
-        s.gravity = 3, 4
-        s.damping = 5
-        s.idle_speed_threshold = 6
-        s.sleep_time_threshold = 7
-        s.collision_slop = 8
-        s.collision_bias = 9
-        s.collision_persistence = 10
-        s.threads = 2
-
-        b1 = p.Body(1, 2)
-        b2 = p.Body(3, 4)
-        b3 = p.Body(5, 6)
-        c1 = p.Circle(b1, 7)
-        c2 = p.Circle(b1, 8)
-        c3 = p.Circle(b2, 9)
-        c4 = p.Circle(s.static_body, 10)
-        s.add(b1, b2, b3, c1, c2, c3, c4)
-        s.static_body.custom = "x"
-
-        j1 = PinJoint(b1, b2)
-        j2 = PinJoint(s.static_body, b2)
-        s.add(j1, j2)
-
-        h = s.add_default_collision_handler()
-        h.begin = f1
-
-        h = s.add_wildcard_collision_handler(1)
-        h.pre_solve = f1
-
-        h = s.add_collision_handler(1, 2)
-        h.post_solve = f1
-
-        h = s.add_collision_handler(3, 4)
-        h.separate = f1
-
-        s2 = copy_func(s)
-
-        # Assert properties
-        self.assertEqual(s.threaded, s2.threaded)
-        self.assertEqual(s.iterations, s2.iterations)
-        self.assertEqual(s.gravity, s2.gravity)
-        self.assertEqual(s.damping, s2.damping)
-        self.assertEqual(s.idle_speed_threshold, s2.idle_speed_threshold)
-        self.assertEqual(s.sleep_time_threshold, s2.sleep_time_threshold)
-        self.assertEqual(s.collision_slop, s2.collision_slop)
-        self.assertEqual(s.collision_bias, s2.collision_bias)
-        self.assertEqual(s.collision_persistence, s2.collision_persistence)
-        self.assertEqual(s.threads, s2.threads)
-
-        # Assert shapes, bodies and constriants
-        self.assertEqual([c.radius for c in s2.shapes], [7, 8, 9, 10])
-        self.assertEqual([b.mass for b in s2.bodies], [1, 3, 5])
-        self.assertEqual(s.static_body.custom, s2.static_body.custom)
-        ja = [j.a for j in s2.constraints]
-        self.assertIn(s2.static_body, ja)
-
-        # Assert collision handlers
-        h2 = s2.add_default_collision_handler()
-        self.assertIsNotNone(h2.begin)
-        self.assertIsNone(h2.pre_solve)
-        self.assertIsNone(h2.post_solve)
-        self.assertIsNone(h2.separate)
-
-        h2 = s2.add_wildcard_collision_handler(1)
-        self.assertIsNone(h2.begin)
-        self.assertIsNotNone(h2.pre_solve)
-        self.assertIsNone(h2.post_solve)
-        self.assertIsNone(h2.separate)
-
-        h2 = s2.add_collision_handler(1, 2)
-        self.assertIsNone(h2.begin)
-        self.assertIsNone(h2.pre_solve)
-        self.assertIsNotNone(h2.post_solve)
-        self.assertIsNone(h2.separate)
-
-        h2 = s2.add_collision_handler(3, 4)
-        self.assertIsNone(h2.begin)
-        self.assertIsNone(h2.pre_solve)
-        self.assertIsNone(h2.post_solve)
-        self.assertIsNotNone(h2.separate)
-
-    def testPickleCachedArbiters(self) -> None:
-        s = p.Space()
-        
-        b1 = p.Body()
-        b2 = p.Body()
-
-        c1 = p.Circle(b1, 10)
-        c2 = p.Circle(b2, 10)
-
-        c1.mass = 1
-        c2.mass = 1
-
-        b2.position = 1,2
-        s.add(c1,c2, b1, b2)
-        
-        s.step(0.1)
-        # print("\nOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO")
-        s_copy = s.copy()
-        
-        # a1 = [p.arbiter._arbiter_to_dict(_arb, s) for _arb in s._get_arbiters()]
-        # a2 = [p.arbiter._arbiter_to_dict(_arb, s_copy) for _arb in s_copy._get_arbiters()]
-        
-        # print("a1", a1)
-        # print("a2", a2)
-        # print("XXXX")
-        
-        # print("s.bodies.position:")
-        # print([b.position for b in s.bodies])
-        # print("s_copy.bodies.position:")
-        # print([b.position for b in s_copy.bodies])
-
-
-        s.step(0.1)
-        s_copy.step(0.1)
-        
-        # a1 = [p.arbiter._arbiter_to_dict(_arb, s) for _arb in s._get_arbiters()]
-        # a2 = [p.arbiter._arbiter_to_dict(_arb, s_copy) for _arb in s_copy._get_arbiters()]
-        
-        # print("a1", a1)
-        # print("a2", a2)
-        # print("XXXX")
-
-        # print("s.bodies.position:")
-        # print([b.position for b in s.bodies])
-        # print("s_copy.bodies.position:")
-        # print([b.position for b in s_copy.bodies])
-
-        s_copy.step(0.1)
-
-        # a1 = [p.arbiter._arbiter_to_dict(_arb, s) for _arb in s._get_arbiters()]
-        # a2 = [p.arbiter._arbiter_to_dict(_arb, s_copy) for _arb in s_copy._get_arbiters()]
-        
-        # print("a1", a1)
-        # print("a2", a2)
-        # print("XXXX")
-
-        # print("s.bodies.position:")
-        # print([b.position for b in s.bodies])
-        # print("s_copy.bodies.position:")
-        # print([b.position for b in s_copy.bodies])
-
-        # TODO: to assert that everything is working as it should all 
-        # properties on the cached the arbiters should be asserted.
-
-
-        self.assertAlmostEqual(s.bodies[0].position.x, s_copy.bodies[0].position.x)
-        self.assertAlmostEqual(s.bodies[0].position.y, s_copy.bodies[0].position.y)
-
-
-
-def f1(*args: Any, **kwargs: Any) -> None:
-    pass
+from __future__ import with_statement
+
+import copy
+import io
+import pickle
+import sys
+import unittest
+import warnings
+from typing import Any, Callable, Sequence, cast
+
+import pymunk as p
+from pymunk import *
+from pymunk.constraints import *
+from pymunk.vec2d import Vec2d
+
+
+class UnitTestSpace(unittest.TestCase):
+    def _setUp(self) -> None:
+        self.s = p.Space()
+
+        self.b1, self.b2 = p.Body(1, 3), p.Body(10, 100)
+        self.s.add(self.b1, self.b2)
+        self.b1.position = 10, 0
+        self.b2.position = 20, 0
+
+        self.s1, self.s2 = p.Circle(self.b1, 5), p.Circle(self.b2, 10)
+        self.s.add(self.s1, self.s2)
+        pass
+
+    def _tearDown(self) -> None:
+        del self.s
+        del self.b1, self.b2
+        del self.s1, self.s2
+        pass
+
+    def testProperties(self) -> None:
+        s = p.Space()
+
+        self.assertEqual(s.iterations, 10)
+        s.iterations = 15
+        self.assertEqual(s.iterations, 15)
+
+        self.assertEqual(s.gravity, (0, 0))
+        s.gravity = Vec2d(10, 2)
+        self.assertEqual(s.gravity, (10, 2))
+        self.assertEqual(s.gravity.x, 10)
+
+        self.assertEqual(s.damping, 1)
+        s.damping = 3
+        self.assertEqual(s.damping, 3)
+
+        self.assertEqual(s.idle_speed_threshold, 0)
+        s.idle_speed_threshold = 4
+        self.assertEqual(s.idle_speed_threshold, 4)
+
+        self.assertEqual(str(s.sleep_time_threshold), "inf")
+        s.sleep_time_threshold = 5
+        self.assertEqual(s.sleep_time_threshold, 5)
+
+        self.assertAlmostEqual(s.collision_slop, 0.1)
+        s.collision_slop = 6
+        self.assertEqual(s.collision_slop, 6)
+
+        self.assertAlmostEqual(s.collision_bias, 0.0017970074436)
+        s.collision_bias = 0.2
+        self.assertEqual(s.collision_bias, 0.2)
+
+        self.assertEqual(s.collision_persistence, 3)
+        s.collision_persistence = 9
+        self.assertEqual(s.collision_persistence, 9)
+
+        self.assertEqual(s.current_time_step, 0)
+        s.step(0.1)
+        self.assertEqual(s.current_time_step, 0.1)
+
+        self.assertTrue(s.static_body != None)
+        self.assertEqual(s.static_body.body_type, p.Body.STATIC)
+
+        self.assertEqual(s.threads, 1)
+        s.threads = 2
+        self.assertEqual(s.threads, 1)
+
+    def testThreaded(self) -> None:
+        s = p.Space(threaded=True)
+        s.step(1)
+        s.threads = 2
+        import platform
+
+        if platform.system() == "Windows":
+            self.assertEqual(s.threads, 1)
+        else:
+            self.assertEqual(s.threads, 2)
+        s.step(1)
+
+    def testSpatialHash(self) -> None:
+        s = p.Space()
+        s.use_spatial_hash(10, 100)
+        s.step(1)
+        s.add(p.Body(1, 2))
+        s.step(1)
+
+    def testAddRemove(self) -> None:
+        s = p.Space()
+
+        self.assertEqual(s.bodies, [])
+        self.assertEqual(s.shapes, [])
+
+        b = p.Body(1, 2)
+        s.add(b)
+        self.assertEqual(s.bodies, [b])
+        self.assertEqual(s.shapes, [])
+
+        c1 = p.Circle(b, 10)
+        s.add(c1)
+        self.assertEqual(s.bodies, [b])
+        self.assertEqual(s.shapes, [c1])
+
+        c2 = p.Circle(b, 15)
+        s.add(c2)
+        self.assertEqual(len(s.shapes), 2)
+        self.assertTrue(c1 in s.shapes)
+        self.assertTrue(c2 in s.shapes)
+
+        s.remove(c1)
+        self.assertEqual(s.shapes, [c2])
+
+        s.remove(c2, b)
+        self.assertEqual(s.bodies, [])
+        self.assertEqual(s.shapes, [])
+
+        # note that shape is before the body, which is something to test
+        s.add(c2, b)
+        self.assertEqual(s.bodies, [b])
+        self.assertEqual(s.shapes, [c2])
+
+    def testAddRemoveInStep(self) -> None:
+        s = p.Space()
+
+        b1 = p.Body(1, 2)
+        c1 = p.Circle(b1, 2)
+
+        b2 = p.Body(1, 2)
+        c2 = p.Circle(b2, 2)
+
+        s.add(b1, b2, c1, c2)
+
+        b = p.Body(1, 2)
+        c = p.Circle(b, 2)
+
+        def pre_solve_add(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
+            space.add(b, c)
+            space.add(c, b)
+            self.assertTrue(b not in s.bodies)
+            self.assertTrue(c not in s.shapes)
+            return True
+
+        def pre_solve_remove(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
+            space.remove(b, c)
+            space.remove(c, b)
+            self.assertTrue(b in s.bodies)
+            self.assertTrue(c in s.shapes)
+            return True
+
+        s.add_collision_handler(0, 0).pre_solve = pre_solve_add
+
+        s.step(0.1)
+        return
+        self.assertTrue(b in s.bodies)
+        self.assertTrue(c in s.shapes)
+
+        s.add_collision_handler(0, 0).pre_solve = pre_solve_remove
+
+        s.step(0.1)
+
+        self.assertTrue(b not in s.bodies)
+        self.assertTrue(c not in s.shapes)
+
+    def testRemoveInStep(self) -> None:
+        self._setUp()
+        s = self.s
+
+        def pre_solve(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
+            space.remove(*arb.shapes)
+            return True
+
+        s.add_collision_handler(0, 0).pre_solve = pre_solve
+
+        s.step(0.1)
+
+        self.assertTrue(self.s1 not in s.shapes)
+        self.assertTrue(self.s2 not in s.shapes)
+        self._tearDown()
+
+    def testAddShapeAsserts(self) -> None:
+        s1 = p.Space()
+        s2 = p.Space()
+        c1 = p.Circle(s1.static_body, 10)
+        s1.add(c1)
+
+        self.assertRaises(AssertionError, s1.add, c1)
+        self.assertRaises(AssertionError, s2.add, c1)
+
+        c2 = p.Circle(None, 10)
+
+        self.assertRaises(AssertionError, s1.add, c2)
+
+        b = p.Body(1, 2)
+        c3 = p.Circle(b, 10)
+
+        self.assertRaises(AssertionError, s1.add, c3)
+
+    def testAddBodyAsserts(self) -> None:
+        s1 = p.Space()
+        s2 = p.Space()
+        c1 = p.Circle(s1.static_body, 10)
+
+        s1.add(c1)
+
+        self.assertRaises(AssertionError, s1.add, c1)
+        self.assertRaises(AssertionError, s2.add, c1)
+
+    def testAddConstraintAsserts(self) -> None:
+        s1 = p.Space()
+        b1 = p.Body(1, 2)
+        b2 = p.Body(1, 2)
+        c1 = p.PinJoint(b1, b2, (20, 0), (-20, 0))
+
+        s1.add(c1)
+
+        self.assertRaises(AssertionError, s1.add, c1)
+
+    def testPointQueryNearestWithShapeFilter(self) -> None:
+        s = p.Space()
+        b1 = p.Body(1, 1)
+        s1 = p.Circle(b1, 10)
+        s.add(b1, s1)
+
+        tests = [
+            {"c1": 0b00, "m1": 0b00, "c2": 0b00, "m2": 0b00, "hit": 0},
+            {"c1": 0b01, "m1": 0b01, "c2": 0b01, "m2": 0b01, "hit": 1},
+            {"c1": 0b10, "m1": 0b01, "c2": 0b01, "m2": 0b10, "hit": 1},
+            {"c1": 0b01, "m1": 0b01, "c2": 0b11, "m2": 0b11, "hit": 1},
+            {"c1": 0b11, "m1": 0b00, "c2": 0b11, "m2": 0b00, "hit": 0},
+            {"c1": 0b00, "m1": 0b11, "c2": 0b00, "m2": 0b11, "hit": 0},
+            {"c1": 0b01, "m1": 0b10, "c2": 0b10, "m2": 0b00, "hit": 0},
+            {"c1": 0b01, "m1": 0b10, "c2": 0b10, "m2": 0b10, "hit": 0},
+            {"c1": 0b01, "m1": 0b10, "c2": 0b10, "m2": 0b01, "hit": 1},
+            {"c1": 0b01, "m1": 0b11, "c2": 0b00, "m2": 0b10, "hit": 0},
+        ]
+
+        for test in tests:
+            f1 = p.ShapeFilter(categories=test["c1"], mask=test["m1"])
+            f2 = p.ShapeFilter(categories=test["c2"], mask=test["m2"])
+            s1.filter = f1
+            hit = s.point_query_nearest((0, 0), 0, f2)
+            self.assertEqual(
+                hit != None,
+                test["hit"],
+                "Got {}!=None, expected {} for test: {}".format(hit, test["hit"], test),
+            )
+
+    def testPointQuery(self) -> None:
+        s = p.Space()
+        b1 = p.Body(1, 1)
+        b1.position = 19, 0
+        s1 = p.Circle(b1, 10)
+        s.add(b1, s1)
+
+        b2 = p.Body(1, 1)
+        b2.position = 0, 0
+        s2 = p.Circle(b2, 10)
+        s.add(b2, s2)
+        s1.filter = p.ShapeFilter(categories=0b10, mask=0b01)
+        hits = s.point_query((23, 0), 0, p.ShapeFilter(categories=0b01, mask=0b10))
+
+        self.assertEqual(len(hits), 1)
+        self.assertEqual(hits[0].shape, s1)
+        self.assertEqual(hits[0].point, (29, 0))
+        self.assertEqual(hits[0].distance, -6)
+        self.assertEqual(hits[0].gradient, (1, 0))
+
+        hits = s.point_query((30, 0), 0, p.ShapeFilter())
+        self.assertEqual(len(hits), 0)
+
+        hits = s.point_query((30, 0), 30, p.ShapeFilter())
+        self.assertEqual(len(hits), 2)
+        self.assertEqual(hits[0].shape, s2)
+        self.assertEqual(hits[0].point, (10, 0))
+        self.assertEqual(hits[0].distance, 20)
+        self.assertEqual(hits[0].gradient, (1, 0))
+
+        self.assertEqual(hits[1].shape, s1)
+        self.assertEqual(hits[1].point, (29, 0))
+        self.assertEqual(hits[1].distance, 1)
+        self.assertEqual(hits[1].gradient, (1, 0))
+
+    def testPointQuerySensor(self) -> None:
+        s = p.Space()
+        c = p.Circle(s.static_body, 10)
+        c.sensor = True
+        s.add(c)
+        hits = s.point_query((0, 0), 100, p.ShapeFilter())
+        self.assertEqual(len(hits), 1)
+
+    def testPointQueryNearest(self) -> None:
+        s = p.Space()
+        b1 = p.Body(1, 1)
+        b1.position = 19, 0
+        s1 = p.Circle(b1, 10)
+        s.add(b1, s1)
+
+        hit = s.point_query_nearest((23, 0), 0, p.ShapeFilter())
+        assert hit is not None
+        self.assertEqual(hit.shape, s1)
+        self.assertEqual(hit.point, (29, 0))
+        self.assertEqual(hit.distance, -6)
+        self.assertEqual(hit.gradient, (1, 0))
+
+        hit = s.point_query_nearest((30, 0), 0, p.ShapeFilter())
+        self.assertEqual(hit, None)
+
+        hit = s.point_query_nearest((30, 0), 10, p.ShapeFilter())
+        assert hit is not None
+        self.assertEqual(hit.shape, s1)
+        self.assertEqual(hit.point, (29, 0))
+        self.assertEqual(hit.distance, 1)
+        self.assertEqual(hit.gradient, (1, 0))
+
+    def testPointQueryNearestSensor(self) -> None:
+        s = p.Space()
+        c = p.Circle(s.static_body, 10)
+        c.sensor = True
+        s.add(c)
+        hit = s.point_query_nearest((0, 0), 100, p.ShapeFilter())
+        self.assertEqual(hit, None)
+
+    def testBBQuery(self) -> None:
+        s = p.Space()
+
+        b1 = p.Body(1, 1)
+        b1.position = 19, 0
+        s1 = p.Circle(b1, 10)
+        s.add(b1, s1)
+
+        b2 = p.Body(1, 1)
+        b2.position = 0, 0
+        s2 = p.Circle(b2, 10)
+        s.add(b2, s2)
+
+        bb = p.BB(-7, -7, 7, 7)
+        hits = s.bb_query(bb, p.ShapeFilter())
+        self.assertEqual(len(hits), 1)
+        self.assertTrue(s2 in hits)
+        self.assertTrue(s1 not in hits)
+
+    def testBBQuerySensor(self) -> None:
+        s = p.Space()
+        c = p.Circle(s.static_body, 10)
+        c.sensor = True
+        s.add(c)
+        hits = s.bb_query(p.BB(0, 0, 10, 10), p.ShapeFilter())
+        self.assertEqual(len(hits), 1)
+
+    def testShapeQuery(self) -> None:
+        self._setUp()
+        b = p.Body(body_type=p.Body.KINEMATIC)
+        s = p.Circle(b, 2)
+        b.position = 20, 1
+
+        hits = self.s.shape_query(s)
+
+        self.assertEqual(len(hits), 1)
+        self.assertEqual(self.s2, hits[0].shape)
+        self._tearDown()
+
+    def testShapeQuerySensor(self) -> None:
+        s = p.Space()
+        c = p.Circle(s.static_body, 10)
+        c.sensor = True
+        s.add(c)
+        hits = s.shape_query(p.Circle(None, 200))
+        self.assertEqual(len(hits), 1)
+
+    def testStaticPointQueries(self) -> None:
+        self._setUp()
+        b = p.Body(body_type=p.Body.KINEMATIC)
+        c = p.Circle(b, 10)
+        b.position = -50, -50
+
+        self.s.add(b, c)
+
+        hit = self.s.point_query_nearest((-50, -55), 0, p.ShapeFilter())
+        assert hit is not None
+        self.assertEqual(hit.shape, c)
+
+        hits = self.s.point_query((-50, -55), 0, p.ShapeFilter())
+        self.assertEqual(hits[0].shape, c)
+        self._tearDown()
+
+    def testReindexShape(self) -> None:
+        s = p.Space()
+
+        b = p.Body(body_type=p.Body.KINEMATIC)
+        c = p.Circle(b, 10)
+
+        s.add(b, c)
+
+        b.position = -50, -50
+        hit = s.point_query_nearest((-50, -55), 0, p.ShapeFilter())
+        self.assertEqual(hit, None)
+        s.reindex_shape(c)
+        hit = s.point_query_nearest((-50, -55), 0, p.ShapeFilter())
+        assert hit is not None
+        self.assertEqual(hit.shape, c)
+
+    def testReindexShapesForBody(self) -> None:
+        s = p.Space()
+        b = p.Body(body_type=p.Body.STATIC)
+        c = p.Circle(b, 10)
+
+        s.add(b, c)
+
+        b.position = -50, -50
+        hit = s.point_query_nearest((-50, -55), 0, p.ShapeFilter())
+        self.assertEqual(hit, None)
+        s.reindex_shapes_for_body(b)
+
+        hit = s.point_query_nearest((-50, -55), 0, p.ShapeFilter())
+        assert hit is not None
+        self.assertEqual(hit.shape, c)
+
+    def testReindexStatic(self) -> None:
+        s = p.Space()
+        b = p.Body(body_type=p.Body.STATIC)
+        c = p.Circle(b, 10)
+
+        s.add(b, c)
+
+        b.position = -50, -50
+        hit = s.point_query_nearest((-50, -55), 0, p.ShapeFilter())
+        self.assertEqual(hit, None)
+        s.reindex_static()
+        hit = s.point_query_nearest((-50, -55), 0, p.ShapeFilter())
+        assert hit is not None
+        self.assertEqual(hit.shape, c)
+
+    def testReindexStaticCollision(self) -> None:
+        s = p.Space()
+        b1 = p.Body(10, 1000)
+        c1 = p.Circle(b1, 10)
+        b1.position = Vec2d(20, 20)
+
+        b2 = p.Body(body_type=p.Body.STATIC)
+        s2 = p.Segment(b2, (-10, 0), (10, 0), 1)
+
+        s.add(b1, c1)
+        s.add(b2, s2)
+
+        s2.unsafe_set_endpoints((-10, 0), (100, 0))
+        s.gravity = 0, -100
+
+        for _ in range(10):
+            s.step(0.1)
+
+        self.assertTrue(b1.position.y < 0)
+
+        b1.position = Vec2d(20, 20)
+        b1.velocity = 0, 0
+        s.reindex_static()
+
+        for _ in range(10):
+            s.step(0.1)
+
+        self.assertTrue(b1.position.y > 10)
+
+    def testSegmentQuery(self) -> None:
+        s = p.Space()
+
+        b1 = p.Body(1, 1)
+        b1.position = 19, 0
+        s1 = p.Circle(b1, 10)
+        s.add(b1, s1)
+
+        b2 = p.Body(1, 1)
+        b2.position = 0, 0
+        s2 = p.Circle(b2, 10)
+        s.add(b2, s2)
+
+        hits = s.segment_query((-13, 0), (131, 0), 0, p.ShapeFilter())
+
+        self.assertEqual(len(hits), 2)
+        self.assertEqual(hits[0].shape, s2)
+        self.assertEqual(hits[0].point, (-10, 0))
+        self.assertEqual(hits[0].normal, (-1, 0))
+        self.assertAlmostEqual(hits[0].alpha, 0.0208333333333)
+
+        self.assertEqual(hits[1].shape, s1)
+        self.assertEqual(hits[1].point, (9, 0))
+        self.assertEqual(hits[1].normal, (-1, 0))
+        self.assertAlmostEqual(hits[1].alpha, 0.1527777777777)
+
+        hits = s.segment_query((-13, 50), (131, 50), 0, p.ShapeFilter())
+        self.assertEqual(len(hits), 0)
+
+    def testSegmentQuerySensor(self) -> None:
+        s = p.Space()
+        c = p.Circle(s.static_body, 10)
+        c.sensor = True
+        s.add(c)
+        hits = s.segment_query((-20, 0), (20, 0), 1, p.ShapeFilter())
+        self.assertEqual(len(hits), 1)
+
+    def testSegmentQueryFirst(self) -> None:
+        s = p.Space()
+
+        b1 = p.Body(1, 1)
+        b1.position = 19, 0
+        s1 = p.Circle(b1, 10)
+        s.add(b1, s1)
+
+        b2 = p.Body(1, 1)
+        b2.position = 0, 0
+        s2 = p.Circle(b2, 10)
+        s.add(b2, s2)
+
+        hit = s.segment_query_first((-13, 0), (131, 0), 0, p.ShapeFilter())
+
+        assert hit is not None
+        self.assertEqual(hit.shape, s2)
+        self.assertEqual(hit.point, (-10, 0))
+        self.assertEqual(hit.normal, (-1, 0))
+        self.assertAlmostEqual(hit.alpha, 0.0208333333333)
+
+        hit = s.segment_query_first((-13, 50), (131, 50), 0, p.ShapeFilter())
+        self.assertEqual(hit, None)
+
+    def testSegmentQueryFirstSensor(self) -> None:
+        s = p.Space()
+        c = p.Circle(s.static_body, 10)
+        c.sensor = True
+        s.add(c)
+        hit = s.segment_query_first((-20, 0), (20, 0), 1, p.ShapeFilter())
+        self.assertIsNone(hit)
+
+    def testStaticSegmentQueries(self) -> None:
+        self._setUp()
+        b = p.Body(body_type=p.Body.KINEMATIC)
+        c = p.Circle(b, 10)
+        b.position = -50, -50
+
+        self.s.add(b, c)
+
+        hit = self.s.segment_query_first((-70, -50), (-30, -50), 0, p.ShapeFilter())
+        assert hit is not None
+        self.assertEqual(hit.shape, c)
+        hits = self.s.segment_query((-70, -50), (-30, -50), 0, p.ShapeFilter())
+        self.assertEqual(hits[0].shape, c)
+        self._tearDown()
+
+    def testCollisionHandlerBegin(self) -> None:
+        s = p.Space()
+        b1 = p.Body(1, 1)
+        c1 = p.Circle(b1, 10)
+        b2 = p.Body(1, 1)
+        c2 = p.Circle(b2, 10)
+        s.add(b1, c1, b2, c2)
+
+        self.hits = 0
+
+        def begin(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
+            self.hits += h.data["test"]
+            return True
+
+        h = s.add_collision_handler(0, 0)
+        h.data["test"] = 1
+        h.begin = begin
+
+        for x in range(10):
+            s.step(0.1)
+
+        self.assertEqual(self.hits, 1)
+
+    def testCollisionHandlerBeginNoReturn(self) -> None:
+        s = p.Space()
+        b1 = p.Body(1, 1)
+        c1 = p.Circle(b1, 10)
+        b2 = p.Body(1, 1)
+        c2 = p.Circle(b2, 10)
+        s.add(b1, c1, b2, c2)
+
+        with warnings.catch_warnings(record=True) as w:
+            warnings.simplefilter("always")
+
+            def begin(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
+                return  # type: ignore
+
+            s.add_collision_handler(0, 0).begin = begin
+            s.step(0.1)
+
+            assert w is not None
+            self.assertEqual(len(w), 1)
+            self.assertTrue(issubclass(w[-1].category, UserWarning))
+
+    def testCollisionHandlerPreSolve(self) -> None:
+        s = p.Space()
+        b1 = p.Body(1, 1)
+        c1 = p.Circle(b1, 10)
+        c1.collision_type = 1
+        b2 = p.Body(1, 1)
+        c2 = p.Circle(b2, 10)
+        s.add(b1, c1, b2, c2)
+
+        d = {}
+
+        def pre_solve(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
+            d["shapes"] = arb.shapes
+            d["space"] = space  # type: ignore
+            d["test"] = data["test"]
+            return True
+
+        h = s.add_collision_handler(0, 1)
+        h.data["test"] = 1
+        h.pre_solve = pre_solve
+        s.step(0.1)
+        self.assertEqual(c1, d["shapes"][1])
+        self.assertEqual(c2, d["shapes"][0])
+        self.assertEqual(s, d["space"])
+        self.assertEqual(1, d["test"])
+
+    def testCollisionHandlerPreSolveNoReturn(self) -> None:
+        s = p.Space()
+        b1 = p.Body(1, 1)
+        c1 = p.Circle(b1, 10)
+        b2 = p.Body(1, 1)
+        c2 = p.Circle(b2, 10)
+        s.add(b1, c1, b2, c2)
+
+        def pre_solve(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
+            return  # type: ignore
+
+        s.add_collision_handler(0, 0).pre_solve = pre_solve
+
+        with warnings.catch_warnings(record=True) as w:
+            warnings.simplefilter("always")
+
+            s.step(0.1)
+            assert w is not None
+            self.assertEqual(len(w), 1)
+            self.assertTrue(issubclass(w[-1].category, UserWarning))
+
+    def testCollisionHandlerPostSolve(self) -> None:
+        self._setUp()
+        self.hit = 0
+
+        def post_solve(arb: p.Arbiter, space: p.Space, data: Any) -> None:
+            self.hit += 1
+
+        self.s.add_collision_handler(0, 0).post_solve = post_solve
+        self.s.step(0.1)
+        self.assertEqual(self.hit, 1)
+        self._tearDown()
+
+    def testCollisionHandlerSeparate(self) -> None:
+        s = p.Space()
+
+        b1 = p.Body(1, 1)
+        c1 = p.Circle(b1, 10)
+        b1.position = 9, 11
+
+        b2 = p.Body(body_type=p.Body.STATIC)
+        c2 = p.Circle(b2, 10)
+        b2.position = 0, 0
+
+        s.add(b1, c1, b2, c2)
+        s.gravity = 0, -100
+
+        self.separated = False
+
+        def separate(arb: p.Arbiter, space: p.Space, data: Any) -> None:
+            self.separated = data["test"]
+
+        h = s.add_collision_handler(0, 0)
+        h.data["test"] = True
+        h.separate = separate
+
+        for x in range(10):
+            s.step(0.1)
+
+        self.assertTrue(self.separated)
+
+    def testCollisionHandlerRemoveSeparateAdd(self) -> None:
+        s = p.Space()
+        b1 = p.Body(1, 10)
+        c1 = p.Circle(b1, 10)
+        c2 = p.Circle(s.static_body, 5)
+
+        s.add(b1, c1, c2)
+
+        def separate(*_: Any) -> None:
+            s.add(p.Circle(s.static_body, 2))
+            s.remove(c1)
+
+        s.add_default_collision_handler().separate = separate
+
+        s.step(1)
+        s.remove(c1)
+
+    def testCollisionHandlerKeyOrder(self) -> None:
+        s = p.Space()
+        h1 = s.add_collision_handler(1, 2)
+        h2 = s.add_collision_handler(2, 1)
+
+        self.assertEqual(h1, h2)
+
+    def testWildcardCollisionHandler(self) -> None:
+        s = p.Space()
+        b1 = p.Body(1, 1)
+        c1 = p.Circle(b1, 10)
+        b2 = p.Body(1, 1)
+        c2 = p.Circle(b2, 10)
+        s.add(b1, c1, b2, c2)
+
+        d = {}
+
+        def pre_solve(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
+            d["shapes"] = arb.shapes
+            d["space"] = space  # type: ignore
+            return True
+
+        s.add_wildcard_collision_handler(1).pre_solve = pre_solve
+        s.step(0.1)
+
+        self.assertEqual({}, d)
+
+        c1.collision_type = 1
+        s.step(0.1)
+
+        self.assertEqual(c1, d["shapes"][0])
+        self.assertEqual(c2, d["shapes"][1])
+        self.assertEqual(s, d["space"])
+
+    def testDefaultCollisionHandler(self) -> None:
+        s = p.Space()
+        b1 = p.Body(1, 1)
+        c1 = p.Circle(b1, 10)
+        c1.collision_type = 1
+        b2 = p.Body(1, 1)
+        c2 = p.Circle(b2, 10)
+        c2.collision_type = 2
+        s.add(b1, c1, b2, c2)
+
+        d = {}
+
+        def pre_solve(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
+            d["shapes"] = arb.shapes
+            d["space"] = space  # type: ignore
+            return True
+
+        s.add_default_collision_handler().pre_solve = pre_solve
+        s.step(0.1)
+
+        self.assertEqual(c1, d["shapes"][1])
+        self.assertEqual(c2, d["shapes"][0])
+        self.assertEqual(s, d["space"])
+
+    def testPostStepCallback(self) -> None:
+        s = p.Space()
+        b1, b2 = p.Body(1, 3), p.Body(10, 100)
+        s.add(b1, b2)
+        b1.position = 10, 0
+        b2.position = 20, 0
+        s1, s2 = p.Circle(b1, 5), p.Circle(b2, 10)
+        s.add(s1, s2)
+
+        self.calls = 0
+
+        def callback(
+            space: p.Space,
+            key: Any,
+            shapes: Sequence[Shape],
+            test_self: "UnitTestSpace",
+        ) -> None:
+            for shape in shapes:
+                s.remove(shape)
+            test_self.calls += 1
+
+        def pre_solve(arb: p.Arbiter, space: p.Space, data: Any) -> bool:
+            # note that we dont pass on the whole arbiters object, instead
+            # we take only the shapes.
+            space.add_post_step_callback(callback, 0, arb.shapes, test_self=self)
+            return True
+
+        ch = s.add_collision_handler(0, 0).pre_solve = pre_solve
+
+        s.step(0.1)
+        self.assertEqual([], s.shapes)
+        self.assertEqual(self.calls, 1)
+
+        s.step(0.1)
+
+        self.assertEqual(self.calls, 1)
+
+    def testDebugDraw(self) -> None:
+        s = p.Space()
+
+        b1 = p.Body(1, 3)
+        s1 = p.Circle(b1, 5)
+        s.add(b1, s1)
+        s.step(1)
+        o = p.SpaceDebugDrawOptions()
+
+        new_out = io.StringIO()
+        sys.stdout = new_out
+        try:
+            s.debug_draw(o)
+        finally:
+            sys.stdout = sys.__stdout__
+
+        msg = (
+            "draw_circle (Vec2d(0.0, 0.0), 0.0, 5.0, "
+            "SpaceDebugColor(r=44.0, g=62.0, b=80.0, a=255.0), "
+            "SpaceDebugColor(r=52.0, g=152.0, b=219.0, a=255.0))\n"
+        )
+        self.assertEqual(msg, new_out.getvalue())
+
+    @unittest.skip(
+        "Different behavior on windows sometimes. Expect it to be fixed in next major python version"
+    )
+    def testDebugDrawZeroLengthSpring(self) -> None:
+        if sys.version_info < (3, 0):
+            return
+        s = p.Space()
+
+        b1 = p.Body(1, 3)
+        c = DampedSpring(b1, s.static_body, (0, 0), (0, 0), 0, 10, 1)
+        s.add(b1, c)
+
+        s.step(1)
+        o = p.SpaceDebugDrawOptions()
+
+        new_out = io.StringIO()
+        sys.stdout = new_out
+        try:
+            s.debug_draw(o)
+        finally:
+            sys.stdout = sys.__stdout__
+
+        expected = (
+            "draw_dot (5.0, Vec2d(0.0, 0.0), SpaceDebugColor(r=142.0, g=68.0, b=173.0, a=255.0))\n"
+            "draw_dot (5.0, Vec2d(0.0, 0.0), SpaceDebugColor(r=142.0, g=68.0, b=173.0, a=255.0)) \n"
+            "draw_segment (Vec2d(0.0, 0.0), Vec2d(0.0, 0.0), SpaceDebugColor(r=142.0, g=68.0, b=173.0, a=255.0))\n"
+            "draw_segment (Vec2d(0.0, 0.0), Vec2d(0.0, 0.0), SpaceDebugColor(r=142.0, g=68.0, b=173.0, a=255.0))\n"
+        )
+
+        actual = new_out.getvalue()
+        try:
+            self.assertEqual(expected, actual)
+        except:
+            print("\nExpected", expected)
+            print("\nActual", actual)
+            raise
+
+    def testPicklePymunkVersionCheck(self) -> None:
+        pickle_string = b"\x80\x04\x95\xc5\x01\x00\x00\x00\x00\x00\x00\x8c\x0cpymunk.space\x94\x8c\x05Space\x94\x93\x94)\x81\x94}\x94(\x8c\x04init\x94]\x94\x8c\x08threaded\x94\x89\x86\x94a\x8c\x07general\x94]\x94(\x8c\niterations\x94K\n\x86\x94\x8c\x07gravity\x94\x8c\x0cpymunk.vec2d\x94\x8c\x05Vec2d\x94\x93\x94G\x00\x00\x00\x00\x00\x00\x00\x00G\x00\x00\x00\x00\x00\x00\x00\x00\x86\x94R\x94\x86\x94\x8c\x07damping\x94G?\xf0\x00\x00\x00\x00\x00\x00\x86\x94\x8c\x14idle_speed_threshold\x94G\x00\x00\x00\x00\x00\x00\x00\x00\x86\x94\x8c\x14sleep_time_threshold\x94G\x7f\xf0\x00\x00\x00\x00\x00\x00\x86\x94\x8c\x0ecollision_slop\x94G?\xb9\x99\x99\xa0\x00\x00\x00\x86\x94\x8c\x0ecollision_bias\x94G?]q2\x0c\xdfCc\x86\x94\x8c\x15collision_persistence\x94K\x03\x86\x94\x8c\x07threads\x94K\x01\x86\x94e\x8c\x06custom\x94]\x94h\x07\x89\x86\x94a\x8c\x07special\x94]\x94(\x8c\x0epymunk_version\x94\x8c\x050.0.1\x94\x86\x94\x8c\x06bodies\x94]\x94\x86\x94\x8c\x06shapes\x94]\x94\x86\x94\x8c\x0bconstraints\x94]\x94\x86\x94\x8c\t_handlers\x94]\x94\x86\x94eub."
+
+        with self.assertRaisesRegex(
+            AssertionError,
+            r"Pymunk version [0-9.]+ of pickled object does not match current Pymunk version [0-9.]+",
+        ):
+            pickle.loads(pickle_string)
+
+    def testCopyMethods(self) -> None:
+        self._testCopyMethod(lambda x: cast(Space, pickle.loads(pickle.dumps(x))))
+        self._testCopyMethod(lambda x: copy.deepcopy(x))
+        self._testCopyMethod(lambda x: x.copy())
+
+    def _testCopyMethod(self, copy_func: Callable[[Space], Space]) -> None:
+        s = p.Space(threaded=True)
+        s.iterations = 2
+        s.gravity = 3, 4
+        s.damping = 5
+        s.idle_speed_threshold = 6
+        s.sleep_time_threshold = 7
+        s.collision_slop = 8
+        s.collision_bias = 9
+        s.collision_persistence = 10
+        s.threads = 2
+
+        b1 = p.Body(1, 2)
+        b2 = p.Body(3, 4)
+        b3 = p.Body(5, 6)
+        c1 = p.Circle(b1, 7)
+        c2 = p.Circle(b1, 8)
+        c3 = p.Circle(b2, 9)
+        c4 = p.Circle(s.static_body, 10)
+        s.add(b1, b2, b3, c1, c2, c3, c4)
+        s.static_body.custom = "x"
+
+        j1 = PinJoint(b1, b2)
+        j2 = PinJoint(s.static_body, b2)
+        s.add(j1, j2)
+
+        h = s.add_default_collision_handler()
+        h.begin = f1
+
+        h = s.add_wildcard_collision_handler(1)
+        h.pre_solve = f1
+
+        h = s.add_collision_handler(1, 2)
+        h.post_solve = f1
+
+        h = s.add_collision_handler(3, 4)
+        h.separate = f1
+
+        s2 = copy_func(s)
+
+        # Assert properties
+        self.assertEqual(s.threaded, s2.threaded)
+        self.assertEqual(s.iterations, s2.iterations)
+        self.assertEqual(s.gravity, s2.gravity)
+        self.assertEqual(s.damping, s2.damping)
+        self.assertEqual(s.idle_speed_threshold, s2.idle_speed_threshold)
+        self.assertEqual(s.sleep_time_threshold, s2.sleep_time_threshold)
+        self.assertEqual(s.collision_slop, s2.collision_slop)
+        self.assertEqual(s.collision_bias, s2.collision_bias)
+        self.assertEqual(s.collision_persistence, s2.collision_persistence)
+        self.assertEqual(s.threads, s2.threads)
+
+        # Assert shapes, bodies and constriants
+        self.assertEqual([c.radius for c in s2.shapes], [7, 8, 9, 10])
+        self.assertEqual([b.mass for b in s2.bodies], [1, 3, 5])
+        self.assertEqual(s.static_body.custom, s2.static_body.custom)
+        ja = [j.a for j in s2.constraints]
+        self.assertIn(s2.static_body, ja)
+
+        # Assert collision handlers
+        h2 = s2.add_default_collision_handler()
+        self.assertIsNotNone(h2.begin)
+        self.assertIsNone(h2.pre_solve)
+        self.assertIsNone(h2.post_solve)
+        self.assertIsNone(h2.separate)
+
+        h2 = s2.add_wildcard_collision_handler(1)
+        self.assertIsNone(h2.begin)
+        self.assertIsNotNone(h2.pre_solve)
+        self.assertIsNone(h2.post_solve)
+        self.assertIsNone(h2.separate)
+
+        h2 = s2.add_collision_handler(1, 2)
+        self.assertIsNone(h2.begin)
+        self.assertIsNone(h2.pre_solve)
+        self.assertIsNotNone(h2.post_solve)
+        self.assertIsNone(h2.separate)
+
+        h2 = s2.add_collision_handler(3, 4)
+        self.assertIsNone(h2.begin)
+        self.assertIsNone(h2.pre_solve)
+        self.assertIsNone(h2.post_solve)
+        self.assertIsNotNone(h2.separate)
+
+    def testPickleCachedArbiters(self) -> None:
+        s = p.Space()
+        
+        b1 = p.Body()
+        b2 = p.Body()
+
+        c1 = p.Circle(b1, 10)
+        c2 = p.Circle(b2, 10)
+
+        c1.mass = 1
+        c2.mass = 1
+
+        b2.position = 1,2
+        s.add(c1,c2, b1, b2)
+        
+        s.step(0.1)
+        # print("\nOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO")
+        s_copy = s.copy()
+        
+        # a1 = [p.arbiter._arbiter_to_dict(_arb, s) for _arb in s._get_arbiters()]
+        # a2 = [p.arbiter._arbiter_to_dict(_arb, s_copy) for _arb in s_copy._get_arbiters()]
+        
+        # print("a1", a1)
+        # print("a2", a2)
+        # print("XXXX")
+        
+        # print("s.bodies.position:")
+        # print([b.position for b in s.bodies])
+        # print("s_copy.bodies.position:")
+        # print([b.position for b in s_copy.bodies])
+
+
+        s.step(0.1)
+        s_copy.step(0.1)
+        
+        # a1 = [p.arbiter._arbiter_to_dict(_arb, s) for _arb in s._get_arbiters()]
+        # a2 = [p.arbiter._arbiter_to_dict(_arb, s_copy) for _arb in s_copy._get_arbiters()]
+        
+        # print("a1", a1)
+        # print("a2", a2)
+        # print("XXXX")
+
+        # print("s.bodies.position:")
+        # print([b.position for b in s.bodies])
+        # print("s_copy.bodies.position:")
+        # print([b.position for b in s_copy.bodies])
+
+        s_copy.step(0.1)
+
+        # a1 = [p.arbiter._arbiter_to_dict(_arb, s) for _arb in s._get_arbiters()]
+        # a2 = [p.arbiter._arbiter_to_dict(_arb, s_copy) for _arb in s_copy._get_arbiters()]
+        
+        # print("a1", a1)
+        # print("a2", a2)
+        # print("XXXX")
+
+        # print("s.bodies.position:")
+        # print([b.position for b in s.bodies])
+        # print("s_copy.bodies.position:")
+        # print([b.position for b in s_copy.bodies])
+
+        # TODO: to assert that everything is working as it should all 
+        # properties on the cached the arbiters should be asserted.
+
+
+        self.assertAlmostEqual(s.bodies[0].position.x, s_copy.bodies[0].position.x)
+        self.assertAlmostEqual(s.bodies[0].position.y, s_copy.bodies[0].position.y)
+
+
+
+def f1(*args: Any, **kwargs: Any) -> None:
+    pass
```

## Comparing `pymunk-6.5.0/pymunk/tests/test_space_debug_draw_options.py` & `pymunk/tests/test_space_debug_draw_options.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,41 +1,41 @@
-import unittest
-from io import StringIO
-from unittest.mock import patch
-
-import pymunk
-
-
-class UnitTestSpaceDebugDrawOptions(unittest.TestCase):
-    def testTransform(self) -> None:
-        options = pymunk.SpaceDebugDrawOptions()
-        transform = pymunk.Transform.translation(2, 3).scaled(2)
-        options.transform = transform
-        self.assertEqual(options.transform, transform)
-
-        space = pymunk.Space()
-        body = pymunk.Body(1, 10)
-        body.position = 4, 5
-        space.add(
-            body,
-            pymunk.Circle(body, 2, offset=(-4, -5)),
-            pymunk.Segment(body, (0, 0), (3, 4), 3),
-            pymunk.Poly(body, [(5, 0), (5, 5), (7, 3)], None, 4),
-        )
-
-        with patch("sys.stdout", new=StringIO()) as out:
-            space.debug_draw(options)
-            actual = out.getvalue()
-
-        self.assertEqual(
-            actual,
-            "draw_circle (Vec2d(2.0, 3.0), 0.0, 4.0, "
-            "SpaceDebugColor(r=44.0, g=62.0, b=80.0, a=255.0), "
-            "SpaceDebugColor(r=52.0, g=152.0, b=219.0, a=255.0))\n"
-            "draw_fat_segment (Vec2d(10.0, 13.0), Vec2d(16.0, 21.0), 6.0, "
-            "SpaceDebugColor(r=44.0, g=62.0, b=80.0, a=255.0), "
-            "SpaceDebugColor(r=52.0, g=152.0, b=219.0, a=255.0))\n"
-            "draw_polygon "
-            "([Vec2d(20.0, 13.0), Vec2d(24.0, 19.0), Vec2d(20.0, 23.0)], 8.0, "
-            "SpaceDebugColor(r=44.0, g=62.0, b=80.0, a=255.0), "
-            "SpaceDebugColor(r=52.0, g=152.0, b=219.0, a=255.0))\n",
-        )
+import unittest
+from io import StringIO
+from unittest.mock import patch
+
+import pymunk
+
+
+class UnitTestSpaceDebugDrawOptions(unittest.TestCase):
+    def testTransform(self) -> None:
+        options = pymunk.SpaceDebugDrawOptions()
+        transform = pymunk.Transform.translation(2, 3).scaled(2)
+        options.transform = transform
+        self.assertEqual(options.transform, transform)
+
+        space = pymunk.Space()
+        body = pymunk.Body(1, 10)
+        body.position = 4, 5
+        space.add(
+            body,
+            pymunk.Circle(body, 2, offset=(-4, -5)),
+            pymunk.Segment(body, (0, 0), (3, 4), 3),
+            pymunk.Poly(body, [(5, 0), (5, 5), (7, 3)], None, 4),
+        )
+
+        with patch("sys.stdout", new=StringIO()) as out:
+            space.debug_draw(options)
+            actual = out.getvalue()
+
+        self.assertEqual(
+            actual,
+            "draw_circle (Vec2d(2.0, 3.0), 0.0, 4.0, "
+            "SpaceDebugColor(r=44.0, g=62.0, b=80.0, a=255.0), "
+            "SpaceDebugColor(r=52.0, g=152.0, b=219.0, a=255.0))\n"
+            "draw_fat_segment (Vec2d(10.0, 13.0), Vec2d(16.0, 21.0), 6.0, "
+            "SpaceDebugColor(r=44.0, g=62.0, b=80.0, a=255.0), "
+            "SpaceDebugColor(r=52.0, g=152.0, b=219.0, a=255.0))\n"
+            "draw_polygon "
+            "([Vec2d(20.0, 13.0), Vec2d(24.0, 19.0), Vec2d(20.0, 23.0)], 8.0, "
+            "SpaceDebugColor(r=44.0, g=62.0, b=80.0, a=255.0), "
+            "SpaceDebugColor(r=52.0, g=152.0, b=219.0, a=255.0))\n",
+        )
```

## Comparing `pymunk-6.5.0/pymunk/tests/__init__.py` & `pymunk/tests/__init__.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,97 +1,97 @@
-"""
-The Pymunk test suite.
-
-The tests cover most of Pymunk and is quick to run. However, some parts 
-requires an additional dependency to tests, e.g. to test pygame the pygame 
-library must be installed. 
-
-Tests can be run both by running the module from a shell::
-
-$> python -m pymunk.tests
-
-But also by importing and running the run_tests method from a python prompt::
-
-    > from pymunk.tests import run_tests
-    > run_tests()
-
-Some arguments are allowed to the tests. You can show them with the --help 
-flag::
-
-    $> python pymunk.tests --help
-
-It is possible to filter out tests with the filter parameter. Tests containing 
-the filter will be run, the others skipped. A special case is doctests, which 
-can be matched against the filter doctest::
-
-$> python -m pymunk.tests -f testTransform
-$> python -m pymynk.tests -f doctest
-
-By default all tests will run except those with an additional dependency. To 
-run tests with dependencies, specify them with the -d parameter::
-
-$> python -m pymunk.tests -d pygame
-
-Note that the tests covers most/all of Pymunk, but does not test the 
-underlying Chipmunk library in a significant way except as a side effect of 
-testing Pymunk features.
-"""
-
-import doctest
-import faulthandler
-import logging
-import os
-import os.path
-import platform
-import sys
-import unittest
-from typing import Any, Iterator, List
-
-from . import doctests
-
-
-def run_tests(filter: str = "", with_dependencies: List[str] = []) -> bool:
-    """Run the Pymunk test suite."""
-
-    faulthandler.enable()
-    print("####################")
-    print("RUNNING pymunk.tests")
-    print("Python / platform:")
-    print(sys.version)
-    try:
-        import cffi  # type: ignore
-
-        print(
-            f"on {platform.system()} {platform.machine()} using cffi {cffi.__version__}"
-        )
-    except:
-        pass
-    print("")
-
-    def list_of_tests_gen(s: Any) -> Iterator[Any]:
-        for test in s:
-            if unittest.suite._isnotsuite(test):  # type: ignore
-                yield test
-            else:
-                for t in list_of_tests_gen(test):
-                    yield t
-
-    path = os.path.dirname(os.path.abspath(__file__))
-    suite = unittest.TestLoader().discover(path)
-
-    doctests.load_tests(suite, with_dependencies)
-
-    filtered_suite = unittest.TestSuite()
-
-    if filter is not None:
-        for test in list_of_tests_gen(suite):
-            if (
-                isinstance(test, doctest.DocTestCase)
-                and filter.startswith("doctest")
-                or filter in str(test.id())
-            ):
-                filtered_suite.addTest(test)
-    else:
-        filtered_suite = suite
-
-    res = unittest.TextTestRunner(verbosity=2).run(filtered_suite)
-    return res.wasSuccessful()
+"""
+The Pymunk test suite.
+
+The tests cover most of Pymunk and is quick to run. However, some parts 
+requires an additional dependency to tests, e.g. to test pygame the pygame 
+library must be installed. 
+
+Tests can be run both by running the module from a shell::
+
+$> python -m pymunk.tests
+
+But also by importing and running the run_tests method from a python prompt::
+
+    > from pymunk.tests import run_tests
+    > run_tests()
+
+Some arguments are allowed to the tests. You can show them with the --help 
+flag::
+
+    $> python pymunk.tests --help
+
+It is possible to filter out tests with the filter parameter. Tests containing 
+the filter will be run, the others skipped. A special case is doctests, which 
+can be matched against the filter doctest::
+
+$> python -m pymunk.tests -f testTransform
+$> python -m pymynk.tests -f doctest
+
+By default all tests will run except those with an additional dependency. To 
+run tests with dependencies, specify them with the -d parameter::
+
+$> python -m pymunk.tests -d pygame
+
+Note that the tests covers most/all of Pymunk, but does not test the 
+underlying Chipmunk library in a significant way except as a side effect of 
+testing Pymunk features.
+"""
+
+import doctest
+import faulthandler
+import logging
+import os
+import os.path
+import platform
+import sys
+import unittest
+from typing import Any, Iterator, List
+
+from . import doctests
+
+
+def run_tests(filter: str = "", with_dependencies: List[str] = []) -> bool:
+    """Run the Pymunk test suite."""
+
+    faulthandler.enable()
+    print("####################")
+    print("RUNNING pymunk.tests")
+    print("Python / platform:")
+    print(sys.version)
+    try:
+        import cffi  # type: ignore
+
+        print(
+            f"on {platform.system()} {platform.machine()} using cffi {cffi.__version__}"
+        )
+    except:
+        pass
+    print("")
+
+    def list_of_tests_gen(s: Any) -> Iterator[Any]:
+        for test in s:
+            if unittest.suite._isnotsuite(test):  # type: ignore
+                yield test
+            else:
+                for t in list_of_tests_gen(test):
+                    yield t
+
+    path = os.path.dirname(os.path.abspath(__file__))
+    suite = unittest.TestLoader().discover(path)
+
+    doctests.load_tests(suite, with_dependencies)
+
+    filtered_suite = unittest.TestSuite()
+
+    if filter is not None:
+        for test in list_of_tests_gen(suite):
+            if (
+                isinstance(test, doctest.DocTestCase)
+                and filter.startswith("doctest")
+                or filter in str(test.id())
+            ):
+                filtered_suite.addTest(test)
+    else:
+        filtered_suite = suite
+
+    res = unittest.TextTestRunner(verbosity=2).run(filtered_suite)
+    return res.wasSuccessful()
```


# Comparing `tmp/pasta_eln-2.3.9-py3-none-any.whl.zip` & `tmp/pasta_eln-2.4.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,52 +1,51 @@
-Zip file size: 113659 bytes, number of entries: 50
--rw-r--r--  2.0 unx       46 b- defN 23-Apr-05 18:33 pasta_eln/__init__.py
--rw-r--r--  2.0 unx    29288 b- defN 23-Apr-05 18:33 pasta_eln/backend.py
--rw-r--r--  2.0 unx    13707 b- defN 23-Apr-05 18:33 pasta_eln/cli.py
--rw-r--r--  2.0 unx      977 b- defN 23-Apr-05 18:33 pasta_eln/communicate.py
--rw-r--r--  2.0 unx    36715 b- defN 23-Apr-05 18:33 pasta_eln/database.py
--rw-r--r--  2.0 unx     1666 b- defN 23-Apr-05 18:33 pasta_eln/dialogConfig.py
--rw-r--r--  2.0 unx     3365 b- defN 23-Apr-05 18:33 pasta_eln/dialogConfigGUI.py
--rw-r--r--  2.0 unx     5348 b- defN 23-Apr-05 18:33 pasta_eln/dialogConfigSetupLinux.py
--rw-r--r--  2.0 unx     6340 b- defN 23-Apr-05 18:33 pasta_eln/dialogConfigSetupWindows.py
--rw-r--r--  2.0 unx    11334 b- defN 23-Apr-05 18:33 pasta_eln/dialogForm.py
--rw-r--r--  2.0 unx     1293 b- defN 23-Apr-05 18:33 pasta_eln/dialogOntology.py
--rw-r--r--  2.0 unx     9042 b- defN 23-Apr-05 18:33 pasta_eln/dialogProjectGroup.py
--rw-r--r--  2.0 unx     5588 b- defN 23-Apr-05 18:33 pasta_eln/dialogTableHeader.py
--rw-r--r--  2.0 unx     5349 b- defN 23-Apr-05 18:33 pasta_eln/fixedStrings.py
--rw-r--r--  2.0 unx     8305 b- defN 23-Apr-05 18:33 pasta_eln/gui.py
--rw-r--r--  2.0 unx     7941 b- defN 23-Apr-05 18:33 pasta_eln/gui.py.orig
--rw-r--r--  2.0 unx     4395 b- defN 23-Apr-05 18:33 pasta_eln/handleDictionaries.py
--rw-r--r--  2.0 unx    15445 b- defN 23-Apr-05 18:33 pasta_eln/inputOutput.py
--rw-r--r--  2.0 unx    21395 b- defN 23-Apr-05 18:33 pasta_eln/installationTools.py
--rw-r--r--  2.0 unx     6541 b- defN 23-Apr-05 18:33 pasta_eln/miscTools.py
--rw-r--r--  2.0 unx     7602 b- defN 23-Apr-05 18:33 pasta_eln/mixin_cli.py
--rw-r--r--  2.0 unx     3764 b- defN 23-Apr-05 18:33 pasta_eln/printer.py
--rw-r--r--  2.0 unx    19199 b- defN 23-Apr-05 18:33 pasta_eln/serverActions.py
--rw-r--r--  2.0 unx     7871 b- defN 23-Apr-05 18:33 pasta_eln/style.py
--rw-r--r--  2.0 unx     1234 b- defN 23-Apr-05 18:33 pasta_eln/tempStrings.py
--rw-r--r--  2.0 unx     1340 b- defN 23-Apr-05 18:33 pasta_eln/widgetBody.py
--rw-r--r--  2.0 unx     8370 b- defN 23-Apr-05 18:33 pasta_eln/widgetDetails.py
--rw-r--r--  2.0 unx     1243 b- defN 23-Apr-05 18:33 pasta_eln/widgetDocTypes.py
--rw-r--r--  2.0 unx    10151 b- defN 23-Apr-05 18:33 pasta_eln/widgetProject.py
--rw-r--r--  2.0 unx     5192 b- defN 23-Apr-05 18:33 pasta_eln/widgetProjectLeafRenderer.py
--rw-r--r--  2.0 unx     4453 b- defN 23-Apr-05 18:33 pasta_eln/widgetProjectTreeView.py
--rw-r--r--  2.0 unx     7297 b- defN 23-Apr-05 18:33 pasta_eln/widgetSidebar.py
--rw-r--r--  2.0 unx    13168 b- defN 23-Apr-05 18:33 pasta_eln/widgetTable.py
--rw-r--r--  2.0 unx      356 b- defN 23-Apr-05 18:33 pasta_eln/Extractors/README.md
--rw-r--r--  2.0 unx     1473 b- defN 23-Apr-05 18:33 pasta_eln/Extractors/extractor_csv.py
--rw-r--r--  2.0 unx     1286 b- defN 23-Apr-05 18:33 pasta_eln/Extractors/extractor_jpeg.py
--rw-r--r--  2.0 unx     1283 b- defN 23-Apr-05 18:33 pasta_eln/Extractors/extractor_jpg.py
--rw-r--r--  2.0 unx      822 b- defN 23-Apr-05 18:33 pasta_eln/Extractors/extractor_json.py
--rw-r--r--  2.0 unx      679 b- defN 23-Apr-05 18:33 pasta_eln/Extractors/extractor_md.py
--rw-r--r--  2.0 unx     1903 b- defN 23-Apr-05 18:33 pasta_eln/Extractors/extractor_png.py
--rw-r--r--  2.0 unx      187 b- defN 23-Apr-05 18:33 pasta_eln/Resources/ExampleMeasurements/simple.csv
--rw-r--r--  2.0 unx     9450 b- defN 23-Apr-05 18:33 pasta_eln/Resources/ExampleMeasurements/simple.png
--rw-r--r--  2.0 unx     5694 b- defN 23-Apr-05 18:33 pasta_eln/Resources/Icons/favicon64.ico
--rw-r--r--  2.0 unx     2161 b- defN 23-Apr-05 18:33 pasta_eln/Resources/Icons/favicon64.png
--rw-r--r--  2.0 unx     1613 b- defN 23-Apr-05 18:33 pasta_eln-2.3.9.dist-info/LICENSE
--rw-r--r--  2.0 unx     3249 b- defN 23-Apr-05 18:33 pasta_eln-2.3.9.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Apr-05 18:33 pasta_eln-2.3.9.dist-info/WHEEL
--rw-r--r--  2.0 unx      150 b- defN 23-Apr-05 18:33 pasta_eln-2.3.9.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       10 b- defN 23-Apr-05 18:33 pasta_eln-2.3.9.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     4276 b- defN 23-Apr-05 18:33 pasta_eln-2.3.9.dist-info/RECORD
-50 files, 319648 bytes uncompressed, 106871 bytes compressed:  66.6%
+Zip file size: 126789 bytes, number of entries: 49
+-rw-r--r--  2.0 unx       46 b- defN 23-Jun-26 11:34 pasta_eln/__init__.py
+-rw-r--r--  2.0 unx    34824 b- defN 23-Jun-26 11:34 pasta_eln/backend.py
+-rw-r--r--  2.0 unx    14028 b- defN 23-Jun-26 11:34 pasta_eln/cli.py
+-rw-r--r--  2.0 unx     1429 b- defN 23-Jun-26 11:34 pasta_eln/communicate.py
+-rw-r--r--  2.0 unx    41851 b- defN 23-Jun-26 11:34 pasta_eln/database.py
+-rw-r--r--  2.0 unx     1513 b- defN 23-Jun-26 11:34 pasta_eln/dialogConfig.py
+-rw-r--r--  2.0 unx     3520 b- defN 23-Jun-26 11:34 pasta_eln/dialogConfigGUI.py
+-rw-r--r--  2.0 unx     5178 b- defN 23-Jun-26 11:34 pasta_eln/dialogConfigSetupLinux.py
+-rw-r--r--  2.0 unx     6323 b- defN 23-Jun-26 11:34 pasta_eln/dialogConfigSetupWindows.py
+-rw-r--r--  2.0 unx    20797 b- defN 23-Jun-26 11:34 pasta_eln/dialogForm.py
+-rw-r--r--  2.0 unx     1291 b- defN 23-Jun-26 11:34 pasta_eln/dialogOntology.py
+-rw-r--r--  2.0 unx     9004 b- defN 23-Jun-26 11:34 pasta_eln/dialogProjectGroup.py
+-rw-r--r--  2.0 unx     5468 b- defN 23-Jun-26 11:34 pasta_eln/dialogTableHeader.py
+-rw-r--r--  2.0 unx     5233 b- defN 23-Jun-26 11:34 pasta_eln/fixedStrings.py
+-rw-r--r--  2.0 unx     9559 b- defN 23-Jun-26 11:34 pasta_eln/gui.py
+-rw-r--r--  2.0 unx     5750 b- defN 23-Jun-26 11:34 pasta_eln/handleDictionaries.py
+-rw-r--r--  2.0 unx    13588 b- defN 23-Jun-26 11:34 pasta_eln/inputOutput.py
+-rw-r--r--  2.0 unx    23058 b- defN 23-Jun-26 11:34 pasta_eln/installationTools.py
+-rw-r--r--  2.0 unx    10273 b- defN 23-Jun-26 11:34 pasta_eln/miscTools.py
+-rw-r--r--  2.0 unx     5714 b- defN 23-Jun-26 11:34 pasta_eln/mixin_cli.py
+-rw-r--r--  2.0 unx     3851 b- defN 23-Jun-26 11:34 pasta_eln/printer.py
+-rw-r--r--  2.0 unx    21356 b- defN 23-Jun-26 11:34 pasta_eln/serverActions.py
+-rw-r--r--  2.0 unx    11408 b- defN 23-Jun-26 11:34 pasta_eln/style.py
+-rw-r--r--  2.0 unx     2335 b- defN 23-Jun-26 11:34 pasta_eln/tempStrings.py
+-rw-r--r--  2.0 unx     1519 b- defN 23-Jun-26 11:34 pasta_eln/widgetBody.py
+-rw-r--r--  2.0 unx    11672 b- defN 23-Jun-26 11:34 pasta_eln/widgetDetails.py
+-rw-r--r--  2.0 unx     1666 b- defN 23-Jun-26 11:34 pasta_eln/widgetDocTypes.py
+-rw-r--r--  2.0 unx    11633 b- defN 23-Jun-26 11:34 pasta_eln/widgetProject.py
+-rw-r--r--  2.0 unx     8873 b- defN 23-Jun-26 11:34 pasta_eln/widgetProjectLeafRenderer.py
+-rw-r--r--  2.0 unx     7349 b- defN 23-Jun-26 11:34 pasta_eln/widgetProjectTreeView.py
+-rw-r--r--  2.0 unx     8521 b- defN 23-Jun-26 11:34 pasta_eln/widgetSidebar.py
+-rw-r--r--  2.0 unx    18564 b- defN 23-Jun-26 11:34 pasta_eln/widgetTable.py
+-rw-r--r--  2.0 unx      356 b- defN 23-Jun-26 11:34 pasta_eln/Extractors/README.md
+-rw-r--r--  2.0 unx     4895 b- defN 23-Jun-26 11:34 pasta_eln/Extractors/extractor_csv.py
+-rw-r--r--  2.0 unx     1275 b- defN 23-Jun-26 11:34 pasta_eln/Extractors/extractor_jpeg.py
+-rw-r--r--  2.0 unx     1560 b- defN 23-Jun-26 11:34 pasta_eln/Extractors/extractor_jpg.py
+-rw-r--r--  2.0 unx      953 b- defN 23-Jun-26 11:34 pasta_eln/Extractors/extractor_json.py
+-rw-r--r--  2.0 unx      681 b- defN 23-Jun-26 11:34 pasta_eln/Extractors/extractor_md.py
+-rw-r--r--  2.0 unx     1875 b- defN 23-Jun-26 11:34 pasta_eln/Extractors/extractor_png.py
+-rw-r--r--  2.0 unx      187 b- defN 23-Jun-26 11:34 pasta_eln/Resources/ExampleMeasurements/simple.csv
+-rw-r--r--  2.0 unx     9450 b- defN 23-Jun-26 11:34 pasta_eln/Resources/ExampleMeasurements/simple.png
+-rw-r--r--  2.0 unx     5694 b- defN 23-Jun-26 11:34 pasta_eln/Resources/Icons/favicon64.ico
+-rw-r--r--  2.0 unx     2161 b- defN 23-Jun-26 11:34 pasta_eln/Resources/Icons/favicon64.png
+-rw-r--r--  2.0 unx     1613 b- defN 23-Jun-26 11:34 pasta_eln-2.4.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     3517 b- defN 23-Jun-26 11:34 pasta_eln-2.4.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jun-26 11:34 pasta_eln-2.4.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx      150 b- defN 23-Jun-26 11:34 pasta_eln-2.4.0.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       10 b- defN 23-Jun-26 11:34 pasta_eln-2.4.0.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     4202 b- defN 23-Jun-26 11:34 pasta_eln-2.4.0.dist-info/RECORD
+49 files, 365865 bytes uncompressed, 120119 bytes compressed:  67.2%
```

## zipnote {}

```diff
@@ -39,17 +39,14 @@
 
 Filename: pasta_eln/fixedStrings.py
 Comment: 
 
 Filename: pasta_eln/gui.py
 Comment: 
 
-Filename: pasta_eln/gui.py.orig
-Comment: 
-
 Filename: pasta_eln/handleDictionaries.py
 Comment: 
 
 Filename: pasta_eln/inputOutput.py
 Comment: 
 
 Filename: pasta_eln/installationTools.py
@@ -126,26 +123,26 @@
 
 Filename: pasta_eln/Resources/Icons/favicon64.ico
 Comment: 
 
 Filename: pasta_eln/Resources/Icons/favicon64.png
 Comment: 
 
-Filename: pasta_eln-2.3.9.dist-info/LICENSE
+Filename: pasta_eln-2.4.0.dist-info/LICENSE
 Comment: 
 
-Filename: pasta_eln-2.3.9.dist-info/METADATA
+Filename: pasta_eln-2.4.0.dist-info/METADATA
 Comment: 
 
-Filename: pasta_eln-2.3.9.dist-info/WHEEL
+Filename: pasta_eln-2.4.0.dist-info/WHEEL
 Comment: 
 
-Filename: pasta_eln-2.3.9.dist-info/entry_points.txt
+Filename: pasta_eln-2.4.0.dist-info/entry_points.txt
 Comment: 
 
-Filename: pasta_eln-2.3.9.dist-info/top_level.txt
+Filename: pasta_eln-2.4.0.dist-info/top_level.txt
 Comment: 
 
-Filename: pasta_eln-2.3.9.dist-info/RECORD
+Filename: pasta_eln-2.4.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## pasta_eln/__init__.py

```diff
@@ -1,2 +1,2 @@
 """ EMPTY INIT FILE """
-__version__ = "2.3.9"
+__version__ = "2.4.0"
```

## pasta_eln/backend.py

```diff
@@ -1,47 +1,49 @@
 """ Python Backend: all operations with the filesystem are here """
-import json, sys, os, shutil, re, importlib, tempfile, logging, traceback
+import json, sys, os, importlib, tempfile, logging, traceback
 from pathlib import Path
+from typing import Any, Optional, Union
 from urllib import request
 from datetime import datetime, timezone
-from .mixin_cli import Bcolors, CLI_Mixin
+from PySide6.QtWidgets import QProgressBar  # pylint: disable=no-name-in-module
+from .mixin_cli import CLI_Mixin
 from .database import Database
-from .miscTools import upIn, upOut, createDirName, generic_hash, camelCase
-from .handleDictionaries import ontology2Labels, fillDocBeforeCreate
+from .miscTools import upOut, createDirName, generic_hash, camelCase, DummyProgressBar
+from .handleDictionaries import fillDocBeforeCreate, diffDicts
+from .miscTools import outputString
 
 class Backend(CLI_Mixin):
   """
   PYTHON BACKEND
   """
 
-  def __init__(self, defaultProjectGroup='', **kwargs):
+  def __init__(self, defaultProjectGroup:str='', **kwargs:int):
     """
     open server and define database
 
     Args:
         defaultProjectGroup (string): name of configuration / project-group used; if not given, use the one defined by 'defaultProjectGroup' in config file
-        kwargs (dict): additional parameters
+        **kwargs (dict): additional parameters
           - initViews (bool): initialize views at startup
           - resetOntology (bool): reset ontology on database from one on file
     """
     #initialize basic values
-    self.hierStack = []
-    self.currentID = ""
-    self.alive     = True
-    self.cwd       = Path('.')
+    self.hierStack:list[str] = []
+    self.alive               = True
+    self.cwd:Optional[Path]  = Path('.')
     self.initialize(defaultProjectGroup, **kwargs)
 
 
-  def initialize(self, defaultProjectGroup="", **kwargs):
+  def initialize(self, defaultProjectGroup:str="", **kwargs:int) -> None:
     """
     initialize or reinitialize server and define database
 
     Args:
         defaultProjectGroup (string): name of configuration / project-group used; if not given, use the one defined by 'defaultProjectGroup' in config file
-        kwargs (dict): additional parameters
+        **kwargs (dict): additional parameters
           - initViews (bool): initialize views at startup
           - resetOntology (bool): reset ontology on database from one on file
     """
     configFileName = Path.home()/'.pastaELN.json'
     if not configFileName.exists():
       print('**ERROR Configuration file does not exist')
       return
@@ -66,78 +68,86 @@
     self.basePath     = Path(projectGroup['local']['path'])
     self.cwd          = Path(projectGroup['local']['path'])
     self.extractorPath = Path(self.configuration['extractorDir'])
     sys.path.append(str(self.extractorPath))  #allow extractors
     # decipher miscellaneous configuration and store
     self.userID   = self.configuration['userID']
     # start database
-    self.db = Database(n,s,databaseName, self.configuration, **kwargs)
+    self.db = Database(n,s,databaseName, self.configuration, basePath=self.basePath)
     if not hasattr(self.db, 'databaseName'):  #not successful database creation
       return
     if kwargs.get('initViews', False):
       self.db.initViews(self.configuration)
     # internal hierarchy structure
     self.hierStack = []
-    self.currentID  = None
     self.alive     = True
     return
 
 
-  def exit(self, deleteDB=False, **kwargs):
+  def exit(self, deleteDB:bool=False) -> None:
     """
     Shutting down things
 
     Args:
       deleteDB (bool): remove database
-      kwargs (dict): additional parameter
     """
     self.db.exit(deleteDB)
     self.alive     = False
     return
 
 
   ######################################################
   ### Change in database
   ######################################################
-  def editData(self, doc):
+  def editData(self, doc:dict[str,Any]) -> None:
     """
     Edit data from version 2 information flow by wrapping addData
 
     Args:
       doc (dict): dict to save
     """
     doc = dict(doc)
     if doc['-branch'][0]['path'] is None:
       self.cwd     = None
     else:
       self.cwd     = self.basePath/doc['-branch'][0]['path']
     self.hierStack = doc['-branch'][0]['stack']+[doc['_id']]
     doc['childNum']= doc['-branch'][0]['child']
+    # change content
     self.addData('-edit-', doc)
+    # change folder-name in database of all children
+    if doc['-type'][0][0]=='x' and self.cwd is not None:
+      items = self.db.getView('viewHierarchy/viewPaths', startKey=self.cwd.relative_to(self.basePath).as_posix()+'/')
+      for item in items:
+        oldPathparts = item['key'].split('/')
+        newPathParts = doc['-branch']['path'].split('/')
+        newPath = '/'.join(newPathParts+oldPathparts[len(newPathParts):]  )
+        # print(item['id']+'  old='+item['key']+'  branch='+str(item['value'][-1])+\
+        #      '  child='+str(item['value'][-3])+'  new='+newPath)
+        self.db.updateBranch(item['id'], item['value'][-1], item['value'][-3], path=newPath)
+    self.cwd = self.basePath #reset to sensible before continuing
+    self.hierStack = []
     return
 
 
-  def addData(self, docType, doc, hierStack=None, localCopy=False, **kwargs):
+  def addData(self, docType:str, doc:dict[str,Any], hierStack:list[str]=[], localCopy:bool=False,
+              forceNewImage:bool=False) -> str:
     """
     Save doc to database, also after edit
 
     Args:
         docType (string): docType to be stored, subtypes are / separated; or '-edit-'
         doc (dict): to be stored
         hierStack (list): hierStack from external functions
         localCopy (bool): copy a remote file to local version
-        kwargs (dict): additional parameter, i.e. callback for curation
-            forceNewImage (bool): create new image in any case
+        forceNewImage (bool): create new image in any case
 
     Returns:
-        bool: success
+        str: docID, empty string if failure
     """
-    if hierStack is None:
-      hierStack=[]
-    forceNewImage=kwargs.get('forceNewImage',False)
     doc['-user']  = self.userID
     childNum     = doc.pop('childNum',None)
     path         = None
     oldPath      = None
     operation    = 'c'  #operation of branch/path
     if docType == '-edit-':
       edit = True
@@ -153,21 +163,21 @@
       elif '-branch' in doc:
         hierStack   = doc['-branch'][0]['stack']
     else:  #new doc
       edit = False
       doc['-type'] = docType.split('/')
       if len(hierStack) == 0:
         hierStack = self.hierStack
-    logging.info('Add/edit data in cwd:'+self.cwd.as_posix()+' with stack:'+str(hierStack)+' and name'\
-                 +doc['-name']+' and type:'+str(doc['-type']))
+    logging.debug('Add/edit data in cwd:'+str(self.cwd)+' with stack:'+str(hierStack)+' and name: '\
+                 +doc['-name']+' type:'+str(doc['-type'])+' and edit: '+str(edit))
 
     # collect structure-doc and prepare
     if doc['-type'][0][0]=='x' and doc['-type'][0]!='x0' and childNum is None:
       #should not have childnumber in other cases
-      thisStack = ' '.join(self.hierStack)
+      thisStack = ' '.join(hierStack)
       view = self.db.getView('viewHierarchy/viewHierarchy', startKey=thisStack) #not faster with cT.getChildren
       childNum = 0
       for item in view:
         if item['value'][1][0]=='x0' or item['value'][1][0][0]!='x':
           continue
         if thisStack == ' '.join(item['key'].split(' ')[:-1]): #remove last item from string
           childNum += 1
@@ -196,508 +206,543 @@
             doc['-name'] = camelCase(baseName)+extension
           else:
             path = Path(doc['-name'])
             try:
               shasum  = generic_hash(path)
             except:
               print('**ERROR bad01: fetch remote content failed. Data not added')
-              return False
+              return ''
         elif doc['-name']!='' and (self.basePath/doc['-name']).exists():          #file exists
           path = self.basePath/doc['-name']
           doc['-name'] = Path(doc['-name']).name
         elif doc['-name']!='' and (self.cwd/doc['-name']).exists():               #file exists
           path = self.cwd/doc['-name']
-        else:                                                     #make up name
-          shasum  = None
-        if shasum is not None: # and doc['-type'][0]=='measurement':         #samples, procedures not added to shasum database, getMeasurement not sensible
+        elif '-branch' in doc:
+          if len(doc['-branch'])==1:
+            if doc['-branch'][0]['path'] is not None and (self.basePath/doc['-branch'][0]['path']).exists():
+              path = self.basePath/doc['-branch'][0]['path']
+          else:
+            logging.warning('backend: add document with multiple branches'+str(doc['-branch']) )
+        else:                                                                     #make up name
+          shasum  = '-'
+        if shasum!='-' and path is not None:
           if shasum == '':
             shasum = generic_hash(path, forceFile=True)
           view = self.db.getView('viewIdentify/viewSHAsum',shasum)
           if len(view)==0 or forceNewImage:  #measurement not in database: create doc
             self.useExtractors(path,shasum,doc)  #create image/content
             # All files should appear in database
             # if not 'image' in doc and not 'content' in doc and not 'otherELNName' in doc:  #did not get valuable data: extractor does not exit
-            #   return False
+            #   return ''
           if len(view)==1:  #measurement is already in database
             doc['_id'] = view[0]['id']
             doc['shasum'] = shasum
+            if doc['-type'] == ['-']:  #don't overwrite identified type, without going through extractor
+              del doc['-type']
             edit = True
     # assemble branch information
     if childNum is None:
       childNum=9999
     if path is not None and path.is_absolute():
       path = path.relative_to(self.basePath)
-    path = None if path is None else path.as_posix()
-    doc['-branch'] = {'stack':hierStack,'child':childNum,'path':path, 'show':[True]*(len(hierStack)+1),\
-                      'op':operation}
+    pathStr = None if path is None else path.as_posix()
+    show = [True]*(len(hierStack)+1)
+    if '-branch' in doc and len(hierStack)+1==len(doc['-branch'][0]['show']):
+      show = doc['-branch'][0]['show']
+    doc['-branch'] = {'stack':hierStack,'child':childNum,'path':pathStr, 'show':show, 'op':operation}
     if edit:
       #update document
       keysNone = [key for key in doc if doc[key] is None]
-      doc = fillDocBeforeCreate(doc, '--')  #store None entries and save back since js2py gets equalizes undefined and null
+      doc = fillDocBeforeCreate(doc, ['--'])  #store None entries and save back since js2py gets equalizes undefined and null
       for key in keysNone:
         doc[key]=None
       doc = self.db.updateDoc(doc, doc['_id'])
     else:
       # add doc to database
       doc = fillDocBeforeCreate(doc, doc['-type'])
       doc = self.db.saveDoc(doc)
 
     ## adaptation of directory tree, information on disk: documentID is required
     if self.cwd is not None and doc['-type'][0][0]=='x':
       #project, step, task
       path = Path(doc['-branch'][0]['path'])
-      if edit:
+      if edit and oldPath is not None:
         if not (self.basePath/oldPath).exists():
-          print('**ERROR: addData edit of folder should have oldPath and that should exist', oldPath)
-          return False
+          print('**WARNING: addData edit of folder should have oldPath and that should exist:'+oldPath+'\n This can be triggered if user moved the folder.')
+          return ''
         (self.basePath/oldPath).rename(self.basePath/path)
       else:
         (self.basePath/path).mkdir(exist_ok=True)   #if exist, create again; moving not necessary since directory moved in changeHierarchy
       with open(self.basePath/path/'.id_pastaELN.json','w', encoding='utf-8') as f:  #local path, update in any case
         f.write(json.dumps(doc))
-    self.currentID = doc['_id']
-    return True
+    return doc['_id']
 
 
   ######################################################
   ### Disk directory/folder methods
   ######################################################
-  def changeHierarchy(self, docID, dirName=None, **kwargs):
+  def changeHierarchy(self, docID:Optional[str], dirName:Optional[Path]=None) -> None:
     """
     Change through text hierarchy structure
     change hierarchyStack, change directory, change stored cwd
 
     Args:
         docID (string): information on how to change
         dirName (string): change into this directory (absolute path given). For if data is moved
-        kwargs (dict): additional parameter
     """
-    logging.info('changeHierarchy should only be used in CLI mode')
+    logging.debug('changeHierarchy should only be used in CLI mode') #TODO_P5 remove this warning
+    if self.cwd is None:
+      return
     if docID is None or (docID[0]=='x' and docID[1]!='-'):  #cd ..: none. close 'project', 'task'
       self.hierStack.pop()
       self.cwd = self.cwd.parent
     else:  # existing ID is given: open that
       if dirName is None:
         doc = self.db.getDoc(docID)
         self.cwd = self.basePath/doc['-branch'][0]['path']
         self.hierStack = doc['-branch'][0]['stack']+[docID]
       else:
         self.cwd = dirName
         self.hierStack.append(docID)
     return
 
 
-  def scanProject(self, projID, projPath=''):
+  def scanProject(self, progressBar:Union[QProgressBar,DummyProgressBar] , projID:str, projPath:str='') -> None:
     """ Scan directory tree recursively from project/...
     - find changes on file system and move those changes to DB
     - use .id_pastaELN.json to track changes of directories, aka projects/steps/tasks
     - use shasum to track changes of measurements etc. (one file=one shasum=one entry in DB)
     - create database entries for measurements in directory
     - move/copy/delete allowed as the doc['path'] = list of all copies
       doc['path'] is adopted once changes are observed
 
     Args:
+      progressBar (QProgressBar): gui - qt progress bar
       projID (str): project's docID
       projPath (str): project's path from basePath; if not given, will be determined
 
     Raises:
       ValueError: could not add new measurement to database
     """
+    progressBar.show()
     self.hierStack = [projID]
     if projPath=='':
       projPath = self.db.getDoc(projID)['-branch'][0]['path']
     self.cwd = self.basePath/projPath
     rerunScanTree = False
     #prepare lists and start iterating
     inDB_all = self.db.getView('viewHierarchy/viewPaths')
-    #update content between DB and harddisk
-    for line in inDB_all:
-      if line['value'][1][0][0]=='x':
-        continue
-      doc = self.db.getDoc(line['id'])
-      if 'content' in doc:
-        path = self.basePath/line['key']
-        doc= {'-type':['procedure']}
-        self.useExtractors(path, '', doc)
-        self.db.updateDoc(doc, line['id'])
-    #TODO_P4 change procedure: on disk / database -> conflicts
-    #    Copy of procedure exists on harddisk: one entry in db and links; then change one, but not other, -branch should separate; can they reunite?
-
     pathsInDB_x    = [i['key'] for i in inDB_all if i['value'][1][0][0]=='x']  #all structure elements: task, subtasts
     pathsInDB_data = [i['key'] for i in inDB_all if i['value'][1][0][0]!='x']
+    filesCountSum = sum(len(files) for (r, d, files) in os.walk(self.cwd))
+    filesCount = 0
     for root, dirs, files in os.walk(self.cwd, topdown=True):
       #find parent-document
       self.cwd = Path(root).relative_to(self.basePath)
       if self.cwd.name.startswith('trash_'):
         del dirs
         del files
         continue
-      parentID = [i for i in inDB_all if i['key']==self.cwd.as_posix()][0]['id']
+      parentIDs = [i for i in inDB_all if i['key']==self.cwd.as_posix()]
+      if len(parentIDs)==0: #skip newly moved folder, will be scanned upon re-scanning
+        continue
+      parentID = parentIDs[0]['id']
       parentDoc = self.db.getDoc(parentID)
       hierStack = parentDoc['-branch'][0]['stack']+[parentID]
       # handle directories
       for dirName in dirs[::-1]: #sorted forward in Linux
         if dirName.startswith('.') or dirName.startswith('trash_'):
           continue
         path = (Path(root)/dirName).relative_to(self.basePath).as_posix()
         if path in pathsInDB_x: #path already in database
           pathsInDB_x.remove(path)
           continue
-        self.addData('x'+str(len(hierStack)), {'-name':dirName}, hierStack)
-        newDir = Path(self.basePath)/self.db.getDoc(self.currentID)['-branch'][0]['path']
-        (newDir/'.id_pastaELN.json').rename(Path(self.basePath)/root/dirName/'.id_pastaELN.json') #move index file into old folder
-        newDir.rmdir()                     #remove created path
-        (Path(self.basePath)/root/dirName).rename(newDir) #move old to new path
+        if (self.basePath/path/'.id_pastaELN.json').exists(): # update branch: path and stack
+          with open(self.basePath/path/'.id_pastaELN.json', 'r', encoding='utf-8') as fIn:
+            doc = json.loads(fIn.read())
+          if (self.basePath/doc['-branch'][0]['path']).parent.as_posix()  == root and \
+             doc['-branch'][0]['stack']==hierStack:
+            # special case: user wants to have a different directory name in same folder: then the child-number should not change
+            childNum = doc['-branch'][0]['child']
+            newPath = path
+          else:
+            #determine childNumber
+            thisStack = ' '.join(hierStack)  #TODO_P5 this childNumSearch could become new function
+            view = self.db.getView('viewHierarchy/viewHierarchy', startKey=thisStack)
+            childNum = 0
+            for item in view:
+              if item['value'][1][0]=='x0' or item['value'][1][0][0]!='x':
+                continue
+              if thisStack == ' '.join(item['key'].split(' ')[:-1]): #remove last item from string
+                childNum += 1
+            newPath = '/'.join(path.split('/')[:-1])+'/'+createDirName(doc['-name'],doc['-type'][0],childNum) #update,or create (if new doc, update ignored anyhow)
+            if (self.basePath/newPath).exists():
+              print("**ERROR new path should not exist",newPath)
+            else:
+              (self.basePath/path).rename(self.basePath/newPath)
+          self.db.updateBranch(doc['_id'], 0, childNum, hierStack, newPath)
+        else:
+          currentID = self.addData('x'+str(len(hierStack)), {'-name':dirName}, hierStack)
+          newDir = self.basePath/self.db.getDoc(currentID)['-branch'][0]['path']
+          (newDir/'.id_pastaELN.json').rename(self.basePath/root/dirName/'.id_pastaELN.json') #move index file into old folder
+          newDir.rmdir()                     #remove created path
+          (self.basePath/root/dirName).rename(newDir) #move old to new path
         rerunScanTree = True
       # handle files
       for fileName in files:
-        if fileName.startswith('.') or fileName.startswith('trash_'):
+        filesCount += 1
+        progressBar.setValue(int(100*filesCount/filesCountSum))
+        if fileName.startswith('.') or fileName.startswith('trash_') or '_PastaExport' in fileName:
           continue
         path = (Path(root).relative_to(self.basePath) /fileName).as_posix()
         if path in pathsInDB_data:
-          print("File already in DB:",path)
+          logging.info("Scan: file already in DB: "+path)
           pathsInDB_data.remove(path)
         else:
-          print("Add file to DB:",path)
-          _ = self.addData('measurement', {'-name':path}, hierStack)
+          logging.info("Scan: add file to DB: "+path)
+          self.addData('-', {'-name':path}, hierStack)
     #finish method
     self.cwd = self.basePath/projPath
-    orphans = [i for i in pathsInDB_data if i.startswith(self.cwd.relative_to(self.basePath).as_posix())]
-    print('These files are on DB but not harddisk\n', orphans )
-    orphanDirs = [i for i in pathsInDB_x if i==self.cwd.relative_to(self.basePath).as_posix() and i!=projPath]
-    print('These directories are on DB but not harddisk\n', orphanDirs)
+    orphans = [i for i in pathsInDB_data if i.startswith(self.cwd.relative_to(self.basePath).as_posix()+'/')]
+    logging.info('Scan: these files are on DB but not harddisk\n'+'\n  '.join(orphans))
+    orphanDirs = [i for i in pathsInDB_x if i.startswith(self.cwd.relative_to(self.basePath).as_posix()+'/') and i!=projPath]
+    logging.info('Scan: these directories are on DB but not harddisk\n'+'\n  '.join(orphanDirs))
     for orphan in orphans+orphanDirs:
       docID = [i for i in inDB_all if i['key']==orphan][0]['id']
       doc   = dict(self.db.getDoc(docID))
       change = None
       for branch in doc['-branch']:
         if branch['path']==orphan:
           change = {'-branch': {'op':'d', 'oldpath':branch['path'], 'path':branch['path'], \
                                 'stack':branch['stack'] }}
           break
       if change is None:
-        print('**ERROR Tried to remove orphan in database but could not', orphan)
+        logging.warning('Tried to remove orphan in database but could not; that can happen if user renames folder:'+orphan)
       else:
         self.db.updateDoc(change, docID)
     #reset to initial values
     self.hierStack = []
     self.cwd = Path(self.basePath)
     if rerunScanTree:
-      self.scanProject(projID, projPath)
+      self.scanProject(progressBar, projID, projPath)
+    progressBar.hide()
     return
 
 
-  def useExtractors(self, filePath, shasum, doc, **kwargs):
+  def useExtractors(self, filePath:Path, shasum:str, doc:dict[str,Any]) -> None:
     """
     get measurements from datafile: central distribution point
     - max image size defined here
 
     Args:
-        filePath (string): path to file
+        filePath (Path): path to file
         shasum (string): shasum (git-style hash) to store in database (not used here)
         doc (dict): pass known data/measurement type, can be used to create image; This doc is altered
-        kwargs (dict): additional parameter
     """
     extension = filePath.suffix[1:]  #cut off initial . of .jpg
     if str(filePath).startswith('http'):
       absFilePath = Path(tempfile.gettempdir())/filePath.name
       request.urlretrieve(filePath.as_posix().replace(':/','://'), absFilePath)
     else:
       if filePath.is_absolute():
         filePath = filePath.relative_to(self.basePath)
       absFilePath = self.basePath/filePath
     pyFile = 'extractor_'+extension.lower()+'.py'
     pyPath = self.extractorPath/pyFile
-    if len(doc['-type'])==1:
-      doc['-type'] += [extension]
-    try:
-      if not pyPath.exists():
-        raise ValueError('Extractor does not exist')
+    success = False
+    if pyPath.exists():
+      success = True
       # import module and use to get data
       os.environ['QT_API'] = 'pyside2'
       import matplotlib.pyplot as plt  #IMPORTANT: NO PYPLOT OUTSIDE THIS QT_API BLOCK
       plt.clf()
-      module  = importlib.import_module(pyFile[:-3])
-      content = module.use(absFilePath, '/'.join(doc['-type']) )
+      try:
+        module  = importlib.import_module(pyFile[:-3])
+        content = module.use(absFilePath, '/'.join(doc['-type']) )
+      except:
+        logging.error('ERROR with extractor '+pyFile+'\n'+traceback.format_exc())
+        success = False
       os.environ['QT_API'] = 'pyside6'
       #combine into document
-      doc.update(content)
-      for meta in ['metaVendor','metaUser']:
-        for item in doc[meta]:
-          if isinstance(doc[meta][item], tuple):
-            doc[meta][item] = list(doc[meta][item])
-          if not isinstance(doc[meta][item], (str, int, float, list)) and \
-            doc[meta][item] is not None:
-            print(' -> simplify ',meta,item, doc[meta][item])
-            doc[meta][item] = str(doc[meta][item])
-      doc['shasum']    = shasum
-      if doc['recipe'].startswith('/'.join(doc['-type'])):
-        doc['-type']      = doc['recipe'].split('/')
-      else:
-        doc['-type']     += doc['recipe'].split('/')
-      del doc['recipe']
-    except:
-      print('  **Error with extractor',pyFile)
-      logging.error('ERROR with extractor '+pyFile+'\n'+traceback.format_exc())
-      doc['-type'] = ['-']
+      if success:
+        doc.update(content)
+        for meta in ['metaVendor','metaUser']:
+          for item in doc[meta]:
+            if isinstance(doc[meta][item], tuple):
+              doc[meta][item] = list(doc[meta][item])
+            if not isinstance(doc[meta][item], (str, int, float, list)) and \
+              doc[meta][item] is not None:
+              print(' -> simplify ',meta,item, doc[meta][item])
+              doc[meta][item] = str(doc[meta][item])
+        if doc['-type'][0]==doc['recipe'].split('/')[0] or doc['-type'][0]=='-':
+          doc['-type']     = doc['recipe'].split('/')
+        else:
+          #user has strange wish: trust him/her
+          logging.info('user has strange wish: trust him/her: '+'/'.join(doc['-type'])+'  '+doc['recipe'])
+        del doc['recipe']
+        if 'fileExtension' not in doc['metaVendor']:
+          doc['metaVendor']['fileExtension'] = extension.lower()
+        if 'links' in doc:
+          #TODO_P3 extractor: creates links to sample/instrument
+          if len(doc['links'])==0:
+            del doc['links']
+    if not success:
+      print('  **Warning, issue with extractor',pyFile)
+      logging.warning('Issue with extractor '+pyFile)
       doc['metaUser'] = {'filename':absFilePath.name, 'extension':absFilePath.suffix,
         'filesize':absFilePath.stat().st_size,
         'created at':datetime.fromtimestamp(absFilePath.stat().st_ctime, tz=timezone.utc).isoformat(),
         'modified at':datetime.fromtimestamp(absFilePath.stat().st_mtime, tz=timezone.utc).isoformat()}
-    # FOR EXTRACTOR DEBUGGING
-    # import json
-    # for item in doc:
-    #   try:
-    #     _ = json.dumps(doc[item])
-    #   except:
-    #     print('**ERROR json dumping', item, doc[item])
-    # #also make sure that no int64 but normal int
+    doc['shasum']=shasum  #essential for logic, always save, unlike image
     return
 
 
-  def testExtractor(self, filePath, extractorPath=None, recipe='', interactive=True, reportHTML=False):
+  def testExtractor(self, filePath:Union[Path,str], extractorPath:Optional[Path]=None, recipe:str='',
+                    outputStyle:str='text') -> str:
     """
     Args:
       filePath (Path, str): path to the file to be tested
       extractorPath (Path, None): path to the directory with extractors
       recipe (str): recipe in / separated
-      interactive (bool): show image and print report; else only give summary
-      reportHTML (bool): return report in qside html style
+      outputStyle (str): report in ['print','text','html'] including show images
 
     Returns:
       str: short summary or long report
     """
     import base64
     from io import BytesIO
     from PIL import Image
     import cairosvg
     os.environ['QT_API'] = 'pyside2'
     import matplotlib.pyplot as plt
     import matplotlib.axes as mpaxes
 
-    report = 'ExtractorSuccess'
     htmlStr= 'Please visit <a href="https://pasta-eln.github.io/pasta-eln/extractors.html#'
     success = True
     if isinstance(filePath, str):
       filePath = Path(filePath)
     if filePath.as_posix().startswith('http'):
       tempFilePath = Path(tempfile.gettempdir())/filePath.name
       request.urlretrieve(filePath.as_posix().replace(':/','://'), tempFilePath)
       filePath = tempFilePath
-    if reportHTML:
-      report = '<h3>Report on extractor test</h3>'
-      report +='check file: '+str(filePath)+'<br>'
+    report = outputString(outputStyle, 'h2', 'Report on extractor test')
+    report += outputString(outputStyle, 'info', 'check file: '+str(filePath))
     extension = filePath.suffix[1:]
     pyFile = 'extractor_'+extension+'.py'
     if extractorPath is None:
       extractorPath = self.extractorPath
     #start testing
     if (extractorPath/pyFile).exists():
-      if reportHTML:
-        report += 'use extractor: '+str(extractorPath/pyFile)+'<br>'
+      report += outputString(outputStyle, 'info', 'use extractor: '+str(extractorPath/pyFile))
     else:
       success = False
-      if reportHTML:
-        report += '<font color="red">No fitting extractor found:'+pyFile+'</font><br>'
-      else:
-        report = 'NoExtractor'
+      report += outputString(outputStyle, 'error', 'No fitting extractor found:'+pyFile)
     if success:
       try:
         module  = importlib.import_module(pyFile[:-3])
+        plt.clf()
         content = module.use(filePath, recipe)
       except:
         success = False
-        if reportHTML:
-          report += '<font color="red">Python error in extractor</font><br>'
-          report += htmlStr+'python-error">website</a><br>'
-          report += '\n'+traceback.format_exc()+'\n'
+        report += outputString(outputStyle, 'error', 'Python error in extractor')
+        report += outputString(outputStyle, 'error', htmlStr+'python-error">website</a>')
+        report += outputString(outputStyle, 'error', traceback.format_exc(limit=3))
+    if success:
+      if 'recipe' in content:
+        possibleDocTypes = [i for i in self.db.dataLabels.keys() if i[0]!='x']
+        matches = [i for i in possibleDocTypes if content['recipe'].startswith(i)]
+        if len(matches)==0 and content['recipe']!='' and content['recipe']!='-':
+          report += outputString(outputStyle, 'error', 'Recipe does not follow doctype in ontology.')
+        else:
+          report += outputString(outputStyle, 'info', 'Recipe is good: '+content['recipe'])
+          size = len(str(content))
+          report += outputString(outputStyle, 'info', 'Entire extracted size: '+str(int(size/1024))+'kB')
+      else:
+        report += outputString(outputStyle,'error','Recipe not included in extractor.')
     if success:
       try:
         _ = json.dumps(content)
       except:
-        if interactive:
-          print("**ERROR: extractor reply not json dumpable.")
-        if reportHTML:
-          report += '<font color="red">Some json format does not fit</font><br>'
-        else:
-          report = "ExtractorERROR json dumpable"
+        report += outputString(outputStyle,'error','Extractor reply not json dumpable.')
     if success:
       try:
         _ = json.dumps(content['metaVendor'])
-        report += 'Number of vendor entries: '+str(len(content['metaVendor']))+'<br>'
+        report += outputString(outputStyle,'info','Number of vendor entries: '+str(len(content['metaVendor'])))
       except:
+        # possible cause of failure: make sure that no int64 but normal int
         success = False
-        if interactive:
-          print("  DETAIL metaVendor incorrect")
-        if reportHTML:
-          report += '<font color="red">Some json format does not fit in metaVendor</font><br>'
-          report += htmlStr+'metadata-error">website</a><br>'
-        else:
-          report = "ExtractorERROR metaVendor"
+        report += outputString(outputStyle,'error','Some json format does not fit in metaVendor')
+        report += outputString(outputStyle,'error',htmlStr+'metadata-error">website</a>')
         #iterate keys
         for key in content['metaVendor']:
           try:
             _ = json.dumps(content['metaVendor'][key])
           except:
-            if reportHTML:
-              report += '<font color="red">FAIL '+key+' : '+str(content['metaVendor'][key])+' type:'+\
-                        str(type(content['metaVendor'][key]))+'</font><br>'
-            else:
-              print('    FAIL',key, content['metaVendor'][key], type(content['metaVendor'][key]))
+            report += outputString(outputStyle,'error','FAIL '+key+' : '+str(content['metaVendor'][key])+\
+                                   ' type:'+str(type(content['metaVendor'][key])))
 
     if success:
       try:
         _ = json.dumps(content['metaUser'])
         report += 'Number of user entries: '+str(len(content['metaUser']))+'<br>'
       except:
-        if interactive:
-          print("  DETAIL metaUser incorrect")
-        if reportHTML:
-          report += '<font color="red">Some json format does not fit in metaUser</font><br>'
-          report += htmlStr+'metadata-error">website</a><br>'
-        else:
-          report = "ExtractorERROR metaUser"
+        report += outputString(outputStyle,'error','Some json format does not fit in metaUser')
+        report += outputString(outputStyle,'error',htmlStr+'metadata-error">website</a>')
         #iterate keys
         for key in content['metaUser']:
           try:
             _ = json.dumps(content['metaUser'][key])
           except:
-            if reportHTML:
-              report += '<font color="red">FAIL '+key+' : '+content['metaUser'][key]+' type:'+\
-                        str(type(content['metaVendor'][key]))+'</font><br>'
-            else:
-              print('    FAIL',key, content['metaUser'][key], type(content['metaUser'][key]))
-      #verify image is of correct type
+            report += outputString(outputStyle,'error','FAIL '+key+' : '+str(content['metaUser'][key])+\
+                                   ' type:'+str(type(content['metaUser'][key])))
+    #verify image is of correct type
     if success and 'image' not in content:
       success = False
-      if interactive:
-        print('**Error: image not produced by extractor')
-      if reportHTML:
-        report += '<font color="red">Image does not exist</font><br>'
-      else:
-        report = "ExtractorERROR image not exsits"
+      report += outputString(outputStyle,'error','Image does not exist')
     if success and isinstance(content['image'],Image.Image):
       success = False
-      if interactive:
-        content['image'].show()
-        print('**Warning: image is a PIL image: not a base64 string')
-        print('Encode image via the following: pay attention to jpg/png which is encoded twice\n```')
-        print('from io import BytesIO')
-        print('figfile = BytesIO()')
-        print('image.save(figfile, format="PNG")')
-        print('imageData = base64.b64encode(figfile.getvalue()).decode()')
-        print('image = "data:image/jpg;base64," + imageData')
-        print('```')
-      if reportHTML:
-        report += '<font color="red">Image is PIL image</font><br>'
-        report += htmlStr+'pillow-image">website</a><br>'
-      else:
-        report = "ExtractorERROR PIL image"
-    if success and isinstance(content['image'], mpaxes._subplots.Axes): # pylint: disable=protected-access
+      report += outputString(outputStyle,'error','Image is a PIL image: not a base64 string')
+      report += outputString(outputStyle,'error', htmlStr+'pillow-image">website</a>')
+      # print('Encode image via the following: pay attention to jpg/png which is encoded twice\n```')
+      # print('from io import BytesIO')
+      # print('figfile = BytesIO()')
+      # print('image.save(figfile, format="PNG")')
+      # print('imageData = base64.b64encode(figfile.getvalue()).decode()')
+      # print('image = "data:image/jpg;base64," + imageData')
+    if success and isinstance(content['image'], mpaxes._axes.Axes): # pylint: disable=protected-access
       success = False
-      if interactive:
-        plt.show()
-        print('**Warning: image is a matplotlib axis: not a svg string')
-        print('  figfile = StringIO()')
-        print('plt.savefig(figfile, format="svg")')
-        print('image = figfile.getvalue()')
-      if reportHTML:
-        report += '<font color="red">Image are matplot axis</font><br>'
-        report += htmlStr+'matplotlib">website</a><br>'
-      else:
-        report = "ExtractorERROR Matplot image"
+      report += outputString(outputStyle,'error','Image is a matplotlib axis: not a base64 string')
+      report += outputString(outputStyle,'error', htmlStr+'matplotlib">website</a>')
+      # print('**Warning: image is a matplotlib axis: not a svg string')
+      # print('  figfile = StringIO()')
+      # print('plt.savefig(figfile, format="svg")')
+      # print('image = figfile.getvalue()')
     if success and isinstance(content['image'], str):  #show content
-      report += '<br><b>Additional window shows the image</b><br>'
-      if content['image'].startswith('data:image/'):
-        #png or jpg encoded base64
-        extension = content['image'][11:14]
-        i = base64.b64decode(content['image'][22:])
-      else:
-        #svg data
-        i = cairosvg.svg2png(bytestring=content['image'].encode())
-      i = BytesIO(i)
-      i = Image.open(i)
-      if interactive:
-        i.show()
+      size = len(content['image'])
+      report += outputString(outputStyle,'info','Image size '+str(int(size/1024))+'kB')
+      if outputStyle!='text':
+        report += outputString(outputStyle,'h2','Additional window shows the image')
+      if len(content['image'])>20:
+        if content['image'].startswith('data:image/'):
+          #png or jpg encoded base64
+          extension = content['image'][11:14]
+          img = base64.b64decode(content['image'][22:])
+        else:
+          #svg data
+          img = cairosvg.svg2png(bytestring=content['image'].encode())
+        i = BytesIO(img)
+        image = Image.open(i)
+        if outputStyle!='text':
+          image.show()
       del content['image']
-    if interactive and not reportHTML:
+    if outputStyle=='print':
       print('Identified metadata',content)
     os.environ['QT_API'] = 'pyside6'
     return report
 
 
   ######################################################
   ### Wrapper for database functions
   ######################################################
-  def replicateDB(self, removeAtStart=False, **kwargs):
+  def replicateDB(self, progressBar:Union[QProgressBar,DummyProgressBar], removeAtStart:bool=False) -> str:
     """
     Replicate local database to remote database
 
     Args:
         removeAtStart (bool): remove remote DB before starting new
-        kwargs (dict): additional parameter
+        progressBar (QProgressBar): gui - qt progress bar
 
     Returns:
-        bool: replication success
+        str: replication report
     """
-    remoteConf = dict(self.confLink['remote'])
+    defaultProjectGroup = self.configuration['defaultProjectGroup']
+    remoteConf = self.configuration['projectGroups'][defaultProjectGroup]['remote']
     if not remoteConf: #empty entry: fails
       print("**ERROR brp01: You tried to replicate although, remote is not defined")
-      return False
-    remoteConf['user'], remoteConf['password'] = upOut(remoteConf['cred'])[0].split(':')
-    success = self.db.replicateDB(remoteConf, removeAtStart)
-    return success
+      return 'ERROR'
+    if 'cred' in remoteConf:
+      remoteConf['user'], remoteConf['password'] = upOut(remoteConf['cred'])[0].split(':')
+    report = self.db.replicateDB(remoteConf, progressBar, removeAtStart)
+    return report
 
 
-  def checkDB(self, verbose=True, **kwargs):
+  def checkDB(self, outputStyle:str='text', repair:bool=False, minimal:bool=False) -> str:
     """
     Wrapper of check database for consistencies by iterating through all documents
 
     Args:
-        verbose (bool): print more or only issues
-        kwargs (dict): additional parameter, i.e. callback
+        outputStyle (str): output using a given style: see outputString
+        repair (bool): repair database
+        minimal (bool): true=only show warnings and errors; else=also show information
 
     Returns:
         string: output incl. \n
     """
     ### check database itself for consistency
-    output = self.db.checkDB(verbose=verbose, **kwargs)
+    output = self.db.checkDB(outputStyle=outputStyle, repair=repair, minimal=minimal)
     ### compare with file system
-    if verbose:
-      output += f'{Bcolors.UNDERLINE}**** File status ****{Bcolors.ENDC}\n'
-    viewProjects   = self.db.getView('viewDocType/x0')
-    inDB_all = self.db.getView('viewHierarchy/viewPaths')
+    output += outputString(outputStyle,'h2','File status')
+    viewProjects   = self.db.getView('viewDocType/x0All')
+    inDB_all = self.db.getView('viewHierarchy/viewPathsAll')
     pathsInDB_data = [i['key'] for i in inDB_all if i['value'][1][0][0]!='x']
     pathsInDB_folder = [i['key'] for i in inDB_all if i['value'][1][0][0]=='x']
     count = 0
     for projI in viewProjects:
       projDoc = self.db.getDoc(projI['id'])
+      if len(projDoc['-branch'])==0:
+        output += outputString(outputStyle,'error','project view got screwed up')
+        continue
       for root, dirs, files in os.walk(self.basePath/projDoc['-branch'][0]['path']):
+        if Path(root).name[0]=='.' or Path(root).name.startswith('trash_'):
+          del dirs
+          continue
         for fileName in files:
-          if fileName.startswith('.') or fileName.startswith('trash_'):
+          if fileName.startswith('.') or fileName.startswith('trash_') or '_PastaExport' in fileName:
             continue
           path = (Path(root).relative_to(self.basePath) /fileName).as_posix()
           if path not in pathsInDB_data:
-            output += '**ERROR File on harddisk but not DB: '+path+'\n'
+            output += outputString(outputStyle,'error','File on harddisk but not DB: '+path)
             count += 1
           else:
             pathsInDB_data.remove(path)
         for dirName in dirs:
           if dirName.startswith('.') or dirName.startswith('trash_'):
             continue
           path = (Path(root).relative_to(self.basePath) /dirName).as_posix()
           if path not in pathsInDB_folder:
-            output += '**ERROR Directory on harddisk but not DB:'+path+'\n'
+            output += outputString(outputStyle,'error','Directory on harddisk but not DB:'+path)
             count += 1
           else:
             pathsInDB_folder.remove(path)
-    output += 'Number of files on disk that are not in database '+str(count)+'\n'
+            if (self.basePath/root/dirName/'.id_pastaELN.json').exists():
+              with open(self.basePath/root/dirName/'.id_pastaELN.json','r',encoding='utf-8') as fIn:
+                docDisk = json.loads(fIn.read())
+                listDocs = self.db.getView('viewHierarchy/viewPathsAll', preciseKey=(path))
+                if len(listDocs)!=1:
+                  output += outputString(outputStyle,'error','Path of folder is non-unique: '+path)
+                docDB   = self.db.getDoc(listDocs[0]['id'])
+                difference = diffDicts(docDisk,docDB)
+                if len(difference)>1:
+                  output += outputString(outputStyle,'error','disk(1) and db(2) content do not match:'+docDisk['_id'])
+                  output += outputString(outputStyle,'error',difference)
+                  # #use only for resetting the content in the .id_pastaELN.json
+                  # with open(self.basePath/root/dirName/'.id_pastaELN.json','w',encoding='utf-8') as fOut:
+                  #   json.dump(docDB, fOut)
+            else:
+              output += outputString(outputStyle,'error','Folder has no .id_pastaELN.json:'+path)
+              count += 1
+              # if True:  #use only for resetting the content in the .id_pastaELN.json
+              #   with open(self.basePath/root/dirName/'.id_pastaELN.json','w',encoding='utf-8') as fOut:
+              #     docDB   = self.db.getDoc( docDisk['_id'] )
+              #     json.dump(docDB, fOut)
+    output += outputString(outputStyle,'info','Number of files on disk that are not in database '+str(count))
     orphans = [i for i in pathsInDB_data   if not (self.basePath/i).exists() and ":/" not in i]
     orphans+= [i for i in pathsInDB_folder if not (self.basePath/i).exists() ]
     if len(orphans)>0:
-      output += f'{Bcolors.FAIL}**ERROR bch01: These files of database not on filesystem: '+',\t'.join(orphans)\
-               +f'{Bcolors.ENDC}\n'
-    if len(orphans)==0 and count==0:
-      output += "** File tree CLEAN **\n"
-    else:
-      output += "** File tree NOT clean **\n"
+      output += outputString(outputStyle,'error','bch01: These files of database not on filesystem:\n- '+'\n- '.join(orphans))
+    output += outputString(outputStyle,'h2','File summary')
+    if outputStyle == 'text':
+      if len(orphans)==0 and count==0:
+        output += "Success\n"
+      else:
+        output += "Failure\n"
     return output
```

## pasta_eln/cli.py

```diff
@@ -1,25 +1,25 @@
 """ OLD Main function when command-line commands used
 
 Called by user or react-electron frontend. Keep it simple: only functions that
 are required by frontend. Otherwise, make only temporary changes
 """
-import json, sys, argparse, traceback
+import json, argparse, traceback
 from pathlib import Path
 from subprocess import run, PIPE, STDOUT
 import urllib.request
 
 from pasta_eln import __version__
 from .backend import Backend
-from .miscTools import upOut, upIn, updateExtractorList
+from .miscTools import upOut, upIn, updateExtractorList, DummyProgressBar
 from .inputOutput import importELN, exportELN
 from .installationTools import configuration as checkConfiguration
 from .installationTools import exampleData
 
-def commands(getDocu, args):
+def commands(getDocu:bool, args:argparse.Namespace) -> str:
   """
   Main function
 
   Args:
     getDocu (bool): True=return documentation string; False=use arguments
     args (argparse.Namespace): arguments supplied by user / frontend
 
@@ -69,15 +69,15 @@
   if getDocu:
     doc += '  scramble: scramble the password and user name in configuration file\n'
     doc += '    example: pastaELN_CLI.py scramble\n'
   elif args.command=='scramble':
     with open(pathConfig,'r', encoding='utf-8') as f:
       configuration = json.load(f)
     configBackup  = dict(configuration)
-    links = configuration['links']
+    links = configuration['projectGroups']
     changed = False
     for link,site in [(i,j) for i in links.keys() for j in ['local','remote']]:
       if 'user' in links[link][site] and 'password' in links[link][site]:
         links[link][site]['cred'] = upIn(links[link][site]['user']+':'+links[link][site]['password'])
         del links[link][site]['user']
         del links[link][site]['password']
         changed = True
@@ -166,132 +166,134 @@
 
     if getDocu:
       doc += '  verifyDB: test PASTA database\n'
       doc += '    example: pastaELN_CLI.py verifyDB\n'
       doc += '    example: pastaELN_CLI.py verifyDBdev (repair function)\n'
     elif args.command.startswith('verifyDB'):
       repair = args.command=='verifyDBdev'
-      output = be.checkDB(verbose=False, repair=repair)
+      output = be.checkDB(outputStyle='', repair=repair)
       print(output)
       return '1'
 
     if getDocu:
       doc += '  exampleData: create example data by DELETING ALL DATA\n'
-      doc += '  BE CERTAIN THAT YOU WANT TO DO THIS!!\n'
+      doc += '    !! BE CERTAIN THAT YOU WANT TO DO THIS !!\n'
       doc += '    example: pastaELN_CLI.py exampleData\n'
     elif args.command.startswith('exampleData'):
       #prints directly to screen
       exampleData(True)
       return '1'
 
     if getDocu:
       doc += '  syncLR / syncRL: synchronize with / from remote server\n'
       doc += '    example: pastaELN_CLI.py syncLR\n'
     elif args.command=='syncLR':
-      success = be.replicateDB()
+      progressBar = DummyProgressBar()
+      success = be.replicateDB(progressBar)
       return '1' if success else '-1'
     elif args.command=='syncRL':
       be.exit()
       print('**ERROR pma03: syncRL not implemented yet')
       return '-1'
 
     if getDocu:
       doc += '  print: print overview\n'
       doc += "    label: possible docLabels 'Projects', 'Samples', 'Measurements', 'Procedures'\n"
       doc += "    example: pastaELN_CLI.py print -d instruments -l instrument\n"
     elif args.command=='print':
       print(be.output(args.label,True))
       return '1'
 
-    if getDocu:
-      doc += '  saveBackup,loadBackup: save to file.zip / load from file.zip\n'
-      doc += '    - docId is optional as it reduces the scope of the backup\n'
-      doc += '    - database is optional as otherwise the default is used\n'
-      doc += '    example: pastaELN_CLI.py saveBackup -d instruments\n'
-      doc += '    example: pastaELN_CLI.py saveBackup -i x-76b0995cf655bcd487ccbdd8f9c68e1b\n'
-    elif args.command=='saveBackup':   #save to backup file.zip
-      if args.docID!='':
-        exportELN(be, args.docID)
-      else:
-        be.backup('backup')
-
-    elif args.command=='loadBackup':   #load from backup file.zip
-      be.backup('restore')
-      return '1'
+    # if getDocu:
+    #   doc += '  saveBackup,loadBackup: save to file.zip / load from file.zip\n'
+    #   doc += '    - docId is optional as it reduces the scope of the backup\n'
+    #   doc += '    - database is optional as otherwise the default is used\n'
+    #   doc += '    example: pastaELN_CLI.py saveBackup -d instruments\n'
+    #   doc += '    example: pastaELN_CLI.py saveBackup -i x-76b0995cf655bcd487ccbdd8f9c68e1b\n'
+    # elif args.command=='saveBackup':   #save to backup file.zip
+    #   if args.docID!='':
+    #     exportELN(be, args.docID, 'test.eln')
+    #   else:
+    #     be.backup('backup')
+
+    # elif args.command=='loadBackup':   #load from backup file.zip
+    #   be.backup('restore')
+    #   return '1'
 
     if getDocu:
       doc += '  extractorTest: test extractor on individual datafile\n'
       doc += '    example: pastaELN_CLI.py extractorTest -i ~/[long-path]/Zeiss.tif\n'
     elif args.command=='extractorTest':
       be.testExtractor(args.docID)
       return '1'
 
-    if getDocu:
-      doc += '  importXLS: import first sheet of excel file into database\n'
-      doc += '    before: ensure database configuration and project exist\n'
-      doc += '    example: pastaELN_CLI.py importXLS -d instruments -i x-123456 -c "~/path/to.xls" -l instrument\n'
-      doc += '    -l is the document type\n'
-      doc += '    afterwards: adopt ontology (views are automatically generated)\n'
-    elif args.command=='importXLS':
-      import pandas as pd
-      from commonTools import commonTools as cT  #not globally imported since confuses translation
-      if args.docID!='':
-        be.changeHierarchy(args.docID)
-      #change for matwerks examples
-      data = pd.read_excel(args.content, sheet_name=0)
-      if data.shape[0]>40 and data.iloc[38].isnull().sum() < data.iloc[36].isnull().sum():
-        data = pd.read_excel(args.content, sheet_name=0, skiprows=39, usecols=range(11))
-        data=data.drop(data.index[[0,1]])
-        data=data.drop(data.index[[-1,-2,-3]])
-        #add metadata
-        meta = pd.read_excel(args.content, sheet_name=0, skiprows=4, nrows=13, usecols=[0,2])
-        for i in range(meta.shape[0]):
-          key, value = meta.iloc[i,0], meta.iloc[i,1]
-          data[key] = value
-        #add more metadata
-        meta = pd.read_excel(args.content, sheet_name=0, skiprows=19, nrows=8, usecols=[2,8])
-        for i in range(meta.shape[0]):
-          if meta.iloc[i,:].isnull().sum()==2:
-            continue
-          key, value = meta.iloc[i,0], meta.iloc[i,1]
-          data[key] = value
-        meta = pd.read_excel(args.content, sheet_name=0)
-        data['batch'] = meta.iloc[1,0].split(' - ')[1].split(' ')[1]
-        data['test']  = meta.iloc[1,0].split(' - ')[0][1:-1]
-        data = data.rename(columns={"AMTwin label": "-name"})
-      else:
-        #default file
-        data = pd.read_excel(args.content, sheet_name=0).fillna('')
-      print(data.columns)
-      print(data)
-      for _, row in data.iterrows():
-        data = dict((k.lower(), v) for k, v in row.items())
-        be.addData(args.label, data )
-      return '1'
+    # if getDocu:
+    #   doc += '  importXLS: import first sheet of excel file into database\n'
+    #   doc += '    before: ensure database configuration and project exist\n'
+    #   doc += '    example: pastaELN_CLI.py importXLS -d instruments -i x-123456 -c "~/path/to.xls" -l instrument\n'
+    #   doc += '    -l is the document type\n'
+    #   doc += '    afterwards: adopt ontology (views are automatically generated)\n'
+    # elif args.command=='importXLS':
+    #   import pandas as pd
+    #   from commonTools import commonTools as cT  #not globally imported since confuses translation
+    #   if args.docID!='':
+    #     be.changeHierarchy(args.docID)
+    #   #change for matwerks examples
+    #   df = pd.read_excel(args.content, sheet_name=0)
+    #   if df.shape[0]>40 and df.iloc[38].isnull().sum() < df.iloc[36].isnull().sum():
+    #     df = pd.read_excel(args.content, sheet_name=0, skiprows=39, usecols=range(11))
+    #     df=df.drop(df.index[[0,1]])
+    #     df=df.drop(df.index[[-1,-2,-3]])
+    #     #add metadata
+    #     meta = pd.read_excel(args.content, sheet_name=0, skiprows=4, nrows=13, usecols=[0,2])
+    #     for i in range(meta.shape[0]):
+    #       key, value = meta.iloc[i,0], meta.iloc[i,1]
+    #       df[key] = value
+    #     #add more metadata
+    #     meta = pd.read_excel(args.content, sheet_name=0, skiprows=19, nrows=8, usecols=[2,8])
+    #     for i in range(meta.shape[0]):
+    #       if meta.iloc[i,:].isnull().sum()==2:
+    #         continue
+    #       key, value = meta.iloc[i,0], meta.iloc[i,1]
+    #       df[key] = value
+    #     meta = pd.read_excel(args.content, sheet_name=0)
+    #     df['batch'] = meta.iloc[1,0].split(' - ')[1].split(' ')[1]
+    #     df['test']  = meta.iloc[1,0].split(' - ')[0][1:-1]
+    #     df = df.rename(columns={"AMTwin label": "-name"})
+    #   else:
+    #     #default file
+    #     df = pd.read_excel(args.content, sheet_name=0).fillna('')
+    #   print(df.columns)
+    #   print(df)
+    #   for _, row in df.iterrows():
+    #     data = dict((k.lower(), v) for k, v in row.items())
+    #     be.addData(args.label, data )
+    #   return '1'
 
     if getDocu:
       doc += '  redo: recreate thumbnail / use-extractor\n'
       doc += '    example: pastaELN_CLI.py redo -i m-1234567890abcdefghijklmnopqrstuv -c type/test/subtest\n'
     elif args.command=='redo':
       data = dict(be.db.getDoc(args.docID))
       if args.content is not None:
         data['-type'] = args.content.split('/')
-      be.useExtractors(be.basePath/data['-branch'][0]['path'], data['shasum'], data, extractorRedo=True)  #any path is good since the file is the same everywhere; data-changed by reference
+      be.useExtractors(be.basePath/data['-branch'][0]['path'], data['shasum'], data)  #any path is good since the file is the same everywhere; data-changed by reference
       if len(data['-type'])>1 and len(data['image'])>1:
         be.db.updateDoc({'image':data['image'], '-type':data['-type']},args.docID)
         return '1'
       else:
         print('**ERROR pma06: error after redo-extraction')
         return '-1'
 
     if getDocu:
       doc += '  scanProject: scan project with docID\n'
       doc += '    example: pastaELN_CLI.py scanProject -i ....\n'
     elif args.command=='scanProject':
-      be.scanProject(args.docID)
+      progressBar = DummyProgressBar()
+      be.scanProject(progressBar, args.docID)
       return '1'
 
     ##################################################
     ## Commands that require open database and open project
     doc += '\n-- Commands that interact with a special project --\n'
     if not getDocu and args.docID!='':
       be.changeHierarchy(args.docID)
@@ -309,28 +311,33 @@
 
   if not getDocu and be is not None:
     be.exit()
   return doc
 
 ###################
 ## MAIN FUNCTION ##
-def main():
+def main() -> None:
   """
   Main function
   """
-  usage = "./pastaELN_CLI.py <command> [-i docID] [-c content] [-l labels] [-d database]\n\n"
+  usage = "python -m pasta_eln.cli <command> [-i docID] [-c content] [-l labels] [-d database]\n\n"
   usage+= "Possible commands are:\n"
-  usage+= commands(True, None)
+  usage+= commands(True, argparse.Namespace())
   argparser = argparse.ArgumentParser(usage=usage)
   argparser.add_argument('command', help='see above...')
   argparser.add_argument('-i','--docID',   help='docID of project; a long alpha-numeric code', default='')
   argparser.add_argument('-c','--content', help='content to save/store', default=None)
   argparser.add_argument('-l','--label',   help='label used for printing', default='x0')
   argparser.add_argument('-d','--database',help='name of database configuration', default='') #required for be = Pasta(args.database)
   arguments = argparser.parse_args()
   result = commands(False, arguments)
   if arguments.command=='help':
     argparser.print_help()
   if result == '':
     print('**ERROR pma08: command in pastaELN_CLI.py does not exist |',arguments.command)
   elif result == '1' and arguments.command!='up':
     print('SUCCESS')
+  return
+
+# start main function
+if __name__ == '__main__':
+  main()
```

## pasta_eln/communicate.py

```diff
@@ -1,17 +1,23 @@
 """ Communication class that sends signals between widgets, incl. backend"""
+from typing import Any
 from PySide6.QtCore import QObject, Signal   # pylint: disable=no-name-in-module
+from .backend import Backend
 
 class Communicate(QObject):
   """ Communication class that sends signals between widgets, incl. backend"""
-  def __init__(self, backend):
+  def __init__(self, backend:Backend):
     super().__init__()
     self.backend = backend
+    self.dbInfo:dict[str,Any]  = {}
 
   # Signals: specify emitter and receiver
   # BE SPECIFIC ABOUT WHAT THIS ACTION DOES
-  changeSidebar= Signal()                #redraw sidebar after hide/show of project in table
-  changeTable = Signal(str, str)         #send doctype,projectID from sidebar to main-table
-  changeDetails = Signal(str)            #send docID from main-table to details
-  changeProject = Signal(str, str)       #send docID,projectID from sidebar or main-table to projects
-  formDoc = Signal(dict)                 #send doc from details to new/edit dialog: dialogForm
-  testExtractor = Signal()               #execute extractorTest in widgetDetails
+  changeSidebar = Signal(str)            # redraw sidebar after hide/show of project in table, focus on this projectID
+  changeTable   = Signal(str, str)       # send doctype,projectID from sidebar to main-table
+                                         #      can also be used for hiding the details on right side if nothing to show
+  changeDetails = Signal(str)            # send docID from main-table to details
+                                         #      docID (str): document-id; ''=draw nothing; 'redraw' implies redraw
+  changeProject = Signal(str, str)       # send docID,projectID from sidebar or main-table to projects
+  formDoc       = Signal(dict)           # send doc from details to new/edit dialog: dialogForm
+  testExtractor = Signal()               # execute extractorTest in widgetDetails
+  stopSequentialEdit = Signal()          # in sequential edit, stop if there is a cancel
```

## pasta_eln/database.py

```diff
@@ -1,77 +1,84 @@
 """ Class for interaction with couchDB """
-import traceback, logging
-from pathlib import PosixPath
+import traceback, logging, time, json, os, re
+from typing import Any, Optional, Union
+from pathlib import Path
+from anytree import Node
+from anytree.search import find_by_attr
+from cloudant.client import CouchDB
+from cloudant.replicator import Replicator
+from PySide6.QtWidgets import QProgressBar  # pylint: disable=no-name-in-module
 from .fixedStrings import defaultOntology, defaultOntologyNode
-
+from .miscTools import tracebackString, DummyProgressBar
 
 class Database:
   """
   Class for interaction with couchDB
   """
-  def __init__(self, user, password, databaseName, configuration, **kwargs):
+  def __init__(self, user:str, password:str, databaseName:str, configuration:dict[str,Any],
+               resetOntology:bool=False, basePath:Path=Path()):
     """
     Args:
       user (string): user name to local database
       password (string): password to local database
       databaseName (string): local database name
       configuration (dict): configuration of GUI elements
-      kwargs (dict): additional parameter
+      resetOntology (bool): reset ontology
     """
-    import json
-    from cloudant.client import CouchDB
     try:
       self.client = CouchDB(user, password, url='http://127.0.0.1:5984', connect=True)
     except:
       print('**ERROR dit01: Could not connect with username+password to local server')
       return
     self.databaseName = databaseName
     if self.databaseName in self.client.all_dbs():
       self.db = self.client[self.databaseName]
     else:
       self.db = self.client.create_database(self.databaseName)
     # check if default documents exist and create
-    if '-ontology-' not in self.db or kwargs.get('resetOntology', False):
+    if '-ontology-' not in self.db or resetOntology:
       if '-ontology-' in self.db:
         print('Info: remove old ontology')
         self.db['-ontology-'].delete()
       self.ontology = defaultOntology
       self.db.create_document(self.ontology)
       self.initViews(configuration)
     self.ontology = self.db['-ontology-']
     if '-version' not in self.ontology or self.ontology['-version']!=2:
       print("**ERROR wrong ontology version")
       raise ValueError("Wrong ontology version")
     self.dataLabels = {i:self.ontology[i]['label'] for i in self.ontology if i[0] not in ['_','-']}
+    self.basePath   = basePath
     return
 
 
-  def initViews(self, configuration):
+  def initViews(self, configuration:dict[str,Any]) -> None:
     """
     initialize all views
 
     Args:
       configuration (dict): configuration of all elements
     """
+    tracebackString(True, 'initView')
     # for the individual docTypes
-    jsDefault = "if ($docType$) {emit($key$, [$outputList$]);}"
+    jsDefault = 'if ($docType$) {doc["-branch"].forEach(function(branch){emit($key$, [$outputList$]);});}'
     viewCode = {}
     for docType in [i for i in self.ontology if i[0] not in ['_','-']]+['-']:
       if docType=='x0':
         js    = jsDefault.replace('$docType$', "doc['-type']=='x0' && (doc['-branch'][0].show.every(\
                 function(i) {return i;}))").replace('$key$','doc._id')
         jsAll = jsDefault.replace('$docType$', "doc['-type']=='x0'").replace('$key$','doc._id')
       elif docType[0]=='x':
         continue
       else:     #show all doctypes that have the same starting ..
         js    = jsDefault.replace('$docType$', "doc['-type'].join('/').substring(0, "+str(len(docType))+")=='"\
                 +docType+"' && (doc['-branch'][0].show.every(function(i) {return i;}))")\
-                .replace('$key$','doc["-branch"][0].stack[0]')
+                .replace('$key$','branch.stack[0]')
         jsAll = jsDefault.replace('$docType$', "doc['-type'].join('/').substring(0, "+str(len(docType))+")=='"\
-                +docType+"'").replace('$key$','doc["-branch"][0].stack[0]')
+                +docType+"'").replace('$key$','branch.stack[0]')
       outputList = []
       if docType == '-':
         enumeration = enumerate(defaultOntologyNode)
       else:
         enumeration = enumerate(self.ontology[docType]['prop'])
       for idx,item in enumeration:
         if idx>configuration['tableColumnsMax']:
@@ -91,17 +98,17 @@
         elif '/' in item['name']:  #stacked requests i.e. metaVendor/date
           parentString = 'doc'+''.join(['["'+i+'"]' for i in item['name'].split('/')[:-1]])
           newString = 'doc'+''.join(['["'+i+'"]' for i in item['name'].split('/')])
           newString = parentString +' ? '+ newString + ': ""'
           outputList.append(newString)
         else:
           outputList.append('doc["'+item['name']+'"]')
-      outputList = ','.join(outputList)
-      viewCode[docType.replace('/','__')]       = js.replace('$outputList$', outputList)
-      viewCode[docType.replace('/','__')+'All'] = jsAll.replace('$outputList$', outputList)
+      outputStr = ','.join(outputList)
+      viewCode[docType.replace('/','__')]       = js.replace('$outputList$', outputStr)
+      viewCode[docType.replace('/','__')+'All'] = jsAll.replace('$outputList$', outputStr)
     self.saveView('viewDocType', viewCode)
     # general views: Hierarchy, Identify
     jsHierarchy  = '''
       if ('-type' in doc && (doc["-branch"][0].show.every(function(i) {return i;}))) {
         doc['-branch'].forEach(function(branch, idx) {emit(branch.stack.concat([doc._id]).join(' '),[branch.child,doc['-type'],doc['-name'],idx]);});
       }
     '''
@@ -124,152 +131,156 @@
     '''
     self.saveView('viewHierarchy',{'viewHierarchy':jsHierarchy,'viewPaths':jsPath,\
                                    'viewHierarchyAll':jsHierarchyAll,'viewPathsAll':jsPathAll})
     jsSHA= "if (doc['-type'][0]==='measurement'){emit(doc.shasum, doc['-name']);}"
     jsQR = "if (doc.qrCode.length > 0)"
     jsQR+= "{doc.qrCode.forEach(function(thisCode) {emit(thisCode, doc['-name']);});}"
     jsTags="if ('-tags' in doc && (doc['-branch'][0].show.every(function(i) {return i;})))"+\
-              "{doc['-tags'].forEach(function(tag){emit(tag,[doc['-name']]);});}"
-    jsTagsAll="if ('-tags' in doc){doc['-tags'].forEach(function(tag){emit(tag,[doc['-name']]);});}"
+              "{doc['-tags'].forEach(function(tag){emit(tag,[doc['-name'], doc['-type'].join('/')]);});}"
+    jsTagsAll="if ('-tags' in doc){doc['-tags'].forEach(function(tag){emit(tag,[doc['-name'], doc['-type'].join('/')]);});}"
     views = {'viewQR':jsQR, 'viewSHAsum':jsSHA, 'viewTags':jsTags, 'viewTagsAll':jsTagsAll}
     self.saveView('viewIdentify', views)
     return
 
 
 
-  def exit(self, deleteDB=False):
+  def exit(self, deleteDB:bool=False) -> None:
     """
     Shutting down things
 
     Args:
       deleteDB (bool): remove database
     """
     import warnings
     if deleteDB:
       self.db.client.delete_database(self.databaseName)
     warnings.simplefilter("ignore")  #client disconnect triggers ignored ResourceWarning on socket
     self.client.disconnect()
     return
 
 
-  def getDoc(self, docID):
+  def getDoc(self, docID:str) -> dict[str,Any]:
     """
     Wrapper for get from database function
 
     Args:
         docID (dict): document id
 
     Returns:
         dict: json representation of document
     """
     return dict(self.db[docID])
 
 
-  def saveDoc(self, doc):
+  def saveDoc(self, doc:dict[str,Any]) ->dict[str,Any]:
     """
     Wrapper for save to database function
 
+    Discussion on -branch['path']:
+    - full path (from basePath) allows to easily create a view of all paths and search through them
+      during each scan, which happens rather often
+    - just the incremental path (file-name, folder-name) allows to easily change that if the user wants
+      and not change all the children paths, too. However, the renaming of the folder is likely occuring
+      less often.
+
     Args:
         doc (dict): document to save
 
     Returns:
         dict: json representation of submitted document
     """
-    tracebackString = traceback.format_stack()
-    tracebackString = [item for item in tracebackString if 'backend.py' in item or 'database.py' in item or 'Tests' in item or 'pasta' in item]
-    tracebackString = '|'.join([item.split('\n')[1].strip() for item in tracebackString])  #| separated list of stack excluding last
-    doc['-client'] = tracebackString
+    doc['-client'] = tracebackString(False, 'save:'+doc['_id'])
     if '-branch' in doc and 'op' in doc['-branch']:
       del doc['-branch']['op']  #remove operation, saveDoc creates and therefore always the same
-      doc['-branch']['show'] = self.createShowFromStack(doc['-branch']['stack'])
+      if 'show' not in doc['-branch']:
+        doc['-branch']['show'] = self.createShowFromStack(doc['-branch']['stack'])
       doc['-branch'] = [doc['-branch']]
     try:
       res = self.db.create_document(doc)
+      logging.debug('successfully saved doc with type and branch '+doc['_id']+' '+'/'.join(doc['-type'])+'  |  '+str(doc['-branch'])+'\n')
     except:
-      print('**ERROR: database.py:saveDoc could not save, likely JSON issue')
-      print(doc)
+      logging.error('could not save, likely JSON issue')
+      if 'image' in doc:
+        del doc['image']
+      logging.error(str(doc))
+      logging.error(traceback.format_exc())
       res=None
     return res
 
 
-  def updateDoc(self, change, docID):
+  def updateDoc(self, change:dict[str,Any], docID:str) -> dict[str,Any]:
     """
     Update document by
     - saving changes to oldDoc (revision document)
     - updating new-document concurrently
     - create a docID for oldDoc
     - Bonus: save '_rev' from newDoc to oldDoc in order to track that updates cannot happen by accident
 
     Args:
         change (dict): item to update
         docID (string):  id of document to change
 
     Returns:
         dict: json representation of updated document
     """
-    import json, os
-    tracebackString = traceback.format_stack()
-    tracebackString = [item for item in tracebackString if 'backend.py' in item or 'database.py' in item or 'Tests' in item or 'pasta' in item]
-    tracebackString = '|'.join([item.split('\n')[1].strip() for item in tracebackString])  #| separated list of stack excluding last
-    change['-client'] = tracebackString
+    change['-client'] = tracebackString(False, 'updateDoc:'+docID)
     newDoc = self.db[docID]  #this is the document that stays live
     initialDocCopy = dict(newDoc)
     if 'edit' in change:     #if delete
       oldDoc = dict(newDoc)
       for item in oldDoc:
         if item not in ('_id', '_rev', '-branch'):
           del newDoc[item]
-      newDoc['-client'] = tracebackString
       newDoc['-user']   = change['-user']
     else:                    #if update
       oldDoc = {}            #this is an older revision of the document
-      nothingChanged = True
+      # nothingChanged = True
       # handle branch
-      if '-branch' in change and len(change['-branch']['stack'])>0:
+      if '-branch' in change:# and len(change['-branch']['stack'])>0:
         op = change['-branch'].pop('op')
         oldpath = change['-branch'].pop('oldpath',None)
         if change['-branch']['path'] is None:
           change['-branch']['path']=newDoc['-branch'][0]['path']
         if not change['-branch'] in newDoc['-branch']:       #skip if new branch is already in branch
           oldDoc['-branch'] = newDoc['-branch'].copy()
           for branch in newDoc['-branch']:
             if op=='c' and branch['path']==change['-branch']['path']:
               op='u'
           if op=='c':    #create, append
             change['-branch']['show'] = self.createShowFromStack(change['-branch']['stack'])
             newDoc['-branch'] += [change['-branch']]
-            nothingChanged = False
+            # nothingChanged = False
           elif op=='u':  #update
             if oldpath is not None:
               for branch in newDoc['-branch']:
                 if branch['path'].startswith(oldpath):
                   if os.path.basename(branch['path']) == newDoc['-name'] and \
-                     os.path.basename(change['-branch']['path'])!='':
-                    newDoc['-name'] = os.path.basename(change['-branch']['path'])
+                     os.path.basename(str(change['-branch']['path']))!='':
+                    newDoc['-name'] = os.path.basename(str(change['-branch']['path']))
                   branch['path'] = branch['path'].replace(oldpath ,change['-branch']['path'])
                   branch['stack']= change['-branch']['stack']
                   branch['show'] = self.createShowFromStack(change['-branch']['stack'])
                   break
             else:
               newDoc['-branch'][0] = change['-branch'] #change the initial one
-            nothingChanged = False
+            # nothingChanged = False
           elif op=='d':  #delete
-            originalLength = len(newDoc['-branch'])
             newDoc['-branch'] = [branch for branch in newDoc['-branch'] if branch['path']!=change['-branch']['path']]
-            if originalLength!=len(newDoc['-branch']):
-              nothingChanged = False
+            # originalLength = len(newDoc['-branch'])
+            # if originalLength!=len(newDoc['-branch']):
+            #   nothingChanged = False
           else:
-            logging.info('database.update.1: unknown branch op: '+newDoc['_id']+' '+newDoc['-name'])
+            logging.warning('database.update.1: unknown branch op: '+newDoc['_id']+' '+newDoc['-name'])
             return newDoc
       #handle other items
       # change has to be dict, not Document
       for item in change:
         if item in ['_id','_rev','-branch']:                #skip items cannot do not result in change
           continue
-        if item=='-type' and change['-type']=='--':          #skip non-set type
+        if item=='-type' and change['-type']==['--']:          #skip non-set type
           continue
         if item=='image' and change['image']=='':          #skip if non-change in image
           continue
         if change[item] is None or (isinstance(change[item], str) and change[item].strip()=='') or \
            (isinstance(change[item], list) and len(change[item])==0):      #skip empty entries
           continue
         ## Discussion: What if content only differs by whitespace changes?
@@ -280,111 +291,166 @@
         #  - also not sure how often simple white space changes occur, how important
         # To identify these cases use the following
         # if (isinstance(change[item], str) and " ".join(change[item].split())!=" ".join(newDoc[item].split()) ) or \
         #    (isinstance(change[item], list) and change[item]!=newDoc[item] ):
         # Add to testBasic to test for it:
         #       myString = myString.replace('A long comment','A long   comment')
         if item not in newDoc or change[item]!=newDoc[item]:
-          if item not in ['-date','-client','-user']:      #if only date/client change, no significant change
-            nothingChanged = False
+          # if item not in ['-date','-client','-user']:      #if only date/client change, no significant change
+          #   nothingChanged = False
           if item == 'image':
             oldDoc[item] = 'image changed'       #don't backup images: makes database big and are only thumbnails anyhow
           elif item in newDoc:
             oldDoc[item] = newDoc[item]
           newDoc[item] = change[item]
-      if nothingChanged:
-        logging.info('database.update.2: doc not updated-nothing changed: '+newDoc['_id']+' '+newDoc['-name'])
-        return newDoc
+      # Always update, for some reason single tags are not recongnized
+      # if nothingChanged:
+      #   logging.debug('database.update.2: doc not updated-nothing changed: '+newDoc['_id']+' '+newDoc['-name'])
+      #   return newDoc
     #For both cases: delete and update
     if '_curated' not in newDoc['-tags'] and newDoc['-type'][0][0]!='x':
       newDoc['-tags'].append('_curated')
     try:
       newDoc.save()
     except:
       logging.error('database.update: update unsuccessful: '+newDoc['_id']+' '+newDoc['-name'])
       print('**ERROR: could not update document. Likely version conflict. Initial and current version:')
       print(initialDocCopy)
       print(newDoc)
-      return None
+      return {}
     attachmentName = 'v0.json'
     if '_attachments' in newDoc:
       attachmentName = 'v'+str(len(newDoc['_attachments']))+'.json'
     newDoc.put_attachment(attachmentName, 'application/json', json.dumps(oldDoc))
-    logging.info('database.update.3: doc update success: '+newDoc['_id']+' '+newDoc['-name'])
+    logging.debug('database.update.3: doc update success: '+newDoc['_id']+' '+newDoc['-name']+'\n')
     return newDoc
 
 
-  def updateBranch(self, docID, branch, child, stack=None, path=None):
+  def updateBranch(self, docID:str, branch:int, child:int, stack:Optional[list[str]]=None,
+                   path:Optional[str]='') -> tuple[str, Optional[str]]:
     """
     Update document by updating the branch
 
     Args:
       docID (string):  id of document to change
       branch (int):  index of branch to change
       child (int):  new number of child
       stack (list):  new list of ids
-      path (str): new path
+      path (str): new path; None is acceptable
 
     Returns:
       str, str: old path, new path
     """
     doc = self.db[docID]
-    doc['-client'] = 'updateBrach'
+    doc['-client'] = tracebackString(False, 'updateBranch:'+docID)
+    if len(doc['-branch'])<=branch:
+      print('**ERROR Cannot delete branch that does not exist '+str(branch)+'in doc '+docID)
+      logging.error('**ERROR Cannot delete branch that does not exist '+str(branch)+'in doc '+docID)
     oldPath = doc['-branch'][branch]['path']
-    if path is None:
+    if oldPath is None:
+      path = None
+    if path=='':
       name = f'{child:03d}'+'_'+'_'.join(oldPath.split('/')[-1].split('_')[1:])
       path = '/'.join(oldPath.split('/')[:-1]+[name])
+    # test if path already exists
+    if docID[0]=='x' and path is not None:
+      if not (self.basePath/path/'.id_pastaELN.json').exists():
+        logging.debug('Target folder\'s json does not exist: '+path)
+        oldDocID = ''
+      else:
+        with open(self.basePath/path/'.id_pastaELN.json', 'r', encoding='utf-8') as fIn:
+          oldJsonContent = json.load(fIn)
+          oldDocID = oldJsonContent['_id']
+      if path is not None and (self.basePath/path).exists() and docID!=oldDocID:
+        print('**ERROR** Target folder already exist: '+path+'. Try to create a new path name')
+        logging.error('Target folder already exist: '+path+'. Try to create a new path name')
+      while path is not None and (self.basePath/path).exists() and docID!=oldDocID:
+        if re.search(r"_\d+$", path) is None:
+          path += '_1'
+        else:
+          path = '_'.join(path.split('_')[:-1])+'_'+str(int(path.split('_')[-1])+1)
+    # assemble data
     doc['-branch'][branch]['path']=path
     doc['-branch'][branch]['child']=child
+    stackOld = list(doc['-branch'][branch]['stack'])
     if stack is not None:
       doc['-branch'][branch]['stack']=stack
-    doc['-branch'][branch]['show'] = self.createShowFromStack(stack)
+    doc['-branch'][branch]['show'] = self.createShowFromStack( doc['-branch'][branch]['stack'] )
     doc.save()
+    logging.debug('success BRANCH updated with type and branch '+doc['_id']+' '+'/'.join(doc['-type'])+'  |  '+str(doc['-branch'])+'\n')
+    # move content: folder and data and write .json to disk
+    if oldPath is not None and path is not None and ':/' not in oldPath:
+      if not (self.basePath/oldPath).exists() and (self.basePath/path).exists():
+        logging.debug('database:updateBranch: dont move since already good')
+      else:
+        (self.basePath/oldPath).rename(self.basePath/path)
+    if docID[0]=='x' and path is not None:
+      with open(self.basePath/path/'.id_pastaELN.json', 'w', encoding='utf-8') as fOut:
+        fOut.write(json.dumps(self.getDoc(docID)))
+      # update children's paths
+      children = self.getView('viewHierarchy/viewHierarchy', startKey=' '.join(stackOld+[docID,'']))
+      for line in children:
+        docLine = self.db[line['id']]
+        flagNotChanged = True
+        for branchLine in docLine['-branch']:
+          if branchLine['path'] is not None and branchLine['path'].startswith(oldPath):
+            branchLine['path'] = path+branchLine['path'][len(oldPath):]
+            flagNotChanged = False
+          if stack is not None and '/'.join(branchLine['stack']).startswith('/'.join(stackOld)):
+            branchLine['stack'] = stack+branchLine['stack'][len(stackOld):]
+            branchLine['show']  = self.createShowFromStack( branchLine['stack'] )
+            flagNotChanged = False
+        if flagNotChanged:
+          print("**Unsure** Not updated"+str(line))
+        docLine.save()
+        # update .json on disk
+        for branchLine in docLine['-branch']:
+          if line['id'][0]=='x'  and (self.basePath/branchLine['path']).exists():
+            with open(self.basePath/branchLine['path']/'.id_pastaELN.json', 'w', encoding='utf-8') as fOut:
+              fOut.write(json.dumps(docLine))
     return oldPath, path
 
 
-  def createShowFromStack(self, stack):
+  def createShowFromStack(self, stack:list[str]) -> list[bool]:
     """
-    For branches: create show from stack
+    For branches: create show entry in the branches by using the stack
     - should be 1 longer than stack
     - check parents if hidden, then this child is hidden too
 
     Args:
       stack (list): list of ancestor docIDs
 
     Returns:
       list: list of show = list of bool
     """
-    if stack is None:
-      show = [True]
-    else:
-      show = (len(stack)+1)*[True]
-      for idx, docID in enumerate(stack):
-        if not self.db[docID]['-branch'][0]['show'][-1]:
-          show[idx] = False
+    show = (len(stack)+1)*[True]
+    for idx, docID in enumerate(stack):
+      if not self.db[docID]['-branch'][0]['show'][-1]:
+        show[idx] = False
     return show
 
 
-  def remove(self, docID):
+  def remove(self, docID:str) -> dict[str,Any]:
     """
     remove doc from database: temporary for development and testing
 
     Args:
       docID (string): id of document to remove
 
     Returns:
       dict: document that was removed
     """
+    tracebackString(True, 'remove:'+docID)
     doc = self.db[docID]
     res = dict(doc)
     doc.delete()
     return res
 
 
-  def addAttachment(self, docID, name, content):
+  def addAttachment(self, docID:str, name:str, content:dict[str,Any]) -> bool:
     """
     Update document by adding attachment (no new revision)
 
     Args:
         docID (string):  id of document to change
         name (string): attachment name to add to
         content (dict): dictionary of content to be added (should include user,date,docID,remark)
@@ -403,44 +469,44 @@
       doc.save()
       return True
     except:
       return False
 
 
 
-  def getView(self, thePath, startKey=None, preciseKey=None):
+  def getView(self, thePath:str, startKey:Optional[str]=None, preciseKey:Optional[str]=None) -> list[dict[str,Any]]:
     """
     Wrapper for getting view function
 
     Args:
         thePath (string): path to view
         startKey (string): if given, use to filter output, everything that starts with this key
         preciseKey (string): if given, use to filter output. Match precisely
 
     Returns:
         list: list of documents in this view
     """
     from cloudant.view import View
-    thePath = thePath.split('/')
-    designDoc = self.db.get_design_document(thePath[0])
-    v = View(designDoc, thePath[1])
+    designDoc = self.db.get_design_document(thePath.split('/')[0])
+    v = View(designDoc, thePath.split('/')[1])
     try:
       if startKey is not None:
         res = v(startkey=startKey, endkey=startKey+'zzz')['rows']
       elif preciseKey is not None:
         res = v(key=preciseKey)['rows']
       else:
         res = list(v.result)
     except:
       print('**ERROR dgv01: Database / Network problem for path |',thePath[0],thePath[1])
+      print(traceback.format_exc())
       res = []
     return res
 
 
-  def saveView(self, designName, viewCode):
+  def saveView(self, designName:str, viewCode:dict[str,str]) -> None:
     """
     Adopt the view by defining a new jsCode
 
     Args:
         designName (string): name of the design
         viewCode (dict): viewName: js-code
     """
@@ -455,224 +521,234 @@
     try:
       designDoc.save()
     except:
       print('**ERROR dsv01: something unexpected has happend. Log-file has traceback')
     return
 
 
-  def getHierarchy(self, start, allItems=False):
+  def getHierarchy(self, start:str, allItems:bool=False) -> Node:
     """
     get hierarchy tree for projects, ...
 
     Args:
       start (str): start of the hierarchy (most parent)
       allItems (bool):  true=show all items, false=only non-hidden
 
     Returns:
       Node: hierarchy in an anytree
     """
-    from anytree import Node, RenderTree, AsciiStyle
-    from anytree.search import find_by_attr
     if not allItems:
       view = self.getView('viewHierarchy/viewHierarchy',    startKey=start)
     if allItems or len(view)==0:
       view = self.getView('viewHierarchy/viewHierarchyAll', startKey=start)
     # for item in view:
     #   print(item)
     levelNum = 1
     while True:
       level = [i for i in view if len(i['key'].split())==levelNum]
       if levelNum==1:
-        dataTree = Node(id=level[0]['key'], docType=level[0]['value'][1], name=level[0]['value'][2])
+        if len(level)==1:
+          dataTree = Node(id=level[0]['key'], docType=level[0]['value'][1], name=level[0]['value'][2])
+        else:
+          print('**ERROR getHierarchy Did not find corresponding '+str(levelNum) )
+          dataTree = Node(id=None, name='')
       else:
         childList = [i['value'][0] for i in level]   #temporary list to allow sorting for child-number
         # https://stackoverflow.com/questions/6618515/sorting-list-based-on-values-from-another-list
         for node in [x for (_,x) in sorted(zip(childList, level), key=lambda pair: pair[0])]:
           parentID = node['key'].split()[-2]
           parentNode = find_by_attr(dataTree, parentID, name='id')
           _ = Node(id=node['id'], parent=parentNode, docType=node['value'][1], name=node['value'][2])
       if len(level)==0:
         break
       levelNum += 1
     # print(RenderTree(dataTree, style=AsciiStyle()))
     return dataTree
 
 
-  def hideShow(self, stack):
+  def hideShow(self, stack:Union[str,list[str]]) -> None:
     """
     Toggle hide/show indicator of branch
 
     Args:
       stack (list, str): stack of docID; docID (str)
     """
     flippedOnce = False
     if isinstance(stack, str):
       doc = self.db[stack]
       for idx, _ in enumerate(doc['-branch']):
         doc['-branch'][idx]['show'][-1] = not doc['-branch'][idx]['show'][-1]
-        print('flipped str', stack)
+        logging.debug('flipped str: '+str(stack))
       doc.save()
       if stack[0]=='x':
         stack = doc['-branch'][0]['stack']+[stack]
       flippedOnce = True
     if isinstance(stack, list):
       iFlip = len(stack)-1
-      print('  database list',stack, iFlip)
+      logging.debug('  database list '+str(stack)+' '+str(iFlip) )
       for item in self.getView('viewHierarchy/viewHierarchyAll', startKey=' '.join(stack)):
-        print('  docID',item['id'])
+        logging.debug('  docID: '+str(item['id']))
         doc = self.db[item['id']]
         for idx, branch in enumerate(doc['-branch']):
           if not flippedOnce or iFlip!=len(branch['stack']):
             doc['-branch'][idx]['show'][iFlip] = not doc['-branch'][idx]['show'][iFlip]
         doc.save()
+    if doc['-type'][0][0]=='x':
+      with open(self.basePath/doc['-branch'][0]['path']/'.id_pastaELN.json','w', encoding='utf-8') as fOut:
+        fOut.write(json.dumps(doc))
     return
 
 
-  def replicateDB(self, dbInfo, removeAtStart=False):
+  def replicateDB(self, dbInfo:dict[str,Any], progressBar:Union[QProgressBar,DummyProgressBar], removeAtStart:bool=False) -> str:
     """
     Replication to another instance
 
     Args:
         dbInfo (dict): info on the remote database
+        progressBar (QProgressBar): gui - qt progress bar
         removeAtStart (bool): remove remote DB before starting new
 
     Returns:
-        dict: json of document
+        str: report
     """
-    import time
-    from cloudant.client import CouchDB
-    from cloudant.replicator import Replicator
+    progressBar.show()
     try:
       rep = Replicator(self.client)
       try:
         client2 = CouchDB(dbInfo['user'], dbInfo['password'], url=dbInfo['url'], connect=True)
       except:
-        print('**ERROR drp01: Could not connect to remote server. Abort replication.')
-        return False
+        return '<b>ERROR drp01: Could not connect to remote server. Abort replication.</b><br>'+\
+               'user:'+dbInfo['user']+'<br>password:'+dbInfo['password']+'<br>url:'+dbInfo['url']
       try:
         listAllDataBases = client2.all_dbs()
         if dbInfo['database'] in listAllDataBases and removeAtStart:
           client2.delete_database(dbInfo['database'])
         if not dbInfo['database'] in listAllDataBases:
           db2 = client2.create_database(dbInfo['database'])
       except:
         pass
       db2 = client2[dbInfo['database']]
       replResult = rep.create_replication(self.db, db2, create_target=False, continuous=False)
-      print('Start replication '+replResult['_id']+'.')
-      #try every 10sec whether replicaton success. Do that for max. of 5min
+      logging.info('Start replication '+replResult['_id']+'.')
+      progressBar.setValue(10)
+      #try every 10sec whether replication success. Do that for max. of 5min
       startTime = time.time()
       while True:
+        progressBar.setValue(10+ int((time.time()-startTime)/60./5.*90) )
         if (time.time()-startTime)/60.>5.:
-          print("Waited for 5min. No replication success in that time")
-          return True
+          logging.info('Stop waiting for replication '+replResult['_id']+'.')
+          progressBar.hide()
+          return "Waited for 5min. No replication success in that time"
         replResult.fetch()        # get updated, latest version from the server
         if '_replication_state' in replResult:
-          print("Replication success state: "+replResult['_replication_state'])
-          return True
+          logging.info('Success replication '+replResult['_id']+'.')
+          progressBar.hide()
+          return "Replication success state: "+replResult['_replication_state']
         time.sleep(10)
     except:
-      print("**ERROR drp02: replicate error |\n",traceback.format_exc())
-      return False
-    return False  #should not reach here
+      progressBar.hide()
+      return "**ERROR drp02: replicate error |\n"+traceback.format_exc()
+
 
 
-  def historyDB(self):
+  def historyDB(self) -> dict[str,Any]:
     """
     Collect last modification days of documents
     """
     from datetime import datetime
     import numpy as np
-    collection = {}
+    collection:dict[str,Any] = {}
     for doc in self.db:
       if doc['_id'][1]=='-' and len(doc['_id'])==34:
         if '-type' in doc and '-date' in doc:
           docType = doc['-type'][0]
           date = doc['-date'][:-1]
           if len(date)==22:
             date += '0'
           date    = datetime.fromisoformat( date ).timestamp()
           if docType in collection:
             collection[docType] = collection[docType] + [date]
           else:
             collection[docType] = [date]
     #determine bins for histogram
     firstSubmit = datetime.now().timestamp()
-    for key in collection.items():
-      if np.min(collection[key]) < firstSubmit:
-        firstSubmit = np.min(collection[key])
+    for key,value in collection.items():
+      if np.min(value) < firstSubmit:
+        firstSubmit = np.min(value)
     bins = np.linspace(firstSubmit, datetime.now().timestamp(), 100 )
     #calculate histgram and save it
     collectionCopy = dict(collection)
-    for key in collection.items():
-      hist, _ = np.histogram(collection[key], bins)
+    for key,value in collection.items():
+      hist, _ = np.histogram(value, bins)
       collectionCopy[key] = hist
     collectionCopy['-bins-'] = (bins[:-1]+bins[1:])/2
     #calculate score
     bias = np.exp(( collectionCopy['-bins-']-collectionCopy['-bins-'][-1] ) / 1.e7)
     score = {}
-    for key in collectionCopy.items():
-      score[key] = np.sum(collectionCopy[key]*bias)
+    for key,value in collectionCopy.items():
+      score[key] = np.sum(value*bias)
     #reformat dates into string
     collectionCopy['-bins-'] = [datetime.fromtimestamp(i).isoformat() for i in collectionCopy['-bins-']]
     collectionCopy['-score-']= score
     return collectionCopy
 
 
-  def checkDB(self, verbose=True, **kwargs):
+  def checkDB(self, outputStyle:str='text', repair:bool=False, minimal:bool=False) -> str:
     """
     Check database for consistencies by iterating through all documents
     - slow since no views used
     - check views
     - only reporting, no repair
     - custom changes are possible with normal scan
     - no interaction with harddisk
 
     Args:
-        verbose (bool): print more or only issues
-        kwargs (dict): additional parameter
+        outputStyle (str): output using a given style: see outputString
+        repair (bool): repair database
+        minimal (bool): true=only show warnings and errors; else=also show information
 
     Returns:
-        bool: success of check
+        str: output
     """
-    import os, re, base64, io
+    import base64, io
     from PIL import Image
-    from .mixin_cli import Bcolors
-    if verbose:
-      outstring = f'{Bcolors.UNDERLINE}**** LEGEND ****{Bcolors.ENDC}\n'
-      outstring+= f'{Bcolors.OKGREEN}Green: perfect and as intended{Bcolors.ENDC}\n'
-      outstring+= f'{Bcolors.OKBLUE}Blue: ok-ish, can happen: empty files for testing, strange path for measurements{Bcolors.ENDC}\n'
-      outstring+= f'{Bcolors.HEADER}Pink: unsure if bug or desired (e.g. move step to random path-name){Bcolors.ENDC}\n'
-      outstring+= f'{Bcolors.WARNING}Yellow: WARNING should not happen (e.g. procedures without project){Bcolors.ENDC}\n'
-      outstring+= f'{Bcolors.FAIL}Red: FAILURE and ERROR: NOT ALLOWED AT ANY TIME{Bcolors.ENDC}\n'
-      outstring+= 'Normal text: not understood, did not appear initially\n'
-      outstring+= f'{Bcolors.UNDERLINE}**** List all DOCUMENTS ****{Bcolors.ENDC}\n'
-    else:
-      outstring = ''
-    repair = kwargs.get('repair', False)
+    from .miscTools import outputString
+    outstring = ''
+    if outputStyle=='html':
+      outstring += '<div align="right">'
+    outstring+= outputString(outputStyle,'h2','LEGEND')
+    if not minimal:
+      outstring+= outputString(outputStyle,'ok','Green: perfect and as intended')
+      outstring+= outputString(outputStyle,'okish', 'Blue: ok-ish, can happen: empty files for testing, strange path for measurements')
+    outstring+= outputString(outputStyle,'unsure','Pink: unsure if bug or desired (e.g. move step to random path-name)')
+    outstring+= outputString(outputStyle,'warning','Yellow: WARNING should not happen (e.g. procedures without project)')
+    outstring+= outputString(outputStyle,'error',  'Red: FAILURE and ERROR: NOT ALLOWED AT ANY TIME')
+    if outputStyle=='html':
+      outstring += '</div>'
+    outstring+= outputString(outputStyle,'h2','List all database entries')
     if repair:
       print('REPAIR MODE IS ON: afterwards, full-reload and create views')
     ## loop all documents
     for doc in self.db:
       try:
         if '_design' in doc['_id']:
-          if verbose:
-            outstring+= f'{Bcolors.OKGREEN}..info: Design document '+doc['_id']+f'{Bcolors.ENDC}\n'
+          if not minimal:
+            outstring+= outputString(outputStyle,'ok','..info: Design document '+doc['_id'])
           continue
         if doc['_id'] == '-ontology-':
           if repair:
             if '-hierarchy-' in doc:
               del doc['-hierarchy-']
             for old,new in [['project','x0'],['step','x1'],['task','x2']]:
               if new not in doc and old in doc:
                 doc[new] = doc[old].copy()
                 del doc[old]
             doc.save()
-          if verbose:
-            outstring+= f'{Bcolors.OKGREEN}..info: ontology exists{Bcolors.ENDC}\n'
+          if not minimal:
+            outstring+= outputString(outputStyle,'ok','..info: ontology exists')
           continue
         #only normal documents after this line
 
         ###custom temporary changes: keep few as examples;
         # BE CAREFUL: PRINT FIRST, delete second run ; RUN ONLY ONCE
         # Version1->Version2 changes
         # if '-branch' in doc:
@@ -720,131 +796,135 @@
         #   if doc['-type'] == ["text","project"]:
         #     doc['-type'] = ["x0"]
         #   if doc['-type'] == ["text","step"]:
         #     doc['-type'] = ["x1"]
         #   if doc['-type'] == ["text","task"]:
         #     doc['-type'] = ["x2"]
 
-        #   # #due to steffen's fuck up
-        #   # if doc['-type'] == [] and doc['-branch'][0]['path']:
+        #   Project renaming bug 1)
+        # if doc['-branch'][0]['path'].startswith('PastaEln'):
+        #   oldPath = doc['-branch'][0]['path']
+        #   newPath = oldPath.replace('PastaEln', 'Pasta')
+        #   print(oldPath, '->', newPath)
+        #   doc['-branch'][0]['path'] = newPath
+        #   doc.save()
+        #
         #   #   if len(doc['-branch'][0]['stack']) == len(doc['-branch'][0]['path'].split('/'))-1 :
         #   #     doc['-type'] = ["x"+str(len(doc['-branch'][0]['stack'])) ]
-        #   doc.save()
         #   # print("after ",doc.keys(),doc['_id'])
 
         #branch test
         if '-branch' not in doc:
-          outstring+= f'{Bcolors.FAIL}**ERROR dch01: branch does not exist '+doc['_id']+f'{Bcolors.ENDC}\n'
+          outstring+= outputString(outputStyle,'error','dch01: branch does not exist '+doc['_id'])
           continue
         if len(doc['-branch'])>1 and doc['-type'] =='x':                 #text elements only one branch
-          outstring+= f'{Bcolors.FAIL}**ERROR dch02: branch length >1 for text'+doc['_id']+' '+str(doc['-type'])+f'{Bcolors.ENDC}\n'
+          outstring+= outputString(outputStyle,'error','dch02: branch length >1 for text'+doc['_id']+' '+str(doc['-type']))
         for branch in doc['-branch']:
           for item in branch['stack']:
             if not item.startswith('x-'):
-              outstring+= f'{Bcolors.FAIL}**ERROR dch03: non-text in stack '+doc['_id']+f'{Bcolors.ENDC}\n'
+              outstring+= outputString(outputStyle,'error','dch03: non-text in stack '+doc['_id'])
 
           if len(branch['stack'])==0 and doc['-type']!=['x0']: #if no inheritance
             if doc['-type'][0] == 'measurement' or  doc['-type'][0][0] == 'x':
-              if verbose:
-                outstring+= f'{Bcolors.WARNING}**warning branch stack length = 0: no parent '+doc['_id']+f'{Bcolors.ENDC}\n'
+              outstring+= outputString(outputStyle,'warning','branch stack length = 0: no parent '+doc['_id'])
             else:
-              if verbose:
-                outstring+= f'{Bcolors.OKBLUE}**ok-ish branch stack length = 0: no parent for procedure/sample '+doc['_id']+'|'+doc['-name']+f'{Bcolors.ENDC}\n'
+              if not minimal:
+                outstring+= outputString(outputStyle,'okish','branch stack length = 0: no parent for procedure/sample '+doc['_id']+'|'+doc['-name'])
           if not '-type' in doc or len(doc['-type'])==0:
-            outstring+= f'{Bcolors.HEADER}**Unsure dch04: no type in (removed data?)'+doc['_id']+f'{Bcolors.ENDC}\n'
+            outstring+= outputString(outputStyle,'unsure','dch04: no type in (removed data?)'+doc['_id'])
             continue
           if doc['-type'][0][0]=='x':
             try:
               dirNamePrefix = branch['path'].split(os.sep)[-1].split('_')[0]
               if dirNamePrefix.isdigit() and branch['child']!=int(dirNamePrefix): #compare child-number to start of directory name
-                outstring+= f'{Bcolors.FAIL}**ERROR dch05: child-number and dirName dont match '+doc['_id']+f'{Bcolors.ENDC}\n'
+                outstring+= outputString(outputStyle,'error','dch05: child-number and dirName dont match '+doc['_id'])
             except:
               pass  #handled next lines
           if branch['path'] is None:
             if doc['-type'][0][0] == 'x':
-              outstring+= f'{Bcolors.FAIL}**ERROR dch06: branch path is None '+doc['_id']+f'{Bcolors.ENDC}\n'
+              outstring+= outputString(outputStyle,'error','dch06: branch path is None '+doc['_id'])
             elif doc['-type'][0] == 'measurement':
-              if verbose:
-                outstring+= f'{Bcolors.OKBLUE}**warning measurement branch path is None=no data '+doc['_id']+' '+doc['-name']+f'{Bcolors.ENDC}\n'
+              if not minimal:
+                outstring+= outputString(outputStyle,'okish','measurement branch path is None=no data '+doc['_id']+' '+doc['-name'])
             else:
-              if verbose:
-                outstring+= f'{Bcolors.OKGREEN}..info: procedure/sample with empty path '+doc['_id']+f'{Bcolors.ENDC}\n'
+              if not minimal:
+                outstring+= outputString(outputStyle,'ok','procedure/sample with empty path '+doc['_id'])
           else:                                                            #if sensible path
             if len(branch['stack'])+1 != len(branch['path'].split(os.sep)):#check if length of path and stack coincide
-              if verbose:
-                outstring+= f'{Bcolors.OKBLUE}**ok-ish branch stack and path lengths not equal: '+doc['_id']+'|'+branch['path'][:30]+f'{Bcolors.ENDC}\n'
+              if doc['-type'][0] == 'procedure':
+                if not minimal:
+                  outstring+= outputString(outputStyle,'ok','procedure: branch stack and path lengths not equal: '+doc['_id']+'|'+branch['path'][:30])
+              else:
+                outstring+= outputString(outputStyle,'unsure','branch stack and path lengths not equal: '+doc['_id']+'|'+branch['path'][:30])
             if branch['child'] != 9999:
               for parentID in branch['stack']:                              #check if all parents in doc have a corresponding path
                 parentDoc = self.getDoc(parentID)
                 if '-branch' not in parentDoc:
-                  outstring+= f'{Bcolors.FAIL}**ERROR dch07: branch not in parent with id '+parentID+f'{Bcolors.ENDC}\n'
+                  outstring+= outputString(outputStyle,'error','dch07: branch not in parent with id '+parentID)
                   continue
                 parentDocBranches = parentDoc['-branch']
                 onePathFound = False
                 for parentBranch in parentDocBranches:
                   if parentBranch['path'] is not None and parentBranch['path'] in branch['path']:
                     onePathFound = True
                 if not onePathFound:
-                  outstring+= f'{Bcolors.HEADER}**Unsure dch08: parent does not have corresponding path (remote content) '+doc['_id']+'| parentID '+parentID+f'{Bcolors.ENDC}\n'
+                  outstring+= outputString(outputStyle,'unsure','dch08: parent does not have corresponding path (remote content) '+doc['_id']+'| parentID '+parentID)
           if 'show' not in branch:
-            outstring+= f'{Bcolors.FAIL}**ERROR dch08a: branch does not have show: '+doc['_id']+f'{Bcolors.ENDC}\n'
+            outstring+= outputString(outputStyle,'error','dch08a: branch does not have show: '+doc['_id'])
           elif len(branch['show']) != len(branch['stack'])+1:
-            outstring+= f'{Bcolors.FAIL}**ERROR dch08b: branch-show not same length as branch-stack: '+doc['_id']+f'{Bcolors.ENDC}\n'
+            outstring+= outputString(outputStyle,'error','dch08b: branch-show not same length as branch-stack: '+doc['_id'])
           #TODO_P5 moreChecksDB: if parent has corresponding show
 
         #every doc should have a name
         if not '-name' in doc:
-          outstring+= f'{Bcolors.HEADER}**Unsure dch17: -name not in (deleted doc?)'+doc['_id']+f'{Bcolors.ENDC}\n'
+          outstring+= outputString(outputStyle,'unsure','dch17: -name not in (deleted doc?)'+doc['_id'])
           if repair and 'name' in doc:  #repair from v0.9.9->1.0.0
             doc['-name']=doc['name']
             del doc['name']
             doc.save()
 
         if not '-tags' in doc:
-          outstring+= f'{Bcolors.FAIL}**ERROR dch17b: -tags not in doc'+doc['_id']+f'{Bcolors.ENDC}\n'
+          outstring+= outputString(outputStyle,'error','dch17b: -tags not in doc'+doc['_id'])
 
         #doc-type specific tests
         if '-type' in doc and doc['-type'][0] == 'sample':
           if 'qrCode' not in doc:
-            outstring+= f'{Bcolors.FAIL}**ERROR dch09: qrCode not in sample '+doc['_id']+f'{Bcolors.ENDC}\n'
+            outstring+= outputString(outputStyle,'error','dch09: qrCode not in sample '+doc['_id'])
         elif '-type' in doc and doc['-type'][0] == 'measurement':
           if 'shasum' not in doc:
-            outstring+= f'{Bcolors.FAIL}**ERROR dch10: shasum not in measurement '+doc['_id']+f'{Bcolors.ENDC}\n'
+            outstring+= outputString(outputStyle,'error','dch10: shasum not in measurement '+doc['_id'])
           if 'image' not in doc:
-            outstring+= f'{Bcolors.FAIL}**ERROR dch11: image not in measurement '+doc['_id']+f'{Bcolors.ENDC}\n'
+            outstring+= outputString(outputStyle,'error','dch11: image not in measurement '+doc['_id'])
           else:
             if doc['image'].startswith('data:image'):  #for jpg and png
               try:
                 imgdata = base64.b64decode(doc['image'][22:])
                 Image.open(io.BytesIO(imgdata))  #can convert, that is all that needs to be tested
               except:
-                outstring+= f'{Bcolors.FAIL}**ERROR dch12: jpg-image not valid '+doc['_id']+f'{Bcolors.ENDC}\n'
+                outstring+= outputString(outputStyle,'error','dch12: jpg-image not valid '+doc['_id'])
             elif doc['image'].startswith('<?xml'):
               #from https://stackoverflow.com/questions/63419010/check-if-an-image-file-is-a-valid-svg-file-in-python
               SVG_R = r'(?:<\?xml\b[^>]*>[^<]*)?(?:<!--.*?-->[^<]*)*(?:<svg|<!DOCTYPE svg)\b'
               SVG_RE = re.compile(SVG_R, re.DOTALL)
               if SVG_RE.match(doc['image']) is None:
-                outstring+= f'{Bcolors.FAIL}**ERROR dch13: svg-image not valid '+doc['_id']+f'{Bcolors.ENDC}\n'
+                outstring+= outputString(outputStyle,'error','dch13: svg-image not valid '+doc['_id'])
             elif doc['image']=='':
-              outstring+= f'{Bcolors.OKBLUE}**warning: image not valid '+doc['_id']+' '+doc['image']+f'{Bcolors.ENDC}\nRecreate it\n'
+              outstring+= outputString(outputStyle,'unsure','image not valid '+doc['_id']+' '+doc['image'])
             else:
-              outstring+= f'{Bcolors.FAIL}**ERROR dch14: image not valid '+doc['_id']+' '+doc['image']+f'{Bcolors.ENDC}\n'
+              outstring+= outputString(outputStyle,'error','dch14: image not valid '+doc['_id']+' '+doc['image'])
 
       except: #if test of document fails
-        outstring+= f'{Bcolors.FAIL}**ERROR dch15: critical error in '+doc['_id']+f'{Bcolors.ENDC}\n'
-        outstring+= traceback.format_exc()
+        outstring+= outputString(outputStyle,'error','dch15: critical error in '+doc['_id']+'\n'+traceback.format_exc())
 
     ##TEST views
-    if verbose:
-      outstring+= f'{Bcolors.UNDERLINE}**** List problematic VIEWS ****{Bcolors.ENDC}\n'
+    outstring+= outputString(outputStyle,'h2','List problematic database tables')
     view = self.getView('viewIdentify/viewSHAsum')
     shasumKeys = []
     for item in view:
       if item['key']=='':
-        if verbose:
-          outstring+= f'{Bcolors.OKBLUE}**warning: measurement without shasum: '+item['id']+' '+item['value']+f'{Bcolors.ENDC}\n'
+        outstring+= outputString(outputStyle,'error','measurement without shasum: '+item['id']+' '+item['value'])
       else:
         if item['key'] in shasumKeys:
-          key = item['key'] if item['key'] else '-empty-'
-          outstring+= f'{Bcolors.FAIL}**ERROR dch16: shasum twice in view: '+key+' '+item['id']+' '+item['value']+f'{Bcolors.ENDC}\n'
+          key = item['key'] if item['key'] else '- empty string -'
+          outstring+= outputString(outputStyle,'error','dch16: shasum twice in view: '+key+' '+item['id']+' '+item['value'])
         shasumKeys.append(item['key'])
     return outstring
```

## pasta_eln/dialogConfig.py

```diff
@@ -1,57 +1,50 @@
 """ Entire config dialog (dialog is blocking the main-window, as opposed to create a new widget-window)"""
 import platform
 from PySide6.QtWidgets import QDialog, QVBoxLayout, QTabWidget,  QTextEdit  # pylint: disable=no-name-in-module
-
-from .fixedStrings import configurationOverview
+from .backend import Backend
 from .dialogConfigGUI import ConfigurationGUI
 if platform.system()=='Windows':
   from .dialogConfigSetupWindows import ConfigurationSetup
 else:
   from .dialogConfigSetupLinux import ConfigurationSetup
 
 class Configuration(QDialog):
   """ Main class of entire config dialog """
-  def __init__(self, backend, startTap=''):
+  def __init__(self, backend:Backend, startTab:str=''):
     """
     Initialization
 
     Args:
       backend (Pasta): backend, not communication
-      startTap (str): tab to show initially
+      startTab (str): tab to show initially
     """
     super().__init__()
     self.backend = backend
     self.setWindowTitle('PASTA-ELN configuration')
 
     # GUI elements
     mainL = QVBoxLayout(self)
     tabW = QTabWidget(self)
     mainL.addWidget(tabW)
 
-    # Overview
-    # --------
-    tabOverview = QTextEdit()
-    tabOverview.setMarkdown(configurationOverview)
-    tabW.addTab(tabOverview, 'Overview')
+    # Misc configuration: e.g. theming...
+    tabGUI = ConfigurationGUI(backend, self.finished)
+    tabW.addTab(tabGUI, 'Appearance')
 
     # Setup / Troubeshoot Pasta: main widget
     tabSetup = ConfigurationSetup(backend, self.finished)
     tabW.addTab(tabSetup, 'Setup')
 
-    # Misc configuration: e.g. theming...
-    tabGUI = ConfigurationGUI(backend, self.finished)
-    tabW.addTab(tabGUI, 'Appearance')
-
-    if startTap=='setup':
+    if startTab=='setup':
       tabW.setCurrentWidget(tabSetup)
       tabW.setTabEnabled(0, False)
       tabW.setTabEnabled(2, False)
 
 
-  def finished(self):
+  def finished(self) -> None:
     """
     callback function to close widget
     """
     self.close()
     self.backend.initialize()  #restart backend
     return
```

## pasta_eln/dialogConfigGUI.py

```diff
@@ -1,18 +1,20 @@
 """ Main class of config tab on GUI elements """
 import json
 from pathlib import Path
+from typing import Callable
 from PySide6.QtWidgets import QWidget, QFormLayout, QLabel, QComboBox, QTextEdit  # pylint: disable=no-name-in-module
 from PySide6.QtGui import QFontMetrics # pylint: disable=no-name-in-module
 from .miscTools import restart
 from .style import TextButton
+from .backend import Backend
 
 class ConfigurationGUI(QWidget):
   """ Main class of config tab on GUI elements """
-  def __init__(self, backend, callbackFinished):
+  def __init__(self, backend:Backend, callbackFinished:Callable[[],None]):
     """
     Initialization
 
     Args:
       backend (Pasta): backend, not communication
       callbackFinished (function): callback function to call upon end
     """
@@ -22,22 +24,22 @@
     #GUI elements
     if hasattr(self.backend, 'configuration'):
       self.tabAppearanceL = QFormLayout(self)
       self.theme = self.addRowList('theme','Theme',
         ['dark_amber','dark_blue','dark_cyan','dark_lightgreen','dark_pink','dark_purple', 'dark_red',\
         'dark_teal','dark_yellow','light_amber','light_blue','light_cyan','light_cyan_500','light_lightgreen',\
         'light_pink','light_purple','light_red','light_teal','light_yellow','none'])
-      self.wP = self.addRowList('imageWidthProject','Image width in project view', ['300','400','500','600'])
-      self.wD = self.addRowList('imageWidthDetails','Image width in details view', ['500','600','700','800'])
-      self.wS = self.addRowList('sidebarWidth','Sidebar width', ['200','300','400'])
+      self.wD = self.addRowList('imageSizeDetails','Image size in details view and form', ['300','400','500','600'])
+      self.wP = self.addRowList('imageWidthProject','Image width in project view', ['200','250','300','350','400'])
+      self.wS = self.addRowList('sidebarWidth','Sidebar width', ['220','280','340'])
       self.log = self.addRowList('loggingLevel','Logging level (more->less)', ['DEBUG','INFO','WARNING','ERROR'])
       self.tabAppearanceL.addRow('Save changes', TextButton('Save changes', self.saveData, None))
 
 
-  def addRowList(self, item, label, itemList):
+  def addRowList(self, item:str, label:str, itemList:list[str]) -> QComboBox:
     """
     Add a row with a combo-box to the form
 
     Args:
       item (str): property name in configuration file
       label (str): label used in form
       itemList (list(str)): items to choose from
@@ -48,15 +50,15 @@
     rightW = QComboBox()
     rightW.addItems(itemList)
     rightW.setCurrentText(str(self.backend.configuration['GUI'][item]))
     self.tabAppearanceL.addRow(QLabel(label), rightW)
     return rightW
 
 
-  def addRowText(self, item, label):
+  def addRowText(self, item:str, label:str) -> QTextEdit:
     """
     Add a row with a combo-box to the form
 
     Args:
       item (str): property name in configuration file
       label (str): label used in form
 
@@ -67,20 +69,20 @@
     rightW.setFixedHeight(QFontMetrics(rightW.font()).lineSpacing()*5)
     rightW.setText(' '.join(self.backend.configuration['GUI'][item]))
     rightW.setAccessibleName(item)
     self.tabAppearanceL.addRow(QLabel(label), rightW)
     return rightW
 
 
-  def saveData(self):
+  def saveData(self) -> None:
     """
     Save changes to hard-disk
     """
     self.backend.configuration['GUI']['theme'] = self.theme.currentText()
+    self.backend.configuration['GUI']['imageSizeDetails'] = int(self.wD.currentText())
     self.backend.configuration['GUI']['imageWidthProject'] = int(self.wP.currentText())
-    self.backend.configuration['GUI']['imageWidthDetails'] = int(self.wD.currentText())
     self.backend.configuration['GUI']['sidebarWidth'] =  int(self.wS.currentText())
     self.backend.configuration['GUI']['loggingLevel'] = self.log.currentText()
     with open(Path.home()/'.pastaELN.json', 'w', encoding='utf-8') as fConf:
       fConf.write(json.dumps(self.backend.configuration,indent=2))
     restart()
     return
```

## pasta_eln/dialogConfigSetupLinux.py

```diff
@@ -1,22 +1,24 @@
 """ Widget: setup tab inside the configuration dialog window """
-import webbrowser, logging
+import logging
 from pathlib import Path
-from PySide6.QtWidgets import QWidget, QVBoxLayout, QHBoxLayout, QTextEdit, QMessageBox, QInputDialog, QFileDialog, QProgressBar    # pylint: disable=no-name-in-module
+from typing import Callable
+from PySide6.QtWidgets import QWidget, QVBoxLayout, QTextEdit, QMessageBox, QFileDialog, QProgressBar    # pylint: disable=no-name-in-module
 
-from .style import TextButton
+from .style import TextButton, widgetAndLayout
 from .installationTools import couchdb, configuration, ontology, exampleData, createShortcut, installLinuxRoot
 from .fixedStrings import setupTextLinux, rootInstallLinux, exampleDataLinux
 from .miscTools import restart
+from .backend import Backend
 
 class ConfigurationSetup(QWidget):
   """
   Main class
   """
-  def __init__(self, backend, callbackFinished):
+  def __init__(self, backend:Backend, callbackFinished:Callable[[],None]):
     """
     Initialization
 
     Args:
       backend (Pasta): backend, not communication
       callbackFinished (function): callback function to call upon end
     """
@@ -26,44 +28,40 @@
     self.mainL = QVBoxLayout()
     self.setMinimumWidth(400)
     self.setMinimumHeight(500)
     self.setLayout(self.mainL)
     self.callbackFinished = callbackFinished
 
     #widget 1 = screen 1
-    self.screen1W = QWidget()
-    self.mainL.addWidget(self.screen1W)
-    screen1L = QVBoxLayout(self.screen1W)
+    self.screen1W, screen1L = widgetAndLayout('V', self.mainL)
     self.text1 = QTextEdit()
     self.mainText = setupTextLinux
     self.text1.setMarkdown(self.mainText)
     screen1L.addWidget(self.text1)
     self.progress1 = QProgressBar(self.screen1W)
     self.progress1.setMaximum(24)
     self.progress1.hide()
     screen1L.addWidget(self.progress1)
 
-    footerW = QWidget()
-    screen1L.addWidget(footerW)
-    footerL = QHBoxLayout(footerW)
+    _, footerL = widgetAndLayout('H', screen1L)
     self.button1 = TextButton('Start analyse and repair', self.analyse, footerL)
 
 
-  def callbackProgress(self, number):
+  def callbackProgress(self, number:int) -> None:
     """
     Increse progressbar by moving to number
 
     Args:
       number (int): integer to move to
     """
     self.progress1.setValue(number)
     return
 
 
-  def analyse(self):
+  def analyse(self) -> None:
     """
     Main method that does all the analysis: open dialogs, ...
     """
     flagContinue = True
     logging.info('Linux setup analyse start')
 
     #Couchdb
@@ -74,33 +72,31 @@
       self.text1.setMarkdown(self.mainText)
       existsCouchDB = True
     else:
       existsCouchDB = False
 
     #Install couchdb
     if not existsCouchDB:
-      textCouchDB  = '' if existsCouchDB else 'couch-DB'
-      text = rootInstallLinux.replace('XX--XX', textCouchDB)
-      button = QMessageBox.question(self, "Root installations", text)
+      button = QMessageBox.question(self, "Root installations", rootInstallLinux)
       if button == QMessageBox.Yes:
         dirName = QFileDialog.getExistingDirectory(self,'Create and select directory for scientific data',str(Path.home()))
-        installLinuxRoot(existsCouchDB, dirName)
+        installLinuxRoot(existsCouchDB, Path(dirName))
         logging.info('Install linux root finished')
       else:
         self.mainText = self.mainText.replace('- CouchDB','- CouchDB: user chose to NOT install' )
         self.text1.setMarkdown(self.mainText)
 
     #Configuration
     if flagContinue:
       res = configuration('test')
       if res =='':
         self.mainText = self.mainText.replace('- Configuration of preferences','- Configuration of preferences is acceptable' )
         self.text1.setMarkdown(self.mainText)
       else:
-        button = QMessageBox.question(self, "PASTA-ELN configuration", "Do you want to create/repain the configuration.")
+        button = QMessageBox.question(self, "PASTA-ELN configuration", "Do you want to create/repair the configuration.")
         if button == QMessageBox.Yes:
           configuration('repair')
         else:
           self.mainText = self.mainText.replace('- Configuration of preferences','- Configuration: user chose to NOT install' )
           self.text1.setMarkdown(self.mainText)
           flagContinue = False
 
@@ -109,23 +105,23 @@
       res = ontology('test')
       if '**ERROR' not in res:
         self.mainText = self.mainText.replace('- Ontology of the datastructure','- Ontology of the datastructure is acceptable\n'+res )
         self.text1.setMarkdown(self.mainText)
       else:
         ontology('install')
 
-    # #Shortcut: created automatically #TODO_P5 Aug 2023: remove
-    # if flagContinue:
-    #   button = QMessageBox.question(self, "Create shortcut", "Do you want to create the shortcut for PASTA-ELN on desktop?")
-    #   if button == QMessageBox.Yes:
-    #     createShortcut()
-    #     self.mainText = self.mainText.replace('- Shortcut creation', '- User selected to add a shortcut' )
-    #   else:
-    #     self.mainText = self.mainText.replace('- Shortcut creation', '- User selected to NOT add a shortcut' )
-    #   self.text1.setMarkdown(self.mainText)
+    #Shortcut
+    if flagContinue:
+      button = QMessageBox.question(self, "Create shortcut", "Do you want to create the shortcut for PASTA-ELN on desktop?")
+      if button == QMessageBox.Yes:
+        createShortcut()
+        self.mainText = self.mainText.replace('- Shortcut creation', '- User selected to add a shortcut' )
+      else:
+        self.mainText = self.mainText.replace('- Shortcut creation', '- User selected to NOT add a shortcut' )
+      self.text1.setMarkdown(self.mainText)
 
     #Example data
     if flagContinue:
       button = QMessageBox.question(self, "Example data", exampleDataLinux)
       if button == QMessageBox.Yes:
         self.progress1.show()
         exampleData(True, self.callbackProgress)
@@ -138,14 +134,14 @@
     self.button1.setText('Finished')
     self.button1.clicked.disconnect(self.analyse)
     self.button1.clicked.connect(self.finished)
     logging.info('Linux setup analyse end')
     return
 
 
-  def finished(self):
+  def finished(self) -> None:
     """
     What do do when setup is finished: success or unsuccessfully
     """
     restart()
     # self.callbackFinished()
     return
```

## pasta_eln/dialogConfigSetupWindows.py

```diff
@@ -1,22 +1,24 @@
 """ Widget: setup tab inside the configuration dialog window """
-import webbrowser, logging
+import logging
 from pathlib import Path
-from PySide6.QtWidgets import QWidget, QVBoxLayout, QHBoxLayout, QTextEdit, QMessageBox, QInputDialog, QFileDialog, QProgressBar   # pylint: disable=no-name-in-module
+from typing import Callable
+from PySide6.QtWidgets import QWidget, QVBoxLayout, QTextEdit, QMessageBox, QFileDialog, QProgressBar   # pylint: disable=no-name-in-module
 
-from .style import TextButton
-from .installationTools import couchdb, couchdbUserPassword, configuration, ontology, exampleData, createShortcut
+from .style import TextButton, widgetAndLayout
+from .installationTools import couchdb, configuration, ontology, exampleData, createShortcut
 from .fixedStrings import setupTextWindows, couchDBWindows, exampleDataWindows, restartPastaWindows
 from .miscTools import restart
+from .backend import Backend
 
 class ConfigurationSetup(QWidget):
   """
   Main class
   """
-  def __init__(self, backend, callbackFinished):
+  def __init__(self, backend:Backend, callbackFinished:Callable[[],None]):
     """
     Initialization
 
     Args:
       backend (Pasta): backend, not communication
       callbackFinished (function): callback function to call upon end
     """
@@ -25,44 +27,40 @@
     self.setMinimumWidth(400)
     self.setMinimumHeight(500)
     self.setLayout(self.mainL)
     self.callbackFinished = callbackFinished
     self.backend = backend
 
     #widget 1 = screen 1
-    self.screen1W = QWidget()
-    self.mainL.addWidget(self.screen1W)
-    screen1L = QVBoxLayout(self.screen1W)
+    self.screen1W, screen1L = widgetAndLayout('V', self.mainL)
     self.text1 = QTextEdit()
     self.mainText = setupTextWindows
     self.text1.setMarkdown(self.mainText)
     screen1L.addWidget(self.text1)
     self.progress1 = QProgressBar(self.screen1W)
     self.progress1.setMaximum(24)
     self.progress1.hide()
     screen1L.addWidget(self.progress1)
 
-    footerW = QWidget()
-    screen1L.addWidget(footerW)
-    footerL = QHBoxLayout(footerW)
+    _, footerL = widgetAndLayout('H', screen1L)
     self.button1 = TextButton('Start analyse and repair', self.analyse, footerL)
 
 
-  def callbackProgress(self, number):
+  def callbackProgress(self, number:int) -> None:
     """
     Increse progressbar by moving to number
 
     Args:
       number (int): integer to move to
     """
     self.progress1.setValue(number)
     return
 
 
-  def analyse(self):
+  def analyse(self) -> None:
     """
     Main method that does all the analysis: open dialogs, ...
     """
     flagContinue = True
     flagInstalledSoftware = False
     logging.info('Windows setup analyse start')
 
@@ -92,15 +90,15 @@
       if res =='':
         self.mainText = self.mainText.replace('- Configuration of preferences','- Configuration of preferences is acceptable' )
         self.text1.setMarkdown(self.mainText)
       else:
         button = QMessageBox.question(self, "PASTA-ELN configuration", "Do you want to create/repain the configuration.")
         if button == QMessageBox.Yes:
           dirName = QFileDialog.getExistingDirectory(self,'Create and select directory for scientific data',str(Path.home()/'Documents'))
-          configuration('repair','admin', password,dirName)
+          configuration('repair','admin', password, Path(dirName))
           flagInstalledSoftware = True
         else:
           self.mainText = self.mainText.replace('- Configuration of preferences','- Configuration: user chose to NOT install' )
           self.text1.setMarkdown(self.mainText)
           flagContinue = False
 
     #Ontology
@@ -155,12 +153,12 @@
     self.button1.setText('Finished')
     self.button1.clicked.disconnect(self.analyse)
     self.button1.clicked.connect(self.finished)
     logging.info('Windows setup analyse end')
     return
 
 
-  def finished(self):
+  def finished(self) -> None:
     """
     What do do when setup is finished: success or unsuccessfully
     """
     self.callbackFinished()
```

## pasta_eln/dialogForm.py

```diff
@@ -1,75 +1,78 @@
 """ New/Edit dialog (dialog is blocking the main-window, as opposed to create a new widget-window)"""
-import json
-#pylint: disable=no-name-in-module
-from PySide6.QtWidgets import QDialog, QWidget, QFormLayout, QVBoxLayout, QHBoxLayout, QLabel, QTextEdit, \
-                              QPlainTextEdit, QComboBox, QLineEdit, QDialogButtonBox, QSplitter, QSizePolicy
-#pylint: enable=no-name-in-module
-from .style import Image, TextButton, IconButton
+import logging, re
+from typing import Any, Union
+from PySide6.QtWidgets import QDialog, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QTextEdit, QPushButton,\
+                              QPlainTextEdit, QComboBox, QLineEdit, QDialogButtonBox, QSplitter, QSizePolicy # pylint: disable=no-name-in-module
+from PySide6.QtGui import QRegularExpressionValidator # pylint: disable=no-name-in-module
+from PySide6.QtCore import QSize                      # pylint: disable=no-name-in-module
+from .style import Image, TextButton, IconButton, Label, showMessage, widgetAndLayout
 from .fixedStrings import defaultOntologyNode
 from .handleDictionaries import fillDocBeforeCreate
+from .miscTools import createDirName
+from .communicate import Communicate
 
 class Form(QDialog):
   """ New/Edit dialog (dialog is blocking the main-window, as opposed to create a new widget-window)"""
-  def __init__(self, comm, doc):
+  def __init__(self, comm:Communicate, doc:dict[str,Any]):
     """
     Initialization
 
     Args:
       comm (Communicate): communication channel
       doc (dict):  document to change / create
     """
     super().__init__()
     self.comm = comm
-    self.doc = dict(doc)
+    self.db   = self.comm.backend.db
+    self.doc  = dict(doc)
     if '_attachments' in self.doc:
       del self.doc['_attachments']
-    flagNewDoc = True
-    if '_id' in self.doc:
-      flagNewDoc = False
-    if flagNewDoc:
+    self.flagNewDoc = True
+    if '_id' in self.doc or '_ids' in self.doc:
+      self.flagNewDoc = False
+    if self.flagNewDoc:
       self.setWindowTitle('Create new entry')
       self.doc['-name'] = ''
     else:
       self.setWindowTitle('Edit content')
     self.setMinimumWidth(600)
 
     # GUI elements
     mainL = QVBoxLayout(self)
     if 'image' in self.doc:
-      width = self.comm.backend.configuration['GUI']['imageWidthDetails'] \
+      width = self.comm.backend.configuration['GUI']['imageSizeDetails'] \
                 if hasattr(self.comm.backend, 'configuration') else 300
-      Image(self.doc['image'], mainL, height=width)
-    formW = QWidget()
-    mainL.addWidget(formW)
-    self.formL = QFormLayout(formW)
+      Image(self.doc['image'], mainL, anyDimension=width)
+    _, self.formL = widgetAndLayout('Form', mainL, 's')
 
     #Add things that are in ontology
-    if '-type' in self.doc:
+    if '_ids' not in self.doc:  #normal form
       setattr(self, 'key_-name', QLineEdit(self.doc['-name']))
+      getattr(self, 'key_-name').setValidator(QRegularExpressionValidator("[\\w\\ .-]+"))
       self.formL.addRow('Name', getattr(self, 'key_-name'))
-      if self.doc['-type'][0] in self.comm.backend.db.ontology:
-        ontologyNode = self.comm.backend.db.ontology[self.doc['-type'][0]]['prop']
-      else:
-        ontologyNode = defaultOntologyNode
-      for item in ontologyNode:
-        if item['name'] not in self.doc and  item['name'][0] not in ['_','-']:
-          self.doc[item['name']] = ''
+    if self.doc['-type'][0] in self.db.ontology:
+      ontologyNode = self.db.ontology[self.doc['-type'][0]]['prop']
+    else:
+      ontologyNode = defaultOntologyNode
+    for item in ontologyNode:
+      if item['name'] not in self.doc and  item['name'][0] not in ['_','-']:
+        self.doc[item['name']] = ''
     # Create form
+    if '-tags' not in self.doc:
+      self.doc['-tags'] = []
     for key,value in self.doc.items():
-      if key[0] in ['_','-', '#'] or key in ['image','metaVendor','metaUser','shasum']:
+      if (key[0] in ['_','-', '#'] and key!='-tags') or key in ['image','metaVendor','metaUser','shasum']:
         continue
       # print("Key:value in form | "+key+':'+str(value))
       if key in ['comment','content']:
-        labelW = QWidget()
-        labelL = QVBoxLayout(labelW)
+        labelW, labelL = widgetAndLayout('V')
         labelL.addWidget(QLabel(key.capitalize()))
-        TextButton('Show', self.btnAdvanced, labelL, key, checkable=True)
-        rightSideW = QWidget()
-        rightSideL = QVBoxLayout(rightSideW)
+        TextButton('More', self.btnFocus, labelL, key, checkable=True)  # type: ignore # btnFocus req. bool, cannot get it to work
+        rightSideW, rightSideL = widgetAndLayout('V')
         setattr(self, 'buttonBarW_'+key, QWidget())
         getattr(self, 'buttonBarW_'+key).hide()
         buttonBarL = QHBoxLayout(getattr(self, 'buttonBarW_'+key))
         for name, tooltip in [['bold','Bold text'],['italic','Italic text'],['list-ul','Bullet list'],\
                               ['list-ol','Numbered list']]:
           IconButton('fa5s.'+name, self.btnText, buttonBarL, name+'_'+key, tooltip)
         for i in range(1,4):
@@ -84,142 +87,263 @@
         getattr(self, 'textShow_'+key).hide()
         splitter= QSplitter()
         splitter.setSizePolicy(QSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding))
         splitter.addWidget(getattr(self, 'textEdit_'+key))
         splitter.addWidget(getattr(self, 'textShow_'+key))
         rightSideL.addWidget(splitter)
         self.formL.addRow(labelW, rightSideW)
-      elif key == '-tags':  #remove - to make work
-        # TODO_P3 tags: get selected via a editable QCombobox and get shown as qlabels, that can be deleted
-        # RR: can you already implement tags as list of qlabels with a '-' button on the right to delete
-        # the qcombox comes later once the database knows what tags are and how to generate the list
-        print('')
-      elif isinstance(value, list):       #list of items
+      elif key == '-tags':
+        tagsBarMainW, tagsBarMainL = widgetAndLayout('H', spacing='s')
+        _, self.tagsBarSubL = widgetAndLayout('H', tagsBarMainL, spacing='s', right='m') #part which shows all the tags
+        self.otherChoices = QComboBox()   #part/combobox that allow user to select
+        self.otherChoices.setEditable(True)
+        self.otherChoices.setMaximumWidth(100)
+        self.otherChoices.setValidator(QRegularExpressionValidator("[a-z]\\w+"))
+        self.otherChoices.setIconSize(QSize(0,0))
+        self.otherChoices.setInsertPolicy(QComboBox.InsertAtBottom)
+        tagsBarMainL.addWidget(self.otherChoices)
+        self.gradeChoices = QComboBox()   #part/combobox that shows grades
+        self.gradeChoices.setMaximumWidth(80)
+        self.gradeChoices.setIconSize(QSize(0,0))
+        self.gradeChoices.addItems(['','\u2605','\u2605'*2,'\u2605'*3,'\u2605'*4,'\u2605'*5])
+        self.gradeChoices.currentTextChanged.connect(self.addTag)
+        tagsBarMainL.addWidget(self.gradeChoices)
+        self.formL.addRow(QLabel('Tags:'), tagsBarMainW)
+        self.updateTagsBar()
+        self.otherChoices.currentIndexChanged.connect(self.addTag) #connect to slot only after all painting is done
+      elif isinstance(value, list):       #list of items, qrCodes in sample
         if len(value)>0 and isinstance(value[0], str):
           setattr(self, 'key_'+key, QLineEdit(' '.join(value)))
         else:
           setattr(self, 'key_'+key, QLineEdit('-- strange content --'))
         self.formL.addRow(QLabel(key.capitalize()), getattr(self, 'key_'+key))
       elif isinstance(value, str):        #string
         ontologyItem = [i for i in ontologyNode if i['name']==key]
-        if len(ontologyItem)==1 and 'list' in ontologyItem[0]:  #choice dropdown
+        if len(ontologyItem)==1 and 'list' in ontologyItem[0]:             #choice dropdown
           setattr(self, 'key_'+key, QComboBox())
-          if isinstance(ontologyItem[0]['list'], list):                    #defined choices
+          if isinstance(ontologyItem[0]['list'], list):                    #ontology-defined choices
             getattr(self, 'key_'+key).addItems(ontologyItem[0]['list'])
-          else:                                                 #docType
+          else:                                                            #choice among docType
             listDocType = ontologyItem[0]['list']
             getattr(self, 'key_'+key).addItem('- no link -', userData='')
-            for line in self.comm.backend.db.getView('viewDocType/'+listDocType):
+            for line in self.db.getView('viewDocType/'+listDocType):
               getattr(self, 'key_'+key).addItem(line['value'][0], userData=line['id'])
-              if line['id'] == value:
+              if line['value'][0] == value:
                 getattr(self, 'key_'+key).setCurrentText(line['value'][0])
         else:                                         #text area
           setattr(self, 'key_'+key, QLineEdit(value))
         self.formL.addRow(QLabel(key.capitalize()), getattr(self, 'key_'+key))
       else:
         print("**ERROR dialogForm: unknown value type",key, value)
     #add extra questions at bottom of form
-    if '_id' in self.doc and self.doc['-type'][0][0]!='x': #if not-new and non-folder
+    allowProjectAndDocTypeChange = '_id' in self.doc and self.doc['-type'][0][0]!='x'
+    if '_ids' in self.doc: #if group edit
+      allowProjectAndDocTypeChange = True
+      for docID in self.doc['_ids']:
+        if docID[0]=='x':
+          allowProjectAndDocTypeChange = False
+    if allowProjectAndDocTypeChange: #if not-new and non-folder
+      self.formL.addRow(QLabel('Special properties:'), QLabel('') )
+    label = '- unassigned -' if self.flagNewDoc else '- no change -'
+    if allowProjectAndDocTypeChange or ('_id' not in self.doc and self.doc['-type'][0][0]!='x'): #if new and non-folder
       self.projectComboBox = QComboBox()
-      self.projectComboBox.addItem('- no change -', userData='')
-      for line in self.comm.backend.db.getView('viewDocType/x0'):
+      self.projectComboBox.addItem(label, userData='')
+      for line in self.db.getView('viewDocType/x0'):
         self.projectComboBox.addItem(line['value'][0], userData=line['id'])
       self.formL.addRow(QLabel('Project'), self.projectComboBox)
+    if allowProjectAndDocTypeChange: #if not-new and non-folder
       self.docTypeComboBox = QComboBox()
-      self.docTypeComboBox.addItem('- no change -', userData='')
-      for key, value in self.comm.backend.db.dataLabels.items():
+      self.docTypeComboBox.addItem(label, userData='')
+      for key, value in self.db.dataLabels.items():
         if key[0]!='x':
           self.docTypeComboBox.addItem(value, userData=key)
+      self.docTypeComboBox.addItem('_UNIDENTIFIED_', userData='-')
       self.formL.addRow(QLabel('Data type'), self.docTypeComboBox)
     #final button box
-    buttonBox = QDialogButtonBox(QDialogButtonBox.Save | QDialogButtonBox.Cancel)
+    buttonBox = QDialogButtonBox(QDialogButtonBox.Cancel | QDialogButtonBox.Save)
+    if self.flagNewDoc: #new dataset
+      buttonBox.addButton('Save && Next', QDialogButtonBox.ApplyRole)
     buttonBox.clicked.connect(self.save)
     mainL.addWidget(buttonBox)
 
-  # TODO_P4 ontologyCheck: all names must be different
-  # TODO_P4 form: add button to add key-values
-  def save(self, btn):
+  # TODO_P4 add splitter to increase / decrease image
+  # TODO_P3 image does not allow for easy context aware clicks
+  # TODO_P3 form: add button to add key-values
+  # TODO_P3 other items as non-edible things that can be copy-pasted
+  def save(self, btn:QPushButton) -> None:
     """
     Action upon save / cancel
     """
+    if self.otherChoices.hasFocus():
+      return
     if btn.text().endswith('Cancel'):
       self.reject()
-    elif btn.text().endswith('Save'):
+    elif 'Save' in btn.text():
+      # create the data that has to be saved
       if hasattr(self, 'key_-name'):
         self.doc['-name'] = getattr(self, 'key_-name').text().strip()
-      for key, value in self.doc.items():
+        if self.doc['-name'] == '':
+          showMessage(self, 'Error', 'A created item has to have a valid name')
+          return
+        if self.doc['-type'][0]=='x0':  #prevent project-directory names that are identical
+          others = [i['value'][0] for i in self.comm.backend.db.getView('viewDocType/x0All')]
+          others = [createDirName(i,'x0', 0) for i in others]
+          while createDirName(self.doc['-name'],'x0', 0) in others:
+            if re.search(r"_\d+$", self.doc['-name']) is None:
+              self.doc['-name'] += '_1'
+            else:
+              self.doc['-name'] = '_'.join(self.doc['-name'].split('_')[:-1])+'_'+str(int(self.doc['-name'].split('_')[-1])+1)
+      for key, valueOld in self.doc.items():
         if key[0] in ['_','-'] or key in ['image','metaVendor','metaUser'] or \
             (not hasattr(self, 'key_'+key) and not hasattr(self, 'textEdit_'+key)):
           continue
         if key in ['comment','content']:
-          self.doc[key] = getattr(self, 'textEdit_'+key).toPlainText().strip()
-        elif isinstance(value, list):
+          text = getattr(self, 'textEdit_'+key).toPlainText().strip()
+          if text!='':
+            self.doc[key] = text
+            if key == 'content' and '-branch' in self.doc:
+              for branch in self.doc['-branch']:
+                if branch['path'] is not None:
+                  if branch['path'].endswith('.md'):  #TODO_P5 only write markdown files for now
+                    with open(self.comm.backend.basePath/branch['path'], 'w', encoding='utf-8') as fOut:
+                      fOut.write(self.doc['content'])
+                    logging.debug('Wrote new content to '+branch['path'])
+                  else:
+                    showMessage(self, 'Information', 'Did not update file on harddisk, since PASTA-ELN cannot write this format')
+        elif isinstance(valueOld, list):  #items that are comma separated in the text-field
           self.doc[key] = getattr(self, 'key_'+key).text().strip().split(' ')
-        elif isinstance(value, str):
+        elif isinstance(valueOld, str):
           if isinstance(getattr(self, 'key_'+key), QComboBox):
-            self.doc[key] = getattr(self, 'key_'+key).currentText()
-          else:   #normal text field
+            valueNew         = getattr(self, 'key_'+key).currentText()
+            if valueNew!='- no link -' and getattr(self, 'key_'+key).currentData() is not None and \
+              re.search(r"^[a-z\-]-[a-z0-9]{32}$",getattr(self, 'key_'+key).currentData()) is not None:
+              #if docID is stored in currentData
+              self.doc[key] = getattr(self, 'key_'+key).currentData()
+            elif valueNew!='- no link -' :
+              self.doc[key] = valueNew
+          else:                                  #normal text field
             self.doc[key] = getattr(self, 'key_'+key).text().strip()
+        elif valueOld is None and key in self.doc:  #important entry, set to empty string
+          self.doc[key]=''
         else:
-          print("**ERROR dialogForm unknown value type",key, value)
+          print("**ERROR dialogForm unknown value type",key, valueOld)
+      # ---- if project changed: only branch save; remaining data still needs saving
+      newProjID = []
       if hasattr(self, 'projectComboBox') and self.projectComboBox.currentData() != '':
-        parentPath = self.comm.backend.db.getDoc(self.projectComboBox.currentData())['-branch'][0]['path']
-        self.doc['-branch'] = {'op':'u', 'stack':[self.projectComboBox.currentData()], 'childNum':9999, \
-                               'path':parentPath}
+        parentPath = self.db.getDoc(self.projectComboBox.currentData())['-branch'][0]['path']
+        if '_ids' in self.doc:  # group update
+          for docID in self.doc['_ids']:
+            doc = self.db.getDoc(docID)
+            if doc['-branch'][0]['stack']!=self.projectComboBox.currentData(): #only if project changed
+              if doc['-branch'][0]['path'] is None:
+                newPath    = ''
+              else:
+                oldPath    = self.comm.backend.basePath/doc['-branch'][0]['path']
+                newPath    = parentPath+'/'+oldPath.name
+                oldPath.rename(self.comm.backend.basePath/newPath)
+              self.db.updateBranch( doc['_id'], 0, 9999, [self.projectComboBox.currentData()], newPath)
+        elif '-branch' in self.doc:                   # sequential or single update
+          if self.doc['-branch'][0]['stack']!=self.projectComboBox.currentData(): #only if project changed
+            if self.doc['-branch'][0]['path'] is None:
+              newPath    = ''
+            else:
+              oldPath    = self.comm.backend.basePath/self.doc['-branch'][0]['path']
+              newPath    = parentPath+'/'+oldPath.name
+            self.db.updateBranch( self.doc['_id'], 0, 9999, [self.projectComboBox.currentData()], newPath)
+        else:
+          newProjID = [self.projectComboBox.currentData()]
+      # ---- if docType changed: save; no further save to db required ----
       if hasattr(self, 'docTypeComboBox') and self.docTypeComboBox.currentData() != '':
         self.doc['-type'] = [self.docTypeComboBox.currentData()]
-        self.comm.backend.db.remove(self.doc['_id'])
-        del self.doc['_id']
-        del self.doc['_rev']
-        self.comm.backend.editData(self.doc)
+        if '_ids' in self.doc: #group update
+          for docID in self.doc.pop('_ids'):
+            doc = self.db.getDoc(docID)
+            doc.update( self.doc )
+            self.db.remove(doc['_id'])
+            del doc['_id']
+            del doc['_rev']
+            doc['-name'] = doc['-name'] if doc['-branch'][0]['path'] is None else doc['-branch'][0]['path']
+            doc = fillDocBeforeCreate(doc, self.docTypeComboBox.currentData())
+            self.db.saveDoc(doc)
+        else:                  #single or sequential update
+          self.db.remove(self.doc['_id'])
+          del self.doc['_id']
+          del self.doc['_rev']
+          self.doc = fillDocBeforeCreate(self.doc, self.docTypeComboBox.currentData())
+          self.db.saveDoc(self.doc)
+      # ---- all other changes ----
       else:
         if '_ids' in self.doc: #group update
-          del self.doc['-name']
+          if '-name' in self.doc:
+            del self.doc['-name']
           ids = self.doc.pop('_ids')
           self.doc = {i:j for i,j in self.doc.items() if j!=''}
           for docID in ids:
-            doc = self.comm.backend.db.getDoc(docID)
+            doc = self.db.getDoc(docID)
             doc.update( self.doc )
             self.comm.backend.editData(doc)
         elif '_id' in self.doc:                                   #default update on item
           self.comm.backend.editData(self.doc)
         else:                                                     #create new dataset
-          self.comm.backend.addData(self.doc['-type'][0], self.doc)
-      #NO updates / redraw here since one does not know from where form came
-      # self.comm.changeTable.emit('/'.join(self.doc['-type']),'')
-      # if self.doc['-type'][0]=='x0':
-      #   self.comm.changeSidebar.emit()
-      self.accept()  #close
+          self.comm.backend.addData(self.doc['-type'][0], self.doc, newProjID)
+      #!!! NO updates / redraw here since one does not know from where form came
+      # e.g. sequential edit cannot have redraw here
+      if btn.text().endswith('Next'):
+        for delKey in [i for i in self.doc.keys() if i[0] in ['-','_'] and i not in ['-name','-type','-tags']]:
+          del self.doc[delKey]
+        self.comm.changeTable.emit('', '')
+      else:
+        self.accept()  #close
+        self.close()
     else:
       print('dialogForm: did not get a fitting btn ',btn.text())
     return
 
-  def btnAdvanced(self, status):
+
+
+  def btnFocus(self, status:bool) -> None:
     """
     Action if advanced button is clicked
     """
-    key = self.sender().accessibleName()
+    key = self.sender().accessibleName()  #comment or content
+    unknownWidget = []
     if status:
       getattr(self, 'textShow_'+key).hide()
       getattr(self, 'buttonBarW_'+key).hide()
       for i in range(self.formL.count()):
         widget = self.formL.itemAt(i).widget()
         if isinstance(widget, (QLabel, QComboBox, QLineEdit)):
           widget.show()
+        else:
+          unknownWidget.append(i)
+      if key=='content' and len(unknownWidget)==4:  #show / hide label and right-side of non-content and non-comment
+        self.formL.itemAt(unknownWidget[0]).widget().show()
+        self.formL.itemAt(unknownWidget[1]).widget().show()
+      if key=='comment' and len(unknownWidget)==4:
+        self.formL.itemAt(unknownWidget[2]).widget().show()
+        self.formL.itemAt(unknownWidget[3]).widget().show()
     else:
       getattr(self, 'textShow_'+key).show()
       getattr(self, 'buttonBarW_'+key).show()
       for i in range(self.formL.count()):
         widget = self.formL.itemAt(i).widget()
         if isinstance(widget, (QLabel, QComboBox, QLineEdit)):
           widget.hide()
+        else:
+          unknownWidget.append(i)
+      if key=='content' and len(unknownWidget)==4:
+        self.formL.itemAt(unknownWidget[0]).widget().hide()
+        self.formL.itemAt(unknownWidget[1]).widget().hide()
+      if key=='comment' and len(unknownWidget)==4:
+        self.formL.itemAt(unknownWidget[2]).widget().hide()
+        self.formL.itemAt(unknownWidget[3]).widget().hide()
     return
 
 
-  def btnText(self):
+  def btnText(self) -> None:
     """
     Add help to text area
     """
     command, key = self.sender().accessibleName().split('_')
     if command=='bold':
       getattr(self, 'textEdit_'+key).insertPlainText('**TEXT**')
     elif command=='italic':
@@ -230,15 +354,69 @@
       getattr(self, 'textEdit_'+key).insertPlainText('\n1. item 1\n1. item 2')
     elif command.startswith('heading'):
       getattr(self, 'textEdit_'+key).insertPlainText('#'*int(command[-1])+' Heading\n')
     else:
       print('**ERROR dialogForm: unknowCommand',command)
     return
 
-
-  def textChanged(self):
+  def textChanged(self) -> None:
     """
     Text changed in editor -> update the display on the right
     """
     key = self.sender().accessibleName()
     getattr(self, 'textShow_'+key).setMarkdown( getattr(self, 'textEdit_'+key).toPlainText())
     return
+
+  def delTag(self, _:str, tag:str) -> None:
+    """
+    Clicked button to delete tag
+    """
+    self.doc['-tags'].remove(tag)
+    self.updateTagsBar()
+    return
+
+  def addTag(self, tag:Union[str,int]) -> None:
+    """
+    Clicked to add tag. Since one needs to use indexChanged to allow the user to enter text, that delivers a int. To allow to differentiate
+    between both comboboxes, they cannot be the same (both int), hence grades has to be textChanged
+
+    Args:
+      tag (str, int): index (otherTags) or text (grades)
+    """
+    if isinstance(tag, str):  #text from grades
+      if tag!='':
+        self.doc['-tags'] = [i for i in self.doc['-tags'] if i[0]!='_']
+        self.doc['-tags']+= ['_'+str(len(tag))]
+        self.gradeChoices.setCurrentText('')
+    elif tag<1:               #zero index from other-tags
+      return
+    else:
+      tag = self.otherChoices.currentText()
+      if tag not in self.doc['-tags']:
+        self.doc['-tags'] += [tag]
+      self.otherChoices.setCurrentText('')
+    self.updateTagsBar()
+    return
+
+
+  def updateTagsBar(self) -> None:
+    """
+    After creation, tag removal, tag addition: update the information on screen
+    """
+    #update tags
+    for i in reversed(range(self.tagsBarSubL.count())):
+      self.tagsBarSubL.itemAt(i).widget().setParent(None)  # type: ignore
+    for tag in self.doc['-tags']:
+      if tag in ['_curated']:
+        continue
+      if tag[0]=='_':
+        Label('\u2605'*int(tag[1]), 'h3', self.tagsBarSubL, self.delTag, tag, 'click to remove')
+      else:
+        Label(tag, 'h3', self.tagsBarSubL, self.delTag, tag, 'click to remove')
+    self.tagsBarSubL.addWidget(QWidget(), stretch=2)  # type: ignore
+    #update choices in combobox
+    tagsAllList = self.comm.backend.db.getView('viewIdentify/viewTagsAll')
+    tagsSet = {i['key'] for i in tagsAllList if i['key'][0]!='_'}
+    newChoicesList = ['']+list(tagsSet.difference([i for i in self.doc['-tags'] if i[0]!='_']))
+    self.otherChoices.clear()
+    self.otherChoices.addItems(newChoicesList)
+    return
```

## pasta_eln/dialogOntology.py

```diff
@@ -1,19 +1,18 @@
 """ Table Header dialog: change which colums are shown and in which order """
 import json
 from pathlib import Path
 #pylint: disable=no-name-in-module
-from PySide6.QtWidgets import QDialog, QWidget, QVBoxLayout, QHBoxLayout, QListWidget, QListWidgetItem, \
-                              QLineEdit, QDialogButtonBox
+from PySide6.QtWidgets import QDialog, QVBoxLayout, QDialogButtonBox, QPushButton
 #pylint: enable=no-name-in-module
-from .style import IconButton
+from .backend import Backend
 
 class Ontology(QDialog):
   """ Table Header dialog: change which colums are shown and in which order """
-  def __init__(self, backend):
+  def __init__(self, backend:Backend):
     """
     Initialization
 
     Args:
       backend (Backend): PASTA-ELN backend
     """
     super().__init__()
@@ -26,18 +25,18 @@
 
     #final button box
     buttonBox = QDialogButtonBox(QDialogButtonBox.Save | QDialogButtonBox.Cancel)
     buttonBox.clicked.connect(self.save)
     mainL.addWidget(buttonBox)
 
 
-
-  def save(self, btn):
+  #++ TODO ontologyCheck: all names must be different
+  def save(self, btn:QPushButton) -> None:
     """ save selectedList to configuration and exit """
     if btn.text().endswith('Cancel'):
       self.reject()
     elif btn.text().endswith('Save'):
-      #TODO_P4 finish ontology dialog
+      #TODO_P3 finish ontology dialog
       self.accept()  #close
     else:
       print('dialogOntology: did not get a fitting btn ',btn.text())
     return
```

## pasta_eln/dialogProjectGroup.py

```diff
@@ -1,55 +1,49 @@
 """ Table Header dialog: change which colums are shown and in which order """
 import json
 from pathlib import Path
 import qrcode
 from PIL.ImageQt import ImageQt
-#pylint: disable=no-name-in-module
-from PySide6.QtWidgets import QDialog, QWidget, QVBoxLayout, QHBoxLayout, QListWidget, QListWidgetItem, \
-                              QLineEdit, QDialogButtonBox, QFormLayout, QLabel, QGroupBox, QComboBox, QTextEdit, QFileDialog
-from PySide6.QtGui import QPixmap, QImage, QRegularExpressionValidator
-#pylint: enable=no-name-in-module
-from .style import Label, TextButton, showMessage
+from PySide6.QtWidgets import QDialog, QVBoxLayout, QLabel, QGroupBox, QLineEdit, QDialogButtonBox, QFormLayout, QComboBox, QFileDialog  # pylint: disable=no-name-in-module
+from PySide6.QtGui import QPixmap, QRegularExpressionValidator # pylint: disable=no-name-in-module
+from .style import Label, TextButton, showMessage, widgetAndLayout
 from .miscTools import upOut, restart, upIn
 from .serverActions import testLocal, testRemote, passwordDecrypt
-
+from .backend import Backend
 
 class ProjectGroup(QDialog):
   """ Table Header dialog: change which colums are shown and in which order """
-  def __init__(self, backend):
+  def __init__(self, backend:Backend):
     """
     Initialization
 
     Args:
       backend (Backend): PASTA-ELN backend
     """
     super().__init__()
     self.backend = backend
 
     # GUI elements
     self.setWindowTitle('Define and use project groups')
     self.setMinimumWidth(1000)
     mainL = QVBoxLayout(self)
     Label('Project group', 'h1', mainL)
-    topbarW = QWidget()
-    topbarL = QHBoxLayout(topbarW)
+    _, topbarL = widgetAndLayout('H', mainL, spacing='m')
     self.selectGroup = QComboBox()
     self.selectGroup.addItems(self.backend.configuration['projectGroups'].keys())
     self.selectGroup.currentTextChanged.connect(self.changeProjectGroup)
     topbarL.addWidget(self.selectGroup)
     TextButton('New', self.btnEvent, topbarL, 'new')
     TextButton('Fill remote', self.btnEvent, topbarL, 'fill')
     TextButton('Create QR', self.btnEvent, topbarL, 'createQR')
     TextButton('Check All', self.btnEvent, topbarL, 'check')
-    mainL.addWidget(topbarW)
     self.projectGroupName = QLineEdit('')
     self.projectGroupName.hide()
     mainL.addWidget(self.projectGroupName)
-    bodyW = QWidget()
-    bodyL = QHBoxLayout(bodyW)
+    _, bodyL = widgetAndLayout('H', mainL)
     #local
     localW = QGroupBox('Local credentials')
     localL = QFormLayout(localW)
     self.userNameL = QLineEdit('')
     self.userNameL.setValidator(QRegularExpressionValidator("[\\w.]{5,}"))
     localL.addRow('User name', self.userNameL)
     self.passwordL = QLineEdit('')
@@ -79,25 +73,24 @@
     self.serverR = QLineEdit('')
     self.serverR.setValidator(QRegularExpressionValidator("http:\\/\\/(?:[0-9]{1,3}\\.){3}[0-9]{1,3}:5984"))
     remoteL.addRow('Server', self.serverR)
     bodyL.addWidget(remoteW)
     #image
     self.image = QLabel()
     bodyL.addWidget(self.image)
-    mainL.addWidget(bodyW)
 
     #final button box
     buttonBox = QDialogButtonBox(QDialogButtonBox.Save | QDialogButtonBox.Cancel)
     buttonBox.addButton('Save encrypted', QDialogButtonBox.AcceptRole)
-    buttonBox.clicked.connect(self.close)
+    buttonBox.clicked.connect(self.closeDialog)
     mainL.addWidget(buttonBox)
     self.selectGroup.currentTextChanged.emit(self.backend.configuration['defaultProjectGroup']) #emit to fill initially
 
 
-  def close(self, btn):
+  def closeDialog(self, btn:TextButton) -> None:
     """
     cancel or save entered data
 
     Args:
       btn (QButton): save or cancel button
     """
     print('project group press',btn.text() )
@@ -122,15 +115,15 @@
         fConf.write(json.dumps(self.backend.configuration,indent=2))
       restart()
     else:
       print('dialogProjectGroup: did not get a fitting btn ',btn.text())
     return
 
 
-  def btnEvent(self):
+  def btnEvent(self) -> None:
     """ events that occur when top-bar buttons are pressed """
     btnName = self.sender().accessibleName()
     if btnName=='new':
       self.selectGroup.hide()
       self.projectGroupName.show()
       self.projectGroupName.setText('my_project_group_name')
       self.userNameL.setText('')
@@ -140,15 +133,15 @@
       self.databaseL.setText('')
       self.databaseR.setText('')
       self.pathL.setText('')
       self.serverR.setText('')
     elif btnName=='fill':
       content = QFileDialog.getOpenFileName(self, "Load remote credentials", str(Path.home()), '*.key')[0]
       with open(content, encoding='utf-8') as fIn:
-        content = json.loads( passwordDecrypt(fIn.read()) )
+        content = json.loads( passwordDecrypt(bytes(fIn.read(), 'UTF-8')) )
         self.userNameR.setText(content['user-name'])
         self.passwordR.setText(content['password'])
         self.databaseR.setText(content['database'])
         self.serverR.setText(content['Server'])
     elif btnName=='createQR':
       if self.projectGroupName.isHidden():
         configname = self.selectGroup.currentText()
@@ -160,15 +153,15 @@
       pixmap = QPixmap.fromImage(ImageQt(img).scaledToWidth(200))
       self.image.setPixmap(pixmap)
     elif btnName=='check':
       self.checkEntries()
     return
 
 
-  def checkEntries(self):
+  def checkEntries(self) -> bool:
     """
     Check if entries are ok
 
     Returns:
       bool: success
     """
     # local
@@ -187,15 +180,15 @@
       showMessage(self, 'ERROR occurred', localTest+remoteTest, 'Critical')
       return False
     #success
     showMessage(self, 'Successful test', localTest+remoteTest, 'Information')
     return True
 
 
-  def changeProjectGroup(self, item):
+  def changeProjectGroup(self, item:str) -> None:
     """
     change the project group to this; do not save to file
 
     Args:
       item (str): name of project group
     """
     config = self.backend.configuration['projectGroups'][item]
```

## pasta_eln/dialogTableHeader.py

```diff
@@ -1,19 +1,15 @@
 """ Table Header dialog: change which colums are shown and in which order """
-import json
-from pathlib import Path
-#pylint: disable=no-name-in-module
-from PySide6.QtWidgets import QDialog, QWidget, QVBoxLayout, QHBoxLayout, QListWidget, QListWidgetItem, \
-                              QLineEdit, QDialogButtonBox
-#pylint: enable=no-name-in-module
-from .style import IconButton, showMessage
+from PySide6.QtWidgets import QDialog, QVBoxLayout, QListWidget, QLineEdit, QDialogButtonBox  # pylint: disable=no-name-in-module
+from .style import IconButton, showMessage, widgetAndLayout
+from .communicate import Communicate
 
 class TableHeader(QDialog):
   """ Table Header dialog: change which colums are shown and in which order """
-  def __init__(self, comm, docType):
+  def __init__(self, comm:Communicate, docType:str):
     """
     Initialization
 
     Args:
       comm (Communicate): communication channel
       docType (string):  document type
     """
@@ -25,52 +21,46 @@
       self.allSet = set(i['name'] for i in self.comm.backend.db.ontology[docType]['prop'])
     else:   #default if not defined
       self.selectedList = [i['name'] for i in self.comm.backend.db.ontology[docType]['prop']]
       self.allSet = set()
     self.allSet = self.allSet.union({i['name'] for i in self.comm.backend.db.ontology[docType]['prop']})
     self.allSet = self.allSet.union({'date','#_curated', '-type', '-name', 'comment', '-tags', 'image'})
     #clean it
-    self.allSet = {'\u2605'+i[1:]+'\u2605' if i[0] in ['-','_'] else i for i in self.allSet}  #change -something to something
-    self.allSet = {'cur\u2605ted'          if i=='#_curated'    else i for i in self.allSet}  #change #_something to somehing
-    self.selectedList = ['\u2605'+i[1:]+'\u2605' if i[0] in ['-','_'] else i for i in self.selectedList]  #change -something to something
-    self.selectedList = ['cur\u2605ted'          if i=='#_curated'    else i for i in self.selectedList]  #change #_something to somehing
+    self.allSet = {'_'+i[1:]+'_' if i[0] in ['-','_'] else i for i in self.allSet}  #change -something to something
+    self.allSet = {'_curated_'   if i=='#_curated'    else i for i in self.allSet}  #change #_something to somehing
+    self.selectedList = ['_'+i[1:]+'_' if i[0] in ['-','_'] else i for i in self.selectedList]  #change -something to something
+    self.selectedList = ['_curated_'   if i=='#_curated'    else i for i in self.selectedList]  #change #_something to somehing
 
     # GUI elements
     self.setWindowTitle('Select table headers')
     self.setMinimumWidth(600)
     mainL = QVBoxLayout(self)
-    bodyW = QWidget()
-    bodyL = QHBoxLayout(bodyW)
-    mainL.addWidget(bodyW)
-    leftW = QWidget()
-    leftL = QVBoxLayout(leftW)
+    _, bodyL = widgetAndLayout('H', mainL)
+    _, leftL = widgetAndLayout('V', bodyL)
     self.choicesW = QListWidget()
-    self.choicesW.addItems(self.allSet.difference(self.selectedList))
+    self.choicesW.addItems(list(self.allSet.difference(self.selectedList)))
     leftL.addWidget(self.choicesW)
     self.inputLine = QLineEdit()
     leftL.addWidget(self.inputLine)
-    bodyL.addWidget(leftW)
-    centerW = QWidget()
-    centerL = QVBoxLayout(centerW)
+    _, centerL = widgetAndLayout('V', bodyL)
     IconButton('fa5s.angle-right', self.moveKey, centerL, 'add', 'add right')
     IconButton('fa5s.angle-left', self.moveKey, centerL, 'del', 'remove right')
     IconButton('fa5s.angle-up', self.moveKey, centerL, 'up', 'move up')
     IconButton('fa5s.angle-down', self.moveKey, centerL, 'down', 'move down')
     IconButton('fa5s.angle-double-right', self.moveKey, centerL, 'text', 'use text')
-    bodyL.addWidget(centerW)
     self.selectW = QListWidget()
     self.selectW.addItems(self.selectedList)
     bodyL.addWidget(self.selectW)
     #final button box
     buttonBox = QDialogButtonBox(QDialogButtonBox.Save | QDialogButtonBox.Cancel)
     buttonBox.clicked.connect(self.save)
     mainL.addWidget(buttonBox)
 
 
-  def moveKey(self):
+  def moveKey(self) -> None:
     """ Event if user clicks button in the center """
     btn = self.sender().accessibleName()
     selectedLeft   = [i.text() for i in self.choicesW.selectedItems()]
     selectedRight  = [i.text() for i in self.selectW.selectedItems()]
     oldIndex, newIndex = -1, -1
     if btn == 'add':
       self.selectedList += selectedLeft
@@ -87,33 +77,34 @@
     elif btn == 'text' and self.inputLine.text()!='':
       self.selectedList += [self.inputLine.text()]
       self.allSet.add(self.inputLine.text())
     #change content
     if oldIndex>-1 and newIndex>-1:
       self.selectedList.insert(newIndex, self.selectedList.pop(oldIndex))
     self.choicesW.clear()
-    self.choicesW.addItems(self.allSet.difference(self.selectedList))
+    self.choicesW.addItems(list(self.allSet.difference(self.selectedList)))
     self.selectW.clear()
     self.selectW.addItems(self.selectedList)
     if oldIndex>-1 and newIndex>-1:
       self.selectW.setCurrentRow(newIndex)
     return
 
 
-  def save(self, btn):
+  def save(self, btn:IconButton) -> None:
     """ save selectedList to configuration and exit """
     if btn.text().endswith('Cancel'):
       self.reject()
     elif btn.text().endswith('Save'):
-      # self.selectedList = ['#_curated' if i=='cur\u2605ted' else i  for i in self.selectedList]  #change #_something to somehing
-      # self.selectedList = ['-'+i[1:-1] if i[0]=='\u2605' and i[-1]=='\u2605'else i  for i in self.selectedList] #change -something to something
+      # self.selectedList = ['#_curated' if i=='_curated_' else i  for i in self.selectedList]  #change #_something to somehing
+      # self.selectedList = ['-'+i[1:-1] if i[0]=='\u2605' and i[-1]=='\u2605' else i  for i in self.selectedList] #change -something to something
       # self.comm.backend.configuration['tableHeaders'][self.docType] = self.selectedList
       # with open(Path.home()/'.pastaELN.json', 'w', encoding='utf-8') as fConf:
       #   fConf.write(json.dumps(self.comm.backend.configuration,indent=2))
       # self.comm.changeTable('','')
       # self.comm.changeDetails('redraw')
-      #TODO_P4 tableHeaderChange: requires view to change to views, not ontology
+      #TODO_P3 tableHeaderChange: requires view to change to views, not ontology
       showMessage(self, 'To be implemented','The changing of the table headers has to be fully implemented, yet.')
+      self.comm.backend.db.initViews(self.comm.backend.configuration)
       self.accept()  #close
     else:
       print('dialogTableHeader: did not get a fitting btn ',btn.text())
     return
```

## pasta_eln/fixedStrings.py

```diff
@@ -58,99 +58,88 @@
    {"name": "-tags"},
    {"name": "comment", "query": "#tags comments remarks :field:value:"},
    {"name": "-type"}]
 """)
 
 
 setupTextLinux = """
-### Welcome to PASTA-ELN setup for Linux
-Three components are needed for proper function
+### Welcome to the PASTA-ELN setup for Linux
+Three components are needed for proper functioning of PASTA-ELN:
 - CouchDB
 - Configuration of preferences / default ontology
-- Example data
+- Example project creation
 
-Analyse and (possibly) correct these items.
+This setup will analyse and (possibly) correct these items.
 
-If the installation is successful, permanently remove the 'pastaELN.log' logfile that is in your home-directory.
-
-Note: this text becomes an installation report
+If the installation is successful, manually and permanently remove the 'pastaELN.log' logfile that is in your home-directory.
 """
 
 
 setupTextWindows = """
-### Welcome to PASTA-ELN setup for Windows
-Four components are needed for proper function
+### Welcome to the PASTA-ELN setup for Windows
+Four components are needed for proper functioning of PASTA-ELN:
 - CouchDB
 - Configuration of preferences / default ontology
 - Shortcut creation
-- Example data
+- Example project creation
 
-Analyse and (possibly) correct these items.
+This setup will analyse and (possibly) correct these items.
 
-If the installation is successful, permanently remove the 'pastaELN.log' logfile that is in your home-directory (folder above "My Documents").
+If the installation is successful, manually and permanently remove the 'pastaELN.log' logfile that is in your home-directory (folder above "My Documents").
 
 If an attempt fails: please follow to this [website](https://pasta-eln.github.io/pasta-eln/install.html).
-
-
-Note: this text becomes an installation report
-"""
-
-configurationOverview = """
-## Overview
-###  Setup: Setup and troubleshoot PASTA-ELN installation
-### Project group: configure how project groups are saved
-### Ontology: configure the data structure for current project group
-### Miscellaneous: different things like look-and-feel
 """
 
 gitWindows = """
 Do you want to install git?
 
 Be aware, downloading the installer requires some time, depending on the internet connection.
 """
 
 rootInstallLinux = """
-Do you want to install XX--XX?
+Do you want to install Apache CouchDB (TM)?
 If you choose yes, you will be first asked to
 
-- choose a location to store the data
-- a terminal will open and ask you for the super-user password.
+- choose a directory to store the data
+- enter the super-user password in the new terminal that will open automatically
 
-Be aware, downloading the installer requires some time, depending on the internet connection.
+Be aware that downloading the installer requires time, depending on the internet connection.
 """
 
 couchDBWindows = """
 Do you want to install CouchDB?
 
-Be aware, downloading the installer requires some time, depending on the internet connection.
+Be aware that downloading the installer requires time, depending on the internet connection.
 """
 
 restartPastaWindows = """
 Close software now (will be done automatically in the future)
 
 Please restart the software by
 - clicking on the shortcut OR
 - executing the command in a new cmd.exe window
 """
 
 exampleDataLinux = """
-Do you want to install example data?
+Do you want to create an example project?
 
-This step helps to verify the installation and the data is an helpful example for new users.
+This step helps to verify the installation and provides an helpful example for new users.
 
-!WARNING! This will RESET everything and thereby DELETE EVERYTHING since you installed pastaELN.
+!WARNING! This process will RESET everything and thereby DELETE EVERYTHING since you installed pastaELN.
 
-This step usually takes up to 20sec, so please be patient. Sometimes, linux likes to mention that the program
-is hanging and asks if to close/wait. Please WAIT.
+This step usually takes up to 20sec, so please be patient. Sometimes, Linux mentions that the program
+is not responding and asks if to close/wait. Please WAIT.
 """
 
 exampleDataWindows = """
-Do you want to install the example data?
+Do you want to create an example project?
+
+This step helps to verify the installation and provides an helpful example for new users.
 
-This step helps to verify the installation and the data is an helpful example for new users.
+!WARNING! This process will RESET everything and thereby DELETE EVERYTHING since you installed pastaELN.
 
 This step usually takes up to 1min, so please be patient.
 """
 
 shortcuts = """
 Ctrl+P: List projects
 Ctrl+M: List measurements
```

## pasta_eln/gui.py

```diff
@@ -1,49 +1,53 @@
 """ Graphical user interface includes all widgets """
-import os, logging, webbrowser, json
+import os, logging, webbrowser, json, sys
+from typing import Any
 from pathlib import Path
-from PySide6.QtCore import Qt, Slot      # pylint: disable=no-name-in-module
 from PySide6.QtWidgets import QMainWindow, QWidget, QHBoxLayout, QApplication, QFileDialog # pylint: disable=no-name-in-module
-from PySide6.QtGui import QIcon, QPixmap, QAction    # pylint: disable=no-name-in-module
+from PySide6.QtCore import Qt, Slot      # pylint: disable=no-name-in-module
+from PySide6.QtGui import QIcon, QPixmap  # pylint: disable=no-name-in-module
 from qt_material import apply_stylesheet  #of https://github.com/UN-GCPDS/qt-material
 
+from pasta_eln import __version__
 from .backend import Backend
 from .communicate import Communicate
 from .widgetSidebar import Sidebar
 from .widgetBody import Body
 from .dialogForm import Form
 from .dialogConfig import Configuration
 from .dialogProjectGroup import ProjectGroup
 from .dialogOntology import Ontology
 from .miscTools import updateExtractorList, restart
-from .mixin_cli import text2html
-from .style import Action, showMessage
+from .style import Action, showMessage, widgetAndLayout, shortCuts
 from .fixedStrings import shortcuts
 os.environ['QT_API'] = 'pyside6'
 
 # Subclass QMainWindow to customize your application's main window
 class MainWindow(QMainWindow):
   """ Graphical user interface includes all widgets """
-  def __init__(self):
+  def __init__(self) -> None:
     #global setting
     super().__init__()
-    self.setWindowTitle("PASTA-ELN")
-    self.setWindowState(Qt.WindowMaximized)
+    venv = ' without venv' if sys.prefix == sys.base_prefix else ' in venv'
+    self.setWindowTitle("PASTA-ELN "+__version__+venv)
+    self.setWindowState(Qt.WindowMaximized) # type: ignore
     resourcesDir = Path(__file__).parent/'Resources'
     self.setWindowIcon(QIcon(QPixmap(resourcesDir/'Icons'/'favicon64.png')))
     self.backend = Backend()
     self.comm = Communicate(self.backend)
     self.comm.formDoc.connect(self.formDoc)
 
     #Menubar
     menu = self.menuBar()
     projectMenu = menu.addMenu("&Project")
     Action('&Export .eln',          self.executeAction, projectMenu, self, name='export')
     Action('&Import .eln',          self.executeAction, projectMenu, self, name='import')
     projectMenu.addSeparator()
+    Action('&Syncronize',           self.executeAction, projectMenu, self, name='sync', shortcut='F5')
+    projectMenu.addSeparator()
     Action('&Exit',                 self.executeAction, projectMenu, self, name='exit')
     viewMenu = menu.addMenu("&Lists")
     systemMenu = menu.addMenu("&System")
     Action('&Project groups',        self.executeAction, systemMenu, self, name='projectGroups')
     changeProjectGroups = systemMenu.addMenu("&Change project group")
     if hasattr(self.backend, 'configuration'):                       #not case in fresh install
       for name in self.backend.configuration['projectGroups'].keys():
@@ -52,70 +56,75 @@
     systemMenu.addSeparator()
     Action('Update &Extractor list', self.executeAction, systemMenu, self, name='updateExtractors')
     Action('&Verify database',       self.executeAction, systemMenu, self, name='verifyDB', shortcut='Ctrl+?')
     systemMenu.addSeparator()
     Action('&Configuration',         self.executeAction, systemMenu, self, name='configuration')
     helpMenu = menu.addMenu("&Help")
     Action('&Website',               self.executeAction, helpMenu, self, name='website')
-    Action('&Test file extraction',  self.executeAction, helpMenu, self, name='extractorTest')
-    Action('&Test selected item extraction', self.executeAction, helpMenu, self, name='extractorTest2', shortcut='F2')
-    Action('&Shortcuts',             self.executeAction, helpMenu, self, name='shortcuts')
-    Action('&Todo list',             self.executeAction, helpMenu, self, name='todo')
-
+    Action('Shortcuts',              self.executeAction, helpMenu, self, name='shortcuts')
+    Action('Todo list',              self.executeAction, helpMenu, self, name='todo')
+    helpMenu.addSeparator()
+    Action('&Test extraction from a file',   self.executeAction, helpMenu, self, name='extractorTest')
+    Action('Test &selected item extraction', self.executeAction, helpMenu, self, name='extractorTest2',
+           shortcut='F2')
+    Action('&Restart',              self.executeAction, helpMenu, self, name='restart', shortcut='F9')
     if hasattr(self.backend, 'db'):
-      shortCuts = {'measurement':'m', 'sample':'s', 'x0':'p'} #TODO_P5 addToConfig
       for docType, docLabel in self.comm.backend.db.dataLabels.items():
         if docType[0]=='x' and docType[1]!='0':
           continue
         Action(docLabel, self.viewMenu, viewMenu, self, \
           "Ctrl+"+shortCuts[docType] if docType in shortCuts else None, docType)
         if docType=='x0':
           viewMenu.addSeparator()
       viewMenu.addSeparator()
       Action('&Tags',         self.viewMenu, viewMenu, self, 'Ctrl+T', '_tags_')
-      Action('&Unidentified', self.viewMenu, viewMenu, self, name='-')
-      #TODO_P4 create list of unaccessible files: linked with accessible files
+      Action('&Unidentified', self.viewMenu, viewMenu, self, 'Ctrl+U', name='-')
+      #TODO_P5 create list of unaccessible files: linked with accessible files
 
     #GUI elements
-    mainWidget = QWidget()
-    mainLayout = QHBoxLayout()
-    mainLayout.setContentsMargins(0,0,0,0)
-    mainLayout.setSpacing(0)
-    mainWidget.setLayout(mainLayout)
+    mainWidget, mainLayout = widgetAndLayout('H')
     self.setCentralWidget(mainWidget)      # Set the central widget of the Window
     body = Body(self.comm)        #body with information
-    sidebar = Sidebar(self.comm)  #sidebar with buttons
-    mainLayout.addWidget(sidebar)
+    self.sidebar = Sidebar(self.comm)  #sidebar with buttons
+    mainLayout.addWidget(self.sidebar)
     mainLayout.addWidget(body)
     self.comm.changeTable.emit('x0','')
 
 
   @Slot(str)
-  def formDoc(self, doc):
+  def formDoc(self, doc:dict[str,Any]) -> None:
     """
     What happens when new/edit dialog is shown
 
     Args:
       doc (dict): document
     """
+    if '_id' in doc:
+      logging.debug('gui:formdoc '+str(doc['_id']))
+    elif '_ids' in doc:
+      logging.debug('gui:formdoc '+str(doc['_ids']))
+    else:
+      logging.debug('gui:formdoc of type '+str(doc['-type']))
     formWindow = Form(self.comm, doc)
-    formWindow.exec()
+    ret = formWindow.exec()
+    if ret==0:
+      self.comm.stopSequentialEdit.emit()
     return
 
 
-  def viewMenu(self):
+  def viewMenu(self) -> None:
     """
     act on user pressing an item in view
     """
     docType = self.sender().data()
     self.comm.changeTable.emit(docType, '')
     return
 
 
-  def executeAction(self):
+  def executeAction(self) -> None:
     """
     action after clicking menu item
     """
     menuName = self.sender().data()
     if menuName=='configuration':
       dialog = Configuration(self.comm.backend)
       dialog.exec()
@@ -123,72 +132,82 @@
       dialog = ProjectGroup(self.comm.backend)
       dialog.exec()
     elif menuName=='ontology':
       showMessage(self, 'To be implemented','A possibility to change the questionaires / change the ontology is missing.')
       # dialog = Ontology(self.comm.backend)
       # dialog.exec()
     elif menuName=='updateExtractors':
-      updateExtractorList(self.backend.extractorPath)
+      report = updateExtractorList(self.backend.extractorPath)
+      showMessage(self, 'Extractor list updated', report)
+      restart()
     elif menuName=='verifyDB':
-      report = self.comm.backend.checkDB(True)
-      showMessage(self, 'Report of database verification', text2html(report), style='QLabel {min-width: 800px}')
+      report = self.comm.backend.checkDB(outputStyle='html', minimal=True)
+      showMessage(self, 'Report of database verification', report, style='QLabel {min-width: 800px}')
+    elif menuName=='sync':
+      report = self.comm.backend.replicateDB(progressBar=self.sidebar.progress)
+      showMessage(self, 'Report of syncronization', report, style='QLabel {min-width: 450px}')
     elif menuName=='exit':
       self.close()
     elif menuName=='website':
       webbrowser.open('https://pasta-eln.github.io/pasta-eln/')
     elif menuName=='extractorTest':
       fileName = QFileDialog.getOpenFileName(self,'Open file for extractor test',str(Path.home()),'*.*')[0]
-      report = self.comm.backend.testExtractor(fileName, reportHTML=True)
+      report = self.comm.backend.testExtractor(fileName, outputStyle='html')
       showMessage(self, 'Report of extractor test', report)
     elif menuName=='extractorTest2':
       self.comm.testExtractor.emit()
     elif menuName=='shortcuts':
       showMessage(self, 'Keyboard shortcuts', shortcuts)
+    elif menuName=='restart':
+      restart()
     elif menuName=='todo':
       try:
         from .tempStrings import todoString
         showMessage(self, 'List of items on todo list',todoString)
       except:
         pass
     else:
       showMessage(self, 'ERROR','menu not implemented yet: '+menuName, icon='Warning')
     return
 
 
-  def changeProjectGroup(self):
+  def changeProjectGroup(self) -> None:
     """
     change default project group in configuration file and restart
     """
     self.backend.configuration['defaultProjectGroup'] = self.sender().data()
     with open(Path.home()/'.pastaELN.json', 'w', encoding='utf-8') as fConf:
       fConf.write(json.dumps(self.backend.configuration,indent=2))
     restart()
     return
 
+# TODO_P5 copy of file: should it the be the same in database or should it be two separate entities??
+#         - what happens if you want to change metadata of one but don't want to change the other?
+#           - copy of raw data into one that will changed, to clean
 
 ##############
 ## Main function
-def main():
+def main() -> None:
   """ Main method and entry point for commands """
-  app = QApplication()
-  window = MainWindow()
-  # logging
+  # logging has to be started first
   logPath = Path.home()/'pastaELN.log'
   #  old versions of basicConfig do not know "encoding='utf-8'"
-  logLevel = getattr(logging, window.backend.configuration['GUI']['loggingLevel'])
-  logging.basicConfig(filename=logPath, level=logLevel, format='%(asctime)s|%(levelname)s:%(message)s',
+  logging.basicConfig(filename=logPath, level=logging.INFO, format='%(asctime)s|%(levelname)s:%(message)s',
                       datefmt='%m-%d %H:%M:%S')
-  for package in ['urllib3', 'requests', 'asyncio', 'PIL', 'matplotlib.font_manager']:
+  for package in ['urllib3', 'requests', 'asyncio', 'PIL', 'matplotlib']:
     logging.getLogger(package).setLevel(logging.WARNING)
   logging.info('Start PASTA GUI')
   # remainder
+  app = QApplication()
+  window = MainWindow()
+  logging.getLogger().setLevel(getattr(logging, window.backend.configuration['GUI']['loggingLevel']))
   theme = window.backend.configuration['GUI']['theme']
   if theme!='none':
     apply_stylesheet(app, theme=theme+'.xml')
-  # test if qtawesome and matplot can coexist
+  # qtawesome and matplot cannot coexist
   import qtawesome as qta
   if not isinstance(qta.icon('fa5s.times'), QIcon):
     logging.error('qtawesome: could not load. Likely matplotlib is included and can not coexist.')
     print('qtawesome: could not load. Likely matplotlib is included and can not coexist.')
   # end test coexistance
   window.show()
   app.exec()
```

## pasta_eln/handleDictionaries.py

```diff
@@ -1,12 +1,13 @@
 """Change the format of dictionaries"""
 import re, uuid
+from typing import Any
 from datetime import datetime
 
-def ontology2Labels(ontology, tableFormat):
+def ontology2Labels(ontology:dict[str,Any], tableFormat:dict[str,Any]) -> dict[str,Any]:
   """
   Extract labels and create lists of docType,docLabel pair
   - docLabel is the plural human-readable form of the docType
   - docType is the single-case noun
 
   Not sure if separation into datalabels and hierarchy labels is still needed. Join
 
@@ -33,15 +34,15 @@
       hierarchyDict[key] = label
     else:
       dataDict[key] = label
   dataDict.update(hierarchyDict)  #join hierarchy and datalabels because reason for separation unclear
   return dataDict
 
 
-def fillDocBeforeCreate(data, docType):
+def fillDocBeforeCreate(data:dict[str,Any], docType:list[str]) -> dict[str,Any]:
   """ Fill the data before submission to database with common data
   - type, project, childs
   - separate comment into tags, fields
   - create id if needed
 
   used in backend.py and Store.js
 
@@ -51,52 +52,59 @@
 
   Returns:
     str: document
   """
   protectedKeys = ['comment','-tags','image']
   # Handle the important entries: -type, _id, -date, -branch
   if '-type' not in data:
-    data['-type'] = [docType]
+    data['-type'] = docType
+  if data['-type']==['']:
+    data['-type']=['-']
   if isinstance(data['-type'], str):
     data['-type'] = data['-type'].split('/')
   if '_id' not in data:  # if new (if not update): create new id
-    data['_id'] = docType[0][0]+'-'+uuid.uuid4().hex
+    data['_id'] = data['-type'][0][0]+'-'+uuid.uuid4().hex
   data['-date']   = datetime.now().isoformat()
   if '-branch' not in data:
     print('Empty branch in data')
     data['-branch'] = [{'stack':[], 'path':None, 'child':-1, 'show':[]}]
-  if 'show' not in data['-branch']:
+  if 'show' not in data['-branch'] and isinstance(data['-branch'], dict):
     data['-branch']['show'] = [True]*(len(data['-branch']['stack'])+1)
   # separate comment into tags and fields
   # these tags are lost: '#d': too short; '#3tag': starts with number
   if 'comment' not in data:
     data['comment'] =''
   if '-tags' not in data:
     data['-tags'] = []
   #always do regex expressions twice: if #lala at beginnig or in middle of comment
   curated = re.findall(r'(?:^|\s)#_curated(?:\s|$)', data['comment']) # #_curated
   rating  = re.findall(r'(?:^|\s)#_\d(?:\s|$)',      data['comment']) # #_number
   if rating is None:
     rating=[]
-  otherTags = re.findall(r'(?:^|\s)#[a-zA-Z]\w+(?:\s|$)', data['comment'])
+  if len(rating)>1:  #prevent multiple new ratings
+    rating=rating[:1]
+  if len(rating)==1: #remove ratings that exist already
+    data['-tags'] = [i for i in data['-tags'] if not re.compile(r'^_\d$').match(i)]
+  otherTags = re.findall(r'(?:^|\s)#[a-zA-Z]\w+(?=\s|$)', data['comment'])
   if otherTags is None:
     otherTags=[]
   data['-tags'] = rating + data['-tags'] + otherTags + curated
-  data['comment'] = re.sub(r'(?:\s|$)#\w+(?:\s|$)', '', data['comment']).strip()
+  data['comment'] = re.sub(r'(?:^|\s)#\w+(?=\s|$)', '', data['comment']).strip()
   fields = re.findall(r':[\S]+:[\S]+:', data['comment'])
   if fields is not None:
     for item in fields:
       aList = item.split(':')
       if aList[1] in data: #do not add if item already exists
         continue
       data[aList[1]] = aList[2]
   data['comment'] = re.sub(r':[\S]+:[\S]+:','',data['comment'])  #remove :field:data: information
   if isinstance(data['-tags'], str):
     data['-tags'] = data['-tags'].split(' ')
-  data['-tags']= [i.strip()[1:] for i in data['-tags']]
+  data['-tags'] = [i.strip()[1:] if i.strip()[0]=='#' else i.strip() for i in data['-tags']]
+  data['-tags'] = list(set(data['-tags']))  #ensure only one is inside
   #other cleaning
   if 'links' in data and isinstance(data['links'], list):
     if len(data['links'])==0 or (len(data['links'])==1 and data['links'][0]==''):
       del data['links']
   #individual verification of documents
   if data['-type'][0]=='sample':
     if 'qrCode' not in data:
@@ -115,7 +123,36 @@
       if data[key]=='' and key not in protectedKeys:
         toDelete.append(key)
       else:
         data[key] = data[key].strip()
   for key in toDelete:
     del data[key]
   return data
+
+
+def diffDicts(dict1:dict[str,Any], dict2:dict[str,Any]) -> str:
+  """ Check if two dictionaries differ. Just compare the lowest level keys/values and output string
+
+  Args:
+    dict1 (dict): dictionary 1
+    dict2 (dict): dictionary 2
+
+  Returns:
+    str: output with \\n
+  """
+  ignoreKeys = ['-client','_rev']
+  outString = ''
+  dict2Copy = dict(dict2)
+  for key,value in dict1.items():
+    if key in ignoreKeys:
+      continue
+    if key not in dict2Copy:
+      outString += 'key not in dictionary 2: '+key+'\n'
+      continue
+    if value != dict2Copy[key]:
+      outString += 'values differ for key: '+key+'\n   '+str(value)+'\n   '+str(dict2Copy[key])+'\n'
+    del dict2Copy[key]
+  for key in dict2Copy.keys():
+    if key in ignoreKeys:
+      continue
+    outString += 'key not in dictionary 1: '+key+'\n'
+  return outString
```

## pasta_eln/inputOutput.py

```diff
@@ -1,382 +1,337 @@
 """Input and output functions towards the .eln file-format"""
-import os, io, json, shutil, base64, subprocess
+import os, json, shutil, logging, hashlib
+from typing import Any
 from pathlib import Path
 from datetime import datetime
 from zipfile import ZipFile, ZIP_DEFLATED
+from pasta_eln import __version__
+from .backend import Backend
+#TODO_P5 Add read info from ror and orcid into personal details section -> config.json
+# curl https://api.ror.org/organizations/02nv7yv05
+# curl -s -H "Accept: application/json" https://pub.orcid.org/v3.0/0000-0001-7691-2856
+
+# include into ./
+# https://gitlab.mpcdf.mpg.de/smenon/elastic-constant-demo/-/blob/main/metadata_data.yml
+# use project metadata to fill as much as possible
+
+#GENERAL TERMS IN ro-crate-metadata.json (None implies not saved)
+pasta2json = {
+  '_id'    : 'identifier',
+  '_rev'   : None,
+  '_attachments': None,
+  '-name'  : 'name',
+  '-tags'  : 'keywords',
+  '-date'  : 'dateModified',
+  '-user'  : None,
+  '-client': None,
+  'comment': 'comment',
+  'content': 'text',
+  'links'  : 'mentions',
+}
+# Possible extensions
+#  'image'  : 'image'
+#
+# # keys not in this dict and require json name
+# 'metaUser', 'status', 'procedure', 'metaVendor', 'chemistry', '-branch', '-type', 'qrCode', 'shasum', 'objective'
+requiredKeys = ['_id', '-name', '-tags', '-date', '-user', '-client']
+
+# Special terms in other elns
+elabFTW = {
+  'elabid':'_id',
+  'title':'-name',
+  'tags':'-tags',
+  'lastchange':'-date',
+  'userid':'-user',
+  'metadata':'metaUser',
+  'id':'_id',
+  'category': '-type'
+}
+# tags: "abc|efg" vs ['abc','efg']
+# internal identifier (elabFTW:id) vs global identifier (elabFTW: identifier)
 
-def importELN(backend, database, elnFileName):
+
+
+# if others eln: write new addDoc to add hierStack and branch based on path
+# - Don't create folders then
+# use internal id for now
+# create a dictonary of old id and new id
+# tags see if list: else split at |
+
+def importELN(backend:Backend, elnFileName:str) -> str:
   '''
   import .eln file from other ELN or from PASTA
 
   Args:
     backend (backend): backend
-    database (string): name of database
-    elnFileName (string): name of file
+    elnFileName (str): name of file
 
   Returns:
-    bool: success of import
+    str: success message
   '''
+  keysNotInDict:set[str] = set()
 
-  def processPart(part):
+  def processPart(part:dict[str,str]) -> int:
     """
     recursive function call to process this node
 
     Args:
       part (dict): dictionary containing this data content
 
     Returns:
       bool: success of this function
     """
-    if not isinstance(part, dict):
+    addedDocs = 0
+    if not isinstance(part, dict): #leave these tests in since other .elns might do funky stuff
       print("**ERROR in part",part)
       return False
-    print('\nProcess:',part['@id'])
+    logging.info('Process: '+part['@id'])
+    print('Process: '+part['@id'])
     # find next node to process
-    newNode = [i for i in graph if '@id' in i and i['@id']==part['@id']]
-    if len(newNode)>1:
-      print('**ERROR multiple nodes with same id')
+    newNodes = [i for i in graph if '@id' in i and i['@id']==part['@id']]
+    if len(newNodes)>1:
+      print('**ERROR multiple nodes with same id', newNodes)
       return False
     # if node with more subnodes
-    if len(newNode)==1:
-      newNode = newNode[0]
+    if len(newNodes)==1:
+      newNode = newNodes[0]
       subparts = newNode.pop('hasPart') if 'hasPart' in newNode else []
-      print('subparts:\n'+'\n'.join(['  '+i['@id'] for i in subparts]))
-      #depending on ELN
-      if elnName=='Kadi4Mat':
-        docType = 'x'+str(len(newNode['@id'].split('/'))-2)
-        newNode['pathOnKadi4Mat'] = newNode.pop('@id')
-        newNode['-name'] = newNode.pop('name')
-        if 'description' in newNode:
-          newNode['comment']=newNode.pop('description')
-      elif elnName=='PASTA ELN':
-        docType = newNode['-type'][0]
-        newNode['_id'] = newNode.pop('@id')
-        if len(subparts)==1 and subparts[0]['@id'].startswith('__thumbnails__'):
-          with elnFile.open(dirName+os.sep+subparts[0]['@id']) as elnFilePointer:
-            imgdata = elnFilePointer.read()
-            if subparts[0]['@id'].endswith('.png'):
-              newNode['image'] = "data:image/png;base64," + base64.b64encode(imgdata).decode()
-            elif subparts[0]['@id'].endswith('.svg'):
-              newNode['image'] = imgdata.decode("utf-8")
-            else:
-              print("**ERROR cannot read this thumbnail")
-          subparts = []
-      else:
-        print('**ERROR undefined ELN-Name', elnName)
-      #for all ELN
-      if '@type' in newNode:
-        del newNode['@type']
-      if elnVersion is not None:
-        newNode['importedFrom'] = elnName+' '+elnVersion
-        elnVersion = None
-      if elnName=='PASTA ELN' and newNode['-type'][0]!='x0':
-        backend.db.saveDoc(newNode)
-        if newNode['-type'][0][0]=='x':
-          os.makedirs(backend.basePath+newNode['-branch'][0]['path'])
-        backend.currentID = newNode['_id']
-      else:
-        backend.addData(docType,newNode)
+      if len(subparts)>0:
+        logging.info('subparts:'+', '.join(['  '+i['@id'] for i in subparts]))
+        print('subparts:'+', '.join(['  '+i['@id'] for i in subparts]))
+      fullPath = backend.basePath/newNode['@id']
+      if newNode['@id'].endswith('.json'):                    #read json content into DB
+        with elnFile.open( (Path(dirName)/newNode['@id']).as_posix() ) as fIn:
+          jsonContent = fIn.read()
+          for dataJson in json.loads(jsonContent):
+            #Transcribe content
+            dataPasta = {}
+            for key, value in dataJson.items():
+              if key in json2pasta:
+                dataPasta[json2pasta[key]] = value
+              else:
+                dataPasta[key] = value
+                keysNotInDict.add(key)
+            dataPasta['-client'] = 'Imported from '+elnName+' '+elnVersion
+            addedDocs += 1
+            for reqKey in requiredKeys:
+              if reqKey not in dataPasta:
+                print('**ERROR key not in doc', reqKey)
+            backend.db.saveDoc(dataPasta)
+      elif newNode['@type']=='Dataset':                     #create folder
+        fullPath.mkdir(exist_ok=True)
+      else:                                                 #copy file
+        # print('copy file', dirName+'/'+part['@id'], fullPath)
+        target = open(fullPath, "wb")
+        source = elnFile.open( (Path(dirName)/part['@id']).as_posix())
+        with source, target:  #extract one file to its target directly
+          shutil.copyfileobj(source, target)
       #recursive part
       if len(subparts)>0:  #don't do if no subparts: measurements, ...
-        backend.changeHierarchy(backend.currentID)
+        # backend.changeHierarchy(backend.currentID)
         for subpart in subparts:
-          processPart(subpart)
-        backend.changeHierarchy(None)
-    # ---
-    # if final leaf node described in hasPart
-    if len(part)>1:
-      #save to file
-      source = elnFile.open(dirName+os.sep+part['@id'])
-      #do database entry
-      if elnName=='Kadi4Mat':
-        docType = 'measurement'
-        part['otherELNName'] = part.pop('@id')
-        part['-name'] = os.path.basename(part['otherELNName'])
-        if 'description' in part:
-          part['comment']=part.pop('description')
-        del part['@type']
-        targetFileName = os.path.basename(part['otherELNName'])
-      elif elnName=='PASTA ELN':
-        targetFileName = part['@id']
-      else:
-        print('**ERROR undefined ELN-Name', elnName)
-      target = open(targetFileName, "wb")
-      with source, target:  #extract one file to its target directly
-        shutil.copyfileobj(source, target)
-      if elnName!='PASTA ELN':
-        backend.addData(docType,part)
-    return True
+          addedDocs += processPart(subpart)
+        # backend.changeHierarchy(None)
+    return addedDocs
 
   ######################
   #main function
-  elnName = None
-  elnVersion = None
+  json2pasta = {v:k for k,v in pasta2json.items() if v is not None}
+  elnName = ''
+  elnVersion = ''
   with ZipFile(elnFileName, 'r', compression=ZIP_DEFLATED) as elnFile:
     files = elnFile.namelist()
-    dirName=files[0].split(os.sep)[0]
+    logging.info('All files '+', '.join(files))
+    print('All files '+', '.join(files))
+    dirName=Path(files[0]).parts[0]
     if dirName+'/ro-crate-metadata.json' not in files:
       print('**ERROR: ro-crate does not exist in folder. EXIT')
-      return False
+      return '**ERROR: ro-crate does not exist in folder. EXIT'
     graph = json.loads(elnFile.read(dirName+'/ro-crate-metadata.json'))["@graph"]
-    # print(json.dumps(graph,indent=2))
     #find information from master node
     rocrateNode = [i for i in graph if i["@id"]=="ro-crate-metadata.json"][0]
     if 'sdPublisher' in rocrateNode:
       elnName     = rocrateNode['sdPublisher']['name']
     if 'version' in rocrateNode:
       elnVersion  = rocrateNode['version']
     else:
       elnVersion  = ''
-    print('Import',elnName,elnVersion)
+    logging.info('Import '+elnName+' '+elnVersion)
+    print('Import '+elnName+' '+elnVersion)
+    if elnName=='eLabFTW':
+      json2pasta.update(elabFTW)
     mainNode    = [i for i in graph if i["@id"]=="./"][0]
     #iteratively go through list
+    addedDocuments = 0
     for part in mainNode['hasPart']:
-      processPart(part)
-  return True
+      if not part['@id'].endswith('ro-crate-metadata.json'):
+        addedDocuments += processPart(part)
+  return 'Success: imported '+str(addedDocuments)+' documents from file '+elnFileName+\
+         ' from ELN '+elnName+' '+elnVersion+'\n'+' '.join(keysNotInDict)
 
 
-def exportELN(backend, docID):
+##########################################
+###               EXPORT               ###
+##########################################
+#TODO_P2 export and import of .eln
+def exportELN(backend:Backend, docID:str, fileName:str='') -> str:
   """
   export eln to file
 
   Args:
     backend (backend): PASTA backend instance
-    docID (string): docId of project
+    docID (str): docId of project
+    fileName (str): fileName which to use for saving; default='' saves in local folder
 
   Returns:
-    bool: success of this export
+    str: report of exportation
   """
   docProject = backend.db.getDoc(docID)
   dirNameProject = docProject['-branch'][0]['path']
-  zipFileName = dirNameProject+'.eln'
-  print('Create eln file '+zipFileName)
-  with ZipFile(zipFileName, 'w', compression=ZIP_DEFLATED) as zipFile:
+  fileName = dirNameProject+'.eln' if fileName=='' else fileName
+  logging.info('Create eln file '+fileName)
+  with ZipFile(fileName, 'w', compression=ZIP_DEFLATED) as elnFile:
     # numAttachments = 0
-    graph = []
+    graph:list[dict[str,Any]] = []
 
-    #1 ------- write JSON files -------------------
-    listDocs = backend.db.getView('viewHierarchy/viewHierarchy', startKey=docID)
-    #create tree of hierarchical data
-    treedata = {}
+    # ------- Prepare local pathTree -------------------
+    listDocs = backend.db.getView('viewHierarchy/viewPaths', startKey=dirNameProject)
+    #create tree of path hierarchy: key=docID; value is a list of children
+    pathTree = {}
 
-    def listChildren(idString, level):
+    def listChildren(parentPath:Path, level:int) -> list[str]:
       """
       List all children
 
       Args:
-        idString (string): id of this part
+        parentPath (Path): path to this document
         level (int): hierarchical level starting from 0
 
       Returns:
         list: list of children ids
       """
-      items = [i for i in listDocs if len(i['key'].split(' '))==level]
-      if idString is not None:
-        items = [i for i in items if i['key'].startswith(idString)]
-      #sort by child
-      keys = [i['key'] for i in items]
-      childNums = [i['value'][0] for i in items]
-      items = [x for _, x in sorted(zip(childNums, keys))]
+      items = [i for i in listDocs if Path(i['key']).parent==parentPath ]
       #create sub-children
       for item in items:
-        children = listChildren(item,level+1)
-        treedata[item.split(' ')[-1]] = children
-        if level == 1:
-          treedata['__masterID__'] = item
-      return [i.split(' ')[-1] for i in items]
-
-    listChildren(idString=None, level=1)
-    masterID = treedata.pop('__masterID__')
-    # print(treedata)
-    for doc in treedata:
-      doc = backend.db.getDoc(doc)
-      doc['@id']   = doc.pop('_id')
-      doc['@type'] = "DigitalDocument"
-      if len(treedata[doc['@id']])>0:
-        doc['hasPart'] = [{'@id':i} for i in treedata[doc['@id']]]
-      if 'image' in doc:
-        fileName = '__thumbnails__'+os.sep+doc['@id']
-        if doc['image'].startswith('data:image/png'):
-          fileName += '.png'
-          imgdata = doc['image'][22:]
-          imgdata = base64.b64decode(imgdata)
-          imgdata = io.BytesIO(imgdata)
-          target = zipFile.open(dirNameProject+os.sep+fileName,'w')
-          with imgdata, target:  #extract one file to its target directly
-            shutil.copyfileobj(imgdata, target)
-        elif doc['image'].startswith('<?xml'):
-          fileName += '.svg'
-          zipFile.writestr(dirNameProject+os.sep+fileName, doc['image'])
-        else:
-          print('image type not implemented')
-        del doc['image']
-        doc['hasPart'] = [{'@id':fileName}]
-        graph.append({'@id':fileName, '@type':'File'})
-      graph.append(doc)
+        children = listChildren(Path(item['key']), level+1)
+        pathTree[item['key']] = children
+      return [i['key'] for i in items]
+
+    children = listChildren(parentPath=Path(dirNameProject), level=1)  #tree data is filled after this command
+    pathTree[dirNameProject] = children
+
+    # ------- Create graph incl. children ----------------
+    # incl. information that is in pasta2json into the graph
+    for me, children in pathTree.items():
+      node = {}
+      node['@id']   = me
+      myLineInListDocs = [i for i in listDocs if i['key'] == me][0]
+      doc = backend.db.getDoc(myLineInListDocs['id'])
+      for keyPasta, keyELN in pasta2json.items():
+        if keyPasta in doc and keyELN is not None:
+          node[keyELN] = doc[keyPasta]
+      if myLineInListDocs['id'][0] == 'x':       #folders
+        node['@type'] = 'Dataset'
+        graph.append({'@id':me+'/metadata.json', '@type':'File'})
+        children.append(me+'/metadata.json')
+      else:                                      #all others: i.e. measurements
+        node['@type'] = 'File'
+      if len(children)>0:
+        node['hasPart'] = [{'@id':i} for i in children]
+      graph.append(node)
       # Attachments are not saved
 
-    #2 ------------------ write data-files --------------------------
-    masterChildren = [{'@id':masterID}]
-    for path, _, files in os.walk(dirNameProject):
-      if '/.git' in path:
-        continue
-      path = os.path.relpath(path, backend.basePath)
-      for iFile in files:
-        if iFile.startswith('.git') or iFile=='.id_pastaELN.json':
-          continue
-        masterChildren.append({'@id':path+os.sep+iFile})
-        graph.append({'@id':path+os.sep+iFile, '@type':'File'})
-        zipFile.write(path+os.sep+iFile, dirNameProject+os.sep+path+os.sep+iFile)
-
-    #3 ------------------- write index.json ---------------------------
-    index = {}
+    # ------------------- create ro-crate-metadata.json header -----------------------
+    index:dict[str,Any] = {}
     index['@context']= 'https://w3id.org/ro/crate/1.1/context'
     # master node ro-crate-metadata.json
-    graphMaster = []
-    cwd = backend.cwd
-    os.chdir(backend.softwarePath)
-    cmd = ['git','tag']
-    output = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, check=True)
-    os.chdir(backend.basePath/cwd)
-    masterNode  = {\
+    graphMaster:list[dict[str,Any]] = []
+    masterNodeInfo  = {\
       '@id':'ro-crate-metadata.json',\
       '@type':'CreativeWork',\
       'about': {'@id': './'},\
       'conformsTo': {'@id': 'https://w3id.org/ro/crate/1.1'},\
       'schemaVersion': 'v1.0',\
       'dateCreated': datetime.now().isoformat(),\
       'sdPublisher': {'@type':'Organization', 'name': 'PASTA ELN',\
         'logo': 'https://raw.githubusercontent.com/PASTA-ELN/desktop/main/pasta.png',\
         'slogan': 'The favorite ELN for experimental scientists',\
         'url': 'https://github.com/PASTA-ELN/',\
-        'description':'Version '+output.stdout.decode('utf-8').split()[-1]},\
+        'description':'Version '+__version__},\
       'version': '1.0'}
-    graphMaster.append(masterNode)
-    masterNode  = {'@id':'./', '@type':['Dataset'], 'hasPart': masterChildren}
-    graphMaster.append(masterNode)
-    #finalize file
-    index['@graph'] = graphMaster+graph
-    zipFile.writestr(dirNameProject+os.sep+'ro-crate-metadata.json', json.dumps(index, indent=2))
-  return True
-
-
-def backup(backend, method='backup', **kwargs):
-  """
-  backup, verify, restore information from/to database
-  - all data is saved to one zip file (NOT ELN file)
-  - after restore-to-database, the database changed (new revision)
+    graphMaster.append(masterNodeInfo)
+    masterNodeRoot  = {'@id':'./', '@type':['Dataset'], 'hasPart': [{'@id':dirNameProject}, {'@id':dirNameProject+'/ro-crate-metadata.json'}]}
+    graphMaster.append(masterNodeRoot)
+
+    # ------------------ copy data-files --------------------------
+    # datafiles are already in the graph-graph: only copy and no addition to graph
+    for path, _, files in os.walk(backend.basePath/dirNameProject):
+      if '/.git' in path:  #if use datalad
+        continue
+      relPath = os.path.relpath(path, backend.basePath) #path of the folder
+      for iFile in files:                            #iterate through all files in folder
+        if iFile.startswith('.git') or iFile=='.id_pastaELN.json':
+          continue
+        # print('copy file', path+'/'+iFile, dirNameProject+'/'+relPath+'/'+iFile )
+        elnFile.write(path+'/'+iFile, dirNameProject+'/'+relPath+'/'+iFile)   #zip file
 
-  Args:
-    backend (Pasta): pasta-backend
-    method (string): backup, restore, compare
-    kwargs (dict): additional parameter, i.e. callback
+    # ------------------ metadata.json files --------------------------
+    # create metadata.json files in zip-file: no addition to graph
+    #++ TODO  get rid of this part
+
+    keysNotInDict = set()
+    for path, children in pathTree.items():
+      metaDataJsonPaths = [i for i in children if 'metadata.json' in i]
+      if len(metaDataJsonPaths)==0:
+        continue
+      metaDataJsonPath = metaDataJsonPaths[0] #want to write into this name
+      #get content
+      pastaContent =[]
+      folderInListDocs = [i for i in listDocs if i['key'] == path][0]
+      stack = folderInListDocs['value'][0]+[folderInListDocs['id']]
+      listHierarchy = backend.db.getView('viewHierarchy/viewHierarchy', startKey=' '.join(stack))
+      for item in listHierarchy:
+        if len(stack)+1 == len(item['key'].split(' ')):
+          doc = backend.db.getDoc(item['id'])
+          pastaContent.append(doc)
+      pastaContent.append( backend.db.getDoc(stack[-1]) )
+      #Iterate through content and transcribe
+      jsonContent = []
+      for dataPasta in pastaContent:
+        dataJson = {}
+        for key,value in dataPasta.items():
+          if key not in pasta2json:                          #keep as is
+            keysNotInDict.add(key)
+            dataJson[key] = value
+          # if key in pasta2json and pasta2json[key] is not None:  #DO NOT TRANSCRIBE
+          #   #  dataJson[pasta2json[key]] = value
+        jsonContent.append(dataJson)
+      elnFile.writestr(dirNameProject+'/'+metaDataJsonPath, json.dumps(jsonContent, indent=2))
+    print('Keys not in dictionary', keysNotInDict)
+
+
+    # ------------------ go through graph and add information ----
+    #++ TODO get rid of this part
+
+    for node in graph:
+      if node['@type']=='File':                    #metadata.json and data file
+        node['name'] = node['@id'].split('/')[-1]
+        with elnFile.open( dirNameProject+'/'+node['@id'] ) as fIn:
+          content = fIn.read()
+          node['contentSize'] = str(len(content))
+          node['sha256'] = hashlib.sha256(content).hexdigest()
+        if node['@id'].endswith('/metadata.json'):    #metadata.json
+          node['description'] = 'JSON export'
+          node['contentType'] = 'application/json'
+        else:                                         #data file
+          #one could pull information from the database here
+          pass
+      else:                                        #dataset = folder
+        #one could pull information from the database here
+        pass
 
-  Returns:
-      bool: success
-  """
-  dirNameProject = 'backup'
-  zipFileName = ''
-  if backend.cwd is None:
-    print("**ERROR bbu01: Specify zip file name or database")
-    return False
-  zipFileName = backend.basePath.parent/'pasta_backup.zip'
-  if method=='backup':  mode = 'w'
-  else:                 mode = 'r'
-  print('  '+method.capitalize()+' to file: '+zipFileName.as_posix())
-  with ZipFile(zipFileName, mode, compression=ZIP_DEFLATED) as zipFile:
-
-    # method backup, iterate through all database entries and save to file
-    if method=='backup':
-      numAttachments = 0
-      #write JSON files
-      listDocs = backend.db.db
-      listFileNames = []
-      for doc in listDocs:
-        if isinstance(doc, str):
-          doc = backend.db.getDoc(doc)
-        fileName = '__database__/'+doc['_id']+'.json'
-        listFileNames.append(fileName)
-        zipFile.writestr((Path(dirNameProject)/fileName).as_posix(), json.dumps(doc) )
-        # Attachments
-        if '_attachments' in doc:
-          numAttachments += len(doc['_attachments'])
-          for i in range(len(doc['_attachments'])):
-            attachmentName = Path(dirNameProject)/'__database__'/doc['_id']/('v'+str(i)+'.json')
-            zipFile.writestr(attachmentName.as_posix(), json.dumps(doc.get_attachment('v'+str(i)+'.json')))
-      #write data-files
-      for path, _, files in os.walk(backend.basePath):
-        path = Path(path).relative_to(backend.basePath)
-        for iFile in files:
-          listFileNames.append(path/iFile)
-          # print('in',Path().absolute(),': save', path/iFile,' as', Path(dirNameProject)/path/iFile)
-          zipFile.write(backend.basePath/path/iFile, Path(dirNameProject)/path/iFile)
-      #create some fun output
-      compressed, fileSize = 0,0
-      for doc in zipFile.infolist():
-        compressed += doc.compress_size
-        fileSize   += doc.file_size
-      print(f'  File size: {fileSize:,} byte   Compressed: {compressed:,} byte')
-      print(f'  Num. documents (incl. ontology and views): {len(backend.db.db):,}\n')#,    num. attachments: {numAttachments:,}\n')
-      return True
-
-    # method compare and restore
-    if zipFileName.as_posix().endswith('.eln'):
-      print('**ERROR: cannot compare/restore .eln files')
-      return False
-    # method compare
-    if  method=='compare':
-      filesInZip = zipFile.namelist()
-      print('  Number of documents (incl. ontology and views) in file:',len(filesInZip))
-      differenceFound, comparedFiles, comparedAttachments = False, 0, 0
-      for doc in backend.db.db:
-        fileName = doc['_id']+'.json'
-        if 'backup/__database__/'+fileName not in filesInZip:
-          print("**ERROR bbu02: document not in zip file |",doc['_id'])
-          differenceFound = True
-        else:
-          filesInZip.remove('backup/__database__/'+fileName)
-          zipData = json.loads( zipFile.read('backup/__database__/'+fileName) )
-          if doc!=zipData:
-            print('  Info: data disagrees database, zipfile ',doc['_id'])
-            differenceFound = True
-          comparedFiles += 1
-        if '_attachments' in doc:
-          for i in range(len(doc['_attachments'])):
-            attachmentName = doc['_id']+'/v'+str(i)+'.json'
-            if 'backup/__database__/'+attachmentName not in filesInZip:
-              print("**ERROR bbu03: revision not in zip file |",attachmentName)
-              differenceFound = True
-            else:
-              filesInZip.remove('backup/__database__/'+attachmentName)
-              zipData = json.loads(zipFile.read('backup/__database__/'+attachmentName) )
-              if doc.get_attachment('v'+str(i)+'.json')!=zipData:
-                print('  Info: data disagrees database, zipfile ',attachmentName)
-                differenceFound = True
-              comparedAttachments += 1
-      filesInZip = [i for i in filesInZip if i.startswith('backup/__database')] #filter out non-db items
-      if len(filesInZip)>0:
-        differenceFound = True
-        print('Files in zipfile not in database',filesInZip)
-      if differenceFound: print("  Difference exists between database and zipfile")
-      else:               print("  Database and zipfile are identical.",comparedFiles,'files &',comparedAttachments,'attachments were compared\n')
-      return not differenceFound
-
-    # method restore: loop through all files in zip and save to database
-    #  - skip design and dataDictionary
-    if method=='restore':
-      beforeLength, restoredFiles = len(backend.db.db), 0
-      for fileName in zipFile.namelist():
-        if fileName.startswith('backup/__database__') and (not \
-          (fileName.startswith('backup/__database__/_') or fileName.startswith('backup/__database__/-'))):  #do not restore design documents and ontology
-          restoredFiles += 1
-          zipData = json.loads( zipFile.read(fileName) )
-          fileName = fileName[len('backup/__database__/'):]
-          if '/' in fileName:  #attachment
-            doc = backend.db.getDoc(fileName.split('/')[0])
-            doc.put_attachment(fileName.split('/')[1], 'application/json', json.dumps(zipData))
-          else:                                                           #normal document
-            backend.db.saveDoc(zipData)
-      print('  Number of documents & revisions in file:',restoredFiles)
-      print('  Number of documents before and after restore:',beforeLength, len(backend.db.db),'\n')
-      return True
-  return False
+    #finalize file
+    index['@graph'] = graphMaster+graph
+    elnFile.writestr(dirNameProject+'/'+'ro-crate-metadata.json', json.dumps(index, indent=2))
+    with open(fileName[:-3]+'json','w', encoding='utf-8') as fOut:
+      fOut.write( json.dumps(index, indent=2) )
+  return 'Success: exported '+str(len(graph))+' documents into file '+fileName
```

## pasta_eln/installationTools.py

```diff
@@ -1,71 +1,73 @@
 '''  Methods that check, repair, the local PASTA-ELN installation '''
-import os, platform, sys, json, shutil, random, string, subprocess, logging
-import importlib.util
+import os, platform, sys, json, shutil, random, string, logging
+from typing import Optional, Any, Callable
 import urllib.request
 from pathlib import Path
 from cloudant.client import CouchDB
 
 from .backend import Backend
 from .fixedStrings import defaultOntology
+from .miscTools import outputString, DummyProgressBar
 
 
-def getOS():
+def getOS() -> str:
   '''
   Get operating system and python environment
 
   Returns:
     string: os + pythonEnvironment
   '''
   operatingSys = platform.system()
   # Get base/real prefix, or sys.prefix if there is none
   get_base_prefix_compat = getattr(sys, 'base_prefix', None) or getattr(sys, 'real_prefix', None) or sys.prefix
   in_virtualenv = get_base_prefix_compat != sys.prefix
   environment = sys.prefix if in_virtualenv else '_system_'
   return operatingSys+' '+environment
 
 
-def createDefaultConfiguration(user, password, pathPasta=None):
+def createDefaultConfiguration(user:str, password:str, pathPasta:Optional[Path]=None) -> dict[str,Any]:
   '''
   Check configuration file .pastaELN.json for consistencies
 
   Args:
     user (str): user name (for windows)
     password (str): password (for windows)
-    pathPasta (str): place to store pasta data
+    pathPasta (Path): place to store pasta data
 
   Returns:
     dict: dictionary of configuration
   '''
   if user == '':
     user = input('Enter user name: ')
   if password == '':
     password = input('Enter password: ')
   if pathPasta is None:
     if platform.system()=='Windows':
-      pathPasta = str(Path.home()/'Documents'/'PASTA_ELN')
+      pathPasta = Path.home()/'Documents'/'PASTA_ELN'
     else:
-      pathPasta = str(Path.home()/'PASTA_ELN')
-  conf = {}
+      pathPasta = Path.home()/'PASTA_ELN'
+  conf:dict[str,Any] = {}
   conf['defaultProjectGroup']     = 'research'
   conf['projectGroups']       = {'research':{\
-                          'local':{'user':user, 'password':password, 'database':'research', 'path':pathPasta},
+                          'local':{'user':user, 'password':password, 'database':'research',
+                                   'path':str(pathPasta)},
                           'remote':{}  }}
   conf['version']     = 2
   try:
     conf['userID']      = os.getlogin()
   except:   #github action
     conf['userID']      = 'github_user'
   #create pastaDir if it does not exist
-  if not Path(pathPasta).exists():
-    Path(pathPasta).mkdir()
+  if not pathPasta.exists():
+    pathPasta.mkdir()
   return conf
 
 
-def runAsAdminWindows(cmdLine):
+def runAsAdminWindows(cmdLine:list[str]) -> None:
   '''
   Run a command as admin in windows
   - (C) COPYRIGHT © Preston Landers 2010
   - https://stackoverflow.com/questions/19672352/how-to-run-script-with-elevated-privilege-on-windows
   - asks user for approval
   - waits for commands to end
 
@@ -82,15 +84,15 @@
                             lpParameters=" ".join(cmdLine[1:]))
   procHandle = procInfo['hProcess']
   _ = win32event.WaitForSingleObject(procHandle, win32event.INFINITE)
   _   = win32process.GetExitCodeProcess(procHandle)
   return
 
 
-def couchdb(command='test'):
+def couchdb(command:str='test') -> str:
   '''
   test couchDB installation or (install it on Windows-only)
 
   Args:
     command (string): 'test' or 'install'
 
   Returns:
@@ -117,26 +119,26 @@
       _, _ = urllib.request.urlretrieve(url, path)
       ## Old version with installer
       # cmd = ['cmd.exe','/K ',str(resultFilePath)]
       # _ = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, check=True)
       ## New version without questions
       password = ''.join(random.choice(string.ascii_letters) for i in range(12))
       logging.info('PASSWORD: '+password)
-      path = str(path).replace('\\','\\\\')
-      cmd = ['msiexec','/i',path,'/quiet','COOKIEVALUE=abcdefghijklmo','INSTALLSERVICE=1','ADMINUSER=admin',\
+      pathS = str(path).replace('\\','\\\\')
+      cmd = ['msiexec','/i',pathS,'/quiet','COOKIEVALUE=abcdefghijklmo','INSTALLSERVICE=1','ADMINUSER=admin',\
              'ADMINPASSWORD='+password,'/norestart','/l*','log.txt']
       logging.info('COMMAND: '+' '.join(cmd))
       runAsAdminWindows(cmd)
       logging.info('CouchDB ending')
       return 'Installed couchDB with password |'+password+'|'
     return '**ERROR: Unknown operating system '+platform.system()
   return '**ERROR: Unknown command'
 
 
-def couchdbUserPassword(username, password):
+def couchdbUserPassword(username:str, password:str) -> bool:
   '''
   test if username and password are correct
 
   Args:
     username (string): user name
     password (string): password
 
@@ -146,50 +148,54 @@
   try:
     _ = CouchDB(username, password, url='http://127.0.0.1:5984', connect=True)
     return True
   except:
     return False
 
 
-def installLinuxRoot(couchDBExists, pathPasta=''):
+def installLinuxRoot(couchDBExists:bool, pathPasta:Path=Path(''), password:str='') -> str:
   '''
   Install all packages in linux using the root-password
 
   Args:
     couchDBExists (bool): does the couchDB installation exist
-    pathPasta (str): path to install pasta in (Linux)
+    pathPasta (Path): path to install pasta in (Linux)
+    password (str): password for couchDB installation
 
   Returns:
     string: ''=success, else error messages
   '''
   logging.info('InstallLinuxRoot starting ...')
   bashCommand = []
   password = ''
   if not couchDBExists:
-    password = ''.join(random.choice(string.ascii_letters) for i in range(12))
-    logging.info('PASSWORD: '+password)
+    if password=='':
+      password = ''.join(random.choice(string.ascii_letters) for i in range(12))
+      logging.info('PASSWORD: '+password)
     #create or adopt .pastaELN.json
     path = Path.home()/'.pastaELN.json'
     if path.exists():
       with open(path,'r', encoding='utf-8') as fConf:
         conf = json.load(fConf)
+      logging.info('.pastaELN.json exists, do not change it')
     else:
       conf = createDefaultConfiguration('admin', password, pathPasta)
-    with open(path,'w', encoding='utf-8') as fConf:
-      fConf.write(json.dumps(conf, indent=2) )
+      with open(path,'w', encoding='utf-8') as fConf:
+        fConf.write(json.dumps(conf, indent=2) )
     bashCommand += [
       'sudo snap install couchdb',
       'sudo snap set couchdb admin='+password,
       'sudo snap start couchdb',
       'sudo snap connect couchdb:mount-observe',
       'sudo snap connect couchdb:process-control',
       'sleep 5',
       'curl -X PUT http://admin:'+password+'@127.0.0.1:5984/_users',
       'curl -X PUT http://admin:'+password+'@127.0.0.1:5984/_replicator',
       'curl -X PUT http://admin:'+password+'@127.0.0.1:5984/_global_changes',
+      'curl -X PUT http://admin:'+password+'@127.0.0.1:5984/_node/_local/_config/couch_httpd_auth/timeout/ -d \'"60000"\'',
       'sleep 10',
       'echo DONE-Press-Key',
       'read']  #TODO_P5 if successful in Aug2023: remove "echo....read"
   #Try all terminals
   scriptFile = Path.home()/'pastaELN_Install.sh'
   with open(scriptFile,'w', encoding='utf-8') as shell:
     shell.write('\n'.join(bashCommand))
@@ -209,23 +215,24 @@
       logging.info('Finished using straight Bash command result='+str(res))
       resultString = '**ERROR: Last terminal failed'
   success = 'CouchDB works' if couchdbUserPassword('admin',password) else 'CouchDB FAILED'
   logging.info('InstallLinuxRoot ending. '+success)
   return resultString
 
 
-def configuration(command='test', user='', password='', pathPasta=''):
+def configuration(command:str='test', user:str='', password:str='', pathPasta:Path=Path('')) -> str:
   '''
+  #TODO_P4 change to string-output
   Check configuration file .pastaELN.json for consistencies
 
   Args:
     command (str): 'test' or 'repair'
     user (str): user name (for windows)
     password (str): password (for windows)
-    pathPasta (str): path to install pasta in (Windows)
+    pathPasta (Path): path to install pasta in (Windows)
 
   Returns:
     string: ''=success, else error messages
   '''
   logging.info('Configuration starting ...')
   output = ''
   try:
@@ -294,17 +301,17 @@
   #GUI items
   if 'GUI' not in conf:
     if command == 'repair':
       conf['GUI'] = {}
     else:
       output += '**ERROR: No GUI in config file\n'
   guiItems = {"theme": "light_blue",
+    "imageSizeDetails": 600,
     "imageWidthProject": 300,
-    "imageWidthDetails": 600,
-    "sidebarWidth": 200,
+    "sidebarWidth": 280,
     "loggingLevel": "INFO",
     "tableColumns": {}}
   for key, value in guiItems.items():
     if 'GUI' in conf and key not in conf['GUI']:
       if command == 'repair':
         conf['GUI'][key] = value
       else:
@@ -314,15 +321,15 @@
     with open(Path.home()/'.pastaELN.json','w', encoding='utf-8') as f:
       f.write(json.dumps(conf,indent=2))
   logging.info('Configuration ending')
   return output
 
 
 
-def ontology(command='test'):
+def ontology(command:str='test') -> str:
   '''
   Check configuration file .pastaELN.json for consistencies
 
   Args:
     command (string): 'test' or 'install'
 
   Returns:
@@ -355,160 +362,172 @@
     # _ = backend.db.create_document(doc)
     return ''
 
   return '**ERROR: Unknown command'
 
 
 
-def exampleData(force=False, callbackPercent=None):
+def exampleData(force:bool=False, callbackPercent:Optional[Callable[[int],None]]=None) -> str:
   '''
   Create example data after installation
 
   Args:
     force (bool): force creation by removing content before creation
     callbackPercent (function): callback function given to exampleData, such that exampleData can report progress back
   '''
   logging.info('Start example data creation')
+  outputFormat = 'print'
   if callbackPercent is not None:
     callbackPercent(0)
   if force:
     backend = Backend(initConfig=False)
     dirName = backend.basePath
     backend.exit(deleteDB=True)
     shutil.rmtree(dirName)
     os.makedirs(dirName)
   if callbackPercent is not None:
     callbackPercent(1)
   backend = Backend(initViews=True, initConfig=False)
   if callbackPercent is not None:
     callbackPercent(2)
   ### CREATE PROJECTS AND SHOW
-  print('*** CREATE EXAMPLE PROJECT AND SHOW ***')
+  outputString(outputFormat,'h2','CREATE EXAMPLE PROJECT AND SHOW')
   backend.addData('x0', {'-name': 'PASTAs Example Project', 'objective': 'Test if everything is working as intended.', 'status': 'active', 'comment': '#Important Can be used as reference or deleted'})
   if callbackPercent is not None:
     callbackPercent(3)
-  print(backend.output('x0'))
+  outputString(outputFormat,'info', backend.output('x0'))
   if callbackPercent is not None:
     callbackPercent(4)
   logging.info('Finished creating example project')
 
   ### TEST PROJECT PLANING
-  print('*** TEST PROJECT PLANING ***')
+  outputString(outputFormat,'h2','TEST PROJECT PLANING')
   viewProj = backend.db.getView('viewDocType/x0')
   projID1  = [i['id'] for i in viewProj if 'PASTA' in i['value'][0]][0]
   if callbackPercent is not None:
     callbackPercent(5)
   backend.changeHierarchy(projID1)
   if callbackPercent is not None:
     callbackPercent(6)
   backend.addData('x1',    {'comment': 'This is hard! #TODO', '-name': 'This is an example task'})
   if callbackPercent is not None:
     callbackPercent(7)
-  backend.addData('x1',    {'comment': 'This will take a long time. #WAIT', '-name': 'This is another example task'})
+  currentID = backend.addData('x1',    {'comment': 'This will take a long time. #WAIT', '-name': 'This is another example task'})
   if callbackPercent is not None:
     callbackPercent(8)
-  backend.changeHierarchy(backend.currentID)
+  backend.changeHierarchy(currentID)
   backend.addData('x2',    {'-name': 'This is an example subtask',     'comment': 'Random comment 1'})
   if callbackPercent is not None:
     callbackPercent(9)
   backend.addData('x2',    {'-name': 'This is another example subtask','comment': 'Random comment 2'})
   if callbackPercent is not None:
     callbackPercent(10)
   backend.changeHierarchy(None)
-  backend.addData('x1',    {'-name': 'Data files'})
+  semStepID = backend.addData('x1',    {'-name': 'Data files'})
   if callbackPercent is not None:
     callbackPercent(11)
-  semStepID = backend.currentID
   backend.changeHierarchy(semStepID)
-  semDirName = backend.basePath/backend.cwd
+  if backend.cwd is not None:
+    semDirName = backend.basePath/backend.cwd
   backend.changeHierarchy(None)
-  print(backend.outputHierarchy())
+  outputString(outputFormat,'info',backend.outputHierarchy())
   if callbackPercent is not None:
     callbackPercent(12)
   logging.info('Finished project planning')
 
   ### TEST PROCEDURES
-  print('\n*** TEST PROCEDURES ***')
+  outputString(outputFormat,'h2','TEST PROCEDURES')
   sopDir = backend.basePath/'StandardOperatingProcedures'
   os.makedirs(sopDir, exist_ok=True)
   with open(sopDir/'Example_SOP.md','w', encoding='utf-8') as fOut:
     fOut.write('# Put sample in instrument\n# Do something\nDo not forget to\n- not do anything wrong\n- **USE BOLD LETTERS**\n')
   if callbackPercent is not None:
     callbackPercent(13)
   backend.addData('procedure', {'-name': 'StandardOperatingProcedures/Example_SOP.md', 'comment': '#v1'})
   if callbackPercent is not None:
     callbackPercent(14)
-  print(backend.output('procedure'))
+  outputString(outputFormat,'info',backend.output('procedure'))
   if callbackPercent is not None:
     callbackPercent(15)
   logging.info('Finished procedures creating')
 
   ### TEST SAMPLES
-  print('*** TEST SAMPLES ***')
+  outputString(outputFormat,'h2','TEST SAMPLES')
   backend.addData('sample',    {'-name': 'Example sample', 'chemistry': 'A2B2C3', 'qrCode': '13214124 99698708', 'comment': 'can be used as example or removed'})
   if callbackPercent is not None:
     callbackPercent(16)
-  print(backend.output('sample'))
+  outputString(outputFormat,'info',backend.output('sample'))
   if callbackPercent is not None:
     callbackPercent(17)
-  print(backend.outputQR())
+  outputString(outputFormat,'info',backend.outputQR())
   if callbackPercent is not None:
     callbackPercent(18)
   logging.info('Finished samples creating')
 
   ###  TEST MEASUREMENTS AND SCANNING/CURATION
-  print('*** TEST MEASUREMENTS AND SCANNING/CURATION ***')
+  outputString(outputFormat,'h2','TEST MEASUREMENTS AND SCANNING')
   shutil.copy(Path(__file__).parent/'Resources'/'ExampleMeasurements'/'simple.png', semDirName)
   shutil.copy(Path(__file__).parent/'Resources'/'ExampleMeasurements'/'simple.csv', semDirName)
   if callbackPercent is not None:
     callbackPercent(19)
   logging.info('Finished copy files')
-  backend.scanProject(projID1)
+  progressBar = DummyProgressBar()
+  backend.scanProject(progressBar, projID1)
   logging.info('Finished scan tree')
   if callbackPercent is not None:
     callbackPercent(20)
 
   ### USE GLOBAL FILES
-  print('*** USE GLOBAL FILES ***')
+  outputString(outputFormat,'h2','USE GLOBAL FILES')
   backend.changeHierarchy(semStepID)
   if callbackPercent is not None:
     callbackPercent(21)
   backend.addData('measurement', {'-name': 'https://upload.wikimedia.org/wikipedia/commons/a/a4/Misc_pollen.jpg', \
     'comment':'remote image from wikipedia. Used for testing and reference. Can be deleted.'})
   if callbackPercent is not None:
     callbackPercent(22)
-  print(backend.output('measurement'))
+  outputString(outputFormat,'info',backend.output('measurement'))
   if callbackPercent is not None:
     callbackPercent(23)
   logging.info('Finished global files additions')
 
   ### VERIFY DATABASE INTEGRITY
-  print('\n*** VERIFY DATABASE INTEGRITY ***')
-  print(backend.checkDB(verbose=True))
-  print('\n*** DONE WITH VERIFY ***')
+  outputString(outputFormat,'h2','VERIFY DATABASE INTEGRITY')
+  outputString(outputFormat,'info',backend.checkDB(outputStyle='text'))
+  outputString(outputFormat,'h2','DONE WITH VERIFY')
   if callbackPercent is not None:
     callbackPercent(24)
   logging.info('Finished checking database')
-  return
+  return 'Finished checking database'
 
 
-def createShortcut():
+def createShortcut() -> None:
   """
-  Create shortcut icon depending on operating system
+  Create alias and shortcut icon depending on operating system
   """
   logging.info('Create shortcut starting')
   if platform.system()=='Linux':
     content ='[Desktop Entry]\nName=PASTA ELN\nComment=PASTA electronic labnotebook\n'
-    content+='Exec=pastaELN\n'
+    if sys.prefix==sys.base_prefix:   #normal installation into user-space
+      content+='Exec=pastaELN\n'
+    else:                             #installation in a virtual environment
+      logging.info('In virtual environment, create an alias')
+      with open(Path.home()/'.bashrc','a', encoding='utf-8') as fOut:
+        alias = "alias pastaELN='"+sys.prefix+"/bin/python3 -m pasta_eln.gui'"
+        logging.info(alias)
+        fOut.write(alias+'\n')
+      content+='Exec='+sys.prefix+'/bin/python3 -m pasta_eln.gui\n'
     content+='Icon='+ (Path(__file__).parent/'Resources'/'Icons'/'favicon64.png').as_posix() + '\n'
     content+='Terminal=false\nType=Application\nCategories=Utility;Application;\n'
     try:
-      with open(Path.home()/'Desktop'/'pastaELN.desktop','w', encoding='utf-8') as fOut:
+      linkString = (Path.home()/'Desktop'/'pastaELN.desktop').as_posix()
+      with open(linkString,'w', encoding='utf-8') as fOut:
         fOut.write(content)
-        os.chmod(Path.home()/'Desktop'/'pastaELN.desktop', 0o777)
+        os.system('gio set '+linkString+' metadata::trusted true') #for ubuntu systems
+        os.chmod(Path.home()/'Desktop'/'pastaELN.desktop', 0o775)
     except:
       pass
     try:
       with open(Path.home()/'.local'/'share'/'applications'/'pastaELN.desktop','w', encoding='utf-8') as fOut:
         fOut.write(content)
         os.chmod(Path.home()/'.local'/'share'/'applications'/'pastaELN.desktop', 0o777)
     except:
@@ -525,15 +544,15 @@
     shortcut.save()
   logging.info('Create shortcut end')
   return
 
 
 ##############
 # Main method for testing and installation without GUI
-def main():
+def main() -> None:
   ''' Main method and entry point for commands '''
   logPath = Path.home()/'pastaELN.log'
   #old versions of basicConfig do not know "encoding='utf-8'"
   logging.basicConfig(filename=logPath, level=logging.INFO, format='%(asctime)s|%(levelname)s:%(message)s',
                       datefmt='%m-%d %H:%M:%S')   #This logging is always info, since for installation only
   for package in ['urllib3', 'requests', 'asyncio', 'PIL', 'matplotlib.font_manager']:
     logging.getLogger(package).setLevel(logging.WARNING)
@@ -557,16 +576,15 @@
 
   print('Add "install" argument to install PASTA-ELN.')
   if len(sys.argv)>1 and 'install' in sys.argv:
     if platform.system()=='Linux':
       print('---- Create PASTA-ELN installation Linux ----')
       if not existsCouchDB:
         print('install with root credentials...')
-        dirName = (Path.home()/'pastaELN').as_posix()
-        installLinuxRoot(existsCouchDB, dirName)
+        installLinuxRoot(existsCouchDB, Path.home()/'pastaELN')
       if flagConfiguration:
         print('repair  configuration:', configuration('repair'))
       if flagOntology and existsCouchDB:
         print('install ontology     :', ontology('install'))
 
     elif platform.system()=='Windows':
       print('---- Create PASTA-ELN installation Windows ----')
```

## pasta_eln/miscTools.py

```diff
@@ -1,25 +1,110 @@
 """ Misc functions that do not require instances """
-import os, sys, uuid, logging, traceback
-from re import sub
+import os, sys, uuid, logging, traceback, json
+from io import BufferedReader
+from pathlib import Path
+from re import sub, match
+import platform
+import yaml
+
+class Bcolors:
+  """
+  Colors for Command-Line-Interface and output
+  """
+  if platform.system()=='Windows':
+    HEADER = ''
+    OKBLUE = ''
+    OKGREEN = ''
+    WARNING = ''
+    FAIL = ''
+    ENDC = ''
+    BOLD = ''
+    UNDERLINE = ''
+  else:
+    HEADER = '\033[95m'
+    OKBLUE = '\033[94m'
+    OKGREEN = '\033[92m'
+    WARNING = '\033[93m'
+    FAIL = '\033[91m'
+    ENDC = '\033[0m'
+    BOLD = '\033[1m'
+    UNDERLINE = '\033[4m'
+
+def outputString(fmt:str='print', level:str='info', message:str='') ->str:
+  """ Output a message into different formats:
+    - print: print to stdout
+    - logging; log to file
+    - text: return text string (superseeds html)
+    - html: return html string https://doc.qt.io/qtforpython/overviews/richtext-html-subset.html#supported-html-subset
+    - else: no output
+    - formats can be union ('print,text')
+  """
+  prefixes = {'h2':f'{Bcolors.UNDERLINE}\n*** ','bold':f'{Bcolors.BOLD}\n*** ', \
+              'ok':f'{Bcolors.OKGREEN}', 'okish':f'{Bcolors.OKBLUE}', 'unsure':f'{Bcolors.HEADER}',\
+              'warning':f'{Bcolors.WARNING}','error':f'{Bcolors.FAIL}'}
+  if level=='info':
+    txtOutput = message.strip()+'\n'
+  elif level in prefixes:
+    txtOutput = prefixes[level]+message
+    txtOutput+= ' ***' if '***' in prefixes[level] else ''
+    txtOutput+= f'{Bcolors.ENDC}\n'
+  else:
+    print('ERROR level not in prefixes ',level)
+  # depend on format
+  if 'print' in fmt:
+    print(txtOutput)
+  if 'logging' in fmt and level in ['info','warning','error']:
+    getattr(logging,level)(message)
+  if 'text' in fmt:
+    return txtOutput
+  if fmt=='html':
+    colors = {'info':'black','error':'red','warning':'orange','ok':'green','okish':'blue','unsure':'magenta'}
+    if level[0]=='h':
+      return '<'+level+'>'+message+'</'+level+'>'
+    if level not in colors:
+      print('**ERROR: wrong level '+level)
+      return ''
+    return '<font color="'+colors[level]+'">'+message.replace('\n','<br>')+'</font><br>'
+  return ''
+
 
-def camelCase(a_string):
-  """ Produce camelCase from normal string
+def tracebackString(log:bool=False, docID:str='') -> str:
+  """ Create a formatted string of traceback
 
   Args:
-     a_string (str): string
+    log (bool): write to logging
+    docID (str): docID used in comment
+
+  Returns:
+    str: | separated string of call functions
+  """
+  tracebackList = traceback.format_stack()[2:-2]
+  reply = '|'.join([item.split('\n')[1].strip() for item in tracebackList])  #| separated list of stack excluding last
+  if log:
+    logging.info(' traceback '+docID+': '+ reply)
+  return reply
+
+
+def camelCase(text:str) -> str:
+  """
+  Produce camelCase from normal string
+  - file names abcdefg.hij are only replaced spaces
+
+  Args:
+     text (str): string
 
   Returns:
     str: camel case of that string: CamelCaseString
   """
-  a_string = sub(r"(_|-)+", " ", a_string).title().replace(" ", "").replace("*","")
-  return ''.join(a_string)
+  if match(r"^[\w-]+\.[\w]+$", text):
+    return text.replace(' ','_')
+  return sub(r"(_|-)+", ' ', text).title().replace(' ','').replace('*','')
 
 
-def createDirName(name,docType,thisChildNumber):
+def createDirName(name:str, docType:str, thisChildNumber:int) -> str:
   """ create directory-name by using camelCase and a prefix
 
   Args:
       name (string): name with spaces etc.
       docType (string): document type used for prefix
       thisChildNumber (int): number of myself
 
@@ -30,87 +115,87 @@
     return camelCase(name)
   #steps, tasks
   if isinstance(thisChildNumber, str):
     thisChildNumber = int(thisChildNumber)
   return f'{thisChildNumber:03d}'+'_'+camelCase(name)
 
 
-def generic_hash(path, forceFile=False):
+def generic_hash(path:Path, forceFile:bool=False) -> str:
   """
   Hash an object based on its mode.
 
   inspired by:
   https://github.com/chris3torek/scripts/blob/master/githash.py
 
   Example implementation:
       result = generic_hash(sys.argv[1])
       print('%s: hash = %s' % (sys.argv[1], result))
 
   Args:
-    path (string): path
+    path (Path): path
     forceFile (bool): force to get shasum of file and not of link (False for gitshasum)
 
   Returns:
     string: shasum
 
   Raises:
     ValueError: shasum of directory not supported
   """
   from urllib import request
-  if str(path).startswith('http'):                      #Remote file
+  if str(path).startswith('http'):                      #Remote file:
     try:
       with request.urlopen(path.as_posix().replace(':/','://')) as site:
         meta = site.headers
         size = int(meta.get_all('Content-Length')[0])
         return blob_hash(site, size)
     except:
       logging.error('Could not download content / hashing issue '+path.as_posix().replace(':/','://')+'\n'+\
         traceback.format_exc())
       return ''
   if path.is_dir():
-    raise ValueError('This seems to be a directory '+path)
+    raise ValueError('This seems to be a directory '+path.as_posix())
   if forceFile and path.is_symlink():
     path = path.resolve()
   if path.is_symlink():    #if link, hash the link
     shasum = symlink_hash(path)
   elif path.is_file():  #Local file
     with open(path, 'rb') as stream:
       shasum = blob_hash(stream, path.stat().st_size)
   return shasum
 
 
-def upOut(key):
+def upOut(key:str) -> list[str]:
   """
-  key (bool): key
+  key (str): key
   """
   import keyring as cred
   keys = key.split() if ' ' in key else [key]
   keys_ = []
   for keyI in keys:
     key_ = cred.get_password('pastaDB',keyI)
     if key_ is None:
       key_ = ':'
     else:
       key_ = ':'.join(key_.split('bcA:Maw'))
     keys_.append(key_)
   return keys_
 
 
-def upIn(key):
+def upIn(key:str) -> str:
   """
-  key (bool): key
+  key (str): key
   """
   import keyring as cred
   key = 'bcA:Maw'.join(key.split(':'))
   id_  = uuid.uuid4().hex
   cred.set_password('pastaDB',id_,key)
   return id_
 
 
-def symlink_hash(path):
+def symlink_hash(path:Path) -> str:
   """
   Return (as hash instance) the hash of a symlink.
   Caller must use hexdigest() or digest() as needed on
   the result.
 
   Args:
     path (string): path to symlink
@@ -122,15 +207,15 @@
   hasher = sha1()
   data = os.readlink(path).encode('utf8', 'surrogateescape')
   hasher.update('blob {len(data)}\0'.encode('ascii'))
   hasher.update(data)
   return hasher.hexdigest()
 
 
-def blob_hash(stream, size):
+def blob_hash(stream:BufferedReader, size:int) -> str:
   """
   Return (as hash instance) the hash of a blob,
   as read from the given stream.
 
   Args:
     stream (string): content to be hashed
     size (int): size of the content
@@ -152,77 +237,106 @@
     nRead += len(data)
     hasher.update(data)
   if nRead != size:
     raise ValueError(f'{stream.name}: expected {size} bytes, found {nRead} bytes')
   return hasher.hexdigest()
 
 
-def updateExtractorList(directory):
+def updateExtractorList(directory:Path) -> str:
   """
   Rules:
   - each data-type in its own try-except
   - inside try: raise ValueError exception on failure/None
   - except empty: pass
   - all descriptions in type have to be small letters
   - if want to force to skip top datatypes and use one at bottom: if doctype... -> exception
 
   Args:
     directory (string): relative directory to scan
 
   Returns:
     bool: success
   """
-  import json
-  from pathlib import Path
+  verboseDebug = False
   extractorsAll = {}
   for fileName in os.listdir(directory):
     if fileName.endswith('.py') and fileName not in ['testExtractor.py','tutorial.py','commit.py'] :
       #start with file
       with open(directory/fileName,'r', encoding='utf-8') as fIn:
+        if verboseDebug: print('\n'+fileName)
         lines = fIn.readlines()
-        extractors = []
-        baseType = ['measurement', fileName.split('_')[1].split('.')[0]]
+        extractorsThis = {}
         ifInFile, headerState, header = False, True, []
         for idx,line in enumerate(lines):
           line = line.rstrip()
           if idx>0 and '"""' in line:
             headerState = False
           if headerState:
             line = line.replace('"""','')
             header.append(line)
             continue
           if "if" in line and "#:" in line:
-            specialType = line.split("endswith('")[1].split("')")[0]
-            extractors.append([ baseType+specialType.split('/'), line.split('#:')[1].strip() ])
+            if verboseDebug: print('line', line)
+            specialType = line.split("==")[1].split(":")[0].strip(" '"+'"')
+            if verboseDebug: print('  special',specialType)
+            extractorsThis[specialType] = line.split('#:')[1].strip()
             ifInFile = True
           elif "else:" in line and "#:" in line:
-            extractors.append([ baseType, line.split('#:')[1].strip() ])
-          elif "return" in line and not ifInFile:
-            try:
-              specialType = line.split("+['")[1].split("']")[0]
-              extractors.append([ baseType+[specialType], '' ])
-            except:
-              pass
-        if len(extractors)>0:
-          extractorsAll.update({'/'.join(docType):label for docType, label in extractors})
-          #header not fused for now
+            print('**ERROR there should not be an else in the code')
+          elif "return" in line and 'recipe' in line and not ifInFile:
+            if verboseDebug: print('line', line)
+            if line.count('recipe')==1:
+              linePart = line.split('recipe')[1].strip()
+              linePart = linePart.split(':')[1].split(',')[0].strip(" '"+'"')
+            elif line.count('recipe')==2:
+              possLines = [i.strip() for i in lines if ('recipe' in i and '=' in i and 'def' not in i)]
+              if len(possLines)==1:
+                linePart=possLines[0].split('=')[1].strip(" '"+'"')
+              else:
+                print('**ERROR Could not decipher '+fileName)
+            extractorsThis[linePart]='Default'
+            if verboseDebug:
+              print('  return', linePart)
+        if verboseDebug:
+          print('Extractors', extractorsThis)
+        ending = fileName.split('_')[1].split('.')[0]
+        extractorsAll[ending]=extractorsThis
+        #header not used for now
   #update configuration file
-  print('Found extractors:')
-  for key, value in extractorsAll.items():
-    print('  ',key, ":", value)
+  print('\n\nFound extractors:')
+  print(yaml.dump(extractorsAll))
   with open(Path.home()/'.pastaELN.json','r', encoding='utf-8') as f:
     configuration = json.load(f)
   configuration['extractors'] = extractorsAll
   with open(Path.home()/'.pastaELN.json','w', encoding='utf-8') as f:
     f.write(json.dumps(configuration, indent=2))
-  return True
+  return yaml.dump(extractorsAll)
 
 
-def restart():
+def restart() -> None:
   """
   Complete restart: cold restart
   """
   try:
-    os.execv('pastaELN',[])  #installed version
+    os.execv('pastaELN',[''])  #installed version
   except:
     os.execv(sys.executable, ['python3','-m','pasta_eln.gui']) #started for programming or debugging
   return
+
+
+class DummyProgressBar():
+  """ Class representing a progressbar that does not do anything
+  """
+  def setValue(self, value:int) -> None:
+    """
+    Set value
+
+    Args:
+      value (int): value to be set
+    """
+    return
+  def show(self) -> None:
+    """ show progress bar """
+    return
+  def hide(self) -> None:
+    """ hide progress bar """
+    return
```

## pasta_eln/mixin_cli.py

```diff
@@ -1,82 +1,23 @@
 """ PYTHON MIXIN FOR BACKEND containing all the functions that output to CLI """
-import re, platform
-from pathlib import Path
+# mypy: ignore-errors
 from .miscTools import createDirName
 
-class Bcolors:
-  """
-  Colors for Command-Line-Interface and output
-  """
-  if platform.system()=='Windows':
-    HEADER = ''
-    OKBLUE = ''
-    OKGREEN = ''
-    WARNING = ''
-    FAIL = ''
-    ENDC = ''
-    BOLD = ''
-    UNDERLINE = ''
-  else:
-    HEADER = '\033[95m'
-    OKBLUE = '\033[94m'
-    OKGREEN = '\033[92m'
-    WARNING = '\033[93m'
-    FAIL = '\033[91m'
-    ENDC = '\033[0m'
-    BOLD = '\033[1m'
-    UNDERLINE = '\033[4m'
-
-
-def text2html(text):
-  """
-  convert text output of checkDatabase into html string
-  - https://doc.qt.io/qtforpython/overviews/richtext-html-subset.html#supported-html-subset
-
-  Args:
-    text (str): text to be converted
-
-  Returns:
-     str: html strings for qt's rich text support
-  """
-  text = text.split('\n')
-  for i, _ in enumerate(text):
-    if '\033[95m' in text[i]:
-      text[i] = text[i].replace('\033[95m','<font color="orange">').replace('\033[0m','</font>')
-    if '\033[94m' in text[i]:
-      text[i] = text[i].replace('\033[94m','<font color="blue">').replace('\033[0m','</font>')
-    if '\033[92m' in text[i]:
-      text[i] = text[i].replace('\033[92m','<font color="green">').replace('\033[0m','</font>')
-    if '\033[93m' in text[i]:
-      text[i] = text[i].replace('\033[93m','<font color="magenta">').replace('\033[0m','</font>')
-    if '\033[91m' in text[i]:
-      text[i] = text[i].replace('\033[91m','<font color="red">').replace('\033[0m','</font>')
-    if '\033[4m' in text[i]:
-      text[i] = text[i].replace('\033[4m','<br><b>').replace('\033[0m','</b>')
-    text[i] = text[i]+'<br>'
-    if 'Pink: unsure if bug' in text[i]:
-      text[i] = text[i].replace('Pink: unsure if bug','Orange: unsure if bug')
-    if 'Yellow: WARNING should' in text[i]:
-      text[i] = text[i].replace('Yellow: WARNING should','Magenta: WARNING should')
-    text[i] = text[i].replace('****','').strip()
-  return '\n'.join(text)
-
-
 class CLI_Mixin:
   """ Python Mixin for backend containing all the functions that output to CLI """
 
   def output(self, docType, printID=False, **kwargs):
     """
     output view to screen
     - length of output 100 character
 
     Args:
       docType (string): document type to output
       printID (bool):  include docID in output string
-      kwargs (dict): additional parameter
+      **kwargs (dict): additional parameter
 
     Returns:
         string: output incl. \n
     """
     outString = []
     widthArray = [25,25,25,25]
     for idx,item in enumerate(self.db.ontology[docType]['prop']):
@@ -129,15 +70,15 @@
   def outputTags(self, tag='', **kwargs):
     """
     output view to screen
     - length of output 100 character
 
     Args:
       tag (string): tag to be listed, if empty: print all
-      kwargs (dict): additional parameter
+      **kwargs (dict): additional parameter
 
     Returns:
         string: output incl. \n
     """
     outString = []
     outString.append(f'{0: <10}'.format('Tags') )
     outString.append(f'{0: <60}'.format('Name') )
@@ -164,15 +105,15 @@
     - convert view into native dictionary
     - ignore key since it is always the same
 
     Args:
        onlyHierarchy (bool): only print project,steps,tasks or print all (incl. measurements...)[default print all]
        addID (bool): add docID to output
        addTags (string): add tags, comments, objective to output ['all','tags',None]
-       kwargs (dict): additional parameter, i.e. callback
+       **kwargs (dict): additional parameter, i.e. callback
 
     Returns:
         string: output incl. \n
     """
     from anytree import PreOrderIter
     if len(self.hierStack) == 0:
       return 'Warning: pasta.outputHierarchy No project selected'
```

## pasta_eln/printer.py

```diff
@@ -1,11 +1,12 @@
 """ Misc PRINTER functions that do not require instances """
 import os, uuid
+from typing import Any
 
-def createQRcodeSheet(fileName="../qrCodes.pdf"):
+def createQRcodeSheet(fileName:str="../qrCodes.pdf") -> None:
   """
   Documentation QR-codes
   - img = qrcode.make("testString",error_correction=qrcode.constants.ERROR_CORRECT_M)
   - or ERROR-CORRECT_H for better errorcorrection
   Sizes:
   - QR code size 1.5-2cm
   - with frame 2.25-3cm
@@ -32,17 +33,17 @@
       #   data[:,:,:][mask.T]=(255,255,0)
       #   img = Image.fromarray(data)
       new_im.paste(img, (i, j))
   new_im.save(fileName)
   return
 
 
-def printQRcodeSticker(codes={},
-                       page={'size':[991,306], 'tiles':2, 'margin': 60, 'font':40},
-                       printer={'model':'QL-700', 'dev':'0x04f9:0x2042/3', 'size':'29x90'}):
+def printQRcodeSticker(codes:list[list[str]]=[],
+                       page:dict[str,Any]={'size':[991,306], 'tiles':2, 'margin': 60, 'font':40},
+                       printer:dict[str,str]={'model':'QL-700', 'dev':'0x04f9:0x2042/3', 'size':'29x90'}) -> None:
   """
   Codes: key-value pairs of qr-code and label
    - filled to achieve tiles
 
   Sticker:
    - size: 90.3x29 mm => [991,306] px
    - tiles: number of items on the sticker
```

## pasta_eln/serverActions.py

```diff
@@ -1,36 +1,40 @@
 #!/usr/bin/python3
 """Commandline utility to admin the remote server"""
 import sys, json, secrets, base64, os
-import requests
+from typing import Any
 from datetime import datetime
-import keyring as cred
+from pathlib import Path
 from zipfile import ZipFile, ZIP_DEFLATED
+import keyring as cred
+import requests
+from requests.structures import CaseInsensitiveDict
+from requests.auth import AuthBase
 from PIL import Image, ImageDraw, ImageFont
 
 #TODO_P5 serverConfiguration: this should become a GUI and CLI and separate into three-files: functions, CLI, GUI
 # add: delete all documents, backup database, backup server (incl. all small things)
 
-def passwordEncrypt(message):
+def passwordEncrypt(message:str) -> bytes:
   """
   obfuscate message
   """
   return base64.b64encode(bytearray(message, encoding='utf-8'))
-def passwordDecrypt(message):
+def passwordDecrypt(message:bytes) -> str:
   """
   de-obfuscate message
   """
   return base64.b64decode(message).decode('utf-8')
 
 #global variables
-headers = requests.structures.CaseInsensitiveDict()
+headers:CaseInsensitiveDict[str]= requests.structures.CaseInsensitiveDict()
 headers["Content-Type"] = "application/json"
 
 
-def createUserDatabase(url, auth, userName):
+def createUserDatabase(url:str, auth:AuthBase, userName:str) -> None:
   '''
   create a new user and database
 
   Args:
     url (string): url incl. http and port
     auth (object): HTTPBasicAuth object
     userName (string): user name, e.g. m.miller
@@ -41,36 +45,36 @@
   # create database
   resp = requests.put(url+'/'+userDB, headers=headers, auth=auth, timeout=10)
   if not resp.ok:
     print("**ERROR 1: put not successful",resp.reason)
     return
 
   # create user
-  data = {"docs":[{"_id":"org.couchdb.user:"+userName,"name": userName,"password":userPW,
+  dataDict:dict[str,Any] = {"docs":[{"_id":"org.couchdb.user:"+userName,"name": userName,"password":userPW,
     "roles":[userDB+"-W"], "type": "user", "orcid": ""}]}
-  data = json.dumps(data)
+  data = json.dumps(dataDict)
   resp = requests.post(url+'/_users/_bulk_docs', headers=headers, auth=auth, data=data, timeout=10)
   if not resp.ok:
     print("**ERROR 2: post not successful",resp.reason)
     return
 
   # create _security in database
-  data = {"admins": {"names":[],"roles":[userDB+"-W"]},
+  dataDict = {"admins": {"names":[],"roles":[userDB+"-W"]},
           "members":{"names":[],"roles":[userDB+"-R"]}}
-  data = json.dumps(data)
+  data = json.dumps(dataDict)
   resp = requests.put(url+'/'+userDB+'/_security', headers=headers, auth=auth, data=data, timeout=10)
   if not resp.ok:
     print("**ERROR 3: post not successful",resp.reason)
     return
 
   # create _design/authentication in database
-  data = {"validate_doc_update": "function(newDoc, oldDoc, userCtx) {"+\
+  dataDict = {"validate_doc_update": "function(newDoc, oldDoc, userCtx) {"+\
     "if (userCtx.roles.indexOf('"+userDB+"-W')!==-1){return;} "+\
     "else {throw({unauthorized:'Only Writers (W) may edit the database'});}}"}
-  data = json.dumps(data)
+  data = json.dumps(dataDict)
   resp = requests.put(url+'/'+userDB+'/_design/authentication',headers=headers,auth=auth,data=data,timeout=10)
   if not resp.ok:
     print("**ERROR 4: post not successful",resp.reason)
     return
 
   print('SUCCESS: Server interaction')
   #create image
@@ -81,23 +85,23 @@
   d.text((30, 70),  "user-name: "+userName, fill=(240,240,240), font=font)
   d.text((30,110),  "password: " +userPW,   fill=(240,240,240), font=font)
   d.text((30,150),  "database: " +userDB,   fill=(240,240,240), font=font)
   d.text((30,190),  "Remote configuration", fill=(240,240,240), font=font)
   d.text((30,230),  "Server:   " +url, fill=(240,240,240), font=font)
   img.save(userDB+'.png')
   #create key file
-  data = {"configuration name":"remote","user-name":userName,"password":userPW,"database":userDB,\
+  dataDict = {"configuration name":"remote","user-name":userName,"password":userPW,"database":userDB,\
     "Remote configuration":"true","Server":url}
-  data = passwordEncrypt(json.dumps(data).encode())
+  dataBin = passwordEncrypt(json.dumps(dataDict))
   with open(userDB+'.key','bw') as fOut:
-    fOut.write(data)
+    fOut.write(dataBin)
   return
 
 
-def listUsers(url, auth, verbose=True):
+def listUsers(url:str, auth:AuthBase, verbose:bool=True) -> dict[str,Any]:
   '''
   list (and test) all users
 
   Args:
     url (string): url incl. http and port
     auth (object): HTTPBasicAuth object
     verbose (bool): verbose output
@@ -113,16 +117,16 @@
     print("List of users:")
   results = {}
   for i in json.loads(resp.text)['rows']:
     if i['id']=='_design/_auth':
       continue
     if verbose:
       print(i['id'][17:]+'       key:'+i['key'][17:])
-    respI = requests.get(url+'/_users/'+i['id'], headers=headers, auth=auth, timeout=10)
-    respI = json.loads(respI.text)
+    responseI = requests.get(url+'/_users/'+i['id'], headers=headers, auth=auth, timeout=10)
+    respI = json.loads(responseI.text)
     results[respI['name']] = respI['roles']
     if verbose:
       print('  Roles',respI['roles'])
       print('  Name ',respI['name'])
       if respI['name'].replace('.','_')+'-W' in respI['roles']:
         print('  -> corresponds to role-name convention')
       else:
@@ -133,15 +137,15 @@
         print('  -> DOES NOT correspond to id-name convention:',respI['name'])
       print('  Orcid',respI['orcid'])
   if verbose:
     return {}
   return results
 
 
-def listDB(url, auth, verbose):
+def listDB(url:str, auth:AuthBase, verbose:bool) -> dict[str,Any]:
   '''
   list (and test) all databases
 
   Args:
     url (string): url incl. http and port
     auth (object): HTTPBasicAuth object
     verbose (bool): verbose output
@@ -158,16 +162,16 @@
   results = {}
   for i in json.loads(resp.text):
     if i in ['_replicator','_users']:
       continue
     if verbose:
       print(i)
     # test security
-    respI = requests.get(url+'/'+i+'/_security', headers=headers, auth=auth, timeout=10)
-    respI = json.loads(respI.text)
+    responseI = requests.get(url+'/'+i+'/_security', headers=headers, auth=auth, timeout=10)
+    respI = json.loads(responseI.text)
     security = [respI['admins']['roles'], respI['members']['roles']]
     if verbose:
       print('  Write',respI['admins']['roles'])
       print('  Read ',respI['members']['roles'])
       if (respI['admins']['roles'][0].endswith('-W') and
           respI['members']['roles'][0].endswith('-R') and
           respI['admins']['roles'][0].split('-')[0] == respI['members']['roles'][0].split('-')[0]):
@@ -185,15 +189,15 @@
       else:
         print('  -> **ERROR** authentication',respI)
   if verbose:
     return {}
   return results
 
 
-def testUser(url, auth, userName, userPassword):
+def testUser(url:str, auth:AuthBase, userName:str, userPassword:str) -> None:
   '''
   test if configuration for this user is correct
   '''
   # Test if server exists
   resp = requests.get(url, headers=headers, timeout=10)
   if resp.ok:
     print("-> Server exists")
@@ -232,15 +236,15 @@
       print("-> Authentication can be read")
     else:
       print("**ERROR: Authentication  cannot be read")
       break
   return
 
 
-def testLocal(userName, password, database=''):
+def testLocal(userName:str, password:str, database:str='') -> str:
   """
   test local server
 
   Args:
     userName (str): user name at local server
     password (str): password at local server
     database (str): couchdb database
@@ -265,15 +269,15 @@
     if resp.ok:
       answer += 'success: Local database exists\n'
     else:
       answer += 'Warning: Local database does not exist\n'
   return answer
 
 
-def testRemote(url, userName, password, database):
+def testRemote(url:str, userName:str, password:str, database:str) -> str:
   """
   test remote server
 
   Args:
     url (str): url of remote server
     userName (str): user name at remote server
     password (str): password at remote server
@@ -293,15 +297,15 @@
   if resp.ok:
     answer += 'success: Remote database exists\n'
   else:
     answer += 'ERROR: Remote username, password, database incorrect\n'
   return answer
 
 
-def backupCouchDB(location='', userName='', password=''):
+def backupCouchDB(location:str='', userName:str='', password:str='') -> None:
   """
   Backup everything of the CouchDB installation accross all databases and all configurations
   - remote location uses username/password combo in local keystore
   - local location requires username and password
 
   Args:
     location (str): 'local', 'remote', else: ask user via CLI
@@ -316,57 +320,73 @@
     if userName=='':
       userName = input('Enter username: ').strip()
     if password=='':
       password = input('Enter password: ').strip()
   elif location=='remote':
     try:
       myString = cred.get_password('pastaDB','admin')
+      if myString is None:
+        print("**ERROR Could not get credentials from keyring 2. Please create manually.")
+        return
       location, userName, password = myString.split(':')
       print("URL and credentials successfully read from keyring")
     except:
-      print("**ERROR Could not get credentials from keyring. Please create manually.")
+      print("**ERROR Could not get credentials from keyring 2b. Please create manually.")
       return
   else:
     print('**ERROR: wrong location given.')
     return
   # use information
   authUser = requests.auth.HTTPBasicAuth(userName, password)
-  kwargs   = {'headers':headers, 'auth':authUser, 'timeout':10}
-  resp = requests.get('http://'+location+':5984/_all_dbs', **kwargs)
+  resp = requests.get('http://'+location+':5984/_all_dbs',
+                      headers=headers, auth=authUser, timeout=10)
   if resp.status_code != 200:
     print('**ERROR response for _all_dbs wrong', resp.text)
     print('Username and password', userName, password)
     return
   timestamp = datetime.now().isoformat().split('.')[0].replace('-','').replace(':','')
   zipFileName = 'couchDB_backup_'+location.replace('.','')+'_'+timestamp
   print('Create zip-file '+zipFileName+'.zip')
   databases = resp.json()
   with ZipFile(zipFileName+'.zip', 'w', compression=ZIP_DEFLATED) as zipFile:
     for database in databases:
       if database.startswith('_'):
         print('Special database', database, ': Nothing to do')
       else:
         print('Backup normal database ',database)
-        resp = requests.get('http://'+location+':5984/'+database+'/_all_docs', **kwargs)
+        resp = requests.get('http://'+location+':5984/'+database+'/_all_docs',
+                            headers=headers, auth=authUser, timeout=10)
         for item in resp.json()['rows']:
           docID = item['id']
-          doc   = requests.get('http://'+location+':5984/'+database+'/'+docID, **kwargs).json()
+          doc   = requests.get('http://'+location+':5984/'+database+'/'+docID,
+                              headers=headers, auth=authUser, timeout=10).json()
           zipFile.writestr(zipFileName+'/'+database+'/'+docID, json.dumps(doc))
           if '_attachments' in doc:
             for att in doc['_attachments']:
-              docAttach = requests.get('http://'+location+':5984/'+database+'/'+docID+'/'+att,**kwargs).json()
+              docAttach = requests.get('http://'+location+':5984/'+database+'/'+docID+'/'+att,
+                                        headers=headers, auth=authUser, timeout=10).json()
               zipFile.writestr(zipFileName+'/'+database+'/'+docID+'_attach/'+att, json.dumps(docAttach))
         #_design/authentication is automatically included
         #_security
-        doc   = requests.get('http://'+location+':5984/'+database+'/_security', **kwargs).json()
+        doc   = requests.get('http://'+location+':5984/'+database+'/_security',
+                              headers=headers, auth=authUser, timeout=10).json()
         zipFile.writestr(zipFileName+'/'+database+'/_security', json.dumps(doc))
-    return
+    with open(Path.home()/'.pastaELN.json', encoding='utf-8') as fIn:
+      configuration = json.loads(fIn.read())
+      for projectG in configuration['projectGroups']:
+        for site in ['local','remote']:
+          subsection = configuration['projectGroups'][projectG][site]
+          if 'cred' in subsection and ('user' not in subsection or 'password' not in subsection):
+            key = cred.get_password('pastaDB', subsection['cred'])
+            subsection['user'], subsection['password'] = ['',''] if key is None else key.split('bcA:Maw')
+      zipFile.writestr(zipFileName+'/pastaELN.json', json.dumps(configuration))
+  return
 
 
-def restoreCouchDB(location='', userName='', password='', fileName=''):
+def restoreCouchDB(location:str='', userName:str='', password:str='', fileName:str='') -> None:
   """
   restore everything to the CouchDB installation accross all databases and all configurations
   - remote location uses username/password combo in local keystore
   - local location requires username and password
 
   Args:
     location (str): 'local', 'remote', else: ask user via CLI
@@ -382,94 +402,107 @@
     if userName=='':
       userName = input('Enter username: ').strip()
     if password=='':
       password = input('Enter password: ').strip()
   elif location=='remote':
     try:
       myString = cred.get_password('pastaDB','admin')
+      if myString is None:
+        print("**ERROR Could not get credentials from keyring 3. Please create manually.")
+        return
       location, userName, password = myString.split(':')
       print("URL and credentials successfully read from keyring")
     except:
-      print("**ERROR Could not get credentials from keyring. Please create manually.")
+      print("**ERROR Could not get credentials from keyring 3b. Please create manually.")
       return
   else:
     print('**ERROR: wrong location given.')
     return
   if fileName=='':
     possFiles = [i for i in os.listdir('.') if i.startswith('couchDB') and i.endswith('.zip')]
     for idx, i in enumerate(possFiles):
       print('['+str(idx+1)+'] '+i)
     fileName = input('Which file to use for restored? (1-'+str(len(possFiles))+') ')
     fileName = possFiles[int(fileName)-1]
   # use information
   authUser = requests.auth.HTTPBasicAuth(userName, password)
-  kwargs   = {'headers':headers, 'auth':authUser, 'timeout':10}
   with ZipFile(fileName, 'r', compression=ZIP_DEFLATED) as zipFile:
     files = zipFile.namelist()
     #first run through: create documents and design documents
     for fileI in files:
       fileParts = fileI.split('/')[1:]
       database = fileParts[0]
       docID = fileParts[1]
       if docID.endswith('_attach'):
         continue #Do in second loop
       #test if database is exists: create otherwise
-      resp = requests.get('http://'+location+':5984/'+database+'/_all_docs', **kwargs)
+      resp = requests.get('http://'+location+':5984/'+database+'/_all_docs',
+                              headers=headers, auth=authUser, timeout=10)
       if resp.status_code != 200 and resp.json()['reason']=='Database does not exist.':
-        resp = requests.put('http://'+location+':5984/'+database, **kwargs)
+        resp = requests.put('http://'+location+':5984/'+database,
+                            headers=headers, auth=authUser, timeout=10)
         if not resp.ok:
           print("**ERROR: could not create database",resp.reason)
           return
       #test if document is exists: create otherwise
       if docID=='_design':
         docID = '/'.join(fileParts[1:])
-      resp = requests.get('http://'+location+':5984/'+database+'/'+docID, **kwargs)
+      resp = requests.get('http://'+location+':5984/'+database+'/'+docID,
+                          headers=headers, auth=authUser, timeout=10)
       if resp.status_code != 200 and resp.json()['reason']=='missing':
-        doc = json.loads( zipFile.open(fileI).read() )  #need doc conversion since deleted from it
-        del doc['_rev']
-        if '_attachments' in doc:
-          del doc['_attachments']
-        resp = requests.put('http://'+location+':5984/'+database+'/'+docID, **kwargs,data=json.dumps(doc) )
-        if resp.ok:
-          print('Saved document:', database, docID)
-        else:
-          print("**ERROR: could not save document:",resp.reason, database, docID, '\n', doc)
+        with zipFile.open(fileI) as dataIn:
+          doc = json.loads( dataIn.read() )  #need doc conversion since deleted from it
+          del doc['_rev']
+          if '_attachments' in doc:
+            del doc['_attachments']
+          resp = requests.put('http://'+location+':5984/'+database+'/'+docID, data=json.dumps(doc),
+                              headers=headers, auth=authUser, timeout=10)
+          if resp.ok:
+            print('Saved document:', database, docID)
+          else:
+            print("**ERROR: could not save document:",resp.reason, database, docID, '\n', doc)
     #second run through: create attachments
     for fileI in files:
       fileParts = fileI.split('/')[1:]
       database = fileParts[0]
       docID = fileParts[1]
       if not docID.endswith('_attach'):
         continue #Did already in the first loop
       #test if attachement exists: create otherwise
       attachPath =docID[:-7]+'/'+fileParts[-1]
-      resp = requests.get('http://'+location+':5984/'+database+'/'+attachPath, **kwargs)
+      resp = requests.get('http://'+location+':5984/'+database+'/'+attachPath,
+                              headers=headers, auth=authUser, timeout=10)
       if resp.status_code == 404 and 'missing' in resp.json()['reason']:
-        attachDoc = zipFile.open(fileI).read()
-        resp = requests.get('http://'+location+':5984/'+database+'/'+docID[:-7],**kwargs)
-        headers['If-Match'] = resp.json()['_rev'] #will be overwritten each time
-        kwargs   = {'headers':headers, 'auth':authUser, 'timeout':10}
-        resp = requests.put('http://'+location+':5984/'+database+'/'+attachPath,**kwargs, data=attachDoc)
-        if resp.ok:
-          print('Saved attachment:', database, attachPath)
-        else:
-          print('\n**ERROR: could not save attachment:',resp.reason, database, attachPath,'\n', doc)
+        with zipFile.open(fileI) as dataIn:
+          attachDoc = dataIn.read()
+          resp = requests.get('http://'+location+':5984/'+database+'/'+docID[:-7],
+                              headers=headers, auth=authUser, timeout=10)
+          headers['If-Match'] = resp.json()['_rev'] #will be overwritten each time
+          resp = requests.put('http://'+location+':5984/'+database+'/'+attachPath, data=attachDoc,
+                              headers=headers, auth=authUser, timeout=10)
+          if resp.ok:
+            print('Saved attachment:', database, attachPath)
+          else:
+            print('\n**ERROR: could not save attachment:',resp.reason, database, attachPath,'\n', doc)
   return
 
 
-def main():
+def main() -> None:
   '''
   Main function
   '''
   #set information once in keyring
   #  myString = url+':'+adminUserName+':'+adminPassword
   #  url without http and port
   #  cred.set_password('pastaDB','admin',myString)
   try:
     myString = cred.get_password('pastaDB','admin')
+    if myString is None:
+      print("**ERROR Could not get credentials from keyring 1. Please create manually.")
+      sys.exit(1)
     url, administrator, password = myString.split(':')
     print("URL and credentials successfully read from keyring")
   except:
     print("Could not get credentials from keyring.")
     ## URL
     url = input('Enter the URL without http and without port: ')
     if len(url)<2:
```

## pasta_eln/style.py

```diff
@@ -1,17 +1,30 @@
 """ all styling of buttons and other general widgets, some defined colors... """
-from PySide6.QtWidgets import QPushButton, QLabel, QSizePolicy, QRadioButton, QMessageBox  # pylint: disable=no-name-in-module
-from PySide6.QtGui import QImage, QPixmap, QAction, QKeySequence  # pylint: disable=no-name-in-module
+from typing import Callable, Optional
+from PySide6.QtWidgets import QPushButton, QLabel, QSizePolicy, QMessageBox, QLayout, QWidget, QMenu, QVBoxLayout, QHBoxLayout, QGridLayout, QFormLayout # pylint: disable=no-name-in-module
+from PySide6.QtGui import QImage, QPixmap, QAction, QKeySequence, QMouseEvent  # pylint: disable=no-name-in-module
 from PySide6.QtCore import QByteArray, Qt           # pylint: disable=no-name-in-module
 from PySide6.QtSvgWidgets import QSvgWidget         # pylint: disable=no-name-in-module
 import qtawesome as qta
 from qt_material import get_theme
+from .backend import Backend
 
+spacesMap = {'0':0, 's':5, 'm':10, 'l':20, 'xl':200} #spaces: padding and margin
 
-def getColor(backend, color):
+iconsDocTypes = {'Measurements':'fa5s.thermometer-half',
+                 'Samples':     'fa5s.vial',
+                 'Procedures':  'fa5s.list-ol',
+                 'Instruments': 'ri.scales-2-line',
+                 '-':           'fa5.file'}
+
+shortCuts = {'measurement':'m', 'sample':'s', 'procedure':'p', 'instrument':'i', 'x0':'space'}
+
+
+
+def getColor(backend:Backend, color:str) -> str:
   """
   get color from theme
 
   Args:
     backend (Pasta): backend instance
     color (str): color to get [primary, primaryLight, secondary, secondaryLight, secondaryDark, primaryText, secondaryText]
 
@@ -30,18 +43,17 @@
   if themeName == 'none':
     return '#000000'
   return get_theme(themeName+'.xml')[color+'Color']
 
 
 class TextButton(QPushButton):
   """ Button that has only text"""
-  def __init__(self, label, function, layout, name='', tooltip='', checkable=False, style='', hide=False):
+  def __init__(self, label:str, function:Optional[Callable[[],None]], layout:Optional[QLayout], name:str='',
+               tooltip:str='', checkable:bool=False, style:str='', hide:bool=False, backend:Optional[Backend]=None):
     """
-    Initialization
-
     Args:
       label (str): label printed on button
       function (function): function to be called upon button-click-event
       layout (QLayout): button to be added to this layout
       name (str): name used for button identification in called-function
       tooltip (str): tooltip shown when mouse hovers the button
       checkable (bool): can the button change its background color
@@ -55,95 +67,70 @@
     self.clicked.connect(function)
     if name != '':
       self.setAccessibleName(name)
     if tooltip != '':
       self.setToolTip(tooltip)
     if style != '':
       self.setStyleSheet(style)
-    if hide:
-      self.hide()
-    if layout is not None:
-      layout.addWidget(self)
-
-
-class LetterButton(QPushButton):
-  """ Button that has only a letter"""
-  def __init__(self, label, function, layout, name='', style='', hide=False):
-    """
-    Initialization
-
-    Args:
-      label (str): label printed on button
-      function (function): function to be called upon button-click-event
-      layout (QLayout): button to be added to this layout
-      name (str): name used for button identification in called-function
-      style (str): css style
-      hide (bool): hidden or shown initially
-    """
-    super().__init__()
-    self.setText(label[0])
-    self.clicked.connect(function)
-    self.setToolTip(label)
-    if name != '':
-      self.setAccessibleName(name)
-    if style != '':
-      self.setStyleSheet(style)
+    else:
+      if backend is None:
+        primaryColor = '#448aff'
+        secTextColor = '#eeeeee'
+      else:
+        primaryColor = getColor(backend, 'primary')
+        secTextColor = getColor(backend, 'secondaryText')
+      self.setStyleSheet('border-width: 0px; background-color: '+primaryColor+'; color: '+secTextColor)
     if hide:
       self.hide()
     if layout is not None:
       layout.addWidget(self)
 
 
 class IconButton(QPushButton):
   """ Button that has only an icon"""
-  def __init__(self, iconName, function, layout, name='', tooltip='', backend=None, style='', **kwargs):
+  def __init__(self, iconName:str, function:Callable[[],None], layout:Optional[QLayout], name:str='',
+               tooltip:str='', backend:Optional[Backend]=None, style:str='', hide:bool=False, text:str=''):
     """
-    Initialization
-
-    Additional parameter:
-    - hide (bool): hidden or shown initially
-    - text (str): text shown on button additionally  #TODO_P4 question? what is the difference to TextButton?
-
     Args:
       iconName (str): icon to show on button
       function (function): function to be called upon button-click-event
       layout (QLayout): button to be added to this layout
       name (str): name used for button identification in called-function
       tooltip (str): tooltip shown when mouse hovers the button
       backend (Pasta): pasta backend
       style (str): css style
-      kwargs (dict): additional parameter
+      hide (bool): hidden or shown initially
+      text (str): text shown on button additionally
     """
-    hide = kwargs.get('hide', False)
-    text = kwargs.get('text', '')
     super().__init__()
     color = 'black' if backend is None else getColor(backend, 'primary')
     icon = qta.icon(iconName, color=color, scale_factor=1)
     self.setIcon(icon)
     self.setText(text)
     self.clicked.connect(function)
     self.setFixedHeight(30)
     if name != '':
       self.setAccessibleName(name)
     if tooltip != '':
       self.setToolTip(tooltip)
-    if style != '':
+    if style == '':
+      self.setStyleSheet("border-width:0")
+    else:
       self.setStyleSheet(style)
     if hide:
       self.hide()
     if layout is not None:
       layout.addWidget(self)
 
 
 class Action(QAction):
   """ QAction and assign function to menu"""
-  def __init__(self, label, function, menu, parent, shortcut=None, name=None):
+  def __init__(self, label:str, function:Callable[[],None], menu:QMenu, parent:QWidget,
+               shortcut:Optional[str]=None, name:Optional[str]=None):
     """
-    Initialization
-
     Args:
       label (str): label printed on submenu
       function (function): function to be called
       menu (QMenu): button to be added to this menu
       parent (QWidget): parent widget
       shortcut (str): shortcut (e.g. Ctrl+K)
       name (str): additional data to transport
@@ -158,73 +145,107 @@
       self.setShortcut(QKeySequence(shortcut))
     if name is not None:
       self.setData(name)
 
 
 class Image():
   """ Image widget depending on type of data """
-  def __init__(self, data, layout, width=-1, height=-1):
+  def __init__(self, data:str, layout:Optional[QLayout], width:int=-1, height:int=-1, anyDimension:int=-1):
     """
-    Initialization
-
     Args:
       data (str): image data in byte64-encoding or svg-encoding
       layout (QLayout): to be added to this layout
       width (int): width of image, dominant if both are given
       height (int): height of image
+      anyDimension (int): maximum size in any direction
     """
     if data.startswith('data:image/'): #jpg or png image
       byteArr = QByteArray.fromBase64(bytearray(data[22:] if data[21]==',' else data[23:], encoding='utf-8'))
       imageW = QImage()
       imageType = data[11:15].upper()
-      imageW.loadFromData(byteArr, imageType[:-1] if imageType.endswith(';') else imageType)
+      imageW.loadFromData(byteArr, format=imageType[:-1] if imageType.endswith(';') else imageType)   # type: ignore
       pixmap = QPixmap.fromImage(imageW)
       if height>0:
         pixmap = pixmap.scaledToHeight(height)
       if width>0:
         pixmap = pixmap.scaledToWidth(width)
+      if anyDimension>0:
+        if pixmap.size().height()>pixmap.size().width():
+          pixmap = pixmap.scaledToHeight(anyDimension)
+        else:
+          pixmap = pixmap.scaledToWidth(anyDimension)
       label = QLabel()
       label.setPixmap(pixmap)
-      label.setAlignment(Qt.AlignCenter)
-      layout.addWidget(label)
+      label.setAlignment(Qt.AlignCenter) # type: ignore
+      if layout is not None:
+        layout.addWidget(label, alignment=Qt.AlignHCenter)  # type: ignore
     elif data.startswith('<?xml'): #svg image
       imageW = QSvgWidget()
       policy = imageW.sizePolicy()
       policy.setHorizontalPolicy(QSizePolicy.Fixed)
       policy.setVerticalPolicy(QSizePolicy.Fixed)
       imageW.setSizePolicy(policy)
       imageW.renderer().load(bytearray(data, encoding='utf-8'))
-      layout.addWidget(imageW)
-      layout.setAlignment(Qt.AlignCenter)
-    else:
+      if height>0:
+        imageW.setMaximumSize(int(float(imageW.width())/float(imageW.height())*height) ,height)
+      if width>0:
+        imageW.setMaximumSize(width, int(float(imageW.height())/float(imageW.width())*width))
+      if anyDimension>0:
+        #TODO_P1: make sure images are not elongated
+        if imageW.height()>imageW.width():
+          imageW.setMaximumSize(int(float(imageW.width())/float(imageW.height())*anyDimension) ,anyDimension)
+        else:
+          imageW.setMaximumSize(anyDimension, int(float(imageW.height())/float(imageW.width())*anyDimension))
+      if layout is not None:
+        layout.addWidget(imageW, alignment=Qt.AlignHCenter) # type: ignore
+    elif len(data)>2:
       print('WidgetProjectLeaf:What is this image |'+data[:50]+'|')
     return
 
 
 class Label(QLabel):
   """ Label widget: headline, ... """
-  def __init__(self, text='', size='', layout=None):
+  def __init__(self, text:str='', size:str='', layout:Optional[QLayout]=None,
+               function:Optional[Callable[[str, str],None]]=None, docID:str='', tooltip:str=''):
     """
-    Initialization
-
     Args:
       text (str): text on label
-      size (str): size ['h1']
+      size (str): size ['h1','h2','h3']
       layout (QLayout): layout to which to add the label
+      function (function): function to call on mouse click
+      docID (str): docID on other string to connect to this label
+      tooltip (str): tooltip shown when mouse hovers the button
     """
     super().__init__()
     self.setText(text)
     if size == 'h1' :
       self.setStyleSheet('font-size: 14pt')
+    if size == 'h2' :
+      self.setStyleSheet('font-size: 12pt')
+    if size == 'h3' :
+      self.setStyleSheet('font-size: 10pt')
     if layout is not None:
       layout.addWidget(self)
+    self.mouseFunction = function
+    self.identifier = docID
+    if tooltip != '':
+      self.setToolTip(tooltip)
+    return
+
+  def mousePressEvent(self, e:QMouseEvent) -> None:
+    """
+    Event after mouse press: only use internal members, not the event itself
+    """
+    if self.mouseFunction is not None:
+      self.mouseFunction(self.text(), self.identifier)
     return
 
 
-def showMessage(parent, title, text, icon='', style=''):
+
+def showMessage(parent:QWidget, title:str, text:str, icon:str='', style:str='') -> None:
   """
   Show a message box
 
   Args:
     parent (QWidget): parent widget (self)
     title (str): title of box
     text (str): text in box
@@ -236,7 +257,48 @@
   dialog.setText(text)
   if icon in ['Information','Warning','Critical']:
     dialog.setIcon(getattr(QMessageBox, icon))
   if style!='':
     dialog.setStyleSheet(style)
   dialog.exec()
   return
+
+
+def widgetAndLayout(direction:str='V', parentLayout:Optional[QLayout]=None, spacing:str='0', left:str='0', top:str='0', right:str='0', bottom:str='0') -> tuple[QWidget, QLayout]:
+  """
+  Convenient function for widget and a boxLayout
+
+  Spacings and margins:
+  - different than in css/html
+  - spacing is the space between elements in the orientation of the BoxLayout
+  - is the padding that surrounds the content in the layout
+
+  Distances are given in
+  - '0': zero distance
+  - 's': small distance used as padding round elements, or vertical spacings
+  - 'm': medium used as space between horizontal elements
+  - 'l': large used when things need to be separated
+  - 'xl': extra large indentations, frames
+
+  Args:
+    direction (str): type of layout [H,V,Grid,Form]
+    parentLayout (QLayout): to which layout should the widget be added. If none, no adding
+    spacing (str): spacing
+    left (str): padding on left
+    top (str): padding on top
+    right (str): padding on right
+    bottom (str): padding on bottom
+  """
+  widget = QWidget()
+  if direction=='V':
+    layout = QVBoxLayout(widget)
+  elif direction=='H':
+    layout = QHBoxLayout(widget)
+  elif direction=='Form':
+    layout = QFormLayout(widget)
+  else:
+    layout = QGridLayout(widget)
+  layout.setSpacing(spacesMap[spacing])
+  layout.setContentsMargins(spacesMap[left], spacesMap[top], spacesMap[right], spacesMap[bottom])
+  if parentLayout is not None:
+    parentLayout.addWidget(widget)
+  return widget, layout
```

## pasta_eln/tempStrings.py

```diff
@@ -1,42 +1,58 @@
 """ ##Automatically created file: do not update manually """
 todoString = """
 
 <h3>Very important show stopper</h3>
 <ul>
+<li>: make sure images are not elongated
 </ul>
 
-<h3>To be verified/identified</h3>
+<h3>Things currently working on</h3>
 <ul>
-<li> create project within project (unable to recreate)
+<li> export and import of .eln
 </ul>
 
 <h3>Improvement to convenience</h3>
 <ul>
-<li> convenience: allow scroll in sidebar
-<li> convenience: selection does not scroll; one cannot select a row
-<li> drag&drop: external files
-<li> invert filter: not 'Sur' in name => '^((?!Sur).)*$' in name
-<li> rerunExtractors: as batch
+<li> design ProjectView: Currently, the comment is more highlighted than the title of an item due
+<li> design: make the checkboxes larger!
+<li> export: export via extractor in high resolution: change order: first save, then rescale
+<li> extractor: creates links to sample/instrument
+<li> finish ontology dialog
+<li> form: add button to add key-values
+<li> image does not allow for easy context aware clicks
+<li> other items as non-edible things that can be copy-pasted
+<li> projectTree design: If folders and other items have boxes of slightly different brightness
+<li> projectView: if table-row click, move to view it project
+<li> projectView: selection does not scroll; one cannot select a row
+<li> table: shift-select
+<li> tableHeaderChange: requires view to change to views, not ontology
 </ul>
 
 <h3>Bigger things implemented soon</h3>
 <ul>
-<li> change procedure: on disk / database -> conflicts
-<li> create list of unaccessible files: linked with accessible files
-<li> finish ontology dialog
-<li> question? what is the difference to TextButton?
-<li> tableHeaderChange: requires view to change to views, not ontology
+<li> add splitter to increase / decrease image
+<li> addToConfig
+<li> can you sort for true false in tables too?
+<li> change to string-output
+<li> from config file
+<li> not sure this will be important
+<li> projectTree: allow right click on measurement to change recipe
+<li> projectTree: drag&drop of external files
+<li> projectTree: select multiple items to edit... What is use case
 </ul>
 
 <h3>Things worthwile remembering/uncritical</h3>
 <ul>
-<li> Aug 2023: remove
-<li> addToConfig
-<li> addToConfig
-<li> addToConfig
-<li> if successful in Aug2023: remove
+<li> Add read info from ror and orcid into personal details section -> config.json
+<li> copy of file: should it the be the same in database or should it be two separate entities??
+<li> create list of unaccessible files: linked with accessible files
+<li> for now, sorted by last change of project itself: future create a view that does that automatically
 <li> if successful in Aug2023: remove "echo....read"
+<li> invert filter: not 'Sur' in name => '^((?!Sur).)*$' in name
 <li> moreChecksDB: if parent has corresponding show
+<li> only write markdown files for now
+<li> remove this warning
 <li> serverConfiguration: this should become a GUI and CLI and separate into three-files: functions, CLI, GUI
+<li> this childNumSearch could become new function
 </ul>
 """
```

## pasta_eln/widgetBody.py

```diff
@@ -1,47 +1,53 @@
 """ Central widget: everything that is not sidebar: switches between project-view and table-details """
+import logging
 from PySide6.QtWidgets import QWidget, QVBoxLayout   # pylint: disable=no-name-in-module
 from PySide6.QtCore import Slot   # pylint: disable=no-name-in-module
 
 from .widgetDocTypes import DocTypes
 from .widgetProject import Project
+from .communicate import Communicate
 
 class Body(QWidget):
   """ Central widget: everything that is not sidebar: switches between project-view and table-details """
-  def __init__(self, comm):
+  def __init__(self, comm:Communicate):
     super().__init__()
     self.comm = comm
     comm.changeTable.connect(self.changeTable)
     comm.changeProject.connect(self.changeProject)
     self.docTypes = DocTypes(comm)
     self.project  = Project(comm)
     self.project.hide()
     mainL = QVBoxLayout()
+    mainL.setSpacing(0)
+    mainL.setContentsMargins(0, 0, 0, 0)
     mainL.addWidget(self.docTypes)
     mainL.addWidget(self.project)
     self.setLayout(mainL)
 
 
   @Slot(str)
-  def changeTable(self, docType, projID):
+  def changeTable(self, docType:str, projID:str) -> None:
     """
     What happens when user clicks to change doc-type
     -> show table
 
     Args:
       docType (str): document type
       projID (str): project ID for filtering
     """
     self.project.hide()
     self.docTypes.show()
+    return
 
 
   @Slot(str)
-  def changeProject(self, docID):
+  def changeProject(self, docID:str) -> None:
     """
     What happens when user clicks to change project
 
     Args:
       docID (str): document id
     """
     self.docTypes.hide()
     self.project.show()
+    return
```

## pasta_eln/widgetDetails.py

```diff
@@ -1,211 +1,275 @@
 """ widget that shows the details of the items """
-import json
 from pathlib import Path
-from PySide6.QtWidgets import QScrollArea, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QMenu, QTextEdit  # pylint: disable=no-name-in-module
-from PySide6.QtCore import Qt, Slot, QByteArray   # pylint: disable=no-name-in-module
-from PySide6.QtSvgWidgets import QSvgWidget       # pylint: disable=no-name-in-module
-from PySide6.QtGui import QPixmap, QImage, QAction# pylint: disable=no-name-in-module
-from .style import TextButton, Image, Label, Action, showMessage
+import platform, subprocess, os, base64, logging
+from typing import Any
+import yaml
+from PySide6.QtWidgets import QScrollArea, QLabel, QMenu, QTextEdit  # pylint: disable=no-name-in-module
+from PySide6.QtCore import Qt, Slot, QPoint  # pylint: disable=no-name-in-module
+from PySide6.QtGui import QTextDocument  # pylint: disable=no-name-in-module
+from .style import TextButton, Image, Label, Action, showMessage, widgetAndLayout
+from .fixedStrings import defaultOntologyNode
+from .communicate import Communicate
 
 class Details(QScrollArea):
   """ widget that shows the details of the items """
-  def __init__(self, comm):
+  def __init__(self, comm:Communicate):
     super().__init__()
     self.comm = comm
     comm.changeDetails.connect(self.changeDetails)
     comm.testExtractor.connect(self.testExtractor)
-    self.doc  = {}
+    self.doc:dict[str,Any]  = {}
     self.docID= ''
 
     # GUI elements
-    self.mainW = QWidget()
-    self.mainL = QVBoxLayout(self.mainW)
+    self.mainW, self.mainL = widgetAndLayout('V', None)
     self.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
     self.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
     self.setWidgetResizable(True)
     self.setWidget(self.mainW)
 
-    headerW = QWidget()
-    self.headerL = QHBoxLayout(headerW)
-    self.mainL.addWidget(headerW)
-    self.specialW = QWidget()
-    self.specialW.setMaximumWidth(self.width())
+    _, self.headerL = widgetAndLayout('H', self.mainL, top='s')
+    self.specialW, self.specialL = widgetAndLayout('V', self.mainL, top='s')
     self.specialW.setContextMenuPolicy(Qt.CustomContextMenu)
     self.specialW.customContextMenuRequested.connect(self.contextMenu)
-    self.specialL = QVBoxLayout(self.specialW)
-    self.mainL.addWidget(self.specialW)
     self.btnDetails = TextButton('Details', self.showArea, self.mainL, 'Details', 'Show / hide details', \
-                                  checkable=True, hide=True)
-    self.metaDetailsW  = QWidget()
+                                  checkable=True, style='margin-top: 3px')
+    self.metaDetailsW, self.metaDetailsL  = widgetAndLayout('V', self.mainL)
     self.metaDetailsW.setMaximumWidth(self.width())
-    self.metaDetailsL = QVBoxLayout(self.metaDetailsW)
-    self.mainL.addWidget(self.metaDetailsW)
     self.btnVendor = TextButton('Vendor metadata', self.showArea, self.mainL, 'Vendor', \
-      'Show / hide vendor metadata', checkable=True, hide=True, style="margin-top: 15px")
-    self.metaVendorW   = QWidget()
+      'Show / hide vendor metadata', checkable=True, style="margin-top: 15px")
+    self.metaVendorW, self.metaVendorL = widgetAndLayout('V', self.mainL)
     self.metaVendorW.setMaximumWidth(self.width())
-    self.metaVendorL = QVBoxLayout(self.metaVendorW)
-    self.mainL.addWidget(self.metaVendorW)
     self.btnUser = TextButton('User metadata', self.showArea, self.mainL, 'User', 'Show / hide user metadata',\
-      checkable=True, hide=True, style="margin-top: 15px")
-    self.metaUserW     = QWidget()
+      checkable=True, style="margin-top: 15px")
+    self.metaUserW, self.metaUserL     = widgetAndLayout('V', self.mainL)
     self.metaUserW.setMaximumWidth(self.width())
-    self.metaUserL = QVBoxLayout(self.metaUserW)
-    self.mainL.addWidget(self.metaUserW)
     self.btnDatabase = TextButton('Database details', self.showArea, self.mainL, 'Database', \
-      'Show / hide database details', checkable= True, hide=True, style="margin-top: 15px")
-    self.metaDatabaseW = QWidget()
+      'Show / hide database details', checkable= True, style="margin-top: 15px")
+    self.metaDatabaseW, self.metaDatabaseL = widgetAndLayout('V', self.mainL)
     self.metaDatabaseW.setMaximumWidth(self.width())
-    self.metaDatabaseL = QVBoxLayout(self.metaDatabaseW)
-    self.mainL.addWidget(self.metaDatabaseW)
     self.mainL.addStretch(1)
 
 
-  def contextMenu(self, pos):
+  def contextMenu(self, pos:QPoint) -> None:
     """
     Create a context menu
 
     Args:
       pos (position): Position to create context menu at
     """
+    extractors = self.comm.backend.configuration['extractors']
+    extension = Path(self.doc['-branch'][0]['path']).suffix[1:]
+    extractors = extractors[extension]
+    baseDocType= self.doc['-type'][0]
+    choices= {key:value for key,value in extractors.items() \
+                if key.startswith(baseDocType)}
     context = QMenu(self)
-    mask   = '/'.join(self.doc['-type'][:3])
-    choices= {key:value for key,value in self.comm.backend.configuration['extractors'].items() \
-                if key.startswith(mask)}
     for key,value in choices.items():
       Action(value, self.changeExtractor, context, self, name=key)
+    context.addSeparator()
+    Action('Open folder in file browser', self.changeExtractor, context, self, name='_openInFileBrowser_')
+    Action('Save as image',               self.changeExtractor, context, self, name='_saveAsImage_')
     context.exec(self.mapToGlobal(pos))
     return
 
-
-  def changeExtractor(self):
+  def changeExtractor(self) -> None:
     """
     What happens when user changes extractor
     """
-    self.doc['-type'] = self.sender().data().split('/')
-    self.comm.backend.useExtractors(Path(self.doc['-branch'][0]['path']), self.doc['shasum'], self.doc, \
-      extractorRedo=True)  #any path is good since the file is the same everywhere; data-changed by reference
-    if len(self.doc['-type'])>1 and len(self.doc['image'])>1:
-      self.doc = self.comm.backend.db.updateDoc({'image':self.doc['image'], '-type':self.doc['-type']}, self.doc['_id'])
-      self.comm.changeTable.emit('','')
-      self.comm.changeDetails.emit(self.doc['_id'])
+    filePath = Path(self.doc['-branch'][0]['path'])
+    if self.sender().data()=='_openInFileBrowser_':
+      filePath = self.comm.backend.basePath/filePath
+      if platform.system() == 'Darwin':       # macOS
+        subprocess.call(('open', filePath.parent))
+      elif platform.system() == 'Windows':    # Windows
+        os.startfile(filePath.parent) # type: ignore[attr-defined]
+      else:                                   # linux variants
+        subprocess.call(('xdg-open', filePath.parent))
+    elif self.sender().data()=='_saveAsImage_':
+      image = self.doc['image']
+      if image.startswith('data:image/'):
+        imageType = image[11:14] if image[14]==';' else image[11:15]
+        image = image[22:] if image[21]==',' else image[23:]
+      else:
+        imageType = 'svg'
+      saveFilePath = filePath.parent/(filePath.stem+'_PastaExport.'+imageType.lower())
+      if imageType == 'svg':
+        with open(self.comm.backend.basePath/saveFilePath,'w', encoding='utf-8') as fOut:
+          fOut.write(image)
+      else:
+        with open(self.comm.backend.basePath/saveFilePath, "wb") as fOut:
+          fOut.write(base64.decodebytes(image.encode('utf-8')))
+    else:
+      self.doc['-type'] = self.sender().data().split('/')
+      self.comm.backend.useExtractors(filePath, self.doc['shasum'], self.doc)  #any path is good since the file is the same everywhere; data-changed by reference
+      if len(self.doc['-type'])>1 and len(self.doc['image'])>1:
+        self.doc = self.comm.backend.db.updateDoc({'image':self.doc['image'], '-type':self.doc['-type']}, self.doc['_id'])
+        self.comm.changeTable.emit('','')
+        self.comm.changeDetails.emit(self.doc['_id'])
     return
 
   @Slot()
-  def testExtractor(self):
+  def testExtractor(self) -> None:
     """
     User selects to test extractor on this dataset
     """
+    logging.debug('details:testExtractor')
     if len(self.doc)>1:
       path = Path(self.doc['-branch'][0]['path'])
       if not path.as_posix().startswith('http'):
         path = self.comm.backend.basePath/path
-      report = self.comm.backend.testExtractor(path, reportHTML=True)
+      report = self.comm.backend.testExtractor(path, outputStyle='html', recipe='/'.join(self.doc['-type']))
       showMessage(self, 'Report of extractor test', report, style='QLabel {min-width: 800px}')
     return
 
 
   @Slot(str)
-  def changeDetails(self, docID):
+  def changeDetails(self, docID:str) -> None:
     """
     What happens when details should change
 
     Args:
-      docID (str): document-id; 'empty' string=draw nothing; 'redraw' implies redraw
+      docID (str): document-id; '' string=draw nothing; 'redraw' implies redraw
     """
-    # show previously hidden buttons
-    if docID=='empty':
-      self.btnDetails.show()
-      self.btnVendor.show()
-      self.btnUser.show()
-      self.btnDatabase.show()
-    else:
-      self.btnDetails.show()
-      self.btnVendor.show()
-      self.btnUser.show()
-      self.btnDatabase.show()
+    logging.debug('details:changeDetails |'+docID+'|')
     # Delete old widgets from layout
     for i in reversed(range(self.headerL.count())):
-      self.headerL.itemAt(i).widget().setParent(None)
+      self.headerL.itemAt(i).widget().setParent(None)       # type: ignore
     for i in reversed(range(self.metaDetailsL.count())):
-      self.metaDetailsL.itemAt(i).widget().setParent(None)
+      self.metaDetailsL.itemAt(i).widget().setParent(None)  # type: ignore
     if self.metaVendorL.itemAt(0) is not None:
-      self.metaVendorL.itemAt(0).widget().setParent(None)
+      self.metaVendorL.itemAt(0).widget().setParent(None)   # type: ignore
     if self.metaUserL.itemAt(0) is not None:
-      self.metaUserL.itemAt(0).widget().setParent(None)
+      self.metaUserL.itemAt(0).widget().setParent(None)     # type: ignore
     for i in reversed(range(self.metaDatabaseL.count())):
-      self.metaDatabaseL.itemAt(i).widget().setParent(None)
+      self.metaDatabaseL.itemAt(i).widget().setParent(None) # type: ignore
     if self.specialL.itemAt(0) is not None:
-      self.specialL.itemAt(0).widget().setParent(None)
+      self.specialL.itemAt(0).widget().setParent(None)      # type: ignore
     self.specialW.hide()
     self.metaDetailsW.hide()
     self.metaVendorW.hide()
     self.metaUserW.hide()
     self.metaDatabaseW.hide()
-    if docID=='empty':  #if given empty docID, return with empty content
+    if docID=='':  #if given '' docID, return
       return
     # Create new
     if docID!='redraw':
       self.docID = docID
+    if self.docID=='':
+      return
     self.doc   = self.comm.backend.db.getDoc(self.docID)
-    Label(self.doc['-name'],'h1', self.headerL)
-    TextButton('Edit',self.callEdit, self.headerL)
+    if '-name' not in self.doc:  #keep empty details and wait for user to click
+      self.comm.changeTable.emit('','')
+      return
+    if self.doc['-type'][0]=='-':
+      ontologyNode = defaultOntologyNode
+    else:
+      ontologyNode = self.comm.backend.db.ontology[self.doc['-type'][0]]['prop']
+    label = self.doc['-name'] if len(self.doc['-name'])<80 else self.doc['-name'][:77]+'...'
+    Label(label,'h1', self.headerL)
+    if 'metaVendor' not in self.doc:
+      self.btnVendor.hide()
+    if 'metUser' not in self.doc:
+      self.btnUser.hide()
     for key in self.doc:
+      size = self.comm.backend.configuration['GUI']['imageSizeDetails'] \
+              if hasattr(self.comm.backend, 'configuration') else 300
       if key=='image':
-        width = self.comm.backend.configuration['GUI']['imageWidthDetails'] \
-                if hasattr(self.comm.backend, 'configuration') else 300
-        Image(self.doc['image'], self.specialL, width=width)
+        Image(self.doc['image'], self.specialL, anyDimension=size)
         self.specialW.show()
       elif key=='content':
         text = QTextEdit()
         text.setMarkdown(self.doc['content'])
+        text.setFixedHeight(int(size/3*2))
         text.setReadOnly(True)
         self.specialL.addWidget(text)
         self.specialW.show()
       elif key=='-tags':
-        tags = ['cur\u2605ted' if i=='_curated' else '#'+i for i in self.doc[key]]
+        tags = ['_curated_' if i=='_curated' else '#'+i for i in self.doc[key]]
         tags = ['\u2605'*int(i[2]) if i[:2]=='#_' else i for i in tags]
-        self.metaDetailsL.addWidget( QLabel('Tags: '+' '.join(tags)))
-      elif key.startswith('_') or key.startswith('-'):
+        label = QLabel('Tags: '+' '.join(tags))
+        label.setTextInteractionFlags(Qt.TextSelectableByMouse)
+        self.metaDetailsL.addWidget(label)
+      elif key[0] in ['_','-'] or key in ['shasum']:
+        if key in ['_attachments']:
+          continue
         label = QLabel(key+': '+str(self.doc[key]))
         label.setWordWrap(True)
+        label.setTextInteractionFlags(Qt.TextSelectableByMouse)
         self.metaDatabaseL.addWidget(label)
         self.btnDatabase.setChecked(False)
       elif key=='metaVendor':
+        self.btnVendor.show()
         label = QLabel()
         label.setWordWrap(True)
-        label.setText(json.dumps(self.doc[key], indent=2)[2:-2].replace('"','')) #remove initial+trailing defaults
+        label.setText(yaml.dump(self.doc[key], indent=4))
+        label.setTextInteractionFlags(Qt.TextSelectableByMouse)
         self.metaVendorL.addWidget(label)
         self.metaVendorW.show()
       elif key=='metaUser':
+        self.btnUser.show()
         label = QLabel()
         label.setWordWrap(True)
-        label.setText(json.dumps(self.doc[key], indent=2)[2:-2].replace('"','')) #remove initial+trailing defaults
+        label.setText(yaml.dump(self.doc[key], indent=4))
+        label.setTextInteractionFlags(Qt.TextSelectableByMouse)
         self.metaUserL.addWidget(label)
         self.metaUserW.show()
       else:
-        self.metaDetailsL.addWidget( QLabel(key.capitalize()+': '+str(self.doc[key])) )
+        link = False
+        ontologyItem = [i for i in ontologyNode if i['name']==key]
+        if len(ontologyItem)==1 and 'list' in ontologyItem[0]:
+          if not isinstance(ontologyItem[0]['list'], list):                #choice among docType
+            table  = self.comm.backend.db.getView('viewDocType/'+ontologyItem[0]['list'])
+            choices= [i for i in table if i['id']==self.doc[key]]
+            if len(choices)==1:
+              value = '\u260D '+choices[0]['value'][0]
+              link = True
+        elif isinstance(self.doc[key], list):
+          value = ', '.join(self.doc[key])
+        elif '\n' in self.doc[key]:     #if returns in value
+          value = '\n    '+self.doc[key].replace('\n','\n    ')
+        else:
+          value = self.doc[key]
+        label = Label(key.capitalize()+': '+value, function=self.clickLink if link else None, docID=self.doc[key])
+        label.setTextInteractionFlags(Qt.TextSelectableByMouse)
+        self.metaDetailsL.addWidget(label)
         self.metaDetailsW.show()
     return
 
 
-
-  def showArea(self):
+  def showArea(self) -> None:
     """
     Hide / show the widget underneath the button
     """
     name = self.sender().accessibleName()
     if getattr(self, 'btn'+name).isChecked(): #get button in question
       getattr(self, 'meta'+name+'W').show()
     else:
       getattr(self, 'meta'+name+'W').hide()
     return
 
-  def callEdit(self):
+
+  def callEdit(self) -> None:
     """
     Call edit dialoge
     """
-    self.comm.formDoc.emit(self.doc)
-    self.comm.changeTable.emit('','')
-    self.comm.changeDetails.emit('redraw')
+    if self.doc['-type'][0][0]=='x':
+      showMessage(self, 'Information','Cannot change project hierarchy here.')
+    else:
+      self.comm.formDoc.emit(self.doc)
+      self.comm.changeTable.emit('','')
+      self.comm.changeDetails.emit('redraw')
+    return
+
+
+  def clickLink(self, label:str, docID:str) -> None:
+    """
+    Click link in details
+
+    Args:
+      label (str): label on link
+      docID (str): docID to which to link
+    """
+    logging.debug('used link on '+label+'|'+docID)
+    self.comm.changeDetails.emit(docID)
     return
```

## pasta_eln/widgetDocTypes.py

```diff
@@ -1,41 +1,58 @@
 """ widget that shows the table and the details of the items """
-
+import logging
 from random import randint
 from PySide6.QtCore import Slot                                                     # pylint: disable=no-name-in-module
 from PySide6.QtWidgets import QWidget, QSplitter, QVBoxLayout, QLabel, QScrollArea  # pylint: disable=no-name-in-module
 from .widgetTable import Table
 from .widgetDetails import Details
+from .communicate import Communicate
 
 class DocTypes(QWidget):
   """ widget that shows the table and the details of the items """
-  def __init__(self, comm):
+  def __init__(self, comm:Communicate):
     super().__init__()
     comm.changeTable.connect(self.changeTable)
+    comm.changeDetails.connect(self.changeDetails)
 
     # GUI elements
     table = Table(comm)
     self.details = Details(comm)
     splitter = QSplitter()
     splitter.setHandleWidth(10)
     splitter.addWidget(table)
     splitter.addWidget(self.details)
+    splitter.setContentsMargins(0,0,0,0)
     splitter.setSizes([1,1])
-    mainLayout = QVBoxLayout()
-    mainLayout.addWidget(splitter)
-    self.setLayout(mainLayout)
+    mainL = QVBoxLayout()
+    mainL.setSpacing(0)
+    mainL.setContentsMargins(0, 0, 0, 0)
+    mainL.addWidget(splitter)
+    self.setLayout(mainL)
 
 
   @Slot(str, str)
-  def changeTable(self, docType, projID):
+  def changeTable(self, docType:str, projID:str) -> None:
     """
     What happens when user clicks to change doc-type
     -> show table
 
     Args:
       docType (str): document type
       projID (str): project ID for filtering
     """
-    if docType=='x0':
-      self.details.hide()
-    else:
+    self.details.hide()
+    return
+
+
+  @Slot(str)
+  def changeDetails(self, docID:str) -> None:
+    """
+    What happens when user clicks to change details
+    -> show show details
+
+    Args:
+      docID (str): document ID
+    """
+    if docID!='':
       self.details.show()
+    return
```

## pasta_eln/widgetProject.py

```diff
@@ -1,106 +1,83 @@
 """ Widget that shows the content of project in a electronic labnotebook """
 import logging
-from pathlib import Path
-from PySide6.QtWidgets import QLabel, QVBoxLayout, QHBoxLayout, QWidget, QStyledItemDelegate, QAbstractItemView, \
-                              QMenu, QMessageBox # pylint: disable=no-name-in-module
+from typing import Optional, Any
+from PySide6.QtWidgets import QLabel, QVBoxLayout, QWidget, QMenu, QMessageBox # pylint: disable=no-name-in-module
 from PySide6.QtGui import QStandardItemModel, QStandardItem    # pylint: disable=no-name-in-module
-from PySide6.QtCore import Slot, Qt, QItemSelectionModel      # pylint: disable=no-name-in-module
-from anytree import PreOrderIter
-from .widgetProjectLeafRenderer import ProjectLeafRenderer
+from PySide6.QtCore import Slot, Qt, QItemSelectionModel, QModelIndex # pylint: disable=no-name-in-module
+from anytree import PreOrderIter, Node
 from .widgetProjectTreeView import TreeView
-from .style import TextButton, Action, showMessage
+from .style import TextButton, Action, Label, showMessage, widgetAndLayout
 from .miscTools import createDirName
-
+from .communicate import Communicate
 
 class Project(QWidget):
   """ Widget that shows the content of project in a electronic labnotebook """
-  def __init__(self, comm):
+  def __init__(self, comm:Communicate):
     super().__init__()
     self.comm = comm
     comm.changeProject.connect(self.changeProject)
     self.mainL = QVBoxLayout()
     self.setLayout(self.mainL)
-    self.tree   = None
-    self.model  = None
-    self.bodyW  = None
+    self.tree:Optional[TreeView]             = None
+    self.model:Optional[QStandardItemModel]  = None
+    self.bodyW:Optional[QWidget]             = None
     self.projID = ''
     self.taskID = ''
-    self.docProj= {}
+    self.docProj:dict[str,Any]= {}
     self.showAll= False
+    self.foldedAll = False
+    self.btnAddSubfolder:Optional[TextButton] = None
+    self.btnHideShow:Optional[TextButton]     = None
 
 
-  @Slot(str)
-  def changeProject(self, projID, docID):
+  @Slot(str, str)
+  def changeProject(self, projID:str, docID:str) -> None:
     """
     What happens when user clicks to change doc-type
 
     Args:
       projID (str): document id of project; if empty, just refresh
       docID (str): document id of focus item, if not given focus at project
     """
+    logging.debug('project:changeProject |'+projID+'|'+docID+'|')
     #initialize
     for i in reversed(range(self.mainL.count())): #remove old
-      self.mainL.itemAt(i).widget().setParent(None)
+      self.mainL.itemAt(i).widget().setParent(None)  # type: ignore
     if projID!='':
       self.projID = projID
       self.taskID = docID
     selectedIndex = None
     self.model = QStandardItemModel()
     self.tree = TreeView(self, self.comm, self.model)
     # self.tree.setSelectionBehavior(QAbstractItemView.SelectRows)
     # self.tree.setSelectionMode(QAbstractItemView.SingleSelection)
     self.model.itemChanged.connect(self.modelChanged)
     rootItem = self.model.invisibleRootItem()
-
-    def iterateTree(nodeHier):
-      """
-      Recursive function to translate the hierarchical node into a tree-node
-
-      Args:
-        nodeHier (Anytree.Node): anytree node
-
-      Returns:
-        QtTreeWidgetItem: tree node
-      """
-      #prefill docID
-      label = '/'.join([i.id for i in nodeHier.ancestors]+[nodeHier.id])
-      nodeTree = QStandardItem(label)  #nodeHier.name,'/'.join(nodeHier.docType),nodeHier.id])
-      if nodeHier.id[0]=='x':
-        nodeTree.setFlags(Qt.ItemIsEnabled | Qt.ItemIsSelectable | Qt.ItemIsDragEnabled | Qt.ItemIsDropEnabled)
-      else:
-        nodeTree.setFlags(Qt.ItemIsEnabled | Qt.ItemIsSelectable | Qt.ItemIsDragEnabled)
-      if self.taskID==nodeHier.id:
-        nonlocal selectedIndex
-        selectedIndex = nodeTree.index()
-      children = []
-      for childHier in nodeHier.children:
-        childTree = iterateTree(childHier)
-        children.append(childTree)
-      if len(children)>0:
-        nodeTree.appendRows(children)
-      return nodeTree
-
     #Populate model body of change project: start recursion
     nodeHier = self.comm.backend.db.getHierarchy(self.projID, allItems=self.showAll)
     for node in PreOrderIter(nodeHier, maxlevel=2):
       if node.is_root:         #Project header
         self.projHeader()
       else:
-        rootItem.appendRow(iterateTree(node))
-    self.tree.expandAll()
+        rootItem.appendRow(self.iterateTree(node))
+    # self.tree.expandAll()
     if selectedIndex is not None:
       self.tree.selectionModel().select(selectedIndex, QItemSelectionModel.Select)
-      #TODO_P3 convenience: selection does not scroll; one cannot select a row
+      #TODO_P3 projectView: selection does not scroll; one cannot select a row
       self.tree.setCurrentIndex(selectedIndex)# Item(selectedItem)
     self.mainL.addWidget(self.tree)
+    if len(nodeHier.children)>0 and self.btnAddSubfolder is not None:
+      self.btnAddSubfolder.setVisible(False)
+    elif self.btnHideShow is not None:
+      self.btnHideShow.setVisible(False)
     return
 
 
-  def modelChanged(self, item):
+  def modelChanged(self, item:QStandardItem) -> None:
     """
     After drag-drop, record changes to backend and database directly
 
     Args:
       item (QStandardItem): item changed, new location
     """
     #gather old information
@@ -111,107 +88,89 @@
       docID = docID[:-2]
     doc      = db.getDoc(docID)
     branchOld= [i for i in doc['-branch'] if i['stack']==stackOld][0]
     childOld = branchOld['child']
     branchIdx= doc['-branch'].index(branchOld)
     siblingsOld = db.getView('viewHierarchy/viewHierarchy', startKey=' '.join(stackOld))
     siblingsOld = [i for i in siblingsOld if len(i['key'].split(' '))==len(stackOld)+1 and \
-                                            i['value'][0]>branchOld['child']]
-    logging.debug('OLD INFORMATION '+docID+' '+str(stackOld)+'  '+str(branchIdx))
+                                            i['value'][0]>branchOld['child'] and i['value'][0]<9999]
     #gather new information
     stackNew = []  #create reversed
     currentItem = item
     while currentItem.parent() is not None:
       currentItem = currentItem.parent()
-      stackNew.append(currentItem.text().split('/')[-1])
+      docIDj = currentItem.text().split('/')[-1]
+      stackNew.append(docIDj[:-2] if docIDj.endswith(' -') else docIDj)
     stackNew = [self.projID] + stackNew[::-1]  #add project id and reverse
     childNew = item.row()
     dirNameNew= createDirName(doc['-name'],doc['-type'][0],childNew)
     parentDir = db.getDoc(stackNew[-1])['-branch'][0]['path']
     pathNew  = parentDir+'/'+dirNameNew
     siblingsNew = db.getView('viewHierarchy/viewHierarchy', startKey=' '.join(stackNew))
     siblingsNew = [i for i in siblingsNew if len(i['key'].split(' '))==len(stackNew)+1 and \
-                                             i['value'][0]>=childNew]
-    logging.debug('NEW INFORMATION '+docID+' '+str(stackNew)+'  '+str(childNew)+' '+pathNew)
+                                             i['value'][0]>=childNew and i['value'][0]<9999]
+    logging.debug('Change project: docID -old- -new- '+docID+' | '+str(stackOld)+'  '+str(branchIdx)+' | '+str(stackNew)+' '+str(childNew)+' '+pathNew)
     if stackOld==stackNew and childOld==childNew:  #nothing changed, just redraw
       return
+    # change item in question
+    db.updateBranch(docID=docID, branch=branchIdx, stack=stackNew, path=pathNew, child=childNew)
+    item.setText('/'.join(stackNew+[docID]))     #update item.text() to new stack
     # change siblings
     for line in siblingsOld:
-      if line['value'][0]<9999:
-        pathOldSib, pathNewSib = db.updateBranch(docID=line['id'], branch=line['value'][3], child=line['value'][0]-1)
-        (Path(self.comm.backend.basePath)/pathOldSib).rename(Path(self.comm.backend.basePath)/pathNewSib)
+      db.updateBranch(docID=line['id'], branch=line['value'][3], child=line['value'][0]-1)
     for line in siblingsNew:
-      if line['value'][0]<9999:
-        pathOldSib, pathNewSib = db.updateBranch(docID=line['id'], branch=line['value'][3], child=line['value'][0]+1)
-        (Path(self.comm.backend.basePath)/pathOldSib).rename(Path(self.comm.backend.basePath)/pathNewSib)
-    #change item in question
-    pathOld = Path(self.comm.backend.basePath)/branchOld['path']
-    if pathOld.exists():
-      pathOld.rename(Path(self.comm.backend.basePath)/pathNew)
-    db.updateBranch(docID=docID, branch=branchIdx, stack=stackNew, path=pathNew, child=childNew)
-    item.setText('/'.join(stackNew+[docID]))     #update item.text() to new stack
-    return
-
-
-  def btnEvent(self):
-    """ Click button on top of project page """
-    btnName = self.sender().accessibleName()
-    if btnName == 'projHide':
-      if self.bodyW.isHidden():
-        self.bodyW.show()
-      else:
-        self.bodyW.hide()
-    elif btnName == 'hideShow':
-      self.showAll = not self.showAll
-      self.changeProject('','')
-    elif btnName == 'addChild':
-      self.comm.backend.cwd = Path(self.comm.backend.basePath)/self.docProj['-branch'][0]['path']
-      self.comm.backend.addData('x1', {'-name':'folder 1', 'childNum':0}, [self.projID])
-      self.comm.changeProject.emit('','') #refresh project
+      if line['id']!=docID:
+        db.updateBranch(docID=line['id'], branch=line['value'][3], child=line['value'][0]+1)
     return
 
 
-  def projHeader(self):
+  def projHeader(self) -> None:
     """
     Create header of page
     """
     self.docProj = self.comm.backend.db.getDoc(self.projID)
-    headerW = QWidget()  # Leaf(self.comm, node.id)
-    headerL = QVBoxLayout(headerW)
-    topbarW = QWidget()
-    topbarL = QHBoxLayout(topbarW)
-    hidden = '     \U0001F441' if len([b for b in self.docProj['-branch'] if False in b['show']])>0 else ''
-    topbarL.addWidget(QLabel(self.docProj['-name']+hidden))
-    TextButton('Reduce',    self.btnEvent, topbarL, 'projHide', checkable=True)
-    TextButton('Hide/Show', self.btnEvent, topbarL, 'hideShow')
-    TextButton('Add child', self.btnEvent, topbarL, 'addChild')
-    more = TextButton('More',None, topbarL)
+    _, headerL       = widgetAndLayout('H',self.mainL)
+    _, infoL         = widgetAndLayout('V', headerL)
+    buttonW, buttonL = widgetAndLayout('H', spacing='m')
+    headerL.addStretch(1)
+    headerL.addWidget(buttonW, alignment=Qt.AlignTop)  # type: ignore
+
+    self.btnHideShow     = TextButton('Hide/Show',     self.executeAction, buttonL, name='hideShow')
+    self.btnAddSubfolder = TextButton('Add subfolder', self.executeAction, buttonL, name='addChild')
+    TextButton('Edit project',      self.executeAction, buttonL, name='editProject')
+    more = TextButton('More',None, buttonL)
     moreMenu = QMenu(self)
-    Action('Scan',   self.executeAction, moreMenu, self, name='scanProject')
-    Action('Edit',   self.executeAction, moreMenu, self, name='editProject')
-    Action('Delete', self.executeAction, moreMenu, self, name='deleteProject')
+    Action('Reduce/increase width', self.executeAction, moreMenu, self, name='projReduceWidth')
+    Action('Hide/show project',     self.executeAction, moreMenu, self, name='projHideShow')
+    Action('Minimize/Maximize all', self.executeAction, moreMenu, self, name='allFold')
+    Action('Scan',                  self.executeAction, moreMenu, self, name='scanProject')
+    Action('Delete',                self.executeAction, moreMenu, self, name='deleteProject')
     more.setMenu(moreMenu)
 
-    headerL.addWidget(topbarW)
-    self.bodyW   = QWidget()
-    bodyL   = QVBoxLayout(self.bodyW)
+    self.bodyW, bodyL =  widgetAndLayout('V')
+    hidden = '     \U0001F441' if len([b for b in self.docProj['-branch'] if False in b['show']])>0 else ''
+    infoL.addWidget(Label(self.docProj['-name']+hidden, 'h2'))
     tags = ', '.join(self.docProj['tags']) if 'tags' in self.docProj else ''
     bodyL.addWidget(QLabel('Tags: '+tags))
     for key,value in self.docProj.items():
       if key[0] in ['_','-']:
         continue
       bodyL.addWidget(QLabel(key+': '+str(value)))
-    headerL.addWidget(self.bodyW)
-    self.mainL.addWidget(headerW)
+    infoL.addWidget(self.bodyW)
     return
 
 
-  def executeAction(self):
+  #TODO_P4 projectTree: select multiple items to edit... What is use case
+  #TODO_P4 projectTree: allow right click on measurement to change recipe
+  def executeAction(self) -> None:
     """ Any action by the buttons at the top of the page """
-    menuName = self.sender().data()
+    if hasattr(self.sender(), 'data'):  #action
+      menuName = self.sender().data()
+    else:                               #button
+      menuName = self.sender().accessibleName()
     if menuName=='editProject':
       self.comm.formDoc.emit(self.docProj)
       self.comm.changeProject.emit(self.projID,'')
       #collect information and then change
       oldPath = self.comm.backend.basePath/self.docProj['-branch'][0]['path']
       if oldPath.exists():
         newPath = self.comm.backend.basePath/createDirName(self.docProj['-name'],'x0',0)
@@ -223,16 +182,71 @@
         #delete database and rename folder
         doc = self.comm.backend.db.remove(self.projID)
         if '-branch' in doc and len(doc['-branch'])>0 and 'path' in doc['-branch'][0]:
           oldPath = self.comm.backend.basePath/doc['-branch'][0]['path']
           newPath = self.comm.backend.basePath/('trash_'+doc['-branch'][0]['path'])
           oldPath.rename(newPath)
         #update sidebar, show projects
-        self.comm.changeSidebar.emit()
+        self.comm.changeSidebar.emit('redraw')
         self.comm.changeTable.emit('x0','')
     elif menuName == 'scanProject':
-      self.comm.backend.scanProject(self.projID, self.docProj['-branch'][0]['path'])
-      self.comm.changeProject.emit(self.projID,'')
+      self.comm.backend.scanProject(self.comm.progressBar, self.projID, self.docProj['-branch'][0]['path'])
+      self.comm.changeSidebar.emit('redraw')
       showMessage(self, 'Information','Scanning finished')
+    elif menuName == 'projReduceWidth':
+      if self.bodyW is not None and self.bodyW.isHidden():
+        self.bodyW.show()
+      elif self.bodyW is not None:
+        self.bodyW.hide()
+    elif menuName == 'projHideShow':
+      self.comm.backend.db.hideShow(self.projID)
+      self.comm.changeProject.emit('','') #refresh project
+    elif menuName == 'allFold' and self.tree is not None:
+      self.foldedAll = not self.foldedAll
+      def recursiveRowIteration(index:QModelIndex) -> None:
+        if self.tree is not None:
+          for subRow in range(self.tree.model().rowCount(index)):
+            subIndex = self.tree.model().index(subRow,0, index)
+            subItem  = self.tree.model().itemFromIndex(subIndex)
+            if self.foldedAll:
+              subItem.setText(subItem.text()+' -')
+            elif subItem.text().endswith(' -'):
+              subItem.setText(subItem.text()[:-2])
+            recursiveRowIteration(subIndex)
+        return
+      recursiveRowIteration(self.tree.model().index(-1,0))
+    elif menuName == 'hideShow':
+      self.showAll = not self.showAll
+      self.changeProject('','')
+    elif menuName == 'addChild':
+      self.comm.backend.cwd = self.comm.backend.basePath/self.docProj['-branch'][0]['path']
+      self.comm.backend.addData('x1', {'-name':'new folder'}, [self.projID])
+      self.comm.changeProject.emit('','') #refresh project
     else:
       print("undefined menu / action",menuName)
     return
+
+
+  def iterateTree(self, nodeHier:Node) -> QStandardItem:
+    """
+    Recursive function to translate the hierarchical node into a tree-node
+
+    Args:
+      nodeHier (Anytree.Node): anytree node
+
+    Returns:
+      QtTreeWidgetItem: tree node
+    """
+    #prefill docID
+    label = '/'.join([i.id for i in nodeHier.ancestors]+[nodeHier.id])
+    nodeTree = QStandardItem(label)  #nodeHier.name,'/'.join(nodeHier.docType),nodeHier.id])
+    if nodeHier.id[0]=='x':
+      nodeTree.setFlags(Qt.ItemIsEnabled | Qt.ItemIsSelectable | Qt.ItemIsDragEnabled | Qt.ItemIsDropEnabled) # type: ignore
+    else:
+      nodeTree.setFlags(Qt.ItemIsEnabled | Qt.ItemIsSelectable | Qt.ItemIsDragEnabled) # type: ignore
+    children = []
+    for childHier in nodeHier.children:
+      childTree = self.iterateTree(childHier)
+      children.append(childTree)
+    if len(children)>0:
+      nodeTree.appendRows(children)
+    return nodeTree
```

## pasta_eln/widgetProjectLeafRenderer.py

```diff
@@ -1,131 +1,185 @@
 """ renders each leaf of project tree using QPaint """
-import base64, logging
-from PySide6.QtCore import Qt, QSize, QPoint, QMargins, QRectF# pylint: disable=no-name-in-module
-from PySide6.QtGui import QStaticText, QPixmap, QTextDocument # pylint: disable=no-name-in-module
-from PySide6.QtWidgets import QStyledItemDelegate             # pylint: disable=no-name-in-module
+import base64, logging, re
+from typing import Optional
+from PySide6.QtCore import Qt, QSize, QPoint, QMargins, QRectF, QModelIndex# pylint: disable=no-name-in-module
+from PySide6.QtGui import QStaticText, QPixmap, QTextDocument, QPainter, QColor, QPen # pylint: disable=no-name-in-module
+from PySide6.QtWidgets import QStyledItemDelegate, QStyleOptionViewItem # pylint: disable=no-name-in-module
 from PySide6.QtSvg import QSvgRenderer                        # pylint: disable=no-name-in-module
+from .communicate import Communicate
+from .style import getColor
 
 _DO_NOT_RENDER_ = ['image','content','metaVendor','metaUser','shasum','comment']
 
 class ProjectLeafRenderer(QStyledItemDelegate):
   """ renders each leaf of project tree using QPaint """
-  def __init__(self):
+  def __init__(self, comm:Communicate) -> None:
     super().__init__()
-    self.lineSep = 20 #TODO_P5 addToConfig
-    self.debugMode = True
-    self.comm = None
-    self.width = -1
-
-
-  def setCommunication(self, comm):
-    """
-    Set communication path
-
-    Args:
-      comm (Communicate): communication path
-    """
     self.comm = comm
-    self.width = self.comm.backend.configuration['GUI']['imageWidthProject']
-    return
-
-
-  def paint(self, painter, option, index):
+    self.debugMode = logging.root.level<logging.INFO
+    self.widthImage = self.comm.backend.configuration['GUI']['imageWidthProject']
+    self.widthContent = 600   #TODO_P4 from config file
+    self.lineSep = 20
+    self.frameSize = 6
+    self.maxHeight = 300
+    self.penDefault:Optional[QPen] = None
+    self.penHighlight              = QPen(QColor(getColor(self.comm.backend, 'primary')))
+    self.penHighlight.setWidth(2)
+    self.colorMargin1 = QColor(getColor(self.comm.backend, 'secondary')).darker(110)
+    self.colorMargin2 = QColor(getColor(self.comm.backend, 'secondaryLight'))
+
+
+  #TODO_P3 projectTree design: If folders and other items have boxes of slightly different brightness
+  # (darker gray for the former and lighter for the latter), the project structure might be easier to understand. 
+  def paint(self, painter:QPainter, option:QStyleOptionViewItem, index:QModelIndex) -> None:
     """
     Paint this item
     - coordinates: left, top
     - COS top left
 
     Args:
       painter (QPainter): painter
       option (QStyleOptionViewItem): option incl. current coordinates
       index (QModelIndex): index
     """
-    xOffset, yOffset = option.rect.topLeft().toTuple()
-    topLeft2nd = option.rect.topRight()-QPoint(self.width,0)
-    docID   = index.data(Qt.DisplayRole).split('/')[-1]
+    if self.comm is None:
+      return
+    if self.penDefault is None:
+      self.penDefault = QPen(painter.pen())
+    x0, y0 = option.rect.topLeft().toTuple()
+    topLeft2nd     = option.rect.topRight()   - QPoint(self.widthImage+self.frameSize+1,-self.frameSize)
+    bottomRight2nd = option.rect.bottomRight()- QPoint(self.frameSize+1,self.frameSize)
+    painter.fillRect(option.rect.marginsRemoved(QMargins(2,6,4,0)),  self.colorMargin1)
+    painter.fillRect(option.rect.marginsRemoved(QMargins(-2,3,8,5)), self.colorMargin2)
+    hierStack = index.data(Qt.DisplayRole) # type: ignore
+    if hierStack is None:
+      return
+    docID   = hierStack.split('/')[-1]
     if docID.endswith(' -'):
       docID = docID[:-2]
       folded = True
     else:
       folded = False
     doc     = self.comm.backend.db.getDoc(docID)
-    painter.fillRect(option.rect.marginsRemoved(QMargins(0,2,0,2)), Qt.lightGray)
-    if 'image' in doc and doc['image']!='' and not folded:
-      if doc['image'].startswith('data:image/'):
-        pixmap = QPixmap()
-        pixmap.loadFromData(base64.b64decode(doc['image'][22:]))
-        pixmap = pixmap.scaledToWidth(self.width)
-        painter.drawPixmap(topLeft2nd, pixmap)
-      elif doc['image'].startswith('<?xml'):
-        image = QSvgRenderer(bytearray(doc['image'], encoding='utf-8'))
-        image.render(painter,    QRectF(topLeft2nd, option.rect.bottomRight()))
-    elif 'content' in doc and not folded:
-      text = QTextDocument()
-      text.setMarkdown(doc['content'])
-      painter.translate(topLeft2nd)
-      text.drawContents(painter)
-      painter.translate(-topLeft2nd)
-    yOffset += self.lineSep/2
+    # header
+    y = self.lineSep/2
     hiddenText = '     \U0001F441' if len([b for b in doc['-branch'] if False in b['show']])>0 else ''
-    painter.drawStaticText(xOffset, yOffset, QStaticText(doc['-name']+hiddenText))
+    docTypeText= 'folder' if doc['-type'][0][0]=='x' else '/'.join(doc['-type'])
+    nameText = doc['-name'] if len(doc['-name'])<55 else '...'+doc['-name'][-50:]
+    painter.drawStaticText(x0, y0+y, QStaticText(nameText+hiddenText))
+    painter.drawStaticText(x0+400, y0+y, QStaticText(docTypeText))
     if self.debugMode:
-      painter.drawStaticText(xOffset+500, yOffset, QStaticText(index.data(Qt.DisplayRole))) #doc['_id']
+      painter.drawStaticText(x0+700, y0+y, QStaticText(index.data(Qt.DisplayRole)))  # type: ignore
+    if folded:  #stop drawing after first line
+      return
+    # body
+    width, height = -1, -1
     if '-tags' in doc and len(doc['-tags'])>0:
-      yOffset += self.lineSep
-      tags = ['cur\u2605ted' if i=='_curated' else '#'+i for i in doc['-tags']]
+      y += self.lineSep
+      tags = ['_curated_' if i=='_curated' else '#'+i for i in doc['-tags']]
       tags = ['\u2605'*int(i[2]) if i[:2]=='#_' else i for i in tags]
-      painter.drawStaticText(xOffset, yOffset, QStaticText('Tags: '+' '.join(tags)))
+      painter.drawStaticText(x0, y0+y, QStaticText('Tags: '+' '.join(tags)))
     for key in doc:
       if key in _DO_NOT_RENDER_ or key[0] in ['-','_']:
         continue
-      yOffset += self.lineSep
+      y += self.lineSep
       if isinstance(doc[key], str):
-        painter.drawStaticText(xOffset, yOffset, QStaticText(key+': '+doc[key]))
-      else:
-        logging.info('Do not know how to paint: '+docID+': '+str(key))
-    if 'comment' in doc and not folded:
-      text = QTextDocument()
-      text.setMarkdown(doc['comment'].strip())
-      painter.translate(QPoint(xOffset-3, yOffset+15))
-      text.drawContents(painter)
-      painter.translate(-QPoint(xOffset-3, yOffset+15))
+        if re.match(r'^[a-z\-]-[a-z0-9]{32}$',doc[key]) is None:  #normal text
+          value = doc[key]
+        elif self.comm is not None:                           #link
+          table  = self.comm.backend.db.getView('viewDocType/'+key+'All')
+          choices= [i for i in table if i['id']==doc[key]]
+          if len(choices)==1:
+            value = '\u260D '+choices[0]['value'][0]
+          else:
+            value = 'ERROR WITH LINK'
+        painter.drawStaticText(x0, y0+y, QStaticText(key+': '+value))
+      elif isinstance(doc[key], list):                         #list of qrCodes
+        painter.drawStaticText(x0, y0+y, QStaticText(key+': '+', '.join(doc[key])))
+    for textType in ['comment', 'content']:
+      if textType in doc and (textType!='content' or not ('image' in doc and doc['image']!='')):
+        textDoc = QTextDocument()
+        text = doc[textType].replace('\n# ','\n### ').replace('\n## ','\n### ')
+        text = '##'+text if text.startswith('# ') else text
+        textDoc.setMarkdown(text.strip())
+        if textType == 'comment':
+          textDoc.setTextWidth(bottomRight2nd.toTuple()[0]-x0-self.widthContent-2*self.frameSize)
+          width, height = textDoc.size().toTuple() # type: ignore
+          painter.translate(QPoint(x0-3, y0+y+15))
+          yMax = int(self.maxHeight-2*self.frameSize-y-15)
+        else:
+          textDoc.setTextWidth(self.widthContent)
+          width, height = textDoc.size().toTuple() # type: ignore
+          topLeftContent = option.rect.topRight() - QPoint(width+self.frameSize-2,-self.frameSize)
+          painter.translate(topLeftContent)
+          yMax = int(self.maxHeight-3*self.frameSize)
+          y = 0
+        textDoc.drawContents(painter, QRectF(0, 0, width, yMax))
+        if y+height > self.maxHeight-2*self.frameSize:
+          painter.setPen(self.penHighlight)
+          painter.drawLine(self.frameSize, yMax+self.frameSize, width-self.frameSize, yMax+self.frameSize)
+          painter.setPen(self.penDefault)
+        if textType == 'comment':
+          painter.translate(-QPoint(x0-3, y0+y+15))
+        else:
+          topLeftContent = option.rect.topRight() - QPoint(width+self.frameSize-2,-self.frameSize)
+          painter.translate(-topLeftContent)
+    if 'image' in doc and doc['image']!='':
+      if doc['image'].startswith('data:image/'):
+        pixmap = QPixmap()
+        pixmap.loadFromData(base64.b64decode(doc['image'][22:]))
+        pixmap = pixmap.scaledToWidth(self.widthImage)
+        painter.drawPixmap(topLeft2nd, pixmap)
+      elif doc['image'].startswith('<?xml'):
+        image = QSvgRenderer(bytearray(doc['image'], encoding='utf-8'))
+        image.render(painter,    QRectF(topLeft2nd, bottomRight2nd))
     return
 
 
-  def sizeHint(self, option, index):
+  def sizeHint(self, option:QStyleOptionViewItem, index:QModelIndex) -> QSize:
     """
     determine size of this leaf
     """
     if index:
-      docID   = index.data(Qt.DisplayRole).split('/')[-1]
+      hierStack = index.data(Qt.DisplayRole)  # type: ignore
+      if hierStack is None:
+        return QSize()
+      docID   = hierStack.split('/')[-1]
       if docID.endswith(' -'):
-        docID = docID[:-2]
-        folded = True
-      else:
-        folded = False
+        return QSize(400, self.lineSep*2)
+      if self.comm is None:
+        return QSize()
       doc = self.comm.backend.db.getDoc(docID)
       docKeys = doc.keys()
       height  = len([i for i in docKeys if not i in _DO_NOT_RENDER_ and i[0] not in ['-','_'] ])  #height in text lines
+      height += 1 if '-tags' in docKeys and len(doc['-tags'])>0 else 0
       height  = (height+3) * self.lineSep
-      if 'comment' in doc.keys() and not folded:
+      if 'content' in docKeys:
         text = QTextDocument()
-        text.setMarkdown(self.comm.backend.db.getDoc(docID)['comment'].strip())
-        cutOff = 30 if text.size().toTuple()[1]>30 else 10
-        height += text.size().toTuple()[1]-cutOff
-      if 'image' in docKeys and not folded:
+        text.setMarkdown(doc['content'])
+        text.setTextWidth(self.widthContent)
+        height = max(height, text.size().toTuple()[1]) +2*self.frameSize # type: ignore
+      elif 'image' in docKeys:
         if doc['image'].startswith('data:image/'):
-          try:
-            pixmap = QPixmap()
-            pixmap.loadFromData(base64.b64decode(doc['image'][22:]))
-            pixmap = pixmap.scaledToWidth(self.width)
-            height = pixmap.height()
-          except:
-            print("**Exception in Renderer.sizeHint") #TODO_P5 if successful in Aug2023: remove
+          pixmap = QPixmap()
+          pixmap.loadFromData(base64.b64decode(doc['image'][22:]))
+          pixmap = pixmap.scaledToWidth(self.widthImage)
+          height = max(height, pixmap.height())+2*self.frameSize
         else:
-          height = int(self.width*3/4)
-      if 'content' in docKeys and not folded:
+          height = max(height, int(self.widthImage*3/4))+2*self.frameSize
+      elif 'comment' in doc.keys() and len(doc['comment'])>0:
         text = QTextDocument()
-        text.setMarkdown(self.comm.backend.db.getDoc(docID)['content'])
-        height = text.size().toTuple()[1]
-      return QSize(400, height)
+        comment = doc['comment']
+        text.setMarkdown(comment.strip())
+        text.setTextWidth(self.widthContent)
+        height += text.size().toTuple()[1] # type: ignore
+        height -= 25
+      else:
+        height -= 25
+      return QSize(400, min(height, self.maxHeight))
     return QSize()
+
+    #TODO_P3 design ProjectView: Currently, the comment is more highlighted than the title of an item due
+    # to a larger and bolder font. It would make more sense though if the titles were bolder, larger and
+    # thus more readable, while tags and comments are less highlighted.
+    # !! Comments are not rendered perfectly: the end sucks, and I cannot blue a consistent blue line at end
+    #  - rendering might not be the best option
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## pasta_eln/widgetProjectTreeView.py

```diff
@@ -1,104 +1,145 @@
 """ Custom tree view on data model """
-import uuid, subprocess, os, platform
+import subprocess, os, platform, logging, shutil
 from pathlib import Path
-from PySide6.QtWidgets import QTreeView, QAbstractItemView, QMenu # pylint: disable=no-name-in-module
-from PySide6.QtGui import QAction, QStandardItem                  # pylint: disable=no-name-in-module
+from PySide6.QtWidgets import QWidget, QTreeView, QAbstractItemView, QMenu, QMessageBox # pylint: disable=no-name-in-module
+from PySide6.QtGui import QStandardItemModel, QStandardItem  # pylint: disable=no-name-in-module
+from PySide6.QtCore import QPoint, Qt  # pylint: disable=no-name-in-module
 from .widgetProjectLeafRenderer import ProjectLeafRenderer
 from .style import Action, showMessage
+from .communicate import Communicate
 
 class TreeView(QTreeView):
   """ Custom tree view on data model """
-  def __init__(self, parent, comm, model):
+  def __init__(self, parent:QWidget, comm:Communicate, model:QStandardItemModel):
     super().__init__(parent)
     self.comm = comm
     self.setModel(model)
     self.setHeaderHidden(True)
     self.setStyleSheet('QTreeView::branch {border-image: none;}')
     self.setIndentation(50)
-    self.renderer = ProjectLeafRenderer()
-    self.renderer.setCommunication(self.comm)
+    self.renderer = ProjectLeafRenderer(self.comm)
     self.setItemDelegate(self.renderer)
     self.setDragDropMode(QAbstractItemView.InternalMove)
     self.doubleClicked.connect(self.treeDoubleClicked)
 
 
-  def contextMenuEvent(self, e):
+  def contextMenuEvent(self, p:QPoint) -> None:
     """
     create context menu
 
     Args:
-      e (QEvent): event
+      p (QPoint): point of clicking
     """
     context = QMenu(self)
     Action('Add child folder',   self.executeAction, context, self, name='addChild')
     Action('Add sibling folder', self.executeAction, context, self, name='addSibling')
-    Action('Remove this',        self.executeAction, context, self, name='del')
+    Action('Remove item',        self.executeAction, context, self, name='del')
     context.addSeparator()
     Action('Minimize/Maximize',  self.executeAction, context, self, name='fold')
     Action('Hide',               self.executeAction, context, self, name='hide')
     context.addSeparator()
-    Action('Open external program', self.executeAction, context, self, name='openExternal')
-    context.exec(e.globalPos())
-
-  #TODO_P3 drag&drop: external files
+    Action('Open with another application', self.executeAction, context, self, name='openExternal')
+    context.exec(p.globalPos())
+    return
 
-  def executeAction(self):
+  #TODO_P4 projectTree: drag&drop of external files
+  def executeAction(self) -> None:
     """ after selecting a item from context menu """
     menuName = self.sender().data()
     if menuName=='addChild':
       hierStack = self.currentIndex().data().split('/')
       if hierStack[-1][0]=='x':
         docType= 'x'+str(len(hierStack))
-        self.comm.backend.cwd = Path(self.comm.backend.db.getDoc(hierStack[-1])['-branch'][0]['path'])
-        self.comm.backend.addData(docType, {'-name':'folder 1', 'childNum':0}, hierStack)
-        self.comm.changeProject.emit('','') #refresh project
+        docID = hierStack[-1][:-2] if hierStack[-1].endswith(' -') else hierStack[-1]
+        self.comm.backend.cwd = Path(self.comm.backend.db.getDoc(docID)['-branch'][0]['path'])
+        docID = self.comm.backend.addData(docType, {'-name':'new folder'}, hierStack)
+        # append item to the GUI
+        item  = self.model().itemFromIndex(self.currentIndex())
+        child = QStandardItem('/'.join(hierStack+[docID]))
+        child.setFlags(Qt.ItemIsEnabled | Qt.ItemIsSelectable | Qt.ItemIsDragEnabled | Qt.ItemIsDropEnabled) # type: ignore
+        item.appendRow(child)
+        #appendRow is not 100% correct:
+        # - better: insertRow before the first non-folder, depending on the child number
+        #   -> get highest non 9999 childNumber
+        # turns out, one can easily move it to correct position with drag&drop
+        # TODO_P4 not sure this will be important
       else:
         showMessage(self, 'Error', 'You cannot create a child of a non-folder!')
     elif menuName=='addSibling':
-      childNum = self.currentIndex().row()+1
       hierStack= self.currentIndex().data().split('/')[:-1]
       docType= 'x'+str(len(hierStack))
-      self.comm.backend.cwd = Path(self.comm.backend.db.getDoc(hierStack[-1])['-branch'][0]['path'])
-      self.comm.backend.addData(docType, {'-name':'folder '+str(childNum+1), 'childNum':childNum}, hierStack)
-      self.comm.changeProject.emit('','') #refresh project
+      docID = hierStack[-1][:-2] if hierStack[-1].endswith(' -') else hierStack[-1]
+      self.comm.backend.cwd = Path(self.comm.backend.db.getDoc(docID)['-branch'][0]['path'])
+      docID = self.comm.backend.addData(docType, {'-name':'new folder'}, hierStack)
+      # append item to the GUI
+      item  = self.model().itemFromIndex(self.currentIndex())
+      parent = item.parent() if item.parent() is not None else self.model().invisibleRootItem()
+      child = QStandardItem('/'.join(hierStack+[docID]))
+      child.setFlags(Qt.ItemIsEnabled | Qt.ItemIsSelectable | Qt.ItemIsDragEnabled | Qt.ItemIsDropEnabled) # type: ignore
+      parent.appendRow(child)
+      #++ TODO appendRow is not 100% correct: see above
     elif menuName=='del':
-      docID = self.currentIndex().data().split('/')[-1]
-      doc = self.comm.backend.db.remove(docID)
-      for branch in doc['-branch']:
-        oldPath = Path(self.comm.backend.basePath)/branch['path']
-        if oldPath.exists():
-          oldPath.rename( oldPath.parent/('trash_'+oldPath.name) )
-      self.comm.changeProject.emit('','') #refresh project
+      ret = QMessageBox.critical(self, 'Warning', 'Are you sure you want to delete this data?',\
+                                QMessageBox.StandardButton.Yes, QMessageBox.StandardButton.No)
+      if ret==QMessageBox.StandardButton.Yes:
+        docID = self.currentIndex().data().split('/')[-1]
+        doc = self.comm.backend.db.remove(docID)
+        for branch in doc['-branch']:
+          oldPath = Path(self.comm.backend.basePath)/branch['path']
+          if oldPath.exists():
+            if (oldPath.parent/('trash_'+oldPath.name)).exists():  #ensure target does not exist
+              endText = ' was marked for deletion. Save it or its content now to some place on harddisk. It will be deleted now!!!'
+              showMessage(self, 'Warning', 'Warning! \nThe folder '+str(oldPath.parent/('trash_'+oldPath.name))+endText)
+              if (oldPath.parent/('trash_'+oldPath.name)).exists():
+                shutil.rmtree(oldPath.parent/('trash_'+oldPath.name))
+            oldPath.rename( oldPath.parent/('trash_'+oldPath.name) )
+        # go through children
+        children = self.comm.backend.db.getView('viewHierarchy/viewHierarchy', startKey=' '.join(doc['-branch'][0]['stack']+[docID,'']))
+        for line in children:
+          self.comm.backend.db.remove(line['id'])
+        # remove leaf from GUI
+        item  = self.model().itemFromIndex(self.currentIndex())
+        parent = item.parent()
+        if parent is None: #top level
+          parent = self.model().invisibleRootItem()
+        parent.removeRow(item.row())
     elif menuName=='fold':
       item = self.model().itemFromIndex(self.currentIndex())
       if item.text().endswith(' -'):
         item.setText(item.text()[:-2])
       else:
         item.setText(item.text()+' -')
     elif menuName=='hide':
       stack = self.currentIndex().data().split('/')
-      print('hide stack', stack)
+      logging.debug('hide stack '+str(stack))
       self.comm.backend.db.hideShow(stack)
       self.comm.changeProject.emit('','') #refresh project
     elif menuName=='openExternal':
       docID = self.currentIndex().data().split('/')[-1]
-      doc   = self.comm.backend.db.getDoc(docID)
-      path  = Path(self.comm.backend.basePath)/doc['-branch'][0]['path']
-      if platform.system() == 'Darwin':       # macOS
-        subprocess.call(('open', path))
-      elif platform.system() == 'Windows':    # Windows
-        os.startfile(path)
-      else:                                   # linux variants
-        subprocess.call(('xdg-open', path))
+      doc   = self.comm.backend.db.getDoc(docID[:-2] if docID.endswith(' -') else docID)
+      if doc['-branch'][0]['path'] is None:
+        showMessage(self, 'ERROR', 'Cannot open file that is only in the database','Warning')
+      else:
+        path  = Path(self.comm.backend.basePath)/doc['-branch'][0]['path']
+        if platform.system() == 'Darwin':       # macOS
+          subprocess.call(('open', path))
+        elif platform.system() == 'Windows':    # Windows
+          os.startfile(path) # type: ignore[attr-defined]
+        else:                                   # linux variants
+          subprocess.call(('xdg-open', path))
     else:
       print('**ERROR**: unknown context menu', menuName)
     return
 
-  def treeDoubleClicked(self):
-    """ after double-click on tree leaf: open form """
+
+  def treeDoubleClicked(self) -> None:
+    """
+    after double-click on tree leaf: open form
+    - no redraw required since renderer asks automatically for update
+    """
     docID = self.currentIndex().data().split('/')[-1]
-    doc   = self.comm.backend.db.getDoc(docID)
+    doc   = self.comm.backend.db.getDoc(docID[:-2] if docID.endswith(' -') else docID)
     self.comm.formDoc.emit(doc)
-    self.comm.changeProject.emit('','')
-
+    item  = self.model().itemFromIndex(self.currentIndex())
+    item.emitDataChanged()  #force redraw (resizing and repainting) of this item only
     return
```

## pasta_eln/widgetSidebar.py

```diff
@@ -1,125 +1,135 @@
 """ Sidebar widget that includes the navigation items """
-from PySide6.QtWidgets import QWidget, QVBoxLayout, QGridLayout, QTreeWidget, QTreeWidgetItem, QFrame # pylint: disable=no-name-in-module
-from PySide6.QtCore import QSize, Slot                                      # pylint: disable=no-name-in-module
-from anytree import PreOrderIter
+from PySide6.QtWidgets import QWidget, QVBoxLayout, QTreeWidget, QTreeWidgetItem, QFrame, QProgressBar # pylint: disable=no-name-in-module
+from PySide6.QtCore import Slot, Qt                                    # pylint: disable=no-name-in-module
+from anytree import PreOrderIter, Node
 
 from .dialogConfig import Configuration
-from .style import TextButton, LetterButton, IconButton, getColor, showMessage
+from .style import TextButton, IconButton, getColor, showMessage, widgetAndLayout, spacesMap, iconsDocTypes
+from .communicate import Communicate
 
 class Sidebar(QWidget):
   """ Sidebar widget that includes the navigation items """
-  def __init__(self, comm):
+  def __init__(self, comm:Communicate):
     super().__init__()
     self.comm = comm
     comm.changeSidebar.connect(self.redraw)
     if hasattr(self.comm.backend, 'configuration'):
-      width = self.comm.backend.configuration['GUI']['sidebarWidth']
-      self.setFixedWidth(width)#64
+      self.sideBarWidth = self.comm.backend.configuration['GUI']['sidebarWidth']
+      self.setFixedWidth(self.sideBarWidth)
     if not hasattr(comm.backend, 'db'):  #if no backend
       configWindow = Configuration(comm.backend, 'setup')
       configWindow.exec()
     self.openProjectId = ''
 
     # GUI elements
-    self.mainL = QVBoxLayout()
-    self.mainL.setContentsMargins(7,15,0,7)
-    self.mainL.setSpacing(7)
-    self.setLayout(self.mainL)
+    mainL = QVBoxLayout()
+    mainL.setContentsMargins(spacesMap['s'],spacesMap['s'],spacesMap['0'],spacesMap['s'])
+    mainL.setSpacing(0)
+    _, self.projectL = widgetAndLayout('V', mainL, spacing='s')
+    self.progress = QProgressBar(self)
+    self.progress.hide()
+    self.comm.progressBar = self.progress
+    mainL.addWidget(self.progress)
+    self.setLayout(mainL)
     self.redraw()
-    #TODO_P3 convenience: allow scroll in sidebar
+    #++ TODO projectView: allow scroll in sidebar, size changegable, drag-and-drop to move
     #   more below and other files
 
 
-  @Slot()
-  def redraw(self):
+  @Slot(str)
+  def redraw(self, projectID:str='') -> None:
     """
     Redraw sidebar: e.g. after change of project visibility in table
+
+    Args:
+      projectID (str): projectID on which to focus: '' string=draw default; 'redraw' implies redraw; id implies id
     """
     # Delete old widgets from layout and create storage
-    for i in reversed(range(self.mainL.count())):
-      self.mainL.itemAt(i).widget().setParent(None)
-    self.openProjectId = ''
+    for i in reversed(range(self.projectL.count())):
+      self.projectL.itemAt(i).widget().setParent(None) # type: ignore
+    if projectID != 'redraw':
+      self.openProjectId = projectID
     self.widgetsAction = {}
     self.widgetsList = {}
     self.widgetsProject = {} #title bar and widget that contains all of project
 
     if hasattr(self.comm.backend, 'db'):
       hierarchy = self.comm.backend.db.getView('viewDocType/x0')
-      for project in hierarchy:
+      #TODO_P5 for now, sorted by last change of project itself: future create a view that does that automatically
+      lastChangeDate = [self.comm.backend.db.getDoc(project['id'])['-date'] for project in hierarchy]
+      for project in [x for _, x in sorted(zip(lastChangeDate, hierarchy))]:
         projID = project['id']
         projName = project['value'][0]
         if self.openProjectId == '':
           self.openProjectId = projID
         #head: show project name as button
         projectW = QFrame()
         # projectW.setMinimumHeight(300) #convenience: allow scroll in sidebar
         projectL = QVBoxLayout(projectW)
         projectL.setContentsMargins(3,3,3,3)
-        btnProj = TextButton(projName, self.btnProject, projectL, projID+'/')
+        maxLabelCharacters = int((self.sideBarWidth-50)/7.1)
+        label = projName if len(projName)<maxLabelCharacters else projName[:maxLabelCharacters-3]+'...'
+        btnProj = TextButton(label, self.btnProject, projectL, projID+'/')
         btnProj.setStyleSheet("border-width:0")
-        projectW.setStyleSheet("background-color:"+ getColor(self.comm.backend, 'secondaryDark'))
         self.widgetsProject[projID] = [btnProj, projectW]
 
         # actions: scan, curate, ...
-        actionW = QWidget()
-        if self.openProjectId != projID:
+        actionW, actionL = widgetAndLayout('Grid', projectL)
+        if self.openProjectId != projID: #depending which project is open
           actionW.hide()
-        actionL = QGridLayout(actionW)
-        actionL.setContentsMargins(0,0,0,0)
+          projectW.setStyleSheet("background-color:"+ getColor(self.comm.backend, 'secondaryDark'))
+        else:
+          projectW.setStyleSheet("background-color:"+ getColor(self.comm.backend, 'secondaryLight'))
         btnScan = IconButton('mdi.clipboard-search-outline', self.btnScan, None, projID, 'Scan', self.comm.backend, text='Scan')
-        actionL.addWidget(btnScan, 0,0)
+        actionL.addWidget(btnScan, 0,0)  # type: ignore
         btnCurate = IconButton('mdi.filter-plus-outline', self.btnCurate, None, projID, 'Special', self.comm.backend, text='Special')
-        actionL.addWidget(btnCurate, 0,1)
-        projectL.addWidget(actionW)
+        btnCurate.hide()
+        actionL.addWidget(btnCurate, 0,1)         # type: ignore
         self.widgetsAction[projID] = actionW
         btnScan.setStyleSheet("border-width:0")
         btnCurate.setStyleSheet("border-width:0")
 
         # lists: view list of measurements, ... of this project
-        listW = QWidget()
-        listW.setContentsMargins(0,0,0,0)
+        listW, listL = widgetAndLayout('Grid', projectL)
         if self.openProjectId != projID:
           listW.hide()
-        listL = QGridLayout(listW)
-        iconTable = {"Measurements":"fa.thermometer-3","Samples":"fa5s.vial","Procedures":"fa.list-ol","Instruments":"ri.scales-2-line"}
         for idx, doctype in enumerate(self.comm.backend.db.dataLabels):
           if doctype[0]!='x':
-            button = IconButton(iconTable[self.comm.backend.db.dataLabels[doctype]], self.btnDocType, None, \
+            button = IconButton(iconsDocTypes[self.comm.backend.db.dataLabels[doctype]], self.btnDocType, None, \
                      doctype+'/'+projID, self.comm.backend.db.dataLabels[doctype],self.comm.backend)
-            listL.addWidget(button, 0, idx)
-            button.setStyleSheet("border-width:0")
-
-        projectL.addWidget(listW)
+            listL.addWidget(button, 0, idx)    # type: ignore
+        button = IconButton(iconsDocTypes['-'], self.btnDocType, None, '-/'+projID, 'Unidentified', self.comm.backend)
+        listL.addWidget(button, 0, len(self.comm.backend.db.dataLabels)+1)  # type: ignore
         self.widgetsList[projID] = listW
 
         # show folders as hierarchy
         treeW = QTreeWidget()
-        #treeW.hide()  #convenience: allow scroll in sidebar
+        treeW.hide()  #convenience: allow scroll in sidebar
         treeW.setHeaderHidden(True)
         treeW.setColumnCount(1)
         treeW.itemClicked.connect(self.btnTree)
         hierarchy = self.comm.backend.db.getHierarchy(projID)
         rootItem = treeW.invisibleRootItem()
         count = 0
         for node in PreOrderIter(hierarchy, maxlevel=2):
-          if not node.is_root:
+          if not node.is_root and node.id[0]=='x':
             rootItem.insertChild(count, self.iterateTree(node, projID))
             count += 1
         projectL.addWidget(treeW)
         # finalize layout
-        self.mainL.addWidget(projectW)
+        self.projectL.addWidget(projectW)
     # Other buttons
     stretch = QWidget()
 
-    self.mainL.addWidget(stretch, stretch=2)
+    self.projectL.addWidget(stretch, stretch=2)  # type: ignore
     return
 
 
-  def iterateTree(self, nodeHier, projectID):
+  def iterateTree(self, nodeHier:Node, projectID:str) -> QTreeWidgetItem:
     """
     Recursive function to translate the hierarchical node into a tree-node
 
     Args:
       nodeHier (Anytree.Node): anytree node
       projectID (str): project id of this tree
 
@@ -134,25 +144,25 @@
         childTree = self.iterateTree(childHier, projectID)
         children.append(childTree)
     if len(children)>0:
       nodeTree.insertChildren(0,children)
     return nodeTree
 
 
-  def btnDocType(self):
+  def btnDocType(self) -> None:
     """
     What happens when user clicks to change doc-type
     """
     btnName = self.sender().accessibleName()
     item, projID = btnName.split('/')
     self.comm.changeTable.emit(item, projID)
     return
 
 
-  def btnProject(self):
+  def btnProject(self) -> None:
     """
     What happens when user clicks to view project
     """
     btnName = self.sender().accessibleName()
     projID, item = btnName.split('/')
     if item=='': #clicked on project-button, not tree view
       self.openProjectId = projID
@@ -171,29 +181,32 @@
           projWidget.setStyleSheet("background-color:"+ getColor(self.comm.backend, 'secondaryLight'))
         else:
           projWidget.setStyleSheet("background-color:"+ getColor(self.comm.backend, 'secondaryDark'))
     self.comm.changeProject.emit(projID, item)
     return
 
 
-  def btnScan(self):
+  def btnScan(self) -> None:
     """
     What happens if user clicks button "Scan"
     """
-    self.comm.backend.scanProject(self.openProjectId)
+    self.comm.backend.scanProject(self.progress, self.openProjectId, '')
     self.comm.changeProject.emit(self.openProjectId,'')
     showMessage(self, 'Information','Scanning finished')
     return
 
-  def btnCurate(self):
+
+  def btnCurate(self) -> None:
     """
-    What happens if user clicks button "Curate"
+    What happens if user clicks button "Special"
+    -> pull data from server and include
     """
-    print("SB is unsure if we still need it? Perhaps to focus the user")
     return
-  def btnTree(self, item):
+
+
+  def btnTree(self, item:QTreeWidgetItem) -> None:
     """
     What happpens if user clicks on branch in tree
     """
     projId, docId = item.text(1).split('/')
     self.comm.changeProject.emit(projId, docId)
     return
```

## pasta_eln/widgetTable.py

```diff
@@ -1,311 +1,429 @@
 """ widget that shows the table of the items """
-import re, json
+import re, logging
 from pathlib import Path
-from PySide6.QtWidgets import QWidget, QVBoxLayout, QHBoxLayout, QTableView, QLabel, QMenu, QFileDialog, \
-                              QHeaderView, QAbstractItemView, QGridLayout, QLineEdit, QComboBox # pylint: disable=no-name-in-module
+from typing import Any
+from PySide6.QtWidgets import QWidget, QVBoxLayout, QTableView, QMenu, QFileDialog, QMessageBox, QHeaderView, QLineEdit, QComboBox # pylint: disable=no-name-in-module
 from PySide6.QtCore import Qt, Slot, QSortFilterProxyModel, QModelIndex       # pylint: disable=no-name-in-module
-from PySide6.QtGui import QBrush, QStandardItemModel, QStandardItem, QAction, QFont # pylint: disable=no-name-in-module
-import qtawesome as qta
+from PySide6.QtGui import QStandardItemModel, QStandardItem, QFont            # pylint: disable=no-name-in-module
 from .dialogTableHeader import TableHeader
-from .style import TextButton, Label, getColor, LetterButton, Action
+from .style import TextButton, IconButton, Label, Action, widgetAndLayout, spacesMap
 from .fixedStrings import defaultOntologyNode
+from .communicate import Communicate
 
 #Scan button to more button
 class Table(QWidget):
   """ widget that shows the table of the items """
-  def __init__(self, comm):
+  def __init__(self, comm:Communicate):
     """
     Initialization
 
     Args:
       comm (Communicate): communication channel
     """
     super().__init__()
     self.comm = comm
     comm.changeTable.connect(self.changeTable)
-    self.data = []
-    self.models = []
+    comm.stopSequentialEdit.connect(self.stopSequentialEditFunction)
+    self.stopSequentialEdit = False
+    self.data:list[dict[str,Any]] = []
+    self.models:list[QStandardItemModel] = []
     self.docType = ''
     self.projID = ''
-    self.filterHeader = []
+    self.filterHeader:list[str] = []
     self.showAll= False
 
     ### GUI elements
     mainL = QVBoxLayout()
+    mainL.setSpacing(0)
+    mainL.setContentsMargins(spacesMap['s'], spacesMap['s'], spacesMap['s'], spacesMap['s'])
     # header
-    self.headerW = QWidget()
+    self.headerW, headerL = widgetAndLayout('H', mainL, 'm')
     self.headerW.hide()
-    headerL = QHBoxLayout(self.headerW)
     self.headline = Label('','h1', headerL)
+    headerL.addStretch(1)
     self.addBtn = TextButton('Add',        self.executeAction, headerL, name='addItem')
     TextButton('Add Filter', self.executeAction, headerL, name='addFilter')
-    TextButton('Group Edit', self.executeAction, headerL, name='groupEdit')
+
+    self.selectionBtn = TextButton('Selection', None, headerL)
+    selectionMenu = QMenu(self)
+    Action('Toggle selection',self.executeAction, selectionMenu, self, name='toggleSelection')
+    selectionMenu.addSeparator()
+    Action('Group Edit',      self.executeAction, selectionMenu, self, name='groupEdit')
+    Action('Sequential edit', self.executeAction, selectionMenu, self, name='sequentialEdit')
+    Action('Toggle hidden',   self.executeAction, selectionMenu, self, name='toggleHide')
+    Action('Rerun extractors',self.executeAction, selectionMenu, self, name='rerunExtractors')
+    Action('Delete',          self.executeAction, selectionMenu, self, name='delete')
+    self.selectionBtn.setMenu(selectionMenu)
+
     more = TextButton('More',None, headerL)
-    moreMenu = QMenu(self)
-    Action('Sequential edit', self.executeAction, moreMenu, self, name='sequentialEdit')
-    Action('Toggle hidden',   self.executeAction, moreMenu, self, name='toggleHide')
-    Action('Hide / Show all', self.executeAction, moreMenu, self, name='showAll')
-    Action('Change headers',  self.executeAction, moreMenu, self, name='changeTableHeader')
-    Action('Export',          self.executeAction, moreMenu, self, name='export')
-    more.setMenu(moreMenu)
-    #TODO_P3 rerunExtractors: as batch
-    mainL.addWidget(self.headerW)
+    self.moreMenu = QMenu(self)
+    Action('Show / Hide hidden items', self.executeAction, self.moreMenu, self, name='showAll')
+    Action('Export to csv',            self.executeAction, self.moreMenu, self, name='export')
+    self.actionChangeColums = Action('Change columns',  self.executeAction, self.moreMenu, self, name='changeColumns')  #add action at end
+
+    more.setMenu(self.moreMenu)
     # filter
-    filterW = QWidget()
-    self.filterL = QGridLayout(filterW)
-    mainL.addWidget(filterW)
+    _, self.filterL = widgetAndLayout('Grid', mainL, top='s', bottom='s')
     # table
     self.table = QTableView(self)
     self.table.verticalHeader().hide()
     self.table.clicked.connect(self.cellClicked)
     self.table.doubleClicked.connect(self.cell2Clicked)
     self.table.setSortingEnabled(True)
     self.table.setAlternatingRowColors(True)
-    self.table.setSelectionMode(QAbstractItemView.MultiSelection)
     header = self.table.horizontalHeader()
     header.setSectionsMovable(True)
     header.setSortIndicatorShown(True)
-    header.setMaximumSectionSize(400) #TODO_P5 addToConfig
+    header.setMaximumSectionSize(400) #TODO_P4 addToConfig
     header.resizeSections(QHeaderView.ResizeToContents)
     header.setStretchLastSection(True)
+    #TODO_P3 table: shift-select
     # ---
     mainL.addWidget(self.table)
     self.setLayout(mainL)
 
 
   @Slot(str, str)
-  def changeTable(self, docType, projID):
+  def changeTable(self, docType:str, projID:str) -> None:
     """
     What happens when the table changes its raw information
 
     Args:
       docType (str): document type; leave empty for redraw
       projID (str): id of project
     """
+    if docType!=self.docType or projID!=self.projID:
+      logging.debug('table:changeTable |'+docType+'|'+projID+'|')
     self.models = []
+    for i in reversed(range(self.filterL.count())):
+      self.filterL.itemAt(i).widget().setParent(None)   # type: ignore
     if docType!='':
       self.docType = docType
       self.projID  = projID
-    if docType=='_tags_':
+    if self.docType=='_tags_':
       self.addBtn.hide()
+      #TODO_P3 projectView: if table-row click, move to view it project
       if self.showAll:
         self.data = self.comm.backend.db.getView('viewIdentify/viewTagsAll')
       else:
         self.data = self.comm.backend.db.getView('viewIdentify/viewTags')
-      self.filterHeader = ['tag','name']
+      self.filterHeader = ['tag','name','type']
       self.headline.setText('TAGS')
+      self.actionChangeColums.setVisible(False)
     else:
       self.addBtn.show()
+      if docType[:2]=='x0':
+        self.selectionBtn.hide()
+      else:
+        self.selectionBtn.show()
       path = 'viewDocType/'+self.docType+'All' if self.showAll else 'viewDocType/'+self.docType
       if self.projID=='':
         self.data = self.comm.backend.db.getView(path)
       else:
         self.data = self.comm.backend.db.getView(path, preciseKey=self.projID)
       if self.docType=='-':
         self.headline.setText('Unidentified')
+        self.actionChangeColums.setVisible(False)
       else:
+        self.actionChangeColums.setVisible(True)
         if self.docType in self.comm.backend.db.dataLabels:
           self.headline.setText(self.comm.backend.db.dataLabels[self.docType])
-      if docType in self.comm.backend.configuration['tableHeaders']:
+      if self.docType in self.comm.backend.configuration['tableHeaders']:
         self.filterHeader = self.comm.backend.configuration['tableHeaders'][docType]
       elif self.docType=='-':
         self.filterHeader = [i['name'] for i in defaultOntologyNode]
       else:
         self.filterHeader = [i['name'] for i in self.comm.backend.db.ontology[self.docType]['prop']]
       self.filterHeader = [i[1:] if i[0]=='-'   else i for i in self.filterHeader]  #change -something to something
       self.filterHeader = [i[2:] if i[:2]=='#_' else i for i in self.filterHeader]  #change #_something to somehing
     self.headerW.show()
     nrows, ncols = len(self.data), len(self.filterHeader)
     model = QStandardItemModel(nrows, ncols)
     model.setHorizontalHeaderLabels(self.filterHeader)
     for i in range(nrows):
       for j in range(ncols):
-        if docType=='_tags_':  #tags list
+        if self.docType=='_tags_':  #tags list
           if j==0:
             if self.data[i]['key']=='_curated':
-              item = QStandardItem('cur\u2605ted')
+              item = QStandardItem('_curated_')
             elif re.match(r'_\d', self.data[i]['key']):
               item = QStandardItem('\u2605'*int(self.data[i]['key'][1]))
             else:
               item = QStandardItem(self.data[i]['key'])
           else:
-            item = QStandardItem(self.data[i]['value'][0])
+            item = QStandardItem(self.data[i]['value'][j-1])
         else:                 #list for normal doctypes
           # print(i,j, self.data[i]['value'][j], type(self.data[i]['value'][j]))
           if self.data[i]['value'][j] is None or not self.data[i]['value'][j]:  #None, False
             item = QStandardItem('\u00D7')
             item.setFont(QFont("Helvetica [Cronyx]", 16))
           elif isinstance(self.data[i]['value'][j], bool) and self.data[i]['value'][j]: #True
             item = QStandardItem('\u2713')
             item.setFont(QFont("Helvetica [Cronyx]", 16))
           elif isinstance(self.data[i]['value'][j], list):                      #list, e.g. qrCodes
             item =  QStandardItem(', '.join(self.data[i]['value'][j]))
-          elif re.match(r'^[a-z]-[a-z0-9]{32}$',self.data[i]['value'][j]):      #Link
+          elif re.match(r'^[a-z\-]-[a-z0-9]{32}$',self.data[i]['value'][j]):      #Link
             item = QStandardItem('\u260D')
             item.setFont(QFont("Helvetica [Cronyx]", 16))
           else:
             if self.filterHeader[j]=='tags':
               tags = self.data[i]['value'][j].split(' ')
               if '_curated' in tags:
-                tags[tags.index('_curated')] = 'cur\u2605ted'
+                tags[tags.index('_curated')] = '_curated_'
               for iStar in range(1,6):
                 if '_'+str(iStar) in tags:
                   tags[tags.index('_'+str(iStar))] = '\u2605'*iStar
               text = ' '.join(tags)
             else:
               text = self.data[i]['value'][j]
             item = QStandardItem(text)
         if j==0:
           doc = self.comm.backend.db.getDoc(self.data[i]['id'])
           if len([b for b in doc['-branch'] if False in b['show']])>0:
             item.setText( item.text()+'  \U0001F441' )
           item.setAccessibleText(doc['_id'])
-          item.setFlags(Qt.ItemFlag.ItemIsUserCheckable | Qt.ItemFlag.ItemIsEnabled)
-          item.setCheckState(Qt.CheckState.Unchecked)
+          if docType!='x0':
+            item.setFlags(Qt.ItemFlag.ItemIsUserCheckable | Qt.ItemFlag.ItemIsEnabled)   # type: ignore[operator]
+            item.setCheckState(Qt.CheckState.Unchecked)
+            #TODO_P3 design: make the checkboxes larger!
         else:
-          item.setFlags(Qt.ItemIsEnabled)
+          item.setFlags(Qt.ItemIsEnabled) # type: ignore[arg-type]
         model.setItem(i, j, item)
     self.models.append(model)
     self.table.setModel(self.models[-1])
     self.table.show()
-    self.comm.changeDetails.emit('empty')
     return
 
 
-  def cellClicked(self, item):
+  def cellClicked(self, item:QStandardItem) -> None:
     """
     What happens when user clicks cell in table of tags, projects, samples, ...
     -> show details
 
     Args:
       item (QStandardItem): cell clicked
     """
     row = item.row()
-    docID = self.models[-1].item(row,0).accessibleText()
+    _, docID = self.itemFromRow(row)
     # column = item.column()
-    if docID!='x0': #only show items for non-folders
+    if docID[0]=='x': #only show items for non-folders
+      doc = self.comm.backend.db.getDoc(docID)
+      if doc['-type'][0]=='x0':
+        self.comm.changeProject.emit(docID,'')
+        self.comm.changeSidebar.emit(docID)
+      else:
+        projID = doc['-branch'][0]['stack'][0]
+        self.comm.changeProject.emit(projID, docID)
+        self.comm.changeSidebar.emit(projID)
+    else:
       self.comm.changeDetails.emit(docID)
     return
-  def cell2Clicked(self, item):
+
+
+  def cell2Clicked(self, item:QStandardItem) -> None:
     """
     What happens when user double clicks cell in table of projects
 
     Args:
       item (QStandardItem): cell clicked
     """
+    row = item.row()
+    _, docID = self.itemFromRow(row)
     if self.docType=='x0':
-      row = item.row()
-      docID = self.models[-1].item(row,0).accessibleText()
       self.comm.changeProject.emit(docID, '')
+      self.comm.changeSidebar.emit(docID)
+    else:
+      doc = self.comm.backend.db.getDoc(docID)
+      self.comm.formDoc.emit(doc)
+      self.comm.changeTable.emit('','')
+      self.comm.changeDetails.emit('redraw')
     return
 
 
-  #TODO_P2 create project within project (unable to recreate)
-
-  def executeAction(self):
+  def executeAction(self) -> None:
     """ Any action by the buttons and menu at the top of the page """
     if hasattr(self.sender(), 'data'):  #action
       menuName = self.sender().data()
     else:                               #button
       menuName = self.sender().accessibleName()
     if menuName == 'addItem':
       self.comm.formDoc.emit({'-type':[self.docType]})
-      self.comm.changeTable.emit(self.docType, '')
+      self.comm.changeTable.emit(self.docType, self.projID)
       if self.docType=='x0':
-        self.comm.changeSidebar.emit()
+        self.comm.changeSidebar.emit('redraw')
     elif menuName == 'addFilter':
       # gui
-      rowW = QWidget()
-      rowL = QHBoxLayout(rowW)
+      _, rowL = widgetAndLayout('H', self.filterL, 'm', 'xl', '0', 'xl')
       text = QLineEdit('')
       rowL.addWidget(text)
       select = QComboBox()
       select.addItems(self.filterHeader)
       select.currentIndexChanged.connect(self.filterChoice)
       # print('create filter row',str(len(self.models)) )
       select.setAccessibleName(str(len(self.models)))
       rowL.addWidget(select)
-      LetterButton('-', self.delFilter, rowL, str(len(self.models)))
-      self.filterL.addWidget(rowW)
+      IconButton('fa5s.minus-square', self.delFilter, rowL, str(len(self.models)), backend=self.comm.backend)
       # data
+      #TODO_P4 can you sort for true false in tables too?
       filterModel = QSortFilterProxyModel()
       text.textChanged.connect(filterModel.setFilterRegularExpression)
       filterModel.setSourceModel(self.models[-1])
       filterModel.setFilterCaseSensitivity(Qt.CaseInsensitive)
       filterModel.setFilterKeyColumn(0)
       self.models.append(filterModel)
       self.table.setModel(self.models[-1])
     elif menuName == 'groupEdit':
       intersection = None
       docIDs = []
       for row in range(self.models[-1].rowCount()):
-        if self.models[-1].item(row,0).checkState() == Qt.CheckState.Checked:
-          docIDs.append( self.data[row]['id'] )
-          thisKeys = set(self.comm.backend.db.getDoc(self.data[row]['id']))
+        item, docID = self.itemFromRow(row)
+        if item.checkState() == Qt.CheckState.Checked:
+          docIDs.append(docID)
+          thisKeys = set(self.comm.backend.db.getDoc(docID))
           if intersection is None:
             intersection = thisKeys
           else:
             intersection = intersection.intersection(thisKeys)
       #remove keys that should not be group edited and build dict
-      intersection = intersection.difference({'-type', '-branch', '-user', '-client', 'metaVendor', 'shasum', \
-        '_id', 'metaUser', '_rev', '-name', '-date', 'image', '_attachments','links'})
-      intersection = {i:'' for i in intersection}
-      intersection.update({'_ids':docIDs})
-      self.comm.formDoc.emit(intersection)
+      if intersection is not None:
+        intersection = intersection.difference({'-branch', '-user', '-client', 'metaVendor', 'shasum', \
+          '_id', 'metaUser', '_rev', '-name', '-date', 'image', '_attachments','links'})
+        intersectionDict:dict[str,Any] = {i:'' for i in intersection}
+        intersectionDict['-tags'] = []
+        intersectionDict['-type'] = [self.docType]
+        intersectionDict.update({'_ids':docIDs})
+        self.comm.formDoc.emit(intersectionDict)
+        self.comm.changeDetails.emit('redraw')
+        self.comm.changeTable.emit(self.docType, '')
     elif menuName == 'sequentialEdit':
+      self.stopSequentialEdit = False
+      for row in range(self.models[-1].rowCount()):
+        item, docID = self.itemFromRow(row)
+        if item.checkState() == Qt.CheckState.Checked:
+          self.comm.formDoc.emit(self.comm.backend.db.getDoc(docID))
+        if self.stopSequentialEdit:
+          break
+      self.comm.changeTable.emit(self.docType, '')
+    elif menuName == 'delete':
       for row in range(self.models[-1].rowCount()):
-        if self.models[-1].item(row,0).checkState() == Qt.CheckState.Checked:
-          self.comm.formDoc.emit(self.comm.backend.db.getDoc( self.data[row]['id'] ))
+        item, docID = self.itemFromRow(row)
+        if item.checkState() == Qt.CheckState.Checked:
+          ret = QMessageBox.critical(self, 'Warning', 'Are you sure you want to delete this data: '+item.text()+'?',\
+                                    QMessageBox.StandardButton.Yes, QMessageBox.StandardButton.No)
+          if ret==QMessageBox.StandardButton.Yes:
+            doc = self.comm.backend.db.getDoc(docID)
+            for branch in doc['-branch']:
+              oldPath = self.comm.backend.basePath/branch['path']
+              if oldPath.exists():
+                newPath    = oldPath.parent/('trash_'+oldPath.name)
+                oldPath.rename(newPath)
+            self.comm.backend.db.remove(docID)
       self.comm.changeTable.emit(self.docType, '')
-    elif menuName == 'changeTableHeader':
+    elif menuName == 'changeColumns':
       dialog = TableHeader(self.comm, self.docType)
       dialog.exec()
     elif menuName == 'export':
+      #TODO_P3 export: export via extractor in high resolution: change order: first save, then rescale
       fileName = QFileDialog.getSaveFileName(self,'Export to ..',str(Path.home()),'*.csv')[0]
       with open(fileName,'w', encoding='utf-8') as fOut:
         header = ['"'+i+'"' for i in self.filterHeader]
         fOut.write(','.join(header)+'\n')
         for row in range(self.models[-1].rowCount()):
           rowContent = []
           for col in range(self.models[-1].columnCount()):
-            value = self.models[-1].index( row, col, QModelIndex() ).data( Qt.DisplayRole )
+            value = self.models[-1].index( row, col, QModelIndex() ).data( Qt.DisplayRole )  # type: ignore[arg-type]
             rowContent.append('"'+value+'"')
           fOut.write(','.join(rowContent)+'\n')
     elif menuName == 'toggleHide':
       for row in range(self.models[-1].rowCount()):
-        if self.models[-1].item(row,0).checkState() == Qt.CheckState.Checked:
-          self.comm.backend.db.hideShow( self.data[row]['id'] )
+        item, docID = self.itemFromRow(row)
+        if item.checkState() == Qt.CheckState.Checked:
+          self.comm.backend.db.hideShow(docID)
       if self.docType=='x0':
-        self.comm.changeSidebar.emit()
+        self.comm.changeSidebar.emit('redraw')
       self.changeTable('','')  # redraw table
+    elif menuName == 'toggleSelection':
+      for row in range(self.models[-1].rowCount()):
+        item,_ = self.itemFromRow(row)
+        if item.checkState() == Qt.CheckState.Checked:
+          item.setCheckState(Qt.CheckState.Unchecked)
+        else:
+          item.setCheckState(Qt.CheckState.Checked)
     elif menuName == 'showAll':
       self.showAll = not self.showAll
       self.changeTable('','')  # redraw table
+    elif menuName == 'rerunExtractors':
+      for row in range(self.models[-1].rowCount()):
+        item, docID = self.itemFromRow(row)
+        if item.checkState() == Qt.CheckState.Checked:
+          doc = self.comm.backend.db.getDoc(docID)
+          oldDocType = doc['-type']
+          if doc['-branch'][0]['path'].startswith('http'):
+            path = Path(doc['-branch'][0]['path'])
+          else:
+            path = self.comm.backend.basePath/doc['-branch'][0]['path']
+          self.comm.backend.useExtractors(path, '', doc)
+          if doc['-type'][0] == oldDocType[0]:
+            del doc['-branch']  #don't update
+            self.comm.backend.db.updateDoc(doc, self.data[row]['id'])
+          else:
+            self.comm.backend.db.remove( self.data[row]['id'] )
+            del doc['_id']
+            del doc['_rev']
+            doc['-name'] = doc['-branch'][0]['path']
+            self.comm.backend.addData('/'.join(doc['-type']), doc, doc['-branch'][0]['stack'])
+      self.changeTable('','')  # redraw table
+      self.comm.changeDetails.emit('redraw')
     else:
       print("**ERROR widgetTable menu unknown:",menuName)
     return
 
-  #TODO_P3 invert filter: not 'Sur' in name => '^((?!Sur).)*$' in name
-  def filterChoice(self, item):
+
+  @Slot()
+  def stopSequentialEditFunction(self) -> None:
+    """ Stop the sequential edit of a number of items """
+    self.stopSequentialEdit=True
+    return
+
+  def itemFromRow(self, row:int) -> tuple[QStandardItem, str]:
+    """
+    get item from row by iterating through the proxyModels
+
+    Args:
+      row (int): row number
+
+    Returns:
+      QItem, str: the item and docID
+    """
+    index = self.models[-1].index(row,0)
+    for idxModel in range(len(self.models)-1,0,-1):
+      index = self.models[idxModel].mapToSource(index)
+    item = self.models[0].itemFromIndex(index)
+    return item, item.accessibleText()
+
+
+  #TODO_P5 invert filter: not 'Sur' in name => '^((?!Sur).)*$' in name
+  def filterChoice(self, item:QStandardItem) -> None:
     """
     Change the column which is used for filtering
 
     Args:
        item (int): column number to filter by
     """
     row = self.sender().accessibleName()
     self.models[int(row)].setFilterKeyColumn(item)
     return
-  def delFilter(self):
+
+  def delFilter(self) -> None:
     """ Remove filter from list of filters """
     row = int(self.sender().accessibleName())
     #print('Delete filter row', row)
     for i in range(row, self.filterL.count()):        #e.g. model 1 is in row=0, so start in 1 for renumbering
       minusBtnW = self.filterL.itemAt(i).widget().layout().itemAt(2).widget()
       minusBtnW.setAccessibleName( str(int(minusBtnW.accessibleName())-1) )  #rename: -1 from accessibleName
     del self.models[row]
-    self.filterL.itemAt(row-1).widget().setParent(None) #e.g. model 1 is in row=0 for deletion
+    self.filterL.itemAt(row-1).widget().setParent(None) # type: ignore # e.g. model 1 is in row=0 for deletion
     for i in range(1, len(self.models)):
       self.models[i].setSourceModel(self.models[i-1])
     self.table.setModel(self.models[-1])
     return
```

## pasta_eln/Extractors/extractor_csv.py

```diff
@@ -1,40 +1,115 @@
 """extract data from .csv file
 """
 import re
 from io import StringIO
 import numpy as np
+from scipy import stats
+import pandas as pd
+from pandas.errors import EmptyDataError
 import matplotlib.pyplot as plt
 
 def use(filePath, recipe='', saveFileName=None):
   """
   Args:
     filePath (string): full path file name
     recipe (string): supplied to guide recipes
                      recipe is / separated hierarchical elements parent->child
     saveFileName (string): if given, save the image to this file-name
 
   Returns:
     dict: containing image, metaVendor, metaUser, recipe
   """
   # Extractor for fancy instrument
+  delimiter = ','
   with open(filePath, encoding='utf-8') as fIn:
-    startRow = 0
-    while True:
-      if len(re.findall('[a-zA-Z]', fIn.readline()))==0:
-        break
-      startRow+=1
-  data = np.loadtxt(filePath, delimiter=',', skiprows=startRow)
-
-  if recipe.endswith('red'):              #: Draw with red curve
-    plt.plot(data[:,0], data[:,1],'r')
-  else:                                   #: Default | blueish curve
-    plt.plot(data[:,0], data[:,1])
-  metaUser = {'max':data[:,1].max(), 'min':data[:,1].min()}
-  recipe = 'csv'
+    content = fIn.read()
+    countComma = content.count(',')
+    countPoint = content.count('.')
+    countTab   = content.count('\t')
+    countSemicolon = content.count(';')
+    countLines = content.count('\n')
+    print('Counts of , . \\t ; \\n in csv file: ',countComma, countPoint, countTab, countSemicolon, countLines)
+    if countSemicolon>=countLines:
+      delimiter = ';'
+  startRow = -1
+  dataType = ''
+  with open(filePath, encoding='utf-8') as fIn:
+    line = fIn.readline()
+    if 'image,imprint size(micrometer)' in line:
+      startRow = 0
+      dataType = 'DFKI'
+    elif 'Ananlysis with contact area from tip area function;' in line:
+      startRow = 1
+      dataType = 'FZJ'
+    elif ',Al (at. %),Fe (at. %),Si (at. %),E (GPa)' in line:
+      startRow = 0
+      dataType = 'pyIron'
+    else:
+      fIn.seek(0)
+      startRow = 0
+      while True:
+        if len(re.findall('[a-zA-Z]', fIn.readline()))==0:
+          break
+        startRow+=1
+  print('delimiter',delimiter, 'startRow',startRow)
+  try:
+    data = pd.read_csv(filePath, delimiter=delimiter, skiprows=startRow)
+  except EmptyDataError:  #if no data left, import everything
+    data = pd.read_csv(filePath, delimiter=delimiter)
+  # temporary fix for data from DFKI
+  if dataType=='DFKI':
+    imprintSize = list(data['imprint size(micrometer)'])
+    imprintSize = [i.split(',')[0].replace('[','').replace(']','') for i in imprintSize]
+    imprintSize = [float(i) for i in imprintSize]
+    data['imprintSize'] = imprintSize
+    force = list(data['image'])
+    force = [int(i.split('mN')[0][3:]) for i in force]
+    data['force'] = force
+    data = data.drop(['image','imprint size(micrometer)'],axis=1)
+    data = np.array(data)
+    plt.plot(data[:,0], data[:,1],'o')
+    plt.xlabel('force [mN]')
+    plt.ylabel(r'area [$\mu m^2$]')
+    metaUser = {'num files':data.shape[0]}
+    if recipe == 'measurement/dkfi/fit':            #: With fitting line
+      fit = np.polyfit(data[:,0], data[:,1], 1)
+      x_ = np.array([0,np.max(data[:,0])])
+      plt.plot(x_, np.polyval(fit, x_))
+      metaUser['fitFunction'] = str(fit[0])+'x+'+str(fit[1])
+      slope, intercept, r_value, p_value, std_err = stats.linregress(data[:,0], data[:,1])
+      metaUser.update({'slope':slope, 'intercept':intercept, 'r_value':r_value, 'p_value':p_value, 'std_err':std_err})
+    elif True or recipe == 'measurement/dkfi':      #: Default | raw data
+      recipe = 'measurement/dkfi'
+  elif dataType=='FZJ':
+    data = pd.read_csv(filePath, delimiter=delimiter, skiprows=startRow, decimal=',')
+    plt.plot(np.array(data['pMax_mN']), np.array(data['E_GPa'])  ,'o',label='Oliver-Pharr')
+    plt.plot(np.array(data['pMax_mN']), np.array(data['E_GPa.1']),'o',label='Image analysis')
+    plt.legend()
+    plt.xlabel('force [$mN$]')
+    plt.ylabel("Young's modulus [$GPa$]")
+    recipe = 'measurement/fzj'
+    metaUser = {'num files':data.shape[0]}
+  elif dataType=='pyIron':
+    ax = plt.figure().add_subplot(projection='3d')
+    ax.plot(np.array(data['Fe (at. %)']),    np.array(data['Si (at. %)']), 'ok', zs=110, zdir='z')
+    ax.scatter(np.array(data['Fe (at. %)']), np.array(data['Si (at. %)']), np.array(data['E (GPa)']), c='b')
+    ax.set_xlabel('Fe (at. %)')
+    ax.set_ylabel('Si (at. %)')
+    ax.set_zlabel('E [GPa]')
+    metaUser = {'num files':data.shape[0], 'max Fe':data['Fe (at. %)'].max(), 'max Si':data['Si (at. %)'].max()}
+    recipe = 'measurement/pyIron'
+  else:
+    data = np.array(data)
+    if recipe == 'measurement/table/red':           #: Draw with red curve
+      plt.plot(data[:,0], data[:,1],'r')
+    elif True or recipe == 'measurement/table/blue': #: Default | blueish curve
+      plt.plot(data[:,0], data[:,1])
+      recipe = 'measurement/table/blue'
+    metaUser = {'max':data[:,1].max(), 'min':data[:,1].min()}
 
   #save to file
   if saveFileName is not None:
     plt.savefig(saveFileName, dpi=150, bbox_inches='tight')
 
   #convert axes to svg image
   figfile = StringIO()
```

## pasta_eln/Extractors/extractor_jpeg.py

```diff
@@ -17,15 +17,14 @@
   Returns:
     dict: containing image, metaVendor, metaUser, recipe
   """
   # Extractor
   image = Image.open(filePath)
   metaVendor = image.info
   imgArr = np.array(image)
-  recipe = 'image/jpeg'
   metaUser   = {'number pixel': imgArr.size,
                 'dimension': imgArr.shape}
 
   #save to file
   imageData = Image.fromarray(imgArr)
   if saveFileName is not None:
     imageData.save(saveFileName)
@@ -33,13 +32,13 @@
   # convert PIL image to base64
   figfile = BytesIO()
   imageData.save(figfile, format="JPEG")
   imageData = base64.b64encode(figfile.getvalue()).decode()
   imageData = "data:image/jpeg;base64," + imageData
 
   # return everything
-  return {'image':imageData, 'recipe':recipe, 'metaVendor':metaVendor, 'metaUser':metaUser}
+  return {'image':imageData, 'recipe':'measurement/image', 'metaVendor':metaVendor, 'metaUser':metaUser}
 
   #other datatypes could follow here if statements are used
   #...
   #final return if nothing successful
   #return {}
```

## pasta_eln/Extractors/extractor_jpg.py

```diff
@@ -1,11 +1,11 @@
 """extract data from vendor
 - default jpg image
 """
-import base64, json
+import base64, json, re
 from io import BytesIO
 import numpy as np
 from PIL import Image
 
 def use(filePath, recipe='', saveFileName=None):
   """
   Args:
@@ -15,17 +15,22 @@
     saveFileName (string): if given, save the image to this file-name
 
   Returns:
     dict: containing image, metaVendor, metaUser, recipe
   """
   # Extractor
   image = Image.open(filePath)
+  maxSize = 400
+  if max(image.size)>maxSize:
+    scale = max(image.size)/maxSize
+    image = image.resize( (np.array(image.size)/scale).astype(int) )
   metaVendor = image.info
+  if 'exif' in metaVendor:
+    metaVendor['exif'] = re.sub(r'[^\x20-\x7F]','', metaVendor['exif'].decode('utf-8', errors='ignore'))
   imgArr = np.array(image)
-  recipe = 'image/jpg'
   metaUser   = {'number pixel': imgArr.size,
                 'dimension': imgArr.shape}
 
   #save to file
   imageData = Image.fromarray(imgArr)
   if saveFileName is not None:
     imageData.save(saveFileName)
@@ -33,13 +38,13 @@
   # convert PIL image to base64
   figfile = BytesIO()
   imageData.save(figfile, format="JPEG")
   imageData = base64.b64encode(figfile.getvalue()).decode()
   imageData = "data:image/jpg;base64," + imageData
 
   # return everything
-  return {'image':imageData, 'recipe':recipe, 'metaVendor':metaVendor, 'metaUser':metaUser}
+  return {'image':imageData, 'recipe':'measurement/image', 'metaVendor':metaVendor, 'metaUser':metaUser}
 
   #other datatypes could follow here if statements are used
   #...
   #final return if nothing successful
   #return {}
```

## pasta_eln/Extractors/extractor_json.py

```diff
@@ -13,17 +13,20 @@
 
   Returns:
     dict: containing image, metaVendor, metaUser, recipe
   """
   # Extractor for fancy instrument
   metaVendor = ''
   with open(filePath,'r', encoding='utf-8') as jsonFile:
-    metaVendor = json.load(jsonFile)
-  recipe = 'json'
+    jsonContent = jsonFile.read()
+    metaVendor = json.loads(jsonContent)
+    if not isinstance(metaVendor, dict):
+      metaVendor= {'content': json.loads(jsonContent)}
   image = ''
+  recipe = '-'
 
   # return everything
   return {'image':image, 'recipe':recipe, 'metaVendor':metaVendor, 'metaUser':{}}
 
   #other datatypes follow here
   #...
   #final return if nothing successful
```

## pasta_eln/Extractors/extractor_md.py

```diff
@@ -9,14 +9,14 @@
     recipe (string): supplied to guide recipes
                      recipe is / separated hierarchical elements parent->child
     saveFileName (string): if given, save the image to this file-name
   Returns:
     dict: containing image, metaVendor, metaUser, recipe
   """
   with open(filePath,'r', encoding='utf-8') as fIn:
-    return {'content':fIn.read(), 'recipe': recipe+'/markdown', 'metaVendor':{}, 'metaUser':{}}
+    return {'content':fIn.read(), 'recipe': 'procedure/markdown', 'metaVendor':{}, 'metaUser':{}}
 
   #other datatypes follow here
   #...
 
   #final return if nothing successful
   # return {}
```

## pasta_eln/Extractors/extractor_png.py

```diff
@@ -25,21 +25,20 @@
     if not isinstance(value, (str, int, float, list)):
       toDelete.append(key)
   for key in toDelete:
     del metaVendor[key]
   imgArr = np.array(image)
   if len(imgArr.shape)==3:
     imgArr = imgArr[:,:,0]
-  if recipe.endswith('crop'):                   #: Crop 3/4 of the image
+  if recipe == 'measurement/image/crop':    #: Crop 3/4 of the image
     newHeight = int(imgArr.shape[0]/2)
     newWidth  = int(imgArr.shape[1]/2)
     imgArr = imgArr[:newHeight, :newWidth]
-    recipe = 'image/png/crop'
-  else:                                         #: Default | uncropped
-    recipe = 'image/png'
+  elif True or recipe == 'measurement/image': #: Default | uncropped
+    recipe = 'measurement/image'
   maskBlackPixel = imgArr<128
   metaUser   = {'number black pixel': len(maskBlackPixel[maskBlackPixel]),
                 'number all pixel': int(np.prod(image.size)) }
 
   #save to file
   imageData = Image.fromarray(imgArr).convert('P')
   if saveFileName is not None:
```

## Comparing `pasta_eln-2.3.9.dist-info/LICENSE` & `pasta_eln-2.4.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `pasta_eln-2.3.9.dist-info/METADATA` & `pasta_eln-2.4.0.dist-info/METADATA`

 * *Files 9% similar despite different names*

```diff
@@ -1,23 +1,24 @@
 Metadata-Version: 2.1
 Name: pasta-eln
-Version: 2.3.9
+Version: 2.4.0
 Summary: The favorite ELN for experimental scientists
 Home-page: https://pasta-eln.github.io/
 Author: The PASTA-ELN Team and Steffen Brinckmann
 Author-email: sbrinckm@gmail.com
 License: MIT
 Platform: UNKNOWN
 Classifier: Programming Language :: Python
 Classifier: License :: OSI Approved :: BSD License
 Classifier: Programming Language :: Python :: 3
 Requires-Python: >=3.7
 Description-Content-Type: text/markdown; charset=UTF-8
 License-File: LICENSE
 Requires-Dist: Pillow
+Requires-Dist: PyYAML
 Requires-Dist: QtAwesome
 Requires-Dist: anytree
 Requires-Dist: cairosvg
 Requires-Dist: cloudant
 Requires-Dist: keyring
 Requires-Dist: matplotlib
 Requires-Dist: numpy
@@ -30,22 +31,25 @@
 Requires-Dist: winshell ; platform_system == "Windows"
 Provides-Extra: devel
 Requires-Dist: coverage ; extra == 'devel'
 Requires-Dist: pytest ; extra == 'devel'
 Requires-Dist: pytest-cov ; extra == 'devel'
 Requires-Dist: pytest-qt ; extra == 'devel'
 Requires-Dist: pytest-xvfb ; extra == 'devel'
+Requires-Dist: sphinx ; extra == 'devel'
+Requires-Dist: sphinx-rtd-theme ; extra == 'devel'
 
 
 [![PyPI version](https://badge.fury.io/py/pasta-eln.svg)](https://badge.fury.io/py/pasta-eln)
 [![GitHub version](https://badge.fury.io/gh/PASTA-ELN%2Fpasta-eln.svg)](https://badge.fury.io/gh/PASTA-ELN%2Fpasta-eln)
 [![PyPi build](https://github.com/PASTA-ELN/pasta-eln/actions/workflows/pypi.yml/badge.svg)](https://github.com/PASTA-ELN/pasta-eln/actions/workflows/pypi.yml)
 [![Verify Linux install](https://github.com/PASTA-ELN/pasta-eln/actions/workflows/installLinux.yml/badge.svg)](https://github.com/PASTA-ELN/pasta-eln/actions/workflows/installLinux.yml)
 [![Documentation building](https://github.com/PASTA-ELN/pasta-eln/actions/workflows/docbuild.yml/badge.svg)](https://github.com/PASTA-ELN/pasta-eln/actions/workflows/docbuild.yml)
 [![Linting](https://github.com/PASTA-ELN/pasta-eln/actions/workflows/pylint.yml/badge.svg)](https://github.com/PASTA-ELN/pasta-eln/actions/workflows/pylint.yml)
+[![MyPy](https://github.com/PASTA-ELN/pasta-eln/actions/workflows/mypy.yml/badge.svg)](https://github.com/PASTA-ELN/pasta-eln/actions/workflows/mypy.yml)
 
 # PASTA electronic lab notebook (ELN) | The favorite ELN for experimental scientists
 
 Pasta-dishes are a mixture pasta and sauce, the latter adds flavors and richness to the otherwise boring pasta. This ELN combines raw-data with rich metadata to allow advanced data science. In the database, one can fully adapt and improvise the metadata definitions to generate something novel. PASTA-ELN uses a local-first approach: store all data and metadata locally (always accessible to user) and synchronize with a server upon user request.
 
 ## Location of information
 More information, incl. detailed installation instructions, for users can be found on the [Github-pages](https://pasta-eln.github.io/pasta-eln/).
```

## Comparing `pasta_eln-2.3.9.dist-info/RECORD` & `pasta_eln-2.4.0.dist-info/RECORD`

 * *Files 17% similar despite different names*

```diff
@@ -1,50 +1,49 @@
-pasta_eln/__init__.py,sha256=oVKobfT11pzrfjc8Ag1kFoJ30FmgK48DU0mMGtjx9Dk,46
-pasta_eln/backend.py,sha256=daGI5yF9KZF30oznjhJVMafwFzDwis6GNMNFGt6WAoI,29288
-pasta_eln/cli.py,sha256=aWJLKc6StjaX0NUOG0F_iCElZGbC7_WueM6NraXZpeo,13707
-pasta_eln/communicate.py,sha256=9kpDtb7aRruV3hG4Bg3b8WJKGwf5tyxYdi_-G3lNTN8,977
-pasta_eln/database.py,sha256=j-IS1zKW2LhU_UWM8MiYaPVgaDYQMk1KEWfoH3SRyH4,36715
-pasta_eln/dialogConfig.py,sha256=RZYzgVQCHOQj2aUfoMGcH3ZAj9sL_gY9J8lFAaIYhOQ,1666
-pasta_eln/dialogConfigGUI.py,sha256=lvcux8caciHLKW0bp218Y2i5QeIOVK9O0KY_UbI8np8,3365
-pasta_eln/dialogConfigSetupLinux.py,sha256=wu6rUyzvfECBAH-Dy6MgU4GfnYUZKb4CfrE-QLuy7Ms,5348
-pasta_eln/dialogConfigSetupWindows.py,sha256=gmWiLz2RpYQ7So2sFvroF2g1sn0vKx5MdOX3U_bOeS0,6340
-pasta_eln/dialogForm.py,sha256=qf0mfXFslyUY3nEdVWR1-aMSsmjHSikvMLy2Qpnb7LA,11334
-pasta_eln/dialogOntology.py,sha256=0onkvQXTIEUuZD3bIJ-C2kTZNLKA62MmqOFtsuAihfE,1293
-pasta_eln/dialogProjectGroup.py,sha256=hiUPr8VlSIqmc6nIKfiCKzEOSdbBihJueCjVWUANqLY,9042
-pasta_eln/dialogTableHeader.py,sha256=Fgf7PHGUfNNioSExYb8O_mEJXDT72P_3N88em3lnt8I,5588
-pasta_eln/fixedStrings.py,sha256=WnTThfydnjeYQ_1PQsneyunqzGdlsyrssfoqXG1CgkI,5349
-pasta_eln/gui.py,sha256=muUpUCkKGtYkCuUDi2UOXWwRpOrnvpkfBX8l5XZJyBM,8305
-pasta_eln/gui.py.orig,sha256=jsaDhWLZIdRp1Ha4-SXFYrWd8e935o6q6lovXdk7lb0,7941
-pasta_eln/handleDictionaries.py,sha256=m9cc4xmboVC11idiwOqd2BusGFLE3FllK95Po4Z10Hk,4395
-pasta_eln/inputOutput.py,sha256=wSNeyPNz28wHKLF6xoAxmEB1sldhcnkxqMv8RMyupCQ,15445
-pasta_eln/installationTools.py,sha256=GQd9s2lLFnB-O-MvMpyhDj4XPRy0C_Yp32myI-Bog1A,21395
-pasta_eln/miscTools.py,sha256=FcJfcoYpQUzSFGwfWih3Xf7-DihGAc5k_Bp7eTTNqm4,6541
-pasta_eln/mixin_cli.py,sha256=RMMi600zxBiXH-3apXkaMGrtdh4b_Or3UpPQJq72VFY,7602
-pasta_eln/printer.py,sha256=kTT59EXTwpaoSg1422xRylQy7vLr2Uth-6vufEVwKV4,3764
-pasta_eln/serverActions.py,sha256=1cZIwo3mB20h2q_U8lAJwaGpqoRGWmDEh0fQRj6CYFs,19199
-pasta_eln/style.py,sha256=Sz3UuwwPSfggN62Imaj35R9EDm6rIMJuVKfrw_bFmss,7871
-pasta_eln/tempStrings.py,sha256=aXJBWF9fttH7Auh23yRgXqa-ppi0jXilEg6WME66yb8,1234
-pasta_eln/widgetBody.py,sha256=-euqDTwCjYVkh8wRKXG7U5wwnqtyzNIF20hM-Yu-KKE,1340
-pasta_eln/widgetDetails.py,sha256=fEBvbGlYO2-v78XU_kDhy0bBNJkT3RUw_GPdM-0SjuY,8370
-pasta_eln/widgetDocTypes.py,sha256=GTnkSU8pFQOyqFwAObjucVUb39rTyPkdJJ_Ok4DsI6Q,1243
-pasta_eln/widgetProject.py,sha256=x8Gbt868Gx8HMZ1aRiku77Ux08QgWui2qOV6LXssgLc,10151
-pasta_eln/widgetProjectLeafRenderer.py,sha256=XtVuobPSnyySDrCwvfHLm8hDiWpGGvvILQp2955MX9I,5192
-pasta_eln/widgetProjectTreeView.py,sha256=euRnHKU6fLTuXr3A_sMX__mi7FQLnkQ5M7oblGcTEAU,4453
-pasta_eln/widgetSidebar.py,sha256=WVPaRKQuXdxqMRNayI7pCyVVRQkhwC1DFJ3MXHlBJBg,7297
-pasta_eln/widgetTable.py,sha256=G-vd_vUhWJPJ8427FXBa86NWsDTpL1KMOsz28RtBAdQ,13168
+pasta_eln/__init__.py,sha256=X47g8LEtsBB1V0zicmXzzHs3Pz2ZsJJAeVFNe7lJOfI,46
+pasta_eln/backend.py,sha256=pTt2EPlPqb7TLKgzJ5V9LVoCgGThVULeN1-sWgENtKY,34824
+pasta_eln/cli.py,sha256=IKLdSOJEOSeQwMbF3ATawJQNwUKdhurcUYOXGEXSXnE,14028
+pasta_eln/communicate.py,sha256=paQakE_zrN8X8F2L0G4DikW116K1jCyGG5tNlIQB7MU,1429
+pasta_eln/database.py,sha256=DSGCio0V2rYhx2YPJEp9LLWhy8D3S7--h5wStkFGc_M,41851
+pasta_eln/dialogConfig.py,sha256=SViPpYkXHy_9IpOclvqLNJlXHqVgmnvtYI2IiKKOGZc,1513
+pasta_eln/dialogConfigGUI.py,sha256=-sW4d2v_--5G6MwIwIQItswUh3GnAI5eCp_1NiZP_3U,3520
+pasta_eln/dialogConfigSetupLinux.py,sha256=GbFR4p_po7I_xnq0hQc04KnVDwbeuyQx-p1zI-ETer8,5178
+pasta_eln/dialogConfigSetupWindows.py,sha256=6yp9lE0A3CBLX2eKj7cRVe2No4c31zw6pyg2prN8hSI,6323
+pasta_eln/dialogForm.py,sha256=QIXtL92i8spmjGTsjC2iJxwOi4LJarG22ttnZETefNg,20797
+pasta_eln/dialogOntology.py,sha256=OpcGx3O-abSSFwroxRMb5aXx3BOaf2y-QM8JIRvD52E,1291
+pasta_eln/dialogProjectGroup.py,sha256=7Ycp1r6MhTmPKSBhNeQaqz9v1h0Rm46gHrcLoe2ouMM,9004
+pasta_eln/dialogTableHeader.py,sha256=rk1jzVV2ZVvjr2bcK2F3JZxFSy6264iHARWMfhJCI6s,5468
+pasta_eln/fixedStrings.py,sha256=UWJCijHywelikrpWVnOHFa_6NEgBi-IHDso72Pzg7b0,5233
+pasta_eln/gui.py,sha256=XQslaEN42CMuFFYpKhfnW3ErTy3PMdMp7slPlKxvgh4,9559
+pasta_eln/handleDictionaries.py,sha256=GQ3lIclyWBQ7n3auwjkIdQbP8XW5hfrl5N8Bwg4480s,5750
+pasta_eln/inputOutput.py,sha256=Yt7nziszG2ctofxD6UCKqZirhI1bueMjFT57MPmrgwA,13588
+pasta_eln/installationTools.py,sha256=jNCCeyLgkEa3peMZRU7WZUUcY1zOtUnlFC3alBH_ROE,23058
+pasta_eln/miscTools.py,sha256=usOezqnzMNNiOE6U-w0d37QojI_ftvTc9gkthN5PECo,10273
+pasta_eln/mixin_cli.py,sha256=-lrh2GJfvNVqBkvf5p-y2eZUSDTsRhTJn1KBOoXRqTs,5714
+pasta_eln/printer.py,sha256=7-IY_Gd5EqfwlPIt-Eb7JMkGgn9faMKGHFk40cbeQco,3851
+pasta_eln/serverActions.py,sha256=iKJJwzT-ijlaJ_SL9p82vPlGUBT-L9R_woCcB-wt0yY,21356
+pasta_eln/style.py,sha256=aZInNUNdcG2_43ZPGNq5z4Ytr7NAPE4rOx-B6UoJN2A,11408
+pasta_eln/tempStrings.py,sha256=ZsWIJFSpu9tPFhN8xhspjnoZrBVS1DaawGxmTlkzaOs,2335
+pasta_eln/widgetBody.py,sha256=FZalRP55FbRZf32MMYkIyxNu5OlVBvJY9T-rBYET2V8,1519
+pasta_eln/widgetDetails.py,sha256=6MAzJn9mydsgYwYBIZG8Xp2KsqDk9sEzt2PXagFWfM4,11672
+pasta_eln/widgetDocTypes.py,sha256=cp-o3gfhkBse98DUEeeaFdccMehLao3wgmaUyJSfWHM,1666
+pasta_eln/widgetProject.py,sha256=o6DHTs6A7uUJMDZo2PbbQDQEvvajtaWyCaCoh9lYgwY,11633
+pasta_eln/widgetProjectLeafRenderer.py,sha256=E39QbSavl5yWDaBBKYUl3ozhA8p_rEFWHX_msQTteiU,8873
+pasta_eln/widgetProjectTreeView.py,sha256=CYxV76p0sqYvsa17M2OGbbx8P2q7G2dgSHHV1rdwYs8,7349
+pasta_eln/widgetSidebar.py,sha256=dC-cWz9so97oa5nzVXJIXwYyIt83tyPE3JUWnA3ddSc,8521
+pasta_eln/widgetTable.py,sha256=2jUo9DqHxsAkXEBONeEKiwWvBT6lzodT_CUNMxgfahg,18564
 pasta_eln/Extractors/README.md,sha256=EookF0Yv-HrTrND6IEs4SuhKNDBOdMF2DjWXFj9ZBoU,356
-pasta_eln/Extractors/extractor_csv.py,sha256=ZMx3ZV07GwHYPAsNqznXgNJbQFBgWMxHlBMHXDSdzAo,1473
-pasta_eln/Extractors/extractor_jpeg.py,sha256=cvmd9khDKSBq9dVqlEQ9fUJLVl9MAuaIiseYPGYzKyw,1286
-pasta_eln/Extractors/extractor_jpg.py,sha256=F2lovVIO7YPCS0LWDB8rPAKHHWpwbR-aMzfDP-_ifq4,1283
-pasta_eln/Extractors/extractor_json.py,sha256=vHi8D_g4FTo51xnNG2rChL0BFC0NgzBAyRKDBIka3ss,822
-pasta_eln/Extractors/extractor_md.py,sha256=1h0zaPM-kPasFB0wFTWfio8kCFzWhTI6jnKWB5nuCIw,679
-pasta_eln/Extractors/extractor_png.py,sha256=PrqeEPV4Eic9w8ufZLzZ_gvpISB1JNUb1VQwgV3lLs8,1903
+pasta_eln/Extractors/extractor_csv.py,sha256=lctirVGePM7izC9SPywf2a7NR7KyyJ5TUqFw7pShlhM,4895
+pasta_eln/Extractors/extractor_jpeg.py,sha256=nVQPPBpb6G1Eckwt-bblTlgEVLeCDC6E74LvN4Wm5qc,1275
+pasta_eln/Extractors/extractor_jpg.py,sha256=4EkWFDGL-GNJx-uJoAVGjwdfxm4Nei3Ihr0VWZPQrCk,1560
+pasta_eln/Extractors/extractor_json.py,sha256=V02ZW7Zo47xKe4zBfV6dg2RoSj66WQcyfJH5laCrDE8,953
+pasta_eln/Extractors/extractor_md.py,sha256=kxFG4PhWkCcH0DLi2dZQbuIF5nwNFzFxYuGVZj9CBVE,681
+pasta_eln/Extractors/extractor_png.py,sha256=CLJlQB3p8Icp_Mbchtl6ahvqqfylnFfa3BkD5rBmd9g,1875
 pasta_eln/Resources/ExampleMeasurements/simple.csv,sha256=jjFFDNmaATgB3p-E4tNkjsjXDdC21b4jx8yCeCqQunM,187
 pasta_eln/Resources/ExampleMeasurements/simple.png,sha256=6LniA-_zI3mmm7N4XlGl7c6Kp_xICcaW6ujd7nurghA,9450
 pasta_eln/Resources/Icons/favicon64.ico,sha256=vveTOeo95-Wmv3ES5gp1FYiE-y9WdxSMDIVPSTVEcqY,5694
 pasta_eln/Resources/Icons/favicon64.png,sha256=vbdaxqyXk5nKiMasATvOMv5sDlSarWrzIXn5qSX69ik,2161
-pasta_eln-2.3.9.dist-info/LICENSE,sha256=czf-VGQ2cp4m5_iQpsMhV5xBreZPJZa58Xi7hxMUMs0,1613
-pasta_eln-2.3.9.dist-info/METADATA,sha256=k6F5AsKFQ4WwRSI7KXcxmBHRrhAx_TmZKhO1QAUuBn8,3249
-pasta_eln-2.3.9.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-pasta_eln-2.3.9.dist-info/entry_points.txt,sha256=lg1LNjxltRABk9eiBjpMqGWGj60m0klbQ1Ly-sOBHcA,150
-pasta_eln-2.3.9.dist-info/top_level.txt,sha256=vRI0uEQNtWCKGRYA0FVyVsiosAcVlxIRApBZqa4vQVk,10
-pasta_eln-2.3.9.dist-info/RECORD,,
+pasta_eln-2.4.0.dist-info/LICENSE,sha256=czf-VGQ2cp4m5_iQpsMhV5xBreZPJZa58Xi7hxMUMs0,1613
+pasta_eln-2.4.0.dist-info/METADATA,sha256=_iuygmXvJsx4OGmchDAXC6NsmD6o5Hlw2BYH6yKo0nc,3517
+pasta_eln-2.4.0.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
+pasta_eln-2.4.0.dist-info/entry_points.txt,sha256=lg1LNjxltRABk9eiBjpMqGWGj60m0klbQ1Ly-sOBHcA,150
+pasta_eln-2.4.0.dist-info/top_level.txt,sha256=vRI0uEQNtWCKGRYA0FVyVsiosAcVlxIRApBZqa4vQVk,10
+pasta_eln-2.4.0.dist-info/RECORD,,
```


# Comparing `tmp/ptrlib-2.0.8-py3-none-any.whl.zip` & `tmp/ptrlib-2.0.9-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,8 +1,8 @@
-Zip file size: 124129 bytes, number of entries: 161
+Zip file size: 125899 bytes, number of entries: 161
 -rw-rw-r--  2.0 unx      423 b- defN 23-May-20 15:23 ptrlib/__init__.py
 -rw-rw-r--  2.0 unx       28 b- defN 23-Jan-21 06:41 ptrlib/algorithm/__init__.py
 -rw-rw-r--  2.0 unx      116 b- defN 23-Jan-21 06:41 ptrlib/algorithm/shortestpath/__init__.py
 -rw-rw-r--  2.0 unx      287 b- defN 23-Jan-21 06:41 ptrlib/algorithm/shortestpath/base.py
 -rw-rw-r--  2.0 unx     1360 b- defN 23-Jan-21 06:41 ptrlib/algorithm/shortestpath/shortestpath.py
 -rw-rw-r--  2.0 unx      941 b- defN 23-Jan-21 06:41 ptrlib/algorithm/shortestpath/types.py
 -rw-rw-r--  2.0 unx      102 b- defN 23-Jan-21 06:41 ptrlib/algorithm/shortestpath/algorithms/__init__.py
@@ -31,32 +31,32 @@
 -rw-rw-r--  2.0 unx    14542 b- defN 23-Jan-21 06:41 ptrlib/arch/intel/syscall.py
 -rw-rw-r--  2.0 unx       45 b- defN 23-Jan-21 06:41 ptrlib/arch/linux/__init__.py
 -rw-rw-r--  2.0 unx      465 b- defN 23-Mar-12 14:56 ptrlib/arch/linux/ospath.py
 -rw-rw-r--  2.0 unx      723 b- defN 23-Jan-21 06:41 ptrlib/arch/linux/syscall.py
 -rw-rw-r--  2.0 unx       98 b- defN 23-Jan-21 06:41 ptrlib/binary/__init__.py
 -rw-rw-r--  2.0 unx       90 b- defN 23-May-09 11:53 ptrlib/binary/encoding/__init__.py
 -rw-rw-r--  2.0 unx      220 b- defN 23-May-09 11:55 ptrlib/binary/encoding/bitconv.py
--rw-rw-r--  2.0 unx     2678 b- defN 23-May-20 15:44 ptrlib/binary/encoding/byteconv.py
+-rw-rw-r--  2.0 unx     4332 b- defN 23-Jun-26 09:53 ptrlib/binary/encoding/byteconv.py
 -rw-rw-r--  2.0 unx     1552 b- defN 23-Jan-21 06:41 ptrlib/binary/encoding/locale.py
 -rw-rw-r--  2.0 unx      520 b- defN 23-Jan-21 06:41 ptrlib/binary/encoding/table.py
 -rw-rw-r--  2.0 unx       41 b- defN 23-Jan-21 06:41 ptrlib/binary/operation/__init__.py
 -rw-rw-r--  2.0 unx     1374 b- defN 23-Jan-21 06:41 ptrlib/binary/operation/rotate.py
 -rw-rw-r--  2.0 unx     1048 b- defN 23-Jan-21 06:41 ptrlib/binary/operation/xor.py
 -rw-rw-r--  2.0 unx       84 b- defN 23-Jan-21 06:41 ptrlib/binary/packing/__init__.py
 -rw-rw-r--  2.0 unx     1006 b- defN 23-Jan-21 06:41 ptrlib/binary/packing/chunks.py
 -rw-rw-r--  2.0 unx      821 b- defN 23-Jan-21 06:41 ptrlib/binary/packing/flat.py
 -rw-rw-r--  2.0 unx     1437 b- defN 23-Jan-21 06:41 ptrlib/binary/packing/pack.py
 -rw-rw-r--  2.0 unx     3547 b- defN 23-Feb-02 14:11 ptrlib/binary/packing/unpack.py
 -rw-rw-r--  2.0 unx       26 b- defN 23-Jan-21 06:41 ptrlib/binary/statistics/__init__.py
 -rw-rw-r--  2.0 unx     1584 b- defN 23-Jan-21 06:41 ptrlib/binary/statistics/statistics.py
 -rw-rw-r--  2.0 unx       82 b- defN 23-Jan-21 06:41 ptrlib/connection/__init__.py
--rw-rw-r--  2.0 unx     6623 b- defN 23-May-20 15:12 ptrlib/connection/proc.py
+-rw-rw-r--  2.0 unx     6899 b- defN 23-Jun-26 09:54 ptrlib/connection/proc.py
 -rw-rw-r--  2.0 unx     4671 b- defN 23-May-20 15:05 ptrlib/connection/sock.py
 -rw-rw-r--  2.0 unx     1919 b- defN 23-Jan-21 06:41 ptrlib/connection/ssh.py
--rw-rw-r--  2.0 unx    11649 b- defN 23-May-20 15:41 ptrlib/connection/tube.py
+-rw-rw-r--  2.0 unx    12696 b- defN 23-Jun-26 09:50 ptrlib/connection/tube.py
 -rw-rw-r--  2.0 unx     7271 b- defN 23-Feb-16 07:43 ptrlib/connection/winproc.py
 -rw-rw-r--  2.0 unx       21 b- defN 23-Jan-21 06:41 ptrlib/console/__init__.py
 -rw-rw-r--  2.0 unx     1461 b- defN 23-May-20 15:24 ptrlib/console/color.py
 -rw-rw-r--  2.0 unx      112 b- defN 23-Jan-21 06:41 ptrlib/crypto/__init__.py
 -rw-rw-r--  2.0 unx       64 b- defN 23-Jan-21 06:41 ptrlib/crypto/blockcipher/__init__.py
 -rw-rw-r--  2.0 unx     1396 b- defN 23-Jan-21 06:41 ptrlib/crypto/blockcipher/ecb.py
 -rw-rw-r--  2.0 unx     3829 b- defN 23-Jan-21 06:41 ptrlib/crypto/blockcipher/padcbc.py
@@ -83,17 +83,17 @@
 -rw-rw-r--  2.0 unx       19 b- defN 23-Jan-21 06:41 ptrlib/filestruct/elf/__init__.py
 -rw-rw-r--  2.0 unx    14938 b- defN 23-Apr-01 03:57 ptrlib/filestruct/elf/elf.py
 -rw-rw-r--  2.0 unx    35234 b- defN 23-Jan-21 06:41 ptrlib/filestruct/elf/enums.py
 -rw-rw-r--  2.0 unx     6418 b- defN 23-Jan-21 06:41 ptrlib/filestruct/elf/parser.py
 -rw-rw-r--  2.0 unx     5410 b- defN 23-Jan-21 06:41 ptrlib/filestruct/elf/structs.py
 -rw-rw-r--  2.0 unx       18 b- defN 23-Apr-14 22:24 ptrlib/filestruct/pe/__init__.py
 -rw-rw-r--  2.0 unx      607 b- defN 23-Apr-15 06:18 ptrlib/filestruct/pe/enums.py
--rw-rw-r--  2.0 unx     6348 b- defN 23-Apr-16 08:05 ptrlib/filestruct/pe/parser.py
--rw-rw-r--  2.0 unx     1123 b- defN 23-Apr-16 08:17 ptrlib/filestruct/pe/pe.py
--rw-rw-r--  2.0 unx     8162 b- defN 23-Apr-16 08:04 ptrlib/filestruct/pe/structs.py
+-rw-rw-r--  2.0 unx     7970 b- defN 23-May-21 12:36 ptrlib/filestruct/pe/parser.py
+-rw-rw-r--  2.0 unx     4514 b- defN 23-May-21 12:46 ptrlib/filestruct/pe/pe.py
+-rw-rw-r--  2.0 unx     9046 b- defN 23-May-21 11:56 ptrlib/filestruct/pe/structs.py
 -rw-rw-r--  2.0 unx       62 b- defN 23-Jan-21 06:41 ptrlib/pwn/__init__.py
 -rw-rw-r--  2.0 unx       39 b- defN 23-Jan-21 06:41 ptrlib/pwn/dynlink/__init__.py
 -rw-rw-r--  2.0 unx     1979 b- defN 23-Jan-21 06:41 ptrlib/pwn/dynlink/dl.py
 -rw-rw-r--  2.0 unx     2769 b- defN 23-Jan-21 06:41 ptrlib/pwn/dynlink/robot.py
 -rw-rw-r--  2.0 unx       19 b- defN 23-Jan-21 06:41 ptrlib/pwn/fsb/__init__.py
 -rw-rw-r--  2.0 unx     4546 b- defN 23-Jan-21 06:41 ptrlib/pwn/fsb/fsb.py
 -rw-rw-r--  2.0 unx       23 b- defN 23-Jan-21 06:41 ptrlib/pwn/fuzz/__init__.py
@@ -103,15 +103,15 @@
 -rw-rw-r--  2.0 unx     3389 b- defN 23-Jan-21 06:41 tests/algorithm/shortestpath/test_shortestpath.py
 -rw-rw-r--  2.0 unx        0 b- defN 23-Jan-21 06:41 tests/arch/__init__.py
 -rw-rw-r--  2.0 unx     1252 b- defN 23-May-09 12:16 tests/arch/test_cpu.py
 -rw-rw-r--  2.0 unx      988 b- defN 23-May-09 08:25 tests/arch/test_simd.py
 -rw-rw-r--  2.0 unx     1120 b- defN 23-May-09 08:02 tests/arch/test_syscall.py
 -rw-rw-r--  2.0 unx        0 b- defN 23-Jan-21 06:41 tests/binary/__init__.py
 -rw-rw-r--  2.0 unx        0 b- defN 23-Jan-21 06:41 tests/binary/encoding/__init__.py
--rw-rw-r--  2.0 unx     1470 b- defN 23-May-20 15:36 tests/binary/encoding/test_byteconv.py
+-rw-rw-r--  2.0 unx     1951 b- defN 23-Jun-26 09:58 tests/binary/encoding/test_byteconv.py
 -rw-rw-r--  2.0 unx     2787 b- defN 23-Jan-21 06:41 tests/binary/encoding/test_locale.py
 -rw-rw-r--  2.0 unx        0 b- defN 23-Jan-21 06:41 tests/binary/operation/__init__.py
 -rw-rw-r--  2.0 unx     1273 b- defN 23-Jan-21 06:41 tests/binary/operation/test_rotate.py
 -rw-rw-r--  2.0 unx      654 b- defN 23-Jan-21 06:41 tests/binary/operation/test_xor.py
 -rw-rw-r--  2.0 unx        0 b- defN 23-Jan-21 06:41 tests/binary/packing/__init__.py
 -rw-rw-r--  2.0 unx      847 b- defN 23-Jan-21 06:41 tests/binary/packing/test_chunks.py
 -rw-rw-r--  2.0 unx      580 b- defN 23-Jan-21 06:41 tests/binary/packing/test_flat.py
@@ -150,14 +150,14 @@
 -rw-rw-r--  2.0 unx     1613 b- defN 23-Jan-21 06:41 tests/filestruct/elf/test_elf_5.py
 -rw-rw-r--  2.0 unx     1124 b- defN 23-Jan-21 06:41 tests/filestruct/elf/test_elf_6.py
 -rw-rw-r--  2.0 unx     1108 b- defN 23-Jan-21 06:41 tests/filestruct/elf/test_elf_7.py
 -rw-rw-r--  2.0 unx      574 b- defN 23-Jan-21 06:41 tests/filestruct/elf/test_elf_8.py
 -rw-rw-r--  2.0 unx        0 b- defN 23-Jan-21 06:41 tests/pwn/__init__.py
 -rw-rw-r--  2.0 unx     1877 b- defN 23-Jan-21 06:41 tests/pwn/test_fsb.py
 -rw-rw-r--  2.0 unx     1988 b- defN 23-Jan-21 06:41 tests/pwn/test_fuzz.py
--rw-rw-r--  2.0 unx     1069 b- defN 23-May-20 15:52 ptrlib-2.0.8.dist-info/LICENSE.txt
--rw-rw-r--  2.0 unx     3535 b- defN 23-May-20 15:52 ptrlib-2.0.8.dist-info/METADATA
--rw-rw-r--  2.0 unx       92 b- defN 23-May-20 15:52 ptrlib-2.0.8.dist-info/WHEEL
--rw-rw-r--  2.0 unx       48 b- defN 23-May-20 15:52 ptrlib-2.0.8.dist-info/entry_points.txt
--rw-rw-r--  2.0 unx       13 b- defN 23-May-20 15:52 ptrlib-2.0.8.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx    14073 b- defN 23-May-20 15:52 ptrlib-2.0.8.dist-info/RECORD
-161 files, 329819 bytes uncompressed, 101693 bytes compressed:  69.2%
+-rw-rw-r--  2.0 unx     1069 b- defN 23-Jun-26 10:02 ptrlib-2.0.9.dist-info/LICENSE.txt
+-rw-rw-r--  2.0 unx     3535 b- defN 23-Jun-26 10:02 ptrlib-2.0.9.dist-info/METADATA
+-rw-rw-r--  2.0 unx       92 b- defN 23-Jun-26 10:02 ptrlib-2.0.9.dist-info/WHEEL
+-rw-rw-r--  2.0 unx       48 b- defN 23-Jun-26 10:02 ptrlib-2.0.9.dist-info/entry_points.txt
+-rw-rw-r--  2.0 unx       13 b- defN 23-Jun-26 10:02 ptrlib-2.0.9.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx    14073 b- defN 23-Jun-26 10:02 ptrlib-2.0.9.dist-info/RECORD
+161 files, 339174 bytes uncompressed, 103463 bytes compressed:  69.5%
```

## zipnote {}

```diff
@@ -459,26 +459,26 @@
 
 Filename: tests/pwn/test_fsb.py
 Comment: 
 
 Filename: tests/pwn/test_fuzz.py
 Comment: 
 
-Filename: ptrlib-2.0.8.dist-info/LICENSE.txt
+Filename: ptrlib-2.0.9.dist-info/LICENSE.txt
 Comment: 
 
-Filename: ptrlib-2.0.8.dist-info/METADATA
+Filename: ptrlib-2.0.9.dist-info/METADATA
 Comment: 
 
-Filename: ptrlib-2.0.8.dist-info/WHEEL
+Filename: ptrlib-2.0.9.dist-info/WHEEL
 Comment: 
 
-Filename: ptrlib-2.0.8.dist-info/entry_points.txt
+Filename: ptrlib-2.0.9.dist-info/entry_points.txt
 Comment: 
 
-Filename: ptrlib-2.0.8.dist-info/top_level.txt
+Filename: ptrlib-2.0.9.dist-info/top_level.txt
 Comment: 
 
-Filename: ptrlib-2.0.8.dist-info/RECORD
+Filename: ptrlib-2.0.9.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## ptrlib/binary/encoding/byteconv.py

```diff
@@ -1,8 +1,8 @@
-from typing import Tuple
+from typing import Tuple, List
 from logging import getLogger
 
 logger = getLogger(__name__)
 
 
 def bytes2str(data: bytes) -> str:
     """Convert bytes to str
@@ -19,74 +19,116 @@
         try:
             return bytes(list(map(ord, data)))
         except ValueError:
             return data.encode('utf-8')
     else:
         raise ValueError("{} given ('str' expected)".format(type(data)))
 
-def bytes2utf8(data: bytes) -> Tuple[str, bytes]:
-    """Convert bytes to UTF-8
+def bytes2utf8(data: bytes) -> Tuple[str, bytes, List[bool]]:
+    """Convert bytes to UTF-8 (!!! EXPERIMENTAL !!!)
 
     Convert byte array into UTF-8 string.
     This function also returns the leftover bytes that cannot not
     be interpreted as UTF-8.
     If it encounters an invalid character, the byte will be directly
     converted into a character just like `bytes2str` do.
 
     Args:
         data: Byte array to convert into UTF-8 (bytes)
 
     Returns:
-        tuple(str, bytes): UTF-8 string and leftover bytes
+        tuple(str, bytes, list): UTF-8 string, leftover bytes, and marker indicating if each character is valid as UTF-8.
     """
     output = ''
     leftover = b''
+    marker = []
     i = 0
     while i < len(data):
         c1 = data[i]
         if (c1 >> 5) & 0b111 == 0b110: # 2 bytes
             if i + 1 >= len(data):
-                leftover = data[i:]
+                leftover = data[i:] # 1 byte left
                 break
             c2 = data[i+1]
             if (c2 >> 6) & 0b11 == 0b10:
-                char = bytes([c1, c2]).decode('utf-8')
-                i += 2
-            else:
+                try:
+                    char = bytes([c1, c2]).decode('utf-8')
+                    i += 2
+                    marker.append(True)
+                except UnicodeDecodeError:
+                    # Sequence of `c1` `c2` is invalid as UTF-8
+                    char = chr(c1)
+                    i += 1
+                    marker.append(False)
+            else: # `c1` is invalid as UTF-8
                 char = chr(c1)
                 i += 1
+                marker.append(False)
             output += char
 
         elif (c1 >> 4) & 0b1111 == 0b1110: # 3 bytes
             if i + 2 >= len(data):
                 leftover = data[i:]
                 break
             c2, c3 = data[i+1], data[i+2]
             if (c2 >> 6) & 0b11 == 0b10 and \
                (c3 >> 6) & 0b11 == 0b10:
-                char = bytes([c1, c2, c3]).decode('utf-8')
-                i += 3
+                try:
+                    char = bytes([c1, c2, c3]).decode('utf-8')
+                    i += 3
+                    marker.append(True)
+                except UnicodeDecodeError:
+                    # Sequence of `c1` `c2` `c3` is invalid as UTF-8
+                    char = chr(c1)
+                    i += 1
+                    marker.append(False)
             else:
                 char = chr(c1)
                 i += 1
+                marker.append(False)
             output += char
 
         elif (c1 >> 3) & 0b11111 == 0b11110: # 4 bytes
             if i + 3 >= len(data):
                 leftover = data[i:]
                 break
             c2, c3, c4 = data[i+1:i+4]
             if (c2 >> 6) & 0b11 == 0b10 and \
                (c3 >> 6) & 0b11 == 0b10 and \
                (c4 >> 6) & 0b11 == 0b10:
-                char = bytes([c1, c2, c3, c4]).decode('utf-8')
-                i += 4
+                try:
+                    char = bytes([c1, c2, c3, c4]).decode('utf-8')
+                    i += 4
+                    marker.append(True)
+                except UnicodeDecodeError:
+                    # Sequence of `c1` `c2` `c3` `c4` is invalid as UTF-8
+                    char = chr(c1)
+                    i += 1
+                    marker.append(False)
             else:
                 char = chr(c1)
                 i += 1
+                marker.append(False)
             output += char
 
         else: # 1 byte or invalid
             output += chr(c1)
             i += 1
+            marker.append(True)
+
+    return output, leftover, marker
+
+def bytes2hex(data: bytes) -> str:
+    """Convert bytes to hex string
+    """
+    if isinstance(data, bytes):
+        return ''.join(list(map(lambda c: f'\\x{c:02x}', data)))
+    else:
+        raise ValueError("{} given ('bytes' expected)".format(type(data)))
 
-    return output, leftover
+def str2hex(data: str) -> str:
+    """Convert string to hex string
+    """
+    if isinstance(data, str):
+        return bytes2hex(data.encode())
+    else:
+        raise ValueError("{} given ('str' expected)".format(type(data)))
```

## ptrlib/connection/proc.py

```diff
@@ -191,20 +191,25 @@
         """Close the socket
 
         Close the socket.
         This method is called from the destructor.
         """
         if self.proc:
             os.close(self.slave)
-            self.proc.stdin.close()
-            self.proc.stdout.close()
-            self.proc.kill()
-            self.proc.wait()
-            self.proc = None
-            logger.info("'{0}' killed".format(self.filepath))
+            if self.is_alive():
+                self.proc.stdin.close()
+                self.proc.stdout.close()
+                self.proc.kill()
+                self.proc.wait()
+                logger.info("'{0}' (PID={1}) killed".format(self.filepath, self.proc.pid))
+                self.proc = None
+            else:
+                self.proc.stdout.close()
+                logger.info("'{0}' (PID={1}) has already exited".format(self.filepath, self.proc.pid))
+                self.proc = None
 
     def shutdown(self, target: Literal['send', 'recv']):
         """Kill one connection
 
         Close send/recv pipe.
 
         Args:
```

## ptrlib/connection/tube.py

```diff
@@ -310,22 +310,43 @@
         """
         self.interactive(timeout)
 
     def interactive(self, timeout: Optional[Union[int, float]]=None):
         """Interactive mode
         """
         def thread_recv():
+            prev_leftover = None
             while not flag.isSet():
                 try:
                     data = self.recv(size=4096, timeout=0.1)
                     if data is not None:
-                        utf8str, leftover = bytes2utf8(data)
-                        sys.stdout.write(utf8str)
-                        sys.stdout.flush()
-                        self.unget(leftover)
+                        utf8str, leftover, marker = bytes2utf8(data)
+                        if len(utf8str) == 0 and prev_leftover == leftover:
+                            # Print raw hex string with color
+                            # if the data is invalid as UTF-8
+                            utf8str = '{red}{hexstr}{end}'.format(
+                                red=Color.RED,
+                                hexstr=bytes2hex(leftover),
+                                end=Color.END
+                            )
+                            leftover = None
+
+                        for c, t in zip(utf8str, marker):
+                            if t == True:
+                                sys.stdout.write(c)
+                            else:
+                                sys.stdout.write('{red}{hexstr}{end}'.format(
+                                    red=Color.RED,
+                                    hexstr=str2hex(c),
+                                    end=Color.END
+                                ))
+                            sys.stdout.flush()
+                        prev_leftover = leftover
+                        if leftover is not None:
+                            self.unget(leftover)
                 except TimeoutError:
                     pass
                 except EOFError:
                     logger.error("Receiver EOF")
                     break
                 except ConnectionAbortedError:
                     logger.error("Receiver EOF")
```

## ptrlib/filestruct/pe/parser.py

```diff
@@ -136,15 +136,16 @@
                 image_aux_symbols.append(image_aux_symbol)
 
             if naux == 0:
                 self._symbol_table.append((image_symbol, image_aux_symbols))
 
         # Parse string table
         size = IMAGE_COFF_STRING_TABLE_SIZE().parse_stream(self.stream)
-        self._offset_string_table = self.stream.tell()
+        self._offset_string_table = self.stream.tell() \
+            - IMAGE_COFF_STRING_TABLE_SIZE().size
         self._size_string_table = size
 
         # Resolve symbol name
         for image_symbol, _ in self._symbol_table:
             self._resolve_symbol_name(image_symbol)
 
     def _parse_export_directory(self):
@@ -161,43 +162,88 @@
             return
 
         offset = self.rva_to_offset(dd['VirtualAddress'])
         if offset is None:
             logger.error("Failed to parse import directory (Invalid RVA)")
             return
 
+        # Parse IMAGE_IMPORT_DESCRIPTOR
         self._import_table = []
         self.stream.seek(offset)
         while True:
             table = IMAGE_IMPORT_DESCRIPTOR().parse_stream(self.stream)
             if table['Name'] == 0 and table['FirstThunk'] == 0:
                 break
             self._import_table.append(table)
 
+        # Resolve names
+        for table in self._import_table:
+            self._resolve_imports(table)
+
     def _resolve_symbol_name(self, image_symbol):
+        """Resolve names in a symbol table
+        """
         if image_symbol['N']['Name']['Zero'] == 0:
             offset = image_symbol['N']['Name']['Offset']
             if offset >= self._size_string_table:
                 name = None
             else:
                 name = self.string_at(self._offset_string_table + offset)
         else:
             name = b''.join(
                 map(lambda c: bytes([c]), image_symbol['N']['ShortName'])
             ).rstrip(b'\0')
 
         image_symbol['Name'] = name
 
+    def _resolve_imports(self, import_table):
+        """Resolve names in an import table
+        """
+        # Resolve DLL name
+        offset = self.rva_to_offset(import_table['Name'])
+        import_table['Name'] = self.string_at(offset)
+
+    def iter_iat(self, import_table):
+        """Iterate over IAT corresponding to an import table
+        """
+        oft = import_table['_']['OriginalFirstThunk']
+        ft = import_table['FirstThunk']
+        p_thunk_name = self.rva_to_offset(oft)
+        p_thunk_func = self.rva_to_offset(ft)
+
+        while True:
+            # Parse thunk name and function
+            self.stream.seek(p_thunk_name)
+            thunk_name = IMAGE_THUNK_DATA(self).parse_stream(self.stream)
+            self.stream.seek(p_thunk_func)
+            thunk_func = IMAGE_THUNK_DATA(self).parse_stream(self.stream)
+            if thunk_func['u1']['Function'] == 0:
+                break
+
+            # Get function name
+            offset = self.rva_to_offset(thunk_name['u1']['AddressOfData'])
+            self.stream.seek(offset)
+            ibn = IMAGE_IMPORT_BY_NAME().parse_stream(self.stream)
+            name = ''.join(map(chr, ibn['Name']))
+
+            yield thunk_func['u1']['Function'], name
+
+            p_thunk_name += IMAGE_THUNK_DATA(self).size
+            p_thunk_func += IMAGE_THUNK_DATA(self).size
+
     def iter_imports(self):
         """Iterate over import table
         """
         for table in self._import_table:
-            offset = self.rva_to_offset(table['Name'])
-            yield {
-                'Name': self.string_at(offset)
-            }
+            yield table
 
     def iter_symbol_table(self):
         """Iterate over symbol table
         """
         for image_symbol, image_aux_symbol in self._symbol_table:
             yield (image_symbol, image_aux_symbol)
+
+    def iter_sections(self):
+        """Iterate over sections
+        """
+        for section in self.sections:
+            yield section
```

## ptrlib/filestruct/pe/pe.py

```diff
@@ -1,10 +1,11 @@
 import functools
 import os
 from logging import getLogger
+from typing import Optional, Union
 from ptrlib.binary.encoding import str2bytes
 from .parser import PEParser
 
 logger = getLogger(__name__)
 
 try:
     cache = functools.cache
@@ -17,35 +18,132 @@
         """PE Parser
         """
         self.filepath = os.path.realpath(filepath)
         self._parser = PEParser(self.filepath)
         self._base = 0
 
     def symbols(self):
-        return
-
-    def symbol(self, name):
-        """Get 
+        """Get all symbols
+        """
+        symbols = {}
+        for image_symbol, image_aux_symbol in self._parser.iter_symbol_table():
+            # TODO: Add base address
+            symbols[image_symbol['Name']] = image_symbol['Value']
+        return symbols
+
+    def symbol(self,
+               name: Union[str, bytes],
+               exact: Optional[bool] = False) -> Optional[int]:
+        """Get the address corresponding to a symbol
         """
         if isinstance(name, str):
             name = str2bytes(name)
 
         for image_symbol, image_aux_symbol in self._parser.iter_symbol_table():
-            print(image_symbol['Name'], hex(image_symbol['Value']))
+            at = image_symbol['Name'].rfind(b'@')
+            if image_symbol['Name'] == name:
+                # Exact match
+                # TODO: Add base address
+                return image_symbol['Value']
+
+            elif not exact and at > 0 and \
+                 image_symbol['Name'][at+1:].isdigit() and \
+                 image_symbol['Name'][:at] == name:
+                # Match "SYMBOL@num" given "SYMBOL"
+                # TODO: Add base address
+                return image_symbol['Value']
 
+        if exact:
+            return None
 
-    def section(self, name):
-        raise NotImplementedError()
+        # Search for "__imp__FUNC@num" given "FUNC"
+        for image_symbol, image_aux_symbol in self._parser.iter_symbol_table():
+            at = image_symbol['Name'].rfind(b'@')
+            if at > 0 and \
+               image_symbol['Name'][at+1:].isdigit() and \
+               image_symbol['Name'].startswith(b'__imp__') and \
+               image_symbol['Name'][7:at] == name:
+                # TODO: Add base address
+                return image_symbol['Value']
+
+        return None
+
+    def sections(self):
+        """Get all section names
+
+        Returns:
+            dict: Dictionary with section name in key and
+                  address of the section name in value.
+        """
+        return {
+            # TODO: Add base address
+            section['Name']: section['VirtualAddress']
+            for section in self._parser.iter_sections()
+        }
 
-    def iat(self, name):
-        raise NotImplementedError()
+    def section(self, name: Union[str, bytes]):
+        """Get address of a section
 
-    def exports(self):
-        raise NotImplementedError()
+        Args:
+            name (str): Section name
+
+        Returns:
+            int: Address of the section name, or None if not found
+        """
+        if isinstance(name, bytes):
+            name = bytes2str(name)
+
+        for section in self._parser.iter_sections():
+            if section['Name'] == name:
+                # TODO: Add base address
+                return section['VirtualAddress']
+
+    def iat(self,
+            dll_or_func: Union[str, bytes],
+            func: Optional[Union[str, bytes]] = None):
+        """IAT entry
+
+        Examples:
+            pe.iat("Sleep")
+            pe.iat("kernel32.dll", "Sleep")
+        """
+        if func is None:
+            dll_name, func_name = None, dll_or_func
+        else:
+            dll_name, func_name = dll_or_func, func
+
+        if isinstance(dll_name, bytes):
+            dll_name = bytes2str(dll_name)
+        if isinstance(func_name, bytes):
+            func_name = bytes2str(func_name)
+
+        for table in self._parser.iter_imports():
+            # Compare DLL name if specified
+            if dll_name is not None and \
+               table['Name'].lower() != dll_name.lower():
+                continue
+
+            for addr, name in self._parser.iter_iat(table):
+                if name == func_name:
+                    # TODO: Add base address
+                    return addr
 
     def imports(self):
+        """Get all imports
+
+        Returns:
+            dict: Dictionary with DLL name in key,
+                  list of function names in value of each key.
+        """
+        imports = {}
         for table in self._parser.iter_imports():
-            print(table)
+            imports[table['Name']] = [
+                name for _, name in self._parser.iter_iat(table)
+            ]
+        return imports
+
+    def exports(self):
+        raise NotImplementedError()
 
     def resources(self):
         raise NotImplementedError()
```

## ptrlib/filestruct/pe/structs.py

```diff
@@ -253,8 +253,36 @@
             'Number'    <= SHORT,
             'Selection' <= BYTE,
         )
     )
 
 @cache
 def IMAGE_COFF_STRING_TABLE_SIZE():
-    return 'Size' <= WORD
+    return 'Size' <= DWORD
+
+@cache
+def IMAGE_THUNK_DATA(parser):
+    if parser.bits == 32:
+        return 'IMAGE_THUNK_DATA' <= Struct(
+            'u1' <= Union(
+                'ForwarderString' <= DWORD, # PBYTE
+                'Function'        <= DWORD, # PDWORD
+                'Ordinal'         <= DWORD,
+                'AddressOfData'   <= DWORD, # PIMAGE_IMPORT_BY_NAME
+            )
+        )
+    else:
+        return 'IMAGE_THUNK_DATA' <= Struct(
+            'u1' <= Union(
+                'ForwarderString' <= ULONGLONG, # PBYTE
+                'Function'        <= ULONGLONG, # PDWORD
+                'Ordinal'         <= ULONGLONG,
+                'AddressOfData'   <= ULONGLONG, # PIMAGE_IMPORT_BY_NAME
+            )
+        )
+
+@cache
+def IMAGE_IMPORT_BY_NAME():
+    return 'IMAGE_IMPORT_BY_NAME' <= Struct(
+        'Hint' <= WORD,
+        'Name' <= VariableArray(lambda c,_: c!=0, BYTE)
+    )
```

## tests/binary/encoding/test_byteconv.py

```diff
@@ -16,23 +16,34 @@
         self.assertEqual(bytes2str(b"Hello"), "Hello")
         self.assertEqual(bytes2str(b"\x01\x80\n\xfe\x7f\x00"),
                          "\x01\x80\n\xfe\x7f\x00")
 
     def test_bytes2utf8(self):
         b1 = b'\xe3\x81\xab\xe3\x82\x83\xe3\x83\xbc\xe3\x82\x93\xf0\x9f\x98\xba\xf0\x9f\x90\xb6\xe3\x82\x8f\xe3\x82\x93\xe3\x82\x8f\xe3\x82\x93\xe3\x81\x8a'
         b2 = b'\xd0\xba\xd0\xbe\xd1\x82\xea\xb3\xa0\xec\x96\x91\xec\x9d\xb4\xd9\x82\xd8\xb7\xd8\xa9'
+        b3 = b'\xf0\x9f\x98\xbaNEKO\xe3NEKO'
 
-        s, leftover = bytes2utf8(b1)
+        s, leftover, marker = bytes2utf8(b1)
         self.assertEqual(s.encode('utf-8'), b1)
         self.assertEqual(len(leftover), 0)
+        self.assertEqual(all(marker), True)
 
-        s, leftover = bytes2utf8(b2)
+        s, leftover, marker = bytes2utf8(b2)
         self.assertEqual(s.encode('utf-8'), b2)
         self.assertEqual(len(leftover), 0)
+        self.assertEqual(all(marker), True)
 
-        s, leftover = bytes2utf8(b1[:len(b1)//2])
+        s, leftover, marker = bytes2utf8(b1[:len(b1)//2])
         self.assertEqual(s.encode('utf-8'), b1[:3+3+3+3+4])
         self.assertEqual(leftover, b1[3+3+3+3+4:len(b1)//2])
+        self.assertEqual(all(marker), True)
 
-        s, leftover = bytes2utf8(b1[len(b1)//2:])
+        s, leftover, marker = bytes2utf8(b1[len(b1)//2:])
         self.assertEqual(s[:3], '\x9f\x90\xb6')
         self.assertEqual(len(leftover), 0)
+        self.assertEqual(all(marker), True)
+
+        s, leftover, marker = bytes2utf8(b3)
+        self.assertEqual(len(leftover), 0)
+        self.assertEqual(all(marker[:5]), True)
+        self.assertEqual(marker[5], False)
+        self.assertEqual(all(marker[6:]), True)
```

## Comparing `ptrlib-2.0.8.dist-info/LICENSE.txt` & `ptrlib-2.0.9.dist-info/LICENSE.txt`

 * *Files identical despite different names*

## Comparing `ptrlib-2.0.8.dist-info/METADATA` & `ptrlib-2.0.9.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: ptrlib
-Version: 2.0.8
+Version: 2.0.9
 Summary: CTF library
 Home-page: https://github.com/ptr-yudai/ptrlib/
 Author: ptr-yudai
 Author-email: ptr.yudai+dev@gmail.com
 Keywords: pwn crypto algorithm
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Programming Language :: Python :: 3.5
```

## Comparing `ptrlib-2.0.8.dist-info/RECORD` & `ptrlib-2.0.9.dist-info/RECORD`

 * *Files 2% similar despite different names*

```diff
@@ -30,32 +30,32 @@
 ptrlib/arch/intel/syscall.py,sha256=kgAoR1WAhqsfeJ4BGchrCqZb_nrsnnJ_g3u5loehatY,14542
 ptrlib/arch/linux/__init__.py,sha256=MxDaHplYTwY16ma16lsigtP2a433xLPZe5QdmSdTZMo,45
 ptrlib/arch/linux/ospath.py,sha256=MekrAU-UCw7HDEmMAe4rTPGI-H6nbQTgmXFUIxMuGIw,465
 ptrlib/arch/linux/syscall.py,sha256=g-_eE5xc98rRL1NluKgI00sDUTBdQ2Qb7_dukkONL3M,723
 ptrlib/binary/__init__.py,sha256=Yq7lZzjQbkGObgBhkc4EyxUQNqoSzq8Upy8aAzcqMmY,98
 ptrlib/binary/encoding/__init__.py,sha256=fQgp0SEFRN-2KBUKUH5AxqsXV3hgxYcT1o7eqT548Rc,90
 ptrlib/binary/encoding/bitconv.py,sha256=Y9p95RbBi4lDqnbeuC0N0MeTkSuVowjtX95-Dnqu2OU,220
-ptrlib/binary/encoding/byteconv.py,sha256=uPfIJGlH3XUswXk4prfMLfCoXDAlxKH5vzzgMgIMDLU,2678
+ptrlib/binary/encoding/byteconv.py,sha256=G1Xfg-XFmufqqlWGDSD01eX2UHJddWvzt_gFUpDdC_M,4332
 ptrlib/binary/encoding/locale.py,sha256=JZALRWQWLDHYkPuYAf8llAGAFmhgR1mDGcCTfz9-Ebc,1552
 ptrlib/binary/encoding/table.py,sha256=0G3-e_GQnHIilV5N9QbyCOelVxnwfE5uVvVXr5h3gMc,520
 ptrlib/binary/operation/__init__.py,sha256=A7OOwayygfMwVev-HJoazt4ryq15xqSXjni1RK5Q7cM,41
 ptrlib/binary/operation/rotate.py,sha256=1K4Z1rtoaqJ-Q7uJkp5LzAoqFbg07IzgKDrN5Rx1XEI,1374
 ptrlib/binary/operation/xor.py,sha256=wa99k4etfCzZHIjkaf5vdLiPxFPEQuIvAkL6GdO_51o,1048
 ptrlib/binary/packing/__init__.py,sha256=2wYJJGaQ_9vEMvdGeSvex4dRsxVziEuwl416yh8w2-o,84
 ptrlib/binary/packing/chunks.py,sha256=_S43yHtbZhKkfURzk8V-Ytw5sXu9uSMiawZiN_GYgTY,1006
 ptrlib/binary/packing/flat.py,sha256=lauRS6KqOz0OXD85rDhlaXbbDHlDmzo4g6M8xerqCrQ,821
 ptrlib/binary/packing/pack.py,sha256=na0-iHIsE4hbnKiBW-b1d-DAG1xd9VkB3Xcb4G7HNlI,1437
 ptrlib/binary/packing/unpack.py,sha256=jmtjKAALZKBPokJRNQubBUT1O6wnF4LMwCJzg6lcBYA,3547
 ptrlib/binary/statistics/__init__.py,sha256=eJAibn0JE1DGzk4G6yPsrQ5KbjcsSYsx2ZfXHt83XYk,26
 ptrlib/binary/statistics/statistics.py,sha256=e7omLfl46nwJwZ842PWWGeJd__KMn7MzAm9Bq9CReLU,1584
 ptrlib/connection/__init__.py,sha256=5_8CIWwIuGTXoWrf1G93E9EFKS2LhA3BvpaSKDaQGGk,82
-ptrlib/connection/proc.py,sha256=BnH7j-JTENYA5Hpnc-h14OK41bmrxAvIcNw6a3rvbR8,6623
+ptrlib/connection/proc.py,sha256=7pj6epn3b-CqVm-LdZEuhNMKIuFYBXy3r4oLLICjghU,6899
 ptrlib/connection/sock.py,sha256=rDU4EtHOl9mRqu7OIeWmtW1FW24qBGts3AcA5SaDOPM,4671
 ptrlib/connection/ssh.py,sha256=0-qwj7GaGmaLSTbMuskmMljaBZ61Juqon_eMmezNxII,1919
-ptrlib/connection/tube.py,sha256=6CAs-xUPUf8WFN3WtwQbL62fZeQiFCfe2q6cu_RY-PM,11649
+ptrlib/connection/tube.py,sha256=4VLutHpT0UV-xdtuc0z_AU1eQTyG5-kYpTQR7RE7Io0,12696
 ptrlib/connection/winproc.py,sha256=X2FDM3Km_QuXpndabHbd2CdUiGIYxxIr3-58KgJCqyQ,7271
 ptrlib/console/__init__.py,sha256=9F_lzTGOwixQ_lOXmw8jgX5IW5OY1es4_cWJQ3BZmDY,21
 ptrlib/console/color.py,sha256=hmCshy6zwB59hGKPI0NpuL2nkk7_1Siz2xDxzwnu5-s,1461
 ptrlib/crypto/__init__.py,sha256=MKfosClfAhL6UHSHie4ADqYjtzkUQeAgOSgyKw9vR5g,112
 ptrlib/crypto/blockcipher/__init__.py,sha256=advd_ktJAtS4JRmViru8yXNjmFUkiHKpb0tgPeYSbZ0,64
 ptrlib/crypto/blockcipher/ecb.py,sha256=-VF-_eOQ-cGiZFFFmFnKVXQWOnpMGSBf4Tlf6_ni3js,1396
 ptrlib/crypto/blockcipher/padcbc.py,sha256=ZmesLDdzGmYASoiLx3psiqqDuFRh29nrlXXK5YXMK7k,3829
@@ -82,17 +82,17 @@
 ptrlib/filestruct/elf/__init__.py,sha256=Qyr5FFu6Las5QoN69F7QOv3dMrfln2UmxpYjcqYovRk,19
 ptrlib/filestruct/elf/elf.py,sha256=pvv9ocZ0pmUzIg1bFBG5MYkZNQJtV7zFBgFPvvftwxc,14938
 ptrlib/filestruct/elf/enums.py,sha256=TMzLlZmQ4CETO8znNQVVbjY5xOkU3gno3DFBC1v__Gg,35234
 ptrlib/filestruct/elf/parser.py,sha256=TMy7XjRqB5UsGwCaSjcq8gQTqSKxWa05AW2t1_dz_YA,6418
 ptrlib/filestruct/elf/structs.py,sha256=lA4C-6KV4oPsfkkxGyH6Ne8QUvopGbSPJ5O-_6pHDW0,5410
 ptrlib/filestruct/pe/__init__.py,sha256=reIZyIl_6_xja8EiDABCxppz-SIubFmsKqSJ6w88Ld0,18
 ptrlib/filestruct/pe/enums.py,sha256=oMDeE1fXR0UyLzffcNzoeUrX9MPearp_LAZffzzZbb0,607
-ptrlib/filestruct/pe/parser.py,sha256=FBvAitE2jNqDM9m5N5io2mEhd3HXvMo3I4o6UBjbsQg,6348
-ptrlib/filestruct/pe/pe.py,sha256=IV_SbwyB18byEx9VCM84FEGQDqgmrlwpfc824GyiNh0,1123
-ptrlib/filestruct/pe/structs.py,sha256=4ewriZKm_v6bDJrspe9HM731rdt9gAm_vrGU7KbNAzg,8162
+ptrlib/filestruct/pe/parser.py,sha256=afPDD6cxf12ycm1L50_bMvgZ6xxV2QOBySMl3MZ3Kb8,7970
+ptrlib/filestruct/pe/pe.py,sha256=QxpZ3OidRTMnjMvgTGfCpj-9XTAikuzS_C64D564Yio,4514
+ptrlib/filestruct/pe/structs.py,sha256=viuB8fU_S-Y8qGeeFB74rouPY6aJFOboJmZyLnm-MAw,9046
 ptrlib/pwn/__init__.py,sha256=_vVnpUu3aXU7v0QlWS0efjg0axTeXtu8dVqiE91EJaM,62
 ptrlib/pwn/dynlink/__init__.py,sha256=VqDqQOGkTHms2jVM37CDYjPLi13Xyvd9PlQBuMoncAc,39
 ptrlib/pwn/dynlink/dl.py,sha256=qCv2Vq9csQ0cYiNXhkazHiVuAGUEamW3-wT9zush6no,1979
 ptrlib/pwn/dynlink/robot.py,sha256=b0K8pGxQoChVPZsX2-3jOTrCFTqlM30hYvq6APQ9SWk,2769
 ptrlib/pwn/fsb/__init__.py,sha256=nlUQAALUrr976oxR3iznuZuSM11vfw1MfOe3tc066uA,19
 ptrlib/pwn/fsb/fsb.py,sha256=OsMPeHXD20NV820D3oMJSNIRIZJmUMuaNTwpqLTfOPA,4546
 ptrlib/pwn/fuzz/__init__.py,sha256=RjOf2xiJg09IktbnSn5CNylxhetu7eoMg8QpUfMFpd4,23
@@ -102,15 +102,15 @@
 tests/algorithm/shortestpath/test_shortestpath.py,sha256=uYKYhsE3K_1FYzuRdhmFFKJulV5qPmIDWN9qVX3fHAk,3389
 tests/arch/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 tests/arch/test_cpu.py,sha256=VnZ03jKE64Oi2X-0asnfR9uCrt4UtCxUe-W9yvzWN6Y,1252
 tests/arch/test_simd.py,sha256=kEWsAkxsY6R3Nq_9lDM_clsgucsC8aabw3IcQ5V4POM,988
 tests/arch/test_syscall.py,sha256=9D-rplpqv80u80zjDRseufnvjP2vyRDerggoOe1NpmM,1120
 tests/binary/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 tests/binary/encoding/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-tests/binary/encoding/test_byteconv.py,sha256=oBgcwBGy54d40OCAy40OhUqjomhcaCjmC6Xr-hvtWaM,1470
+tests/binary/encoding/test_byteconv.py,sha256=-q_u0O5k4ofrMUe_PGOX5cvtmiZt0n0Fglc9H_2UOcE,1951
 tests/binary/encoding/test_locale.py,sha256=ipVE8agDaOABSUBdXhGIRDrKg2SOmVEF8ntaDHYFy84,2787
 tests/binary/operation/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 tests/binary/operation/test_rotate.py,sha256=ppoWXsBskZsvmNtT7MlLU65roOq9NKhvzfHAUApD7yU,1273
 tests/binary/operation/test_xor.py,sha256=lw8-DCfeIM9zSZwjM6lTuRrcQiL7qsBKzv2w10O1MyA,654
 tests/binary/packing/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 tests/binary/packing/test_chunks.py,sha256=Ric7fk05PbObslpeQop3O-5W8M_iMZqLmevicdltJgw,847
 tests/binary/packing/test_flat.py,sha256=P2PXQYOYquqSbyYiUg3xJyXKhzeNbXgNW1PhfmNTL7A,580
@@ -149,13 +149,13 @@
 tests/filestruct/elf/test_elf_5.py,sha256=LEi8_R6uog7U3LLkrYAdfrdJH3JJXH8Olv77xPFBIgQ,1613
 tests/filestruct/elf/test_elf_6.py,sha256=XJ7pRu9whJq4wdgfk8ere4q4QbcgONtV-e2ZBo4S544,1124
 tests/filestruct/elf/test_elf_7.py,sha256=uwkPsovbAdZFUJNWZ5XySf0kYtaaPJNs1YDzjYce0-Q,1108
 tests/filestruct/elf/test_elf_8.py,sha256=C1Gnylu5lOqPFo8NfJBo5YyUULe026uKL-hvwWprON0,574
 tests/pwn/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 tests/pwn/test_fsb.py,sha256=VC_0csTXIS1_PIGUBJmy2uN7hllr4kXJ0mibNYN5d_A,1877
 tests/pwn/test_fuzz.py,sha256=ARnTx48YnuV-awKeFhjsPAyCYJDn9M80q4DyVj5pvOA,1988
-ptrlib-2.0.8.dist-info/LICENSE.txt,sha256=ACwmltkrXIz5VsEQcrqljq-fat6ZXAMepjXGoe40KtE,1069
-ptrlib-2.0.8.dist-info/METADATA,sha256=DRGyh0roxSIdPGUz9WQYD_6gDkVpH6z8FCSESUEsad8,3535
-ptrlib-2.0.8.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
-ptrlib-2.0.8.dist-info/entry_points.txt,sha256=xJ7v7w7uhxUeAzagSodmQhexYh_8GjCTPDCKMFse9T0,48
-ptrlib-2.0.8.dist-info/top_level.txt,sha256=A_zqZPqp9QidhyWj2_hpnC7wz0tTQ2nbR8D6vOnhzYk,13
-ptrlib-2.0.8.dist-info/RECORD,,
+ptrlib-2.0.9.dist-info/LICENSE.txt,sha256=ACwmltkrXIz5VsEQcrqljq-fat6ZXAMepjXGoe40KtE,1069
+ptrlib-2.0.9.dist-info/METADATA,sha256=SBE0i6-ksSDtMziHAyCzVx4-T-gXjgPxRe0WntybkIU,3535
+ptrlib-2.0.9.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
+ptrlib-2.0.9.dist-info/entry_points.txt,sha256=xJ7v7w7uhxUeAzagSodmQhexYh_8GjCTPDCKMFse9T0,48
+ptrlib-2.0.9.dist-info/top_level.txt,sha256=A_zqZPqp9QidhyWj2_hpnC7wz0tTQ2nbR8D6vOnhzYk,13
+ptrlib-2.0.9.dist-info/RECORD,,
```

